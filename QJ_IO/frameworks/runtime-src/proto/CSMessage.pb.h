// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSMessage.proto

#ifndef PROTOBUF_CSMessage_2eproto__INCLUDED
#define PROTOBUF_CSMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MessageHeader.pb.h"
#include "XML.pb.h"
#include "StoC.pb.h"
// @@protoc_insertion_point(includes)

namespace jynetwork {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSMessage_2eproto();
void protobuf_AssignDesc_CSMessage_2eproto();
void protobuf_ShutdownFile_CSMessage_2eproto();

class CSMessageNetBattleBegin;
class CSMessageNetBattleOper;
class CSMessageLoginAuth;
class CSMessageGateAuth;
class CSMessageCreateCharInfo;
class CSMessageCreateCharJob;
class batchInject;
class CSMessageClientOperation;
class CSMessageBattleBegin;
class BattleTime;
class BattleAttr;
class CSMessageBattleCheck;
class BatttleSkillStatistics;
class DamageScore;
class CSMessageBattleResult;
class CSMessagePing;
class CSMessageGMCommond;
class CSMessageRankList;
class CSMessagePlayerQuery;
class CSMessageCorpsOper;
class CSMessageChat;
class CSMessageArenaBattleBegin;

// ===================================================================

class CSMessageNetBattleBegin : public ::google::protobuf::MessageLite {
 public:
  CSMessageNetBattleBegin();
  virtual ~CSMessageNetBattleBegin();

  CSMessageNetBattleBegin(const CSMessageNetBattleBegin& from);

  inline CSMessageNetBattleBegin& operator=(const CSMessageNetBattleBegin& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageNetBattleBegin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageNetBattleBegin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageNetBattleBegin* other);

  // implements Message ----------------------------------------------

  CSMessageNetBattleBegin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageNetBattleBegin& from);
  void MergeFrom(const CSMessageNetBattleBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 net_type = 2;
  inline bool has_net_type() const;
  inline void clear_net_type();
  static const int kNetTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 net_type() const;
  inline void set_net_type(::google::protobuf::uint32 value);

  // optional .jynetwork.proto.sCharactorInit ci = 4;
  inline bool has_ci() const;
  inline void clear_ci();
  static const int kCiFieldNumber = 4;
  inline const ::jynetwork::proto::sCharactorInit& ci() const;
  inline ::jynetwork::proto::sCharactorInit* mutable_ci();
  inline ::jynetwork::proto::sCharactorInit* release_ci();
  inline void set_allocated_ci(::jynetwork::proto::sCharactorInit* ci);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageNetBattleBegin)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_net_type();
  inline void clear_has_net_type();
  inline void set_has_ci();
  inline void clear_has_ci();

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 net_type_;
  ::jynetwork::proto::sCharactorInit* ci_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageNetBattleBegin* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageNetBattleOper : public ::google::protobuf::MessageLite {
 public:
  CSMessageNetBattleOper();
  virtual ~CSMessageNetBattleOper();

  CSMessageNetBattleOper(const CSMessageNetBattleOper& from);

  inline CSMessageNetBattleOper& operator=(const CSMessageNetBattleOper& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageNetBattleOper& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageNetBattleOper* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageNetBattleOper* other);

  // implements Message ----------------------------------------------

  CSMessageNetBattleOper* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageNetBattleOper& from);
  void MergeFrom(const CSMessageNetBattleOper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jynetwork.proto.NetBattleOper opers = 1;
  inline int opers_size() const;
  inline void clear_opers();
  static const int kOpersFieldNumber = 1;
  inline const ::jynetwork::proto::NetBattleOper& opers(int index) const;
  inline ::jynetwork::proto::NetBattleOper* mutable_opers(int index);
  inline ::jynetwork::proto::NetBattleOper* add_opers();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::NetBattleOper >&
      opers() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::NetBattleOper >*
      mutable_opers();

  // optional uint32 battle_time = 2;
  inline bool has_battle_time() const;
  inline void clear_battle_time();
  static const int kBattleTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 battle_time() const;
  inline void set_battle_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageNetBattleOper)
 private:
  inline void set_has_battle_time();
  inline void clear_has_battle_time();

  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::NetBattleOper > opers_;
  ::google::protobuf::uint32 battle_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageNetBattleOper* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageLoginAuth : public ::google::protobuf::MessageLite {
 public:
  CSMessageLoginAuth();
  virtual ~CSMessageLoginAuth();

  CSMessageLoginAuth(const CSMessageLoginAuth& from);

  inline CSMessageLoginAuth& operator=(const CSMessageLoginAuth& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageLoginAuth& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageLoginAuth* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageLoginAuth* other);

  // implements Message ----------------------------------------------

  CSMessageLoginAuth* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageLoginAuth& from);
  void MergeFrom(const CSMessageLoginAuth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ver_main = 1;
  inline bool has_ver_main() const;
  inline void clear_ver_main();
  static const int kVerMainFieldNumber = 1;
  inline ::google::protobuf::uint32 ver_main() const;
  inline void set_ver_main(::google::protobuf::uint32 value);

  // optional uint32 ver_sub = 2;
  inline bool has_ver_sub() const;
  inline void clear_ver_sub();
  static const int kVerSubFieldNumber = 2;
  inline ::google::protobuf::uint32 ver_sub() const;
  inline void set_ver_sub(::google::protobuf::uint32 value);

  // optional uint32 ver_type = 3;
  inline bool has_ver_type() const;
  inline void clear_ver_type();
  static const int kVerTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 ver_type() const;
  inline void set_ver_type(::google::protobuf::uint32 value);

  // optional string user_name = 4;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 4;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional bytes user_pass = 5;
  inline bool has_user_pass() const;
  inline void clear_user_pass();
  static const int kUserPassFieldNumber = 5;
  inline const ::std::string& user_pass() const;
  inline void set_user_pass(const ::std::string& value);
  inline void set_user_pass(const char* value);
  inline void set_user_pass(const void* value, size_t size);
  inline ::std::string* mutable_user_pass();
  inline ::std::string* release_user_pass();
  inline void set_allocated_user_pass(::std::string* user_pass);

  // optional uint32 gm_check = 6;
  inline bool has_gm_check() const;
  inline void clear_gm_check();
  static const int kGmCheckFieldNumber = 6;
  inline ::google::protobuf::uint32 gm_check() const;
  inline void set_gm_check(::google::protobuf::uint32 value);

  // optional uint32 is_create = 7;
  inline bool has_is_create() const;
  inline void clear_is_create();
  static const int kIsCreateFieldNumber = 7;
  inline ::google::protobuf::uint32 is_create() const;
  inline void set_is_create(::google::protobuf::uint32 value);

  // optional string packetid = 8;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketidFieldNumber = 8;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // optional string open_id = 9;
  inline bool has_open_id() const;
  inline void clear_open_id();
  static const int kOpenIdFieldNumber = 9;
  inline const ::std::string& open_id() const;
  inline void set_open_id(const ::std::string& value);
  inline void set_open_id(const char* value);
  inline void set_open_id(const char* value, size_t size);
  inline ::std::string* mutable_open_id();
  inline ::std::string* release_open_id();
  inline void set_allocated_open_id(::std::string* open_id);

  // optional string token = 10;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 10;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional bytes device_id = 11;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 11;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const void* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional fixed32 inner_crc = 12;
  inline bool has_inner_crc() const;
  inline void clear_inner_crc();
  static const int kInnerCrcFieldNumber = 12;
  inline ::google::protobuf::uint32 inner_crc() const;
  inline void set_inner_crc(::google::protobuf::uint32 value);

  // optional fixed32 outer_crc = 13;
  inline bool has_outer_crc() const;
  inline void clear_outer_crc();
  static const int kOuterCrcFieldNumber = 13;
  inline ::google::protobuf::uint32 outer_crc() const;
  inline void set_outer_crc(::google::protobuf::uint32 value);

  // optional bytes idfa = 14;
  inline bool has_idfa() const;
  inline void clear_idfa();
  static const int kIdfaFieldNumber = 14;
  inline const ::std::string& idfa() const;
  inline void set_idfa(const ::std::string& value);
  inline void set_idfa(const char* value);
  inline void set_idfa(const void* value, size_t size);
  inline ::std::string* mutable_idfa();
  inline ::std::string* release_idfa();
  inline void set_allocated_idfa(::std::string* idfa);

  // optional bytes ip = 15;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 15;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 test_key = 16;
  inline bool has_test_key() const;
  inline void clear_test_key();
  static const int kTestKeyFieldNumber = 16;
  inline ::google::protobuf::uint32 test_key() const;
  inline void set_test_key(::google::protobuf::uint32 value);

  // optional bytes lilith_packet_name = 17;
  inline bool has_lilith_packet_name() const;
  inline void clear_lilith_packet_name();
  static const int kLilithPacketNameFieldNumber = 17;
  inline const ::std::string& lilith_packet_name() const;
  inline void set_lilith_packet_name(const ::std::string& value);
  inline void set_lilith_packet_name(const char* value);
  inline void set_lilith_packet_name(const void* value, size_t size);
  inline ::std::string* mutable_lilith_packet_name();
  inline ::std::string* release_lilith_packet_name();
  inline void set_allocated_lilith_packet_name(::std::string* lilith_packet_name);

  // optional bytes lilith_channel_id = 18;
  inline bool has_lilith_channel_id() const;
  inline void clear_lilith_channel_id();
  static const int kLilithChannelIdFieldNumber = 18;
  inline const ::std::string& lilith_channel_id() const;
  inline void set_lilith_channel_id(const ::std::string& value);
  inline void set_lilith_channel_id(const char* value);
  inline void set_lilith_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_lilith_channel_id();
  inline ::std::string* release_lilith_channel_id();
  inline void set_allocated_lilith_channel_id(::std::string* lilith_channel_id);

  // optional bytes lilith_idfa = 19;
  inline bool has_lilith_idfa() const;
  inline void clear_lilith_idfa();
  static const int kLilithIdfaFieldNumber = 19;
  inline const ::std::string& lilith_idfa() const;
  inline void set_lilith_idfa(const ::std::string& value);
  inline void set_lilith_idfa(const char* value);
  inline void set_lilith_idfa(const void* value, size_t size);
  inline ::std::string* mutable_lilith_idfa();
  inline ::std::string* release_lilith_idfa();
  inline void set_allocated_lilith_idfa(::std::string* lilith_idfa);

  // optional bytes lilith_andriod_id = 20;
  inline bool has_lilith_andriod_id() const;
  inline void clear_lilith_andriod_id();
  static const int kLilithAndriodIdFieldNumber = 20;
  inline const ::std::string& lilith_andriod_id() const;
  inline void set_lilith_andriod_id(const ::std::string& value);
  inline void set_lilith_andriod_id(const char* value);
  inline void set_lilith_andriod_id(const void* value, size_t size);
  inline ::std::string* mutable_lilith_andriod_id();
  inline ::std::string* release_lilith_andriod_id();
  inline void set_allocated_lilith_andriod_id(::std::string* lilith_andriod_id);

  // optional bytes lilith_google_id = 21;
  inline bool has_lilith_google_id() const;
  inline void clear_lilith_google_id();
  static const int kLilithGoogleIdFieldNumber = 21;
  inline const ::std::string& lilith_google_id() const;
  inline void set_lilith_google_id(const ::std::string& value);
  inline void set_lilith_google_id(const char* value);
  inline void set_lilith_google_id(const void* value, size_t size);
  inline ::std::string* mutable_lilith_google_id();
  inline ::std::string* release_lilith_google_id();
  inline void set_allocated_lilith_google_id(::std::string* lilith_google_id);

  // optional bytes lilith_os_type = 22;
  inline bool has_lilith_os_type() const;
  inline void clear_lilith_os_type();
  static const int kLilithOsTypeFieldNumber = 22;
  inline const ::std::string& lilith_os_type() const;
  inline void set_lilith_os_type(const ::std::string& value);
  inline void set_lilith_os_type(const char* value);
  inline void set_lilith_os_type(const void* value, size_t size);
  inline ::std::string* mutable_lilith_os_type();
  inline ::std::string* release_lilith_os_type();
  inline void set_allocated_lilith_os_type(::std::string* lilith_os_type);

  // optional bytes lilith_os_version = 23;
  inline bool has_lilith_os_version() const;
  inline void clear_lilith_os_version();
  static const int kLilithOsVersionFieldNumber = 23;
  inline const ::std::string& lilith_os_version() const;
  inline void set_lilith_os_version(const ::std::string& value);
  inline void set_lilith_os_version(const char* value);
  inline void set_lilith_os_version(const void* value, size_t size);
  inline ::std::string* mutable_lilith_os_version();
  inline ::std::string* release_lilith_os_version();
  inline void set_allocated_lilith_os_version(::std::string* lilith_os_version);

  // optional bytes lilith_app_version = 24;
  inline bool has_lilith_app_version() const;
  inline void clear_lilith_app_version();
  static const int kLilithAppVersionFieldNumber = 24;
  inline const ::std::string& lilith_app_version() const;
  inline void set_lilith_app_version(const ::std::string& value);
  inline void set_lilith_app_version(const char* value);
  inline void set_lilith_app_version(const void* value, size_t size);
  inline ::std::string* mutable_lilith_app_version();
  inline ::std::string* release_lilith_app_version();
  inline void set_allocated_lilith_app_version(::std::string* lilith_app_version);

  // optional bytes lilith_device_model = 25;
  inline bool has_lilith_device_model() const;
  inline void clear_lilith_device_model();
  static const int kLilithDeviceModelFieldNumber = 25;
  inline const ::std::string& lilith_device_model() const;
  inline void set_lilith_device_model(const ::std::string& value);
  inline void set_lilith_device_model(const char* value);
  inline void set_lilith_device_model(const void* value, size_t size);
  inline ::std::string* mutable_lilith_device_model();
  inline ::std::string* release_lilith_device_model();
  inline void set_allocated_lilith_device_model(::std::string* lilith_device_model);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageLoginAuth)
 private:
  inline void set_has_ver_main();
  inline void clear_has_ver_main();
  inline void set_has_ver_sub();
  inline void clear_has_ver_sub();
  inline void set_has_ver_type();
  inline void clear_has_ver_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_pass();
  inline void clear_has_user_pass();
  inline void set_has_gm_check();
  inline void clear_has_gm_check();
  inline void set_has_is_create();
  inline void clear_has_is_create();
  inline void set_has_packetid();
  inline void clear_has_packetid();
  inline void set_has_open_id();
  inline void clear_has_open_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_inner_crc();
  inline void clear_has_inner_crc();
  inline void set_has_outer_crc();
  inline void clear_has_outer_crc();
  inline void set_has_idfa();
  inline void clear_has_idfa();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_test_key();
  inline void clear_has_test_key();
  inline void set_has_lilith_packet_name();
  inline void clear_has_lilith_packet_name();
  inline void set_has_lilith_channel_id();
  inline void clear_has_lilith_channel_id();
  inline void set_has_lilith_idfa();
  inline void clear_has_lilith_idfa();
  inline void set_has_lilith_andriod_id();
  inline void clear_has_lilith_andriod_id();
  inline void set_has_lilith_google_id();
  inline void clear_has_lilith_google_id();
  inline void set_has_lilith_os_type();
  inline void clear_has_lilith_os_type();
  inline void set_has_lilith_os_version();
  inline void clear_has_lilith_os_version();
  inline void set_has_lilith_app_version();
  inline void clear_has_lilith_app_version();
  inline void set_has_lilith_device_model();
  inline void clear_has_lilith_device_model();

  ::google::protobuf::uint32 ver_main_;
  ::google::protobuf::uint32 ver_sub_;
  ::std::string* user_name_;
  ::google::protobuf::uint32 ver_type_;
  ::google::protobuf::uint32 gm_check_;
  ::std::string* user_pass_;
  ::std::string* packetid_;
  ::std::string* open_id_;
  ::google::protobuf::uint32 is_create_;
  ::google::protobuf::uint32 inner_crc_;
  ::std::string* token_;
  ::std::string* device_id_;
  ::std::string* idfa_;
  ::google::protobuf::uint32 outer_crc_;
  ::google::protobuf::uint32 test_key_;
  ::std::string* ip_;
  ::std::string* lilith_packet_name_;
  ::std::string* lilith_channel_id_;
  ::std::string* lilith_idfa_;
  ::std::string* lilith_andriod_id_;
  ::std::string* lilith_google_id_;
  ::std::string* lilith_os_type_;
  ::std::string* lilith_os_version_;
  ::std::string* lilith_app_version_;
  ::std::string* lilith_device_model_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageLoginAuth* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageGateAuth : public ::google::protobuf::MessageLite {
 public:
  CSMessageGateAuth();
  virtual ~CSMessageGateAuth();

  CSMessageGateAuth(const CSMessageGateAuth& from);

  inline CSMessageGateAuth& operator=(const CSMessageGateAuth& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageGateAuth& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageGateAuth* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageGateAuth* other);

  // implements Message ----------------------------------------------

  CSMessageGateAuth* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageGateAuth& from);
  void MergeFrom(const CSMessageGateAuth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 session_key = 2;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 session_key() const;
  inline void set_session_key(::google::protobuf::uint32 value);

  // optional uint32 need_full_data = 3;
  inline bool has_need_full_data() const;
  inline void clear_need_full_data();
  static const int kNeedFullDataFieldNumber = 3;
  inline ::google::protobuf::uint32 need_full_data() const;
  inline void set_need_full_data(::google::protobuf::uint32 value);

  // optional bytes push_token = 4;
  inline bool has_push_token() const;
  inline void clear_push_token();
  static const int kPushTokenFieldNumber = 4;
  inline const ::std::string& push_token() const;
  inline void set_push_token(const ::std::string& value);
  inline void set_push_token(const char* value);
  inline void set_push_token(const void* value, size_t size);
  inline ::std::string* mutable_push_token();
  inline ::std::string* release_push_token();
  inline void set_allocated_push_token(::std::string* push_token);

  // optional uint32 push_type = 5;
  inline bool has_push_type() const;
  inline void clear_push_type();
  static const int kPushTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 push_type() const;
  inline void set_push_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageGateAuth)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_need_full_data();
  inline void clear_has_need_full_data();
  inline void set_has_push_token();
  inline void clear_has_push_token();
  inline void set_has_push_type();
  inline void clear_has_push_type();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 session_key_;
  ::std::string* push_token_;
  ::google::protobuf::uint32 need_full_data_;
  ::google::protobuf::uint32 push_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageGateAuth* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageCreateCharInfo : public ::google::protobuf::MessageLite {
 public:
  CSMessageCreateCharInfo();
  virtual ~CSMessageCreateCharInfo();

  CSMessageCreateCharInfo(const CSMessageCreateCharInfo& from);

  inline CSMessageCreateCharInfo& operator=(const CSMessageCreateCharInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageCreateCharInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageCreateCharInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageCreateCharInfo* other);

  // implements Message ----------------------------------------------

  CSMessageCreateCharInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageCreateCharInfo& from);
  void MergeFrom(const CSMessageCreateCharInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes char_name = 1;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 1;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // optional uint32 char_camp = 2;
  inline bool has_char_camp() const;
  inline void clear_char_camp();
  static const int kCharCampFieldNumber = 2;
  inline ::google::protobuf::uint32 char_camp() const;
  inline void set_char_camp(::google::protobuf::uint32 value);

  // optional uint32 acc_id = 3;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 3;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageCreateCharInfo)
 private:
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_char_camp();
  inline void clear_has_char_camp();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::std::string* char_name_;
  ::google::protobuf::uint32 char_camp_;
  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageCreateCharInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageCreateCharJob : public ::google::protobuf::MessageLite {
 public:
  CSMessageCreateCharJob();
  virtual ~CSMessageCreateCharJob();

  CSMessageCreateCharJob(const CSMessageCreateCharJob& from);

  inline CSMessageCreateCharJob& operator=(const CSMessageCreateCharJob& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageCreateCharJob& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageCreateCharJob* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageCreateCharJob* other);

  // implements Message ----------------------------------------------

  CSMessageCreateCharJob* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageCreateCharJob& from);
  void MergeFrom(const CSMessageCreateCharJob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 char_job = 1;
  inline bool has_char_job() const;
  inline void clear_char_job();
  static const int kCharJobFieldNumber = 1;
  inline ::google::protobuf::uint32 char_job() const;
  inline void set_char_job(::google::protobuf::uint32 value);

  // optional uint32 acc_id = 2;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 2;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageCreateCharJob)
 private:
  inline void set_has_char_job();
  inline void clear_has_char_job();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 char_job_;
  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageCreateCharJob* default_instance_;
};
// -------------------------------------------------------------------

class batchInject : public ::google::protobuf::MessageLite {
 public:
  batchInject();
  virtual ~batchInject();

  batchInject(const batchInject& from);

  inline batchInject& operator=(const batchInject& from) {
    CopyFrom(from);
    return *this;
  }

  static const batchInject& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const batchInject* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(batchInject* other);

  // implements Message ----------------------------------------------

  batchInject* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const batchInject& from);
  void MergeFrom(const batchInject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 opvalue1 = 1;
  inline bool has_opvalue1() const;
  inline void clear_opvalue1();
  static const int kOpvalue1FieldNumber = 1;
  inline ::google::protobuf::uint64 opvalue1() const;
  inline void set_opvalue1(::google::protobuf::uint64 value);

  // repeated uint64 opvalue4 = 2;
  inline int opvalue4_size() const;
  inline void clear_opvalue4();
  static const int kOpvalue4FieldNumber = 2;
  inline ::google::protobuf::uint64 opvalue4(int index) const;
  inline void set_opvalue4(int index, ::google::protobuf::uint64 value);
  inline void add_opvalue4(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      opvalue4() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_opvalue4();

  // repeated uint64 opvalue5 = 3;
  inline int opvalue5_size() const;
  inline void clear_opvalue5();
  static const int kOpvalue5FieldNumber = 3;
  inline ::google::protobuf::uint64 opvalue5(int index) const;
  inline void set_opvalue5(int index, ::google::protobuf::uint64 value);
  inline void add_opvalue5(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      opvalue5() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_opvalue5();

  // @@protoc_insertion_point(class_scope:jynetwork.proto.batchInject)
 private:
  inline void set_has_opvalue1();
  inline void clear_has_opvalue1();

  ::google::protobuf::uint64 opvalue1_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > opvalue4_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > opvalue5_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static batchInject* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageClientOperation : public ::google::protobuf::MessageLite {
 public:
  CSMessageClientOperation();
  virtual ~CSMessageClientOperation();

  CSMessageClientOperation(const CSMessageClientOperation& from);

  inline CSMessageClientOperation& operator=(const CSMessageClientOperation& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageClientOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageClientOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageClientOperation* other);

  // implements Message ----------------------------------------------

  CSMessageClientOperation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageClientOperation& from);
  void MergeFrom(const CSMessageClientOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .jynetwork.proto.eOpertionType oper = 1;
  inline bool has_oper() const;
  inline void clear_oper();
  static const int kOperFieldNumber = 1;
  inline ::jynetwork::proto::eOpertionType oper() const;
  inline void set_oper(::jynetwork::proto::eOpertionType value);

  // optional uint64 opvalue1 = 2;
  inline bool has_opvalue1() const;
  inline void clear_opvalue1();
  static const int kOpvalue1FieldNumber = 2;
  inline ::google::protobuf::uint64 opvalue1() const;
  inline void set_opvalue1(::google::protobuf::uint64 value);

  // optional uint64 opvalue2 = 3;
  inline bool has_opvalue2() const;
  inline void clear_opvalue2();
  static const int kOpvalue2FieldNumber = 3;
  inline ::google::protobuf::uint64 opvalue2() const;
  inline void set_opvalue2(::google::protobuf::uint64 value);

  // optional uint64 opvalue3 = 4;
  inline bool has_opvalue3() const;
  inline void clear_opvalue3();
  static const int kOpvalue3FieldNumber = 4;
  inline ::google::protobuf::uint64 opvalue3() const;
  inline void set_opvalue3(::google::protobuf::uint64 value);

  // optional uint32 acc_id = 5;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 5;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // repeated uint64 opvalue4 = 6;
  inline int opvalue4_size() const;
  inline void clear_opvalue4();
  static const int kOpvalue4FieldNumber = 6;
  inline ::google::protobuf::uint64 opvalue4(int index) const;
  inline void set_opvalue4(int index, ::google::protobuf::uint64 value);
  inline void add_opvalue4(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      opvalue4() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_opvalue4();

  // repeated uint64 opvalue5 = 7;
  inline int opvalue5_size() const;
  inline void clear_opvalue5();
  static const int kOpvalue5FieldNumber = 7;
  inline ::google::protobuf::uint64 opvalue5(int index) const;
  inline void set_opvalue5(int index, ::google::protobuf::uint64 value);
  inline void add_opvalue5(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      opvalue5() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_opvalue5();

  // optional uint32 oper_index = 8;
  inline bool has_oper_index() const;
  inline void clear_oper_index();
  static const int kOperIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 oper_index() const;
  inline void set_oper_index(::google::protobuf::uint32 value);

  // optional bytes opvalue6 = 9;
  inline bool has_opvalue6() const;
  inline void clear_opvalue6();
  static const int kOpvalue6FieldNumber = 9;
  inline const ::std::string& opvalue6() const;
  inline void set_opvalue6(const ::std::string& value);
  inline void set_opvalue6(const char* value);
  inline void set_opvalue6(const void* value, size_t size);
  inline ::std::string* mutable_opvalue6();
  inline ::std::string* release_opvalue6();
  inline void set_allocated_opvalue6(::std::string* opvalue6);

  // repeated .jynetwork.proto.batchInject opvalue7 = 10;
  inline int opvalue7_size() const;
  inline void clear_opvalue7();
  static const int kOpvalue7FieldNumber = 10;
  inline const ::jynetwork::proto::batchInject& opvalue7(int index) const;
  inline ::jynetwork::proto::batchInject* mutable_opvalue7(int index);
  inline ::jynetwork::proto::batchInject* add_opvalue7();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::batchInject >&
      opvalue7() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::batchInject >*
      mutable_opvalue7();

  // optional bytes opvalue8 = 11;
  inline bool has_opvalue8() const;
  inline void clear_opvalue8();
  static const int kOpvalue8FieldNumber = 11;
  inline const ::std::string& opvalue8() const;
  inline void set_opvalue8(const ::std::string& value);
  inline void set_opvalue8(const char* value);
  inline void set_opvalue8(const void* value, size_t size);
  inline ::std::string* mutable_opvalue8();
  inline ::std::string* release_opvalue8();
  inline void set_allocated_opvalue8(::std::string* opvalue8);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageClientOperation)
 private:
  inline void set_has_oper();
  inline void clear_has_oper();
  inline void set_has_opvalue1();
  inline void clear_has_opvalue1();
  inline void set_has_opvalue2();
  inline void clear_has_opvalue2();
  inline void set_has_opvalue3();
  inline void clear_has_opvalue3();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_oper_index();
  inline void clear_has_oper_index();
  inline void set_has_opvalue6();
  inline void clear_has_opvalue6();
  inline void set_has_opvalue8();
  inline void clear_has_opvalue8();

  ::google::protobuf::uint64 opvalue1_;
  ::google::protobuf::uint64 opvalue2_;
  int oper_;
  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint64 opvalue3_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > opvalue4_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > opvalue5_;
  ::std::string* opvalue6_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::batchInject > opvalue7_;
  ::std::string* opvalue8_;
  ::google::protobuf::uint32 oper_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageClientOperation* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageBattleBegin : public ::google::protobuf::MessageLite {
 public:
  CSMessageBattleBegin();
  virtual ~CSMessageBattleBegin();

  CSMessageBattleBegin(const CSMessageBattleBegin& from);

  inline CSMessageBattleBegin& operator=(const CSMessageBattleBegin& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageBattleBegin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageBattleBegin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageBattleBegin* other);

  // implements Message ----------------------------------------------

  CSMessageBattleBegin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageBattleBegin& from);
  void MergeFrom(const CSMessageBattleBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 difficult = 2;
  inline bool has_difficult() const;
  inline void clear_difficult();
  static const int kDifficultFieldNumber = 2;
  inline ::google::protobuf::uint32 difficult() const;
  inline void set_difficult(::google::protobuf::uint32 value);

  // optional uint32 catlog = 3;
  inline bool has_catlog() const;
  inline void clear_catlog();
  static const int kCatlogFieldNumber = 3;
  inline ::google::protobuf::uint32 catlog() const;
  inline void set_catlog(::google::protobuf::uint32 value);

  // optional .jynetwork.proto.sCharactorInit ci = 4;
  inline bool has_ci() const;
  inline void clear_ci();
  static const int kCiFieldNumber = 4;
  inline const ::jynetwork::proto::sCharactorInit& ci() const;
  inline ::jynetwork::proto::sCharactorInit* mutable_ci();
  inline ::jynetwork::proto::sCharactorInit* release_ci();
  inline void set_allocated_ci(::jynetwork::proto::sCharactorInit* ci);

  // optional uint32 endless_continue = 5;
  inline bool has_endless_continue() const;
  inline void clear_endless_continue();
  static const int kEndlessContinueFieldNumber = 5;
  inline ::google::protobuf::uint32 endless_continue() const;
  inline void set_endless_continue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageBattleBegin)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_difficult();
  inline void clear_has_difficult();
  inline void set_has_catlog();
  inline void clear_has_catlog();
  inline void set_has_ci();
  inline void clear_has_ci();
  inline void set_has_endless_continue();
  inline void clear_has_endless_continue();

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 difficult_;
  ::jynetwork::proto::sCharactorInit* ci_;
  ::google::protobuf::uint32 catlog_;
  ::google::protobuf::uint32 endless_continue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageBattleBegin* default_instance_;
};
// -------------------------------------------------------------------

class BattleTime : public ::google::protobuf::MessageLite {
 public:
  BattleTime();
  virtual ~BattleTime();

  BattleTime(const BattleTime& from);

  inline BattleTime& operator=(const BattleTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleTime* other);

  // implements Message ----------------------------------------------

  BattleTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleTime& from);
  void MergeFrom(const BattleTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 net_time = 2;
  inline bool has_net_time() const;
  inline void clear_net_time();
  static const int kNetTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 net_time() const;
  inline void set_net_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.BattleTime)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_net_time();
  inline void clear_has_net_time();

  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 net_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static BattleTime* default_instance_;
};
// -------------------------------------------------------------------

class BattleAttr : public ::google::protobuf::MessageLite {
 public:
  BattleAttr();
  virtual ~BattleAttr();

  BattleAttr(const BattleAttr& from);

  inline BattleAttr& operator=(const BattleAttr& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleAttr& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleAttr* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleAttr* other);

  // implements Message ----------------------------------------------

  BattleAttr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleAttr& from);
  void MergeFrom(const BattleAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 attr_id = 1;
  inline bool has_attr_id() const;
  inline void clear_attr_id();
  static const int kAttrIdFieldNumber = 1;
  inline ::google::protobuf::uint32 attr_id() const;
  inline void set_attr_id(::google::protobuf::uint32 value);

  // repeated uint32 attr_value = 2;
  inline int attr_value_size() const;
  inline void clear_attr_value();
  static const int kAttrValueFieldNumber = 2;
  inline ::google::protobuf::uint32 attr_value(int index) const;
  inline void set_attr_value(int index, ::google::protobuf::uint32 value);
  inline void add_attr_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attr_value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attr_value();

  // @@protoc_insertion_point(class_scope:jynetwork.proto.BattleAttr)
 private:
  inline void set_has_attr_id();
  inline void clear_has_attr_id();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attr_value_;
  ::google::protobuf::uint32 attr_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static BattleAttr* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageBattleCheck : public ::google::protobuf::MessageLite {
 public:
  CSMessageBattleCheck();
  virtual ~CSMessageBattleCheck();

  CSMessageBattleCheck(const CSMessageBattleCheck& from);

  inline CSMessageBattleCheck& operator=(const CSMessageBattleCheck& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageBattleCheck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageBattleCheck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageBattleCheck* other);

  // implements Message ----------------------------------------------

  CSMessageBattleCheck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageBattleCheck& from);
  void MergeFrom(const CSMessageBattleCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 check_id = 1;
  inline bool has_check_id() const;
  inline void clear_check_id();
  static const int kCheckIdFieldNumber = 1;
  inline ::google::protobuf::uint32 check_id() const;
  inline void set_check_id(::google::protobuf::uint32 value);

  // repeated .jynetwork.proto.BattleTime battle_time = 2;
  inline int battle_time_size() const;
  inline void clear_battle_time();
  static const int kBattleTimeFieldNumber = 2;
  inline const ::jynetwork::proto::BattleTime& battle_time(int index) const;
  inline ::jynetwork::proto::BattleTime* mutable_battle_time(int index);
  inline ::jynetwork::proto::BattleTime* add_battle_time();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime >&
      battle_time() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime >*
      mutable_battle_time();

  // repeated .jynetwork.proto.BattleAttr battle_attr = 3;
  inline int battle_attr_size() const;
  inline void clear_battle_attr();
  static const int kBattleAttrFieldNumber = 3;
  inline const ::jynetwork::proto::BattleAttr& battle_attr(int index) const;
  inline ::jynetwork::proto::BattleAttr* mutable_battle_attr(int index);
  inline ::jynetwork::proto::BattleAttr* add_battle_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleAttr >&
      battle_attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleAttr >*
      mutable_battle_attr();

  // optional .jynetwork.proto.sGameStats gamestats = 4;
  inline bool has_gamestats() const;
  inline void clear_gamestats();
  static const int kGamestatsFieldNumber = 4;
  inline const ::jynetwork::proto::sGameStats& gamestats() const;
  inline ::jynetwork::proto::sGameStats* mutable_gamestats();
  inline ::jynetwork::proto::sGameStats* release_gamestats();
  inline void set_allocated_gamestats(::jynetwork::proto::sGameStats* gamestats);

  // optional float battle_modify = 5;
  inline bool has_battle_modify() const;
  inline void clear_battle_modify();
  static const int kBattleModifyFieldNumber = 5;
  inline float battle_modify() const;
  inline void set_battle_modify(float value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageBattleCheck)
 private:
  inline void set_has_check_id();
  inline void clear_has_check_id();
  inline void set_has_gamestats();
  inline void clear_has_gamestats();
  inline void set_has_battle_modify();
  inline void clear_has_battle_modify();

  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime > battle_time_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleAttr > battle_attr_;
  ::google::protobuf::uint32 check_id_;
  float battle_modify_;
  ::jynetwork::proto::sGameStats* gamestats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageBattleCheck* default_instance_;
};
// -------------------------------------------------------------------

class BatttleSkillStatistics : public ::google::protobuf::MessageLite {
 public:
  BatttleSkillStatistics();
  virtual ~BatttleSkillStatistics();

  BatttleSkillStatistics(const BatttleSkillStatistics& from);

  inline BatttleSkillStatistics& operator=(const BatttleSkillStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  static const BatttleSkillStatistics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BatttleSkillStatistics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BatttleSkillStatistics* other);

  // implements Message ----------------------------------------------

  BatttleSkillStatistics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BatttleSkillStatistics& from);
  void MergeFrom(const BatttleSkillStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // optional uint32 skill_auto = 2;
  inline bool has_skill_auto() const;
  inline void clear_skill_auto();
  static const int kSkillAutoFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_auto() const;
  inline void set_skill_auto(::google::protobuf::uint32 value);

  // optional uint32 skill_manual = 3;
  inline bool has_skill_manual() const;
  inline void clear_skill_manual();
  static const int kSkillManualFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_manual() const;
  inline void set_skill_manual(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.BatttleSkillStatistics)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_skill_auto();
  inline void clear_has_skill_auto();
  inline void set_has_skill_manual();
  inline void clear_has_skill_manual();

  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 skill_auto_;
  ::google::protobuf::uint32 skill_manual_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static BatttleSkillStatistics* default_instance_;
};
// -------------------------------------------------------------------

class DamageScore : public ::google::protobuf::MessageLite {
 public:
  DamageScore();
  virtual ~DamageScore();

  DamageScore(const DamageScore& from);

  inline DamageScore& operator=(const DamageScore& from) {
    CopyFrom(from);
    return *this;
  }

  static const DamageScore& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DamageScore* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DamageScore* other);

  // implements Message ----------------------------------------------

  DamageScore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DamageScore& from);
  void MergeFrom(const DamageScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // optional float score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.DamageScore)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::uint32 uid_;
  float score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static DamageScore* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageBattleResult : public ::google::protobuf::MessageLite {
 public:
  CSMessageBattleResult();
  virtual ~CSMessageBattleResult();

  CSMessageBattleResult(const CSMessageBattleResult& from);

  inline CSMessageBattleResult& operator=(const CSMessageBattleResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageBattleResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageBattleResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageBattleResult* other);

  // implements Message ----------------------------------------------

  CSMessageBattleResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageBattleResult& from);
  void MergeFrom(const CSMessageBattleResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes battle_data = 3;
  inline bool has_battle_data() const;
  inline void clear_battle_data();
  static const int kBattleDataFieldNumber = 3;
  inline const ::std::string& battle_data() const;
  inline void set_battle_data(const ::std::string& value);
  inline void set_battle_data(const char* value);
  inline void set_battle_data(const void* value, size_t size);
  inline ::std::string* mutable_battle_data();
  inline ::std::string* release_battle_data();
  inline void set_allocated_battle_data(::std::string* battle_data);

  // optional uint32 battle_score = 4;
  inline bool has_battle_score() const;
  inline void clear_battle_score();
  static const int kBattleScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 battle_score() const;
  inline void set_battle_score(::google::protobuf::uint32 value);

  // optional uint32 battle_money = 5;
  inline bool has_battle_money() const;
  inline void clear_battle_money();
  static const int kBattleMoneyFieldNumber = 5;
  inline ::google::protobuf::uint32 battle_money() const;
  inline void set_battle_money(::google::protobuf::uint32 value);

  // optional uint32 difficult = 6;
  inline bool has_difficult() const;
  inline void clear_difficult();
  static const int kDifficultFieldNumber = 6;
  inline ::google::protobuf::uint32 difficult() const;
  inline void set_difficult(::google::protobuf::uint32 value);

  // optional uint32 battle_star = 7;
  inline bool has_battle_star() const;
  inline void clear_battle_star();
  static const int kBattleStarFieldNumber = 7;
  inline ::google::protobuf::uint32 battle_star() const;
  inline void set_battle_star(::google::protobuf::uint32 value);

  // optional uint32 rand_num = 8;
  inline bool has_rand_num() const;
  inline void clear_rand_num();
  static const int kRandNumFieldNumber = 8;
  inline ::google::protobuf::uint32 rand_num() const;
  inline void set_rand_num(::google::protobuf::uint32 value);

  // optional uint32 is_sweep = 9;
  inline bool has_is_sweep() const;
  inline void clear_is_sweep();
  static const int kIsSweepFieldNumber = 9;
  inline ::google::protobuf::uint32 is_sweep() const;
  inline void set_is_sweep(::google::protobuf::uint32 value);

  // optional uint32 sweep_times = 10;
  inline bool has_sweep_times() const;
  inline void clear_sweep_times();
  static const int kSweepTimesFieldNumber = 10;
  inline ::google::protobuf::uint32 sweep_times() const;
  inline void set_sweep_times(::google::protobuf::uint32 value);

  // optional uint32 dropmiddle = 11;
  inline bool has_dropmiddle() const;
  inline void clear_dropmiddle();
  static const int kDropmiddleFieldNumber = 11;
  inline ::google::protobuf::uint32 dropmiddle() const;
  inline void set_dropmiddle(::google::protobuf::uint32 value);

  // optional uint32 dropgolin = 12;
  inline bool has_dropgolin() const;
  inline void clear_dropgolin();
  static const int kDropgolinFieldNumber = 12;
  inline ::google::protobuf::uint32 dropgolin() const;
  inline void set_dropgolin(::google::protobuf::uint32 value);

  // optional bytes battle_data_type = 13;
  inline bool has_battle_data_type() const;
  inline void clear_battle_data_type();
  static const int kBattleDataTypeFieldNumber = 13;
  inline const ::std::string& battle_data_type() const;
  inline void set_battle_data_type(const ::std::string& value);
  inline void set_battle_data_type(const char* value);
  inline void set_battle_data_type(const void* value, size_t size);
  inline ::std::string* mutable_battle_data_type();
  inline ::std::string* release_battle_data_type();
  inline void set_allocated_battle_data_type(::std::string* battle_data_type);

  // repeated .jynetwork.proto.BattleTime battle_time = 14;
  inline int battle_time_size() const;
  inline void clear_battle_time();
  static const int kBattleTimeFieldNumber = 14;
  inline const ::jynetwork::proto::BattleTime& battle_time(int index) const;
  inline ::jynetwork::proto::BattleTime* mutable_battle_time(int index);
  inline ::jynetwork::proto::BattleTime* add_battle_time();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime >&
      battle_time() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime >*
      mutable_battle_time();

  // optional uint32 hit_score = 15;
  inline bool has_hit_score() const;
  inline void clear_hit_score();
  static const int kHitScoreFieldNumber = 15;
  inline ::google::protobuf::uint32 hit_score() const;
  inline void set_hit_score(::google::protobuf::uint32 value);

  // optional uint32 time_score = 16;
  inline bool has_time_score() const;
  inline void clear_time_score();
  static const int kTimeScoreFieldNumber = 16;
  inline ::google::protobuf::uint32 time_score() const;
  inline void set_time_score(::google::protobuf::uint32 value);

  // repeated .jynetwork.proto.BatttleSkillStatistics battle_skill_statistics = 17;
  inline int battle_skill_statistics_size() const;
  inline void clear_battle_skill_statistics();
  static const int kBattleSkillStatisticsFieldNumber = 17;
  inline const ::jynetwork::proto::BatttleSkillStatistics& battle_skill_statistics(int index) const;
  inline ::jynetwork::proto::BatttleSkillStatistics* mutable_battle_skill_statistics(int index);
  inline ::jynetwork::proto::BatttleSkillStatistics* add_battle_skill_statistics();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BatttleSkillStatistics >&
      battle_skill_statistics() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BatttleSkillStatistics >*
      mutable_battle_skill_statistics();

  // optional uint32 hp = 18;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 18;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // optional uint32 catlog = 19;
  inline bool has_catlog() const;
  inline void clear_catlog();
  static const int kCatlogFieldNumber = 19;
  inline ::google::protobuf::uint32 catlog() const;
  inline void set_catlog(::google::protobuf::uint32 value);

  // repeated .jynetwork.proto.CSMessageBattleCheck check = 20;
  inline int check_size() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 20;
  inline const ::jynetwork::proto::CSMessageBattleCheck& check(int index) const;
  inline ::jynetwork::proto::CSMessageBattleCheck* mutable_check(int index);
  inline ::jynetwork::proto::CSMessageBattleCheck* add_check();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::CSMessageBattleCheck >&
      check() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::CSMessageBattleCheck >*
      mutable_check();

  // optional uint32 battle_wave = 21;
  inline bool has_battle_wave() const;
  inline void clear_battle_wave();
  static const int kBattleWaveFieldNumber = 21;
  inline ::google::protobuf::uint32 battle_wave() const;
  inline void set_battle_wave(::google::protobuf::uint32 value);

  // repeated float hurts = 22;
  inline int hurts_size() const;
  inline void clear_hurts();
  static const int kHurtsFieldNumber = 22;
  inline float hurts(int index) const;
  inline void set_hurts(int index, float value);
  inline void add_hurts(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      hurts() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_hurts();

  // repeated .jynetwork.proto.DamageScore damage_score = 23;
  inline int damage_score_size() const;
  inline void clear_damage_score();
  static const int kDamageScoreFieldNumber = 23;
  inline const ::jynetwork::proto::DamageScore& damage_score(int index) const;
  inline ::jynetwork::proto::DamageScore* mutable_damage_score(int index);
  inline ::jynetwork::proto::DamageScore* add_damage_score();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore >&
      damage_score() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore >*
      mutable_damage_score();

  // repeated .jynetwork.proto.DamageScore solo_score = 24;
  inline int solo_score_size() const;
  inline void clear_solo_score();
  static const int kSoloScoreFieldNumber = 24;
  inline const ::jynetwork::proto::DamageScore& solo_score(int index) const;
  inline ::jynetwork::proto::DamageScore* mutable_solo_score(int index);
  inline ::jynetwork::proto::DamageScore* add_solo_score();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore >&
      solo_score() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore >*
      mutable_solo_score();

  // optional uint32 endless_check_wave = 25;
  inline bool has_endless_check_wave() const;
  inline void clear_endless_check_wave();
  static const int kEndlessCheckWaveFieldNumber = 25;
  inline ::google::protobuf::uint32 endless_check_wave() const;
  inline void set_endless_check_wave(::google::protobuf::uint32 value);

  // optional uint32 endless_check_score = 26;
  inline bool has_endless_check_score() const;
  inline void clear_endless_check_score();
  static const int kEndlessCheckScoreFieldNumber = 26;
  inline ::google::protobuf::uint32 endless_check_score() const;
  inline void set_endless_check_score(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageBattleResult)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_battle_data();
  inline void clear_has_battle_data();
  inline void set_has_battle_score();
  inline void clear_has_battle_score();
  inline void set_has_battle_money();
  inline void clear_has_battle_money();
  inline void set_has_difficult();
  inline void clear_has_difficult();
  inline void set_has_battle_star();
  inline void clear_has_battle_star();
  inline void set_has_rand_num();
  inline void clear_has_rand_num();
  inline void set_has_is_sweep();
  inline void clear_has_is_sweep();
  inline void set_has_sweep_times();
  inline void clear_has_sweep_times();
  inline void set_has_dropmiddle();
  inline void clear_has_dropmiddle();
  inline void set_has_dropgolin();
  inline void clear_has_dropgolin();
  inline void set_has_battle_data_type();
  inline void clear_has_battle_data_type();
  inline void set_has_hit_score();
  inline void clear_has_hit_score();
  inline void set_has_time_score();
  inline void clear_has_time_score();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_catlog();
  inline void clear_has_catlog();
  inline void set_has_battle_wave();
  inline void clear_has_battle_wave();
  inline void set_has_endless_check_wave();
  inline void clear_has_endless_check_wave();
  inline void set_has_endless_check_score();
  inline void clear_has_endless_check_score();

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 result_;
  ::std::string* battle_data_;
  ::google::protobuf::uint32 battle_score_;
  ::google::protobuf::uint32 battle_money_;
  ::google::protobuf::uint32 difficult_;
  ::google::protobuf::uint32 battle_star_;
  ::google::protobuf::uint32 rand_num_;
  ::google::protobuf::uint32 is_sweep_;
  ::google::protobuf::uint32 sweep_times_;
  ::google::protobuf::uint32 dropmiddle_;
  ::std::string* battle_data_type_;
  ::google::protobuf::uint32 dropgolin_;
  ::google::protobuf::uint32 hit_score_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime > battle_time_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BatttleSkillStatistics > battle_skill_statistics_;
  ::google::protobuf::uint32 time_score_;
  ::google::protobuf::uint32 hp_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::CSMessageBattleCheck > check_;
  ::google::protobuf::uint32 catlog_;
  ::google::protobuf::uint32 battle_wave_;
  ::google::protobuf::RepeatedField< float > hurts_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore > damage_score_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore > solo_score_;
  ::google::protobuf::uint32 endless_check_wave_;
  ::google::protobuf::uint32 endless_check_score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageBattleResult* default_instance_;
};
// -------------------------------------------------------------------

class CSMessagePing : public ::google::protobuf::MessageLite {
 public:
  CSMessagePing();
  virtual ~CSMessagePing();

  CSMessagePing(const CSMessagePing& from);

  inline CSMessagePing& operator=(const CSMessagePing& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessagePing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessagePing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessagePing* other);

  // implements Message ----------------------------------------------

  CSMessagePing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessagePing& from);
  void MergeFrom(const CSMessagePing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessagePing)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessagePing* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageGMCommond : public ::google::protobuf::MessageLite {
 public:
  CSMessageGMCommond();
  virtual ~CSMessageGMCommond();

  CSMessageGMCommond(const CSMessageGMCommond& from);

  inline CSMessageGMCommond& operator=(const CSMessageGMCommond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageGMCommond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageGMCommond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageGMCommond* other);

  // implements Message ----------------------------------------------

  CSMessageGMCommond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageGMCommond& from);
  void MergeFrom(const CSMessageGMCommond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const void* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageGMCommond)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::std::string* cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageGMCommond* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageRankList : public ::google::protobuf::MessageLite {
 public:
  CSMessageRankList();
  virtual ~CSMessageRankList();

  CSMessageRankList(const CSMessageRankList& from);

  inline CSMessageRankList& operator=(const CSMessageRankList& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageRankList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageRankList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageRankList* other);

  // implements Message ----------------------------------------------

  CSMessageRankList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageRankList& from);
  void MergeFrom(const CSMessageRankList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rank_type = 1;
  inline bool has_rank_type() const;
  inline void clear_rank_type();
  static const int kRankTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 rank_type() const;
  inline void set_rank_type(::google::protobuf::uint32 value);

  // optional uint32 page = 2;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 2;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageRankList)
 private:
  inline void set_has_rank_type();
  inline void clear_has_rank_type();
  inline void set_has_page();
  inline void clear_has_page();

  ::google::protobuf::uint32 rank_type_;
  ::google::protobuf::uint32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageRankList* default_instance_;
};
// -------------------------------------------------------------------

class CSMessagePlayerQuery : public ::google::protobuf::MessageLite {
 public:
  CSMessagePlayerQuery();
  virtual ~CSMessagePlayerQuery();

  CSMessagePlayerQuery(const CSMessagePlayerQuery& from);

  inline CSMessagePlayerQuery& operator=(const CSMessagePlayerQuery& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessagePlayerQuery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessagePlayerQuery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessagePlayerQuery* other);

  // implements Message ----------------------------------------------

  CSMessagePlayerQuery* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessagePlayerQuery& from);
  void MergeFrom(const CSMessagePlayerQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 query_type = 1;
  inline bool has_query_type() const;
  inline void clear_query_type();
  static const int kQueryTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 query_type() const;
  inline void set_query_type(::google::protobuf::uint32 value);

  // optional uint32 acc_id = 2;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 2;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // optional uint32 job = 3;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 3;
  inline ::google::protobuf::uint32 job() const;
  inline void set_job(::google::protobuf::uint32 value);

  // optional uint32 my_acc_id = 4;
  inline bool has_my_acc_id() const;
  inline void clear_my_acc_id();
  static const int kMyAccIdFieldNumber = 4;
  inline ::google::protobuf::uint32 my_acc_id() const;
  inline void set_my_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessagePlayerQuery)
 private:
  inline void set_has_query_type();
  inline void clear_has_query_type();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_my_acc_id();
  inline void clear_has_my_acc_id();

  ::google::protobuf::uint32 query_type_;
  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 job_;
  ::google::protobuf::uint32 my_acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessagePlayerQuery* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageCorpsOper : public ::google::protobuf::MessageLite {
 public:
  CSMessageCorpsOper();
  virtual ~CSMessageCorpsOper();

  CSMessageCorpsOper(const CSMessageCorpsOper& from);

  inline CSMessageCorpsOper& operator=(const CSMessageCorpsOper& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageCorpsOper& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageCorpsOper* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageCorpsOper* other);

  // implements Message ----------------------------------------------

  CSMessageCorpsOper* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageCorpsOper& from);
  void MergeFrom(const CSMessageCorpsOper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .jynetwork.proto.eCorpsOpertionType oper = 1;
  inline bool has_oper() const;
  inline void clear_oper();
  static const int kOperFieldNumber = 1;
  inline ::jynetwork::proto::eCorpsOpertionType oper() const;
  inline void set_oper(::jynetwork::proto::eCorpsOpertionType value);

  // optional uint32 corps_id = 2;
  inline bool has_corps_id() const;
  inline void clear_corps_id();
  static const int kCorpsIdFieldNumber = 2;
  inline ::google::protobuf::uint32 corps_id() const;
  inline void set_corps_id(::google::protobuf::uint32 value);

  // optional uint32 char_id = 3;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 3;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // optional bytes name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 page = 5;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 5;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // optional uint32 fight_power = 6;
  inline bool has_fight_power() const;
  inline void clear_fight_power();
  static const int kFightPowerFieldNumber = 6;
  inline ::google::protobuf::uint32 fight_power() const;
  inline void set_fight_power(::google::protobuf::uint32 value);

  // optional bytes info = 7;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 7;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageCorpsOper)
 private:
  inline void set_has_oper();
  inline void clear_has_oper();
  inline void set_has_corps_id();
  inline void clear_has_corps_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_fight_power();
  inline void clear_has_fight_power();
  inline void set_has_info();
  inline void clear_has_info();

  int oper_;
  ::google::protobuf::uint32 corps_id_;
  ::std::string* name_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 page_;
  ::std::string* info_;
  ::google::protobuf::uint32 fight_power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageCorpsOper* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageChat : public ::google::protobuf::MessageLite {
 public:
  CSMessageChat();
  virtual ~CSMessageChat();

  CSMessageChat(const CSMessageChat& from);

  inline CSMessageChat& operator=(const CSMessageChat& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageChat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageChat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageChat* other);

  // implements Message ----------------------------------------------

  CSMessageChat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageChat& from);
  void MergeFrom(const CSMessageChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 chat_type = 1;
  inline bool has_chat_type() const;
  inline void clear_chat_type();
  static const int kChatTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 chat_type() const;
  inline void set_chat_type(::google::protobuf::uint32 value);

  // optional string from_char = 2;
  inline bool has_from_char() const;
  inline void clear_from_char();
  static const int kFromCharFieldNumber = 2;
  inline const ::std::string& from_char() const;
  inline void set_from_char(const ::std::string& value);
  inline void set_from_char(const char* value);
  inline void set_from_char(const char* value, size_t size);
  inline ::std::string* mutable_from_char();
  inline ::std::string* release_from_char();
  inline void set_allocated_from_char(::std::string* from_char);

  // optional string to_char = 3;
  inline bool has_to_char() const;
  inline void clear_to_char();
  static const int kToCharFieldNumber = 3;
  inline const ::std::string& to_char() const;
  inline void set_to_char(const ::std::string& value);
  inline void set_to_char(const char* value);
  inline void set_to_char(const char* value, size_t size);
  inline ::std::string* mutable_to_char();
  inline ::std::string* release_to_char();
  inline void set_allocated_to_char(::std::string* to_char);

  // optional string chat_string = 4;
  inline bool has_chat_string() const;
  inline void clear_chat_string();
  static const int kChatStringFieldNumber = 4;
  inline const ::std::string& chat_string() const;
  inline void set_chat_string(const ::std::string& value);
  inline void set_chat_string(const char* value);
  inline void set_chat_string(const char* value, size_t size);
  inline ::std::string* mutable_chat_string();
  inline ::std::string* release_chat_string();
  inline void set_allocated_chat_string(::std::string* chat_string);

  // repeated .jynetwork.proto.sPersonEquipStats item = 5;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 5;
  inline const ::jynetwork::proto::sPersonEquipStats& item(int index) const;
  inline ::jynetwork::proto::sPersonEquipStats* mutable_item(int index);
  inline ::jynetwork::proto::sPersonEquipStats* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::sPersonEquipStats >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::sPersonEquipStats >*
      mutable_item();

  // optional uint64 except_id = 6;
  inline bool has_except_id() const;
  inline void clear_except_id();
  static const int kExceptIdFieldNumber = 6;
  inline ::google::protobuf::uint64 except_id() const;
  inline void set_except_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageChat)
 private:
  inline void set_has_chat_type();
  inline void clear_has_chat_type();
  inline void set_has_from_char();
  inline void clear_has_from_char();
  inline void set_has_to_char();
  inline void clear_has_to_char();
  inline void set_has_chat_string();
  inline void clear_has_chat_string();
  inline void set_has_except_id();
  inline void clear_has_except_id();

  ::std::string* from_char_;
  ::std::string* to_char_;
  ::std::string* chat_string_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::sPersonEquipStats > item_;
  ::google::protobuf::uint64 except_id_;
  ::google::protobuf::uint32 chat_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageChat* default_instance_;
};
// -------------------------------------------------------------------

class CSMessageArenaBattleBegin : public ::google::protobuf::MessageLite {
 public:
  CSMessageArenaBattleBegin();
  virtual ~CSMessageArenaBattleBegin();

  CSMessageArenaBattleBegin(const CSMessageArenaBattleBegin& from);

  inline CSMessageArenaBattleBegin& operator=(const CSMessageArenaBattleBegin& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMessageArenaBattleBegin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMessageArenaBattleBegin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMessageArenaBattleBegin* other);

  // implements Message ----------------------------------------------

  CSMessageArenaBattleBegin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMessageArenaBattleBegin& from);
  void MergeFrom(const CSMessageArenaBattleBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 net_type = 2;
  inline bool has_net_type() const;
  inline void clear_net_type();
  static const int kNetTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 net_type() const;
  inline void set_net_type(::google::protobuf::uint32 value);

  // optional .jynetwork.proto.sCharactorInit ci = 4;
  inline bool has_ci() const;
  inline void clear_ci();
  static const int kCiFieldNumber = 4;
  inline const ::jynetwork::proto::sCharactorInit& ci() const;
  inline ::jynetwork::proto::sCharactorInit* mutable_ci();
  inline ::jynetwork::proto::sCharactorInit* release_ci();
  inline void set_allocated_ci(::jynetwork::proto::sCharactorInit* ci);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.CSMessageArenaBattleBegin)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_net_type();
  inline void clear_has_net_type();
  inline void set_has_ci();
  inline void clear_has_ci();

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 net_type_;
  ::jynetwork::proto::sCharactorInit* ci_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMessage_2eproto();
  friend void protobuf_ShutdownFile_CSMessage_2eproto();

  void InitAsDefaultInstance();
  static CSMessageArenaBattleBegin* default_instance_;
};
// ===================================================================


// ===================================================================

// CSMessageNetBattleBegin

// optional uint32 map_id = 1;
inline bool CSMessageNetBattleBegin::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageNetBattleBegin::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageNetBattleBegin::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageNetBattleBegin::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 CSMessageNetBattleBegin::map_id() const {
  return map_id_;
}
inline void CSMessageNetBattleBegin::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 net_type = 2;
inline bool CSMessageNetBattleBegin::has_net_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageNetBattleBegin::set_has_net_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageNetBattleBegin::clear_has_net_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageNetBattleBegin::clear_net_type() {
  net_type_ = 0u;
  clear_has_net_type();
}
inline ::google::protobuf::uint32 CSMessageNetBattleBegin::net_type() const {
  return net_type_;
}
inline void CSMessageNetBattleBegin::set_net_type(::google::protobuf::uint32 value) {
  set_has_net_type();
  net_type_ = value;
}

// optional .jynetwork.proto.sCharactorInit ci = 4;
inline bool CSMessageNetBattleBegin::has_ci() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageNetBattleBegin::set_has_ci() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageNetBattleBegin::clear_has_ci() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageNetBattleBegin::clear_ci() {
  if (ci_ != NULL) ci_->::jynetwork::proto::sCharactorInit::Clear();
  clear_has_ci();
}
inline const ::jynetwork::proto::sCharactorInit& CSMessageNetBattleBegin::ci() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ci_ != NULL ? *ci_ : *default_instance().ci_;
#else
  return ci_ != NULL ? *ci_ : *default_instance_->ci_;
#endif
}
inline ::jynetwork::proto::sCharactorInit* CSMessageNetBattleBegin::mutable_ci() {
  set_has_ci();
  if (ci_ == NULL) ci_ = new ::jynetwork::proto::sCharactorInit;
  return ci_;
}
inline ::jynetwork::proto::sCharactorInit* CSMessageNetBattleBegin::release_ci() {
  clear_has_ci();
  ::jynetwork::proto::sCharactorInit* temp = ci_;
  ci_ = NULL;
  return temp;
}
inline void CSMessageNetBattleBegin::set_allocated_ci(::jynetwork::proto::sCharactorInit* ci) {
  delete ci_;
  ci_ = ci;
  if (ci) {
    set_has_ci();
  } else {
    clear_has_ci();
  }
}

// -------------------------------------------------------------------

// CSMessageNetBattleOper

// repeated .jynetwork.proto.NetBattleOper opers = 1;
inline int CSMessageNetBattleOper::opers_size() const {
  return opers_.size();
}
inline void CSMessageNetBattleOper::clear_opers() {
  opers_.Clear();
}
inline const ::jynetwork::proto::NetBattleOper& CSMessageNetBattleOper::opers(int index) const {
  return opers_.Get(index);
}
inline ::jynetwork::proto::NetBattleOper* CSMessageNetBattleOper::mutable_opers(int index) {
  return opers_.Mutable(index);
}
inline ::jynetwork::proto::NetBattleOper* CSMessageNetBattleOper::add_opers() {
  return opers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::NetBattleOper >&
CSMessageNetBattleOper::opers() const {
  return opers_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::NetBattleOper >*
CSMessageNetBattleOper::mutable_opers() {
  return &opers_;
}

// optional uint32 battle_time = 2;
inline bool CSMessageNetBattleOper::has_battle_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageNetBattleOper::set_has_battle_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageNetBattleOper::clear_has_battle_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageNetBattleOper::clear_battle_time() {
  battle_time_ = 0u;
  clear_has_battle_time();
}
inline ::google::protobuf::uint32 CSMessageNetBattleOper::battle_time() const {
  return battle_time_;
}
inline void CSMessageNetBattleOper::set_battle_time(::google::protobuf::uint32 value) {
  set_has_battle_time();
  battle_time_ = value;
}

// -------------------------------------------------------------------

// CSMessageLoginAuth

// optional uint32 ver_main = 1;
inline bool CSMessageLoginAuth::has_ver_main() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageLoginAuth::set_has_ver_main() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageLoginAuth::clear_has_ver_main() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageLoginAuth::clear_ver_main() {
  ver_main_ = 0u;
  clear_has_ver_main();
}
inline ::google::protobuf::uint32 CSMessageLoginAuth::ver_main() const {
  return ver_main_;
}
inline void CSMessageLoginAuth::set_ver_main(::google::protobuf::uint32 value) {
  set_has_ver_main();
  ver_main_ = value;
}

// optional uint32 ver_sub = 2;
inline bool CSMessageLoginAuth::has_ver_sub() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageLoginAuth::set_has_ver_sub() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageLoginAuth::clear_has_ver_sub() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageLoginAuth::clear_ver_sub() {
  ver_sub_ = 0u;
  clear_has_ver_sub();
}
inline ::google::protobuf::uint32 CSMessageLoginAuth::ver_sub() const {
  return ver_sub_;
}
inline void CSMessageLoginAuth::set_ver_sub(::google::protobuf::uint32 value) {
  set_has_ver_sub();
  ver_sub_ = value;
}

// optional uint32 ver_type = 3;
inline bool CSMessageLoginAuth::has_ver_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageLoginAuth::set_has_ver_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageLoginAuth::clear_has_ver_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageLoginAuth::clear_ver_type() {
  ver_type_ = 0u;
  clear_has_ver_type();
}
inline ::google::protobuf::uint32 CSMessageLoginAuth::ver_type() const {
  return ver_type_;
}
inline void CSMessageLoginAuth::set_ver_type(::google::protobuf::uint32 value) {
  set_has_ver_type();
  ver_type_ = value;
}

// optional string user_name = 4;
inline bool CSMessageLoginAuth::has_user_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessageLoginAuth::set_has_user_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessageLoginAuth::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessageLoginAuth::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& CSMessageLoginAuth::user_name() const {
  return *user_name_;
}
inline void CSMessageLoginAuth::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void CSMessageLoginAuth::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void CSMessageLoginAuth::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* CSMessageLoginAuth::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes user_pass = 5;
inline bool CSMessageLoginAuth::has_user_pass() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMessageLoginAuth::set_has_user_pass() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMessageLoginAuth::clear_has_user_pass() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMessageLoginAuth::clear_user_pass() {
  if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
    user_pass_->clear();
  }
  clear_has_user_pass();
}
inline const ::std::string& CSMessageLoginAuth::user_pass() const {
  return *user_pass_;
}
inline void CSMessageLoginAuth::set_user_pass(const ::std::string& value) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(value);
}
inline void CSMessageLoginAuth::set_user_pass(const char* value) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(value);
}
inline void CSMessageLoginAuth::set_user_pass(const void* value, size_t size) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_user_pass() {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  return user_pass_;
}
inline ::std::string* CSMessageLoginAuth::release_user_pass() {
  clear_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_pass_;
    user_pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_user_pass(::std::string* user_pass) {
  if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
    delete user_pass_;
  }
  if (user_pass) {
    set_has_user_pass();
    user_pass_ = user_pass;
  } else {
    clear_has_user_pass();
    user_pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gm_check = 6;
inline bool CSMessageLoginAuth::has_gm_check() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSMessageLoginAuth::set_has_gm_check() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSMessageLoginAuth::clear_has_gm_check() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSMessageLoginAuth::clear_gm_check() {
  gm_check_ = 0u;
  clear_has_gm_check();
}
inline ::google::protobuf::uint32 CSMessageLoginAuth::gm_check() const {
  return gm_check_;
}
inline void CSMessageLoginAuth::set_gm_check(::google::protobuf::uint32 value) {
  set_has_gm_check();
  gm_check_ = value;
}

// optional uint32 is_create = 7;
inline bool CSMessageLoginAuth::has_is_create() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSMessageLoginAuth::set_has_is_create() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSMessageLoginAuth::clear_has_is_create() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSMessageLoginAuth::clear_is_create() {
  is_create_ = 0u;
  clear_has_is_create();
}
inline ::google::protobuf::uint32 CSMessageLoginAuth::is_create() const {
  return is_create_;
}
inline void CSMessageLoginAuth::set_is_create(::google::protobuf::uint32 value) {
  set_has_is_create();
  is_create_ = value;
}

// optional string packetid = 8;
inline bool CSMessageLoginAuth::has_packetid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSMessageLoginAuth::set_has_packetid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSMessageLoginAuth::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSMessageLoginAuth::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& CSMessageLoginAuth::packetid() const {
  return *packetid_;
}
inline void CSMessageLoginAuth::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void CSMessageLoginAuth::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void CSMessageLoginAuth::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* CSMessageLoginAuth::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string open_id = 9;
inline bool CSMessageLoginAuth::has_open_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSMessageLoginAuth::set_has_open_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSMessageLoginAuth::clear_has_open_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSMessageLoginAuth::clear_open_id() {
  if (open_id_ != &::google::protobuf::internal::kEmptyString) {
    open_id_->clear();
  }
  clear_has_open_id();
}
inline const ::std::string& CSMessageLoginAuth::open_id() const {
  return *open_id_;
}
inline void CSMessageLoginAuth::set_open_id(const ::std::string& value) {
  set_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    open_id_ = new ::std::string;
  }
  open_id_->assign(value);
}
inline void CSMessageLoginAuth::set_open_id(const char* value) {
  set_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    open_id_ = new ::std::string;
  }
  open_id_->assign(value);
}
inline void CSMessageLoginAuth::set_open_id(const char* value, size_t size) {
  set_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    open_id_ = new ::std::string;
  }
  open_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_open_id() {
  set_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    open_id_ = new ::std::string;
  }
  return open_id_;
}
inline ::std::string* CSMessageLoginAuth::release_open_id() {
  clear_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = open_id_;
    open_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_open_id(::std::string* open_id) {
  if (open_id_ != &::google::protobuf::internal::kEmptyString) {
    delete open_id_;
  }
  if (open_id) {
    set_has_open_id();
    open_id_ = open_id;
  } else {
    clear_has_open_id();
    open_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 10;
inline bool CSMessageLoginAuth::has_token() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSMessageLoginAuth::set_has_token() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSMessageLoginAuth::clear_has_token() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSMessageLoginAuth::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CSMessageLoginAuth::token() const {
  return *token_;
}
inline void CSMessageLoginAuth::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSMessageLoginAuth::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSMessageLoginAuth::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CSMessageLoginAuth::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes device_id = 11;
inline bool CSMessageLoginAuth::has_device_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSMessageLoginAuth::set_has_device_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSMessageLoginAuth::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSMessageLoginAuth::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CSMessageLoginAuth::device_id() const {
  return *device_id_;
}
inline void CSMessageLoginAuth::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CSMessageLoginAuth::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CSMessageLoginAuth::set_device_id(const void* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CSMessageLoginAuth::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 inner_crc = 12;
inline bool CSMessageLoginAuth::has_inner_crc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSMessageLoginAuth::set_has_inner_crc() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSMessageLoginAuth::clear_has_inner_crc() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSMessageLoginAuth::clear_inner_crc() {
  inner_crc_ = 0u;
  clear_has_inner_crc();
}
inline ::google::protobuf::uint32 CSMessageLoginAuth::inner_crc() const {
  return inner_crc_;
}
inline void CSMessageLoginAuth::set_inner_crc(::google::protobuf::uint32 value) {
  set_has_inner_crc();
  inner_crc_ = value;
}

// optional fixed32 outer_crc = 13;
inline bool CSMessageLoginAuth::has_outer_crc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSMessageLoginAuth::set_has_outer_crc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSMessageLoginAuth::clear_has_outer_crc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSMessageLoginAuth::clear_outer_crc() {
  outer_crc_ = 0u;
  clear_has_outer_crc();
}
inline ::google::protobuf::uint32 CSMessageLoginAuth::outer_crc() const {
  return outer_crc_;
}
inline void CSMessageLoginAuth::set_outer_crc(::google::protobuf::uint32 value) {
  set_has_outer_crc();
  outer_crc_ = value;
}

// optional bytes idfa = 14;
inline bool CSMessageLoginAuth::has_idfa() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSMessageLoginAuth::set_has_idfa() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSMessageLoginAuth::clear_has_idfa() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSMessageLoginAuth::clear_idfa() {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    idfa_->clear();
  }
  clear_has_idfa();
}
inline const ::std::string& CSMessageLoginAuth::idfa() const {
  return *idfa_;
}
inline void CSMessageLoginAuth::set_idfa(const ::std::string& value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void CSMessageLoginAuth::set_idfa(const char* value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void CSMessageLoginAuth::set_idfa(const void* value, size_t size) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_idfa() {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  return idfa_;
}
inline ::std::string* CSMessageLoginAuth::release_idfa() {
  clear_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idfa_;
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_idfa(::std::string* idfa) {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    delete idfa_;
  }
  if (idfa) {
    set_has_idfa();
    idfa_ = idfa;
  } else {
    clear_has_idfa();
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ip = 15;
inline bool CSMessageLoginAuth::has_ip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSMessageLoginAuth::set_has_ip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSMessageLoginAuth::clear_has_ip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSMessageLoginAuth::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& CSMessageLoginAuth::ip() const {
  return *ip_;
}
inline void CSMessageLoginAuth::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void CSMessageLoginAuth::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void CSMessageLoginAuth::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* CSMessageLoginAuth::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 test_key = 16;
inline bool CSMessageLoginAuth::has_test_key() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSMessageLoginAuth::set_has_test_key() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSMessageLoginAuth::clear_has_test_key() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSMessageLoginAuth::clear_test_key() {
  test_key_ = 0u;
  clear_has_test_key();
}
inline ::google::protobuf::uint32 CSMessageLoginAuth::test_key() const {
  return test_key_;
}
inline void CSMessageLoginAuth::set_test_key(::google::protobuf::uint32 value) {
  set_has_test_key();
  test_key_ = value;
}

// optional bytes lilith_packet_name = 17;
inline bool CSMessageLoginAuth::has_lilith_packet_name() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_packet_name() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_packet_name() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CSMessageLoginAuth::clear_lilith_packet_name() {
  if (lilith_packet_name_ != &::google::protobuf::internal::kEmptyString) {
    lilith_packet_name_->clear();
  }
  clear_has_lilith_packet_name();
}
inline const ::std::string& CSMessageLoginAuth::lilith_packet_name() const {
  return *lilith_packet_name_;
}
inline void CSMessageLoginAuth::set_lilith_packet_name(const ::std::string& value) {
  set_has_lilith_packet_name();
  if (lilith_packet_name_ == &::google::protobuf::internal::kEmptyString) {
    lilith_packet_name_ = new ::std::string;
  }
  lilith_packet_name_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_packet_name(const char* value) {
  set_has_lilith_packet_name();
  if (lilith_packet_name_ == &::google::protobuf::internal::kEmptyString) {
    lilith_packet_name_ = new ::std::string;
  }
  lilith_packet_name_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_packet_name(const void* value, size_t size) {
  set_has_lilith_packet_name();
  if (lilith_packet_name_ == &::google::protobuf::internal::kEmptyString) {
    lilith_packet_name_ = new ::std::string;
  }
  lilith_packet_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_packet_name() {
  set_has_lilith_packet_name();
  if (lilith_packet_name_ == &::google::protobuf::internal::kEmptyString) {
    lilith_packet_name_ = new ::std::string;
  }
  return lilith_packet_name_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_packet_name() {
  clear_has_lilith_packet_name();
  if (lilith_packet_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_packet_name_;
    lilith_packet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_packet_name(::std::string* lilith_packet_name) {
  if (lilith_packet_name_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_packet_name_;
  }
  if (lilith_packet_name) {
    set_has_lilith_packet_name();
    lilith_packet_name_ = lilith_packet_name;
  } else {
    clear_has_lilith_packet_name();
    lilith_packet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes lilith_channel_id = 18;
inline bool CSMessageLoginAuth::has_lilith_channel_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_channel_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_channel_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CSMessageLoginAuth::clear_lilith_channel_id() {
  if (lilith_channel_id_ != &::google::protobuf::internal::kEmptyString) {
    lilith_channel_id_->clear();
  }
  clear_has_lilith_channel_id();
}
inline const ::std::string& CSMessageLoginAuth::lilith_channel_id() const {
  return *lilith_channel_id_;
}
inline void CSMessageLoginAuth::set_lilith_channel_id(const ::std::string& value) {
  set_has_lilith_channel_id();
  if (lilith_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_channel_id_ = new ::std::string;
  }
  lilith_channel_id_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_channel_id(const char* value) {
  set_has_lilith_channel_id();
  if (lilith_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_channel_id_ = new ::std::string;
  }
  lilith_channel_id_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_channel_id(const void* value, size_t size) {
  set_has_lilith_channel_id();
  if (lilith_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_channel_id_ = new ::std::string;
  }
  lilith_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_channel_id() {
  set_has_lilith_channel_id();
  if (lilith_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_channel_id_ = new ::std::string;
  }
  return lilith_channel_id_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_channel_id() {
  clear_has_lilith_channel_id();
  if (lilith_channel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_channel_id_;
    lilith_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_channel_id(::std::string* lilith_channel_id) {
  if (lilith_channel_id_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_channel_id_;
  }
  if (lilith_channel_id) {
    set_has_lilith_channel_id();
    lilith_channel_id_ = lilith_channel_id;
  } else {
    clear_has_lilith_channel_id();
    lilith_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes lilith_idfa = 19;
inline bool CSMessageLoginAuth::has_lilith_idfa() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_idfa() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_idfa() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CSMessageLoginAuth::clear_lilith_idfa() {
  if (lilith_idfa_ != &::google::protobuf::internal::kEmptyString) {
    lilith_idfa_->clear();
  }
  clear_has_lilith_idfa();
}
inline const ::std::string& CSMessageLoginAuth::lilith_idfa() const {
  return *lilith_idfa_;
}
inline void CSMessageLoginAuth::set_lilith_idfa(const ::std::string& value) {
  set_has_lilith_idfa();
  if (lilith_idfa_ == &::google::protobuf::internal::kEmptyString) {
    lilith_idfa_ = new ::std::string;
  }
  lilith_idfa_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_idfa(const char* value) {
  set_has_lilith_idfa();
  if (lilith_idfa_ == &::google::protobuf::internal::kEmptyString) {
    lilith_idfa_ = new ::std::string;
  }
  lilith_idfa_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_idfa(const void* value, size_t size) {
  set_has_lilith_idfa();
  if (lilith_idfa_ == &::google::protobuf::internal::kEmptyString) {
    lilith_idfa_ = new ::std::string;
  }
  lilith_idfa_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_idfa() {
  set_has_lilith_idfa();
  if (lilith_idfa_ == &::google::protobuf::internal::kEmptyString) {
    lilith_idfa_ = new ::std::string;
  }
  return lilith_idfa_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_idfa() {
  clear_has_lilith_idfa();
  if (lilith_idfa_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_idfa_;
    lilith_idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_idfa(::std::string* lilith_idfa) {
  if (lilith_idfa_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_idfa_;
  }
  if (lilith_idfa) {
    set_has_lilith_idfa();
    lilith_idfa_ = lilith_idfa;
  } else {
    clear_has_lilith_idfa();
    lilith_idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes lilith_andriod_id = 20;
inline bool CSMessageLoginAuth::has_lilith_andriod_id() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_andriod_id() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_andriod_id() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CSMessageLoginAuth::clear_lilith_andriod_id() {
  if (lilith_andriod_id_ != &::google::protobuf::internal::kEmptyString) {
    lilith_andriod_id_->clear();
  }
  clear_has_lilith_andriod_id();
}
inline const ::std::string& CSMessageLoginAuth::lilith_andriod_id() const {
  return *lilith_andriod_id_;
}
inline void CSMessageLoginAuth::set_lilith_andriod_id(const ::std::string& value) {
  set_has_lilith_andriod_id();
  if (lilith_andriod_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_andriod_id_ = new ::std::string;
  }
  lilith_andriod_id_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_andriod_id(const char* value) {
  set_has_lilith_andriod_id();
  if (lilith_andriod_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_andriod_id_ = new ::std::string;
  }
  lilith_andriod_id_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_andriod_id(const void* value, size_t size) {
  set_has_lilith_andriod_id();
  if (lilith_andriod_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_andriod_id_ = new ::std::string;
  }
  lilith_andriod_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_andriod_id() {
  set_has_lilith_andriod_id();
  if (lilith_andriod_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_andriod_id_ = new ::std::string;
  }
  return lilith_andriod_id_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_andriod_id() {
  clear_has_lilith_andriod_id();
  if (lilith_andriod_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_andriod_id_;
    lilith_andriod_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_andriod_id(::std::string* lilith_andriod_id) {
  if (lilith_andriod_id_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_andriod_id_;
  }
  if (lilith_andriod_id) {
    set_has_lilith_andriod_id();
    lilith_andriod_id_ = lilith_andriod_id;
  } else {
    clear_has_lilith_andriod_id();
    lilith_andriod_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes lilith_google_id = 21;
inline bool CSMessageLoginAuth::has_lilith_google_id() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_google_id() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_google_id() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CSMessageLoginAuth::clear_lilith_google_id() {
  if (lilith_google_id_ != &::google::protobuf::internal::kEmptyString) {
    lilith_google_id_->clear();
  }
  clear_has_lilith_google_id();
}
inline const ::std::string& CSMessageLoginAuth::lilith_google_id() const {
  return *lilith_google_id_;
}
inline void CSMessageLoginAuth::set_lilith_google_id(const ::std::string& value) {
  set_has_lilith_google_id();
  if (lilith_google_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_google_id_ = new ::std::string;
  }
  lilith_google_id_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_google_id(const char* value) {
  set_has_lilith_google_id();
  if (lilith_google_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_google_id_ = new ::std::string;
  }
  lilith_google_id_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_google_id(const void* value, size_t size) {
  set_has_lilith_google_id();
  if (lilith_google_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_google_id_ = new ::std::string;
  }
  lilith_google_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_google_id() {
  set_has_lilith_google_id();
  if (lilith_google_id_ == &::google::protobuf::internal::kEmptyString) {
    lilith_google_id_ = new ::std::string;
  }
  return lilith_google_id_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_google_id() {
  clear_has_lilith_google_id();
  if (lilith_google_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_google_id_;
    lilith_google_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_google_id(::std::string* lilith_google_id) {
  if (lilith_google_id_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_google_id_;
  }
  if (lilith_google_id) {
    set_has_lilith_google_id();
    lilith_google_id_ = lilith_google_id;
  } else {
    clear_has_lilith_google_id();
    lilith_google_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes lilith_os_type = 22;
inline bool CSMessageLoginAuth::has_lilith_os_type() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_os_type() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_os_type() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CSMessageLoginAuth::clear_lilith_os_type() {
  if (lilith_os_type_ != &::google::protobuf::internal::kEmptyString) {
    lilith_os_type_->clear();
  }
  clear_has_lilith_os_type();
}
inline const ::std::string& CSMessageLoginAuth::lilith_os_type() const {
  return *lilith_os_type_;
}
inline void CSMessageLoginAuth::set_lilith_os_type(const ::std::string& value) {
  set_has_lilith_os_type();
  if (lilith_os_type_ == &::google::protobuf::internal::kEmptyString) {
    lilith_os_type_ = new ::std::string;
  }
  lilith_os_type_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_os_type(const char* value) {
  set_has_lilith_os_type();
  if (lilith_os_type_ == &::google::protobuf::internal::kEmptyString) {
    lilith_os_type_ = new ::std::string;
  }
  lilith_os_type_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_os_type(const void* value, size_t size) {
  set_has_lilith_os_type();
  if (lilith_os_type_ == &::google::protobuf::internal::kEmptyString) {
    lilith_os_type_ = new ::std::string;
  }
  lilith_os_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_os_type() {
  set_has_lilith_os_type();
  if (lilith_os_type_ == &::google::protobuf::internal::kEmptyString) {
    lilith_os_type_ = new ::std::string;
  }
  return lilith_os_type_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_os_type() {
  clear_has_lilith_os_type();
  if (lilith_os_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_os_type_;
    lilith_os_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_os_type(::std::string* lilith_os_type) {
  if (lilith_os_type_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_os_type_;
  }
  if (lilith_os_type) {
    set_has_lilith_os_type();
    lilith_os_type_ = lilith_os_type;
  } else {
    clear_has_lilith_os_type();
    lilith_os_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes lilith_os_version = 23;
inline bool CSMessageLoginAuth::has_lilith_os_version() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_os_version() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_os_version() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CSMessageLoginAuth::clear_lilith_os_version() {
  if (lilith_os_version_ != &::google::protobuf::internal::kEmptyString) {
    lilith_os_version_->clear();
  }
  clear_has_lilith_os_version();
}
inline const ::std::string& CSMessageLoginAuth::lilith_os_version() const {
  return *lilith_os_version_;
}
inline void CSMessageLoginAuth::set_lilith_os_version(const ::std::string& value) {
  set_has_lilith_os_version();
  if (lilith_os_version_ == &::google::protobuf::internal::kEmptyString) {
    lilith_os_version_ = new ::std::string;
  }
  lilith_os_version_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_os_version(const char* value) {
  set_has_lilith_os_version();
  if (lilith_os_version_ == &::google::protobuf::internal::kEmptyString) {
    lilith_os_version_ = new ::std::string;
  }
  lilith_os_version_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_os_version(const void* value, size_t size) {
  set_has_lilith_os_version();
  if (lilith_os_version_ == &::google::protobuf::internal::kEmptyString) {
    lilith_os_version_ = new ::std::string;
  }
  lilith_os_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_os_version() {
  set_has_lilith_os_version();
  if (lilith_os_version_ == &::google::protobuf::internal::kEmptyString) {
    lilith_os_version_ = new ::std::string;
  }
  return lilith_os_version_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_os_version() {
  clear_has_lilith_os_version();
  if (lilith_os_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_os_version_;
    lilith_os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_os_version(::std::string* lilith_os_version) {
  if (lilith_os_version_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_os_version_;
  }
  if (lilith_os_version) {
    set_has_lilith_os_version();
    lilith_os_version_ = lilith_os_version;
  } else {
    clear_has_lilith_os_version();
    lilith_os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes lilith_app_version = 24;
inline bool CSMessageLoginAuth::has_lilith_app_version() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_app_version() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_app_version() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CSMessageLoginAuth::clear_lilith_app_version() {
  if (lilith_app_version_ != &::google::protobuf::internal::kEmptyString) {
    lilith_app_version_->clear();
  }
  clear_has_lilith_app_version();
}
inline const ::std::string& CSMessageLoginAuth::lilith_app_version() const {
  return *lilith_app_version_;
}
inline void CSMessageLoginAuth::set_lilith_app_version(const ::std::string& value) {
  set_has_lilith_app_version();
  if (lilith_app_version_ == &::google::protobuf::internal::kEmptyString) {
    lilith_app_version_ = new ::std::string;
  }
  lilith_app_version_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_app_version(const char* value) {
  set_has_lilith_app_version();
  if (lilith_app_version_ == &::google::protobuf::internal::kEmptyString) {
    lilith_app_version_ = new ::std::string;
  }
  lilith_app_version_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_app_version(const void* value, size_t size) {
  set_has_lilith_app_version();
  if (lilith_app_version_ == &::google::protobuf::internal::kEmptyString) {
    lilith_app_version_ = new ::std::string;
  }
  lilith_app_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_app_version() {
  set_has_lilith_app_version();
  if (lilith_app_version_ == &::google::protobuf::internal::kEmptyString) {
    lilith_app_version_ = new ::std::string;
  }
  return lilith_app_version_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_app_version() {
  clear_has_lilith_app_version();
  if (lilith_app_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_app_version_;
    lilith_app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_app_version(::std::string* lilith_app_version) {
  if (lilith_app_version_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_app_version_;
  }
  if (lilith_app_version) {
    set_has_lilith_app_version();
    lilith_app_version_ = lilith_app_version;
  } else {
    clear_has_lilith_app_version();
    lilith_app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes lilith_device_model = 25;
inline bool CSMessageLoginAuth::has_lilith_device_model() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CSMessageLoginAuth::set_has_lilith_device_model() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CSMessageLoginAuth::clear_has_lilith_device_model() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CSMessageLoginAuth::clear_lilith_device_model() {
  if (lilith_device_model_ != &::google::protobuf::internal::kEmptyString) {
    lilith_device_model_->clear();
  }
  clear_has_lilith_device_model();
}
inline const ::std::string& CSMessageLoginAuth::lilith_device_model() const {
  return *lilith_device_model_;
}
inline void CSMessageLoginAuth::set_lilith_device_model(const ::std::string& value) {
  set_has_lilith_device_model();
  if (lilith_device_model_ == &::google::protobuf::internal::kEmptyString) {
    lilith_device_model_ = new ::std::string;
  }
  lilith_device_model_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_device_model(const char* value) {
  set_has_lilith_device_model();
  if (lilith_device_model_ == &::google::protobuf::internal::kEmptyString) {
    lilith_device_model_ = new ::std::string;
  }
  lilith_device_model_->assign(value);
}
inline void CSMessageLoginAuth::set_lilith_device_model(const void* value, size_t size) {
  set_has_lilith_device_model();
  if (lilith_device_model_ == &::google::protobuf::internal::kEmptyString) {
    lilith_device_model_ = new ::std::string;
  }
  lilith_device_model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageLoginAuth::mutable_lilith_device_model() {
  set_has_lilith_device_model();
  if (lilith_device_model_ == &::google::protobuf::internal::kEmptyString) {
    lilith_device_model_ = new ::std::string;
  }
  return lilith_device_model_;
}
inline ::std::string* CSMessageLoginAuth::release_lilith_device_model() {
  clear_has_lilith_device_model();
  if (lilith_device_model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lilith_device_model_;
    lilith_device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageLoginAuth::set_allocated_lilith_device_model(::std::string* lilith_device_model) {
  if (lilith_device_model_ != &::google::protobuf::internal::kEmptyString) {
    delete lilith_device_model_;
  }
  if (lilith_device_model) {
    set_has_lilith_device_model();
    lilith_device_model_ = lilith_device_model;
  } else {
    clear_has_lilith_device_model();
    lilith_device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSMessageGateAuth

// required uint32 acc_id = 1;
inline bool CSMessageGateAuth::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageGateAuth::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageGateAuth::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageGateAuth::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 CSMessageGateAuth::acc_id() const {
  return acc_id_;
}
inline void CSMessageGateAuth::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 session_key = 2;
inline bool CSMessageGateAuth::has_session_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageGateAuth::set_has_session_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageGateAuth::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageGateAuth::clear_session_key() {
  session_key_ = 0u;
  clear_has_session_key();
}
inline ::google::protobuf::uint32 CSMessageGateAuth::session_key() const {
  return session_key_;
}
inline void CSMessageGateAuth::set_session_key(::google::protobuf::uint32 value) {
  set_has_session_key();
  session_key_ = value;
}

// optional uint32 need_full_data = 3;
inline bool CSMessageGateAuth::has_need_full_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageGateAuth::set_has_need_full_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageGateAuth::clear_has_need_full_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageGateAuth::clear_need_full_data() {
  need_full_data_ = 0u;
  clear_has_need_full_data();
}
inline ::google::protobuf::uint32 CSMessageGateAuth::need_full_data() const {
  return need_full_data_;
}
inline void CSMessageGateAuth::set_need_full_data(::google::protobuf::uint32 value) {
  set_has_need_full_data();
  need_full_data_ = value;
}

// optional bytes push_token = 4;
inline bool CSMessageGateAuth::has_push_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessageGateAuth::set_has_push_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessageGateAuth::clear_has_push_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessageGateAuth::clear_push_token() {
  if (push_token_ != &::google::protobuf::internal::kEmptyString) {
    push_token_->clear();
  }
  clear_has_push_token();
}
inline const ::std::string& CSMessageGateAuth::push_token() const {
  return *push_token_;
}
inline void CSMessageGateAuth::set_push_token(const ::std::string& value) {
  set_has_push_token();
  if (push_token_ == &::google::protobuf::internal::kEmptyString) {
    push_token_ = new ::std::string;
  }
  push_token_->assign(value);
}
inline void CSMessageGateAuth::set_push_token(const char* value) {
  set_has_push_token();
  if (push_token_ == &::google::protobuf::internal::kEmptyString) {
    push_token_ = new ::std::string;
  }
  push_token_->assign(value);
}
inline void CSMessageGateAuth::set_push_token(const void* value, size_t size) {
  set_has_push_token();
  if (push_token_ == &::google::protobuf::internal::kEmptyString) {
    push_token_ = new ::std::string;
  }
  push_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageGateAuth::mutable_push_token() {
  set_has_push_token();
  if (push_token_ == &::google::protobuf::internal::kEmptyString) {
    push_token_ = new ::std::string;
  }
  return push_token_;
}
inline ::std::string* CSMessageGateAuth::release_push_token() {
  clear_has_push_token();
  if (push_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = push_token_;
    push_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageGateAuth::set_allocated_push_token(::std::string* push_token) {
  if (push_token_ != &::google::protobuf::internal::kEmptyString) {
    delete push_token_;
  }
  if (push_token) {
    set_has_push_token();
    push_token_ = push_token;
  } else {
    clear_has_push_token();
    push_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 push_type = 5;
inline bool CSMessageGateAuth::has_push_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMessageGateAuth::set_has_push_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMessageGateAuth::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMessageGateAuth::clear_push_type() {
  push_type_ = 0u;
  clear_has_push_type();
}
inline ::google::protobuf::uint32 CSMessageGateAuth::push_type() const {
  return push_type_;
}
inline void CSMessageGateAuth::set_push_type(::google::protobuf::uint32 value) {
  set_has_push_type();
  push_type_ = value;
}

// -------------------------------------------------------------------

// CSMessageCreateCharInfo

// required bytes char_name = 1;
inline bool CSMessageCreateCharInfo::has_char_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageCreateCharInfo::set_has_char_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageCreateCharInfo::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageCreateCharInfo::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& CSMessageCreateCharInfo::char_name() const {
  return *char_name_;
}
inline void CSMessageCreateCharInfo::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void CSMessageCreateCharInfo::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void CSMessageCreateCharInfo::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageCreateCharInfo::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* CSMessageCreateCharInfo::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageCreateCharInfo::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 char_camp = 2;
inline bool CSMessageCreateCharInfo::has_char_camp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageCreateCharInfo::set_has_char_camp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageCreateCharInfo::clear_has_char_camp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageCreateCharInfo::clear_char_camp() {
  char_camp_ = 0u;
  clear_has_char_camp();
}
inline ::google::protobuf::uint32 CSMessageCreateCharInfo::char_camp() const {
  return char_camp_;
}
inline void CSMessageCreateCharInfo::set_char_camp(::google::protobuf::uint32 value) {
  set_has_char_camp();
  char_camp_ = value;
}

// optional uint32 acc_id = 3;
inline bool CSMessageCreateCharInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageCreateCharInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageCreateCharInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageCreateCharInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 CSMessageCreateCharInfo::acc_id() const {
  return acc_id_;
}
inline void CSMessageCreateCharInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// CSMessageCreateCharJob

// optional uint32 char_job = 1;
inline bool CSMessageCreateCharJob::has_char_job() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageCreateCharJob::set_has_char_job() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageCreateCharJob::clear_has_char_job() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageCreateCharJob::clear_char_job() {
  char_job_ = 0u;
  clear_has_char_job();
}
inline ::google::protobuf::uint32 CSMessageCreateCharJob::char_job() const {
  return char_job_;
}
inline void CSMessageCreateCharJob::set_char_job(::google::protobuf::uint32 value) {
  set_has_char_job();
  char_job_ = value;
}

// optional uint32 acc_id = 2;
inline bool CSMessageCreateCharJob::has_acc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageCreateCharJob::set_has_acc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageCreateCharJob::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageCreateCharJob::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 CSMessageCreateCharJob::acc_id() const {
  return acc_id_;
}
inline void CSMessageCreateCharJob::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// batchInject

// optional uint64 opvalue1 = 1;
inline bool batchInject::has_opvalue1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void batchInject::set_has_opvalue1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void batchInject::clear_has_opvalue1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void batchInject::clear_opvalue1() {
  opvalue1_ = GOOGLE_ULONGLONG(0);
  clear_has_opvalue1();
}
inline ::google::protobuf::uint64 batchInject::opvalue1() const {
  return opvalue1_;
}
inline void batchInject::set_opvalue1(::google::protobuf::uint64 value) {
  set_has_opvalue1();
  opvalue1_ = value;
}

// repeated uint64 opvalue4 = 2;
inline int batchInject::opvalue4_size() const {
  return opvalue4_.size();
}
inline void batchInject::clear_opvalue4() {
  opvalue4_.Clear();
}
inline ::google::protobuf::uint64 batchInject::opvalue4(int index) const {
  return opvalue4_.Get(index);
}
inline void batchInject::set_opvalue4(int index, ::google::protobuf::uint64 value) {
  opvalue4_.Set(index, value);
}
inline void batchInject::add_opvalue4(::google::protobuf::uint64 value) {
  opvalue4_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
batchInject::opvalue4() const {
  return opvalue4_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
batchInject::mutable_opvalue4() {
  return &opvalue4_;
}

// repeated uint64 opvalue5 = 3;
inline int batchInject::opvalue5_size() const {
  return opvalue5_.size();
}
inline void batchInject::clear_opvalue5() {
  opvalue5_.Clear();
}
inline ::google::protobuf::uint64 batchInject::opvalue5(int index) const {
  return opvalue5_.Get(index);
}
inline void batchInject::set_opvalue5(int index, ::google::protobuf::uint64 value) {
  opvalue5_.Set(index, value);
}
inline void batchInject::add_opvalue5(::google::protobuf::uint64 value) {
  opvalue5_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
batchInject::opvalue5() const {
  return opvalue5_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
batchInject::mutable_opvalue5() {
  return &opvalue5_;
}

// -------------------------------------------------------------------

// CSMessageClientOperation

// required .jynetwork.proto.eOpertionType oper = 1;
inline bool CSMessageClientOperation::has_oper() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageClientOperation::set_has_oper() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageClientOperation::clear_has_oper() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageClientOperation::clear_oper() {
  oper_ = 1;
  clear_has_oper();
}
inline ::jynetwork::proto::eOpertionType CSMessageClientOperation::oper() const {
  return static_cast< ::jynetwork::proto::eOpertionType >(oper_);
}
inline void CSMessageClientOperation::set_oper(::jynetwork::proto::eOpertionType value) {
  assert(::jynetwork::proto::eOpertionType_IsValid(value));
  set_has_oper();
  oper_ = value;
}

// optional uint64 opvalue1 = 2;
inline bool CSMessageClientOperation::has_opvalue1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageClientOperation::set_has_opvalue1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageClientOperation::clear_has_opvalue1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageClientOperation::clear_opvalue1() {
  opvalue1_ = GOOGLE_ULONGLONG(0);
  clear_has_opvalue1();
}
inline ::google::protobuf::uint64 CSMessageClientOperation::opvalue1() const {
  return opvalue1_;
}
inline void CSMessageClientOperation::set_opvalue1(::google::protobuf::uint64 value) {
  set_has_opvalue1();
  opvalue1_ = value;
}

// optional uint64 opvalue2 = 3;
inline bool CSMessageClientOperation::has_opvalue2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageClientOperation::set_has_opvalue2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageClientOperation::clear_has_opvalue2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageClientOperation::clear_opvalue2() {
  opvalue2_ = GOOGLE_ULONGLONG(0);
  clear_has_opvalue2();
}
inline ::google::protobuf::uint64 CSMessageClientOperation::opvalue2() const {
  return opvalue2_;
}
inline void CSMessageClientOperation::set_opvalue2(::google::protobuf::uint64 value) {
  set_has_opvalue2();
  opvalue2_ = value;
}

// optional uint64 opvalue3 = 4;
inline bool CSMessageClientOperation::has_opvalue3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessageClientOperation::set_has_opvalue3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessageClientOperation::clear_has_opvalue3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessageClientOperation::clear_opvalue3() {
  opvalue3_ = GOOGLE_ULONGLONG(0);
  clear_has_opvalue3();
}
inline ::google::protobuf::uint64 CSMessageClientOperation::opvalue3() const {
  return opvalue3_;
}
inline void CSMessageClientOperation::set_opvalue3(::google::protobuf::uint64 value) {
  set_has_opvalue3();
  opvalue3_ = value;
}

// optional uint32 acc_id = 5;
inline bool CSMessageClientOperation::has_acc_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMessageClientOperation::set_has_acc_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMessageClientOperation::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMessageClientOperation::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 CSMessageClientOperation::acc_id() const {
  return acc_id_;
}
inline void CSMessageClientOperation::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// repeated uint64 opvalue4 = 6;
inline int CSMessageClientOperation::opvalue4_size() const {
  return opvalue4_.size();
}
inline void CSMessageClientOperation::clear_opvalue4() {
  opvalue4_.Clear();
}
inline ::google::protobuf::uint64 CSMessageClientOperation::opvalue4(int index) const {
  return opvalue4_.Get(index);
}
inline void CSMessageClientOperation::set_opvalue4(int index, ::google::protobuf::uint64 value) {
  opvalue4_.Set(index, value);
}
inline void CSMessageClientOperation::add_opvalue4(::google::protobuf::uint64 value) {
  opvalue4_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CSMessageClientOperation::opvalue4() const {
  return opvalue4_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CSMessageClientOperation::mutable_opvalue4() {
  return &opvalue4_;
}

// repeated uint64 opvalue5 = 7;
inline int CSMessageClientOperation::opvalue5_size() const {
  return opvalue5_.size();
}
inline void CSMessageClientOperation::clear_opvalue5() {
  opvalue5_.Clear();
}
inline ::google::protobuf::uint64 CSMessageClientOperation::opvalue5(int index) const {
  return opvalue5_.Get(index);
}
inline void CSMessageClientOperation::set_opvalue5(int index, ::google::protobuf::uint64 value) {
  opvalue5_.Set(index, value);
}
inline void CSMessageClientOperation::add_opvalue5(::google::protobuf::uint64 value) {
  opvalue5_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CSMessageClientOperation::opvalue5() const {
  return opvalue5_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CSMessageClientOperation::mutable_opvalue5() {
  return &opvalue5_;
}

// optional uint32 oper_index = 8;
inline bool CSMessageClientOperation::has_oper_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSMessageClientOperation::set_has_oper_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSMessageClientOperation::clear_has_oper_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSMessageClientOperation::clear_oper_index() {
  oper_index_ = 0u;
  clear_has_oper_index();
}
inline ::google::protobuf::uint32 CSMessageClientOperation::oper_index() const {
  return oper_index_;
}
inline void CSMessageClientOperation::set_oper_index(::google::protobuf::uint32 value) {
  set_has_oper_index();
  oper_index_ = value;
}

// optional bytes opvalue6 = 9;
inline bool CSMessageClientOperation::has_opvalue6() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSMessageClientOperation::set_has_opvalue6() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSMessageClientOperation::clear_has_opvalue6() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSMessageClientOperation::clear_opvalue6() {
  if (opvalue6_ != &::google::protobuf::internal::kEmptyString) {
    opvalue6_->clear();
  }
  clear_has_opvalue6();
}
inline const ::std::string& CSMessageClientOperation::opvalue6() const {
  return *opvalue6_;
}
inline void CSMessageClientOperation::set_opvalue6(const ::std::string& value) {
  set_has_opvalue6();
  if (opvalue6_ == &::google::protobuf::internal::kEmptyString) {
    opvalue6_ = new ::std::string;
  }
  opvalue6_->assign(value);
}
inline void CSMessageClientOperation::set_opvalue6(const char* value) {
  set_has_opvalue6();
  if (opvalue6_ == &::google::protobuf::internal::kEmptyString) {
    opvalue6_ = new ::std::string;
  }
  opvalue6_->assign(value);
}
inline void CSMessageClientOperation::set_opvalue6(const void* value, size_t size) {
  set_has_opvalue6();
  if (opvalue6_ == &::google::protobuf::internal::kEmptyString) {
    opvalue6_ = new ::std::string;
  }
  opvalue6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageClientOperation::mutable_opvalue6() {
  set_has_opvalue6();
  if (opvalue6_ == &::google::protobuf::internal::kEmptyString) {
    opvalue6_ = new ::std::string;
  }
  return opvalue6_;
}
inline ::std::string* CSMessageClientOperation::release_opvalue6() {
  clear_has_opvalue6();
  if (opvalue6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opvalue6_;
    opvalue6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageClientOperation::set_allocated_opvalue6(::std::string* opvalue6) {
  if (opvalue6_ != &::google::protobuf::internal::kEmptyString) {
    delete opvalue6_;
  }
  if (opvalue6) {
    set_has_opvalue6();
    opvalue6_ = opvalue6;
  } else {
    clear_has_opvalue6();
    opvalue6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .jynetwork.proto.batchInject opvalue7 = 10;
inline int CSMessageClientOperation::opvalue7_size() const {
  return opvalue7_.size();
}
inline void CSMessageClientOperation::clear_opvalue7() {
  opvalue7_.Clear();
}
inline const ::jynetwork::proto::batchInject& CSMessageClientOperation::opvalue7(int index) const {
  return opvalue7_.Get(index);
}
inline ::jynetwork::proto::batchInject* CSMessageClientOperation::mutable_opvalue7(int index) {
  return opvalue7_.Mutable(index);
}
inline ::jynetwork::proto::batchInject* CSMessageClientOperation::add_opvalue7() {
  return opvalue7_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::batchInject >&
CSMessageClientOperation::opvalue7() const {
  return opvalue7_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::batchInject >*
CSMessageClientOperation::mutable_opvalue7() {
  return &opvalue7_;
}

// optional bytes opvalue8 = 11;
inline bool CSMessageClientOperation::has_opvalue8() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSMessageClientOperation::set_has_opvalue8() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSMessageClientOperation::clear_has_opvalue8() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSMessageClientOperation::clear_opvalue8() {
  if (opvalue8_ != &::google::protobuf::internal::kEmptyString) {
    opvalue8_->clear();
  }
  clear_has_opvalue8();
}
inline const ::std::string& CSMessageClientOperation::opvalue8() const {
  return *opvalue8_;
}
inline void CSMessageClientOperation::set_opvalue8(const ::std::string& value) {
  set_has_opvalue8();
  if (opvalue8_ == &::google::protobuf::internal::kEmptyString) {
    opvalue8_ = new ::std::string;
  }
  opvalue8_->assign(value);
}
inline void CSMessageClientOperation::set_opvalue8(const char* value) {
  set_has_opvalue8();
  if (opvalue8_ == &::google::protobuf::internal::kEmptyString) {
    opvalue8_ = new ::std::string;
  }
  opvalue8_->assign(value);
}
inline void CSMessageClientOperation::set_opvalue8(const void* value, size_t size) {
  set_has_opvalue8();
  if (opvalue8_ == &::google::protobuf::internal::kEmptyString) {
    opvalue8_ = new ::std::string;
  }
  opvalue8_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageClientOperation::mutable_opvalue8() {
  set_has_opvalue8();
  if (opvalue8_ == &::google::protobuf::internal::kEmptyString) {
    opvalue8_ = new ::std::string;
  }
  return opvalue8_;
}
inline ::std::string* CSMessageClientOperation::release_opvalue8() {
  clear_has_opvalue8();
  if (opvalue8_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opvalue8_;
    opvalue8_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageClientOperation::set_allocated_opvalue8(::std::string* opvalue8) {
  if (opvalue8_ != &::google::protobuf::internal::kEmptyString) {
    delete opvalue8_;
  }
  if (opvalue8) {
    set_has_opvalue8();
    opvalue8_ = opvalue8;
  } else {
    clear_has_opvalue8();
    opvalue8_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSMessageBattleBegin

// optional uint32 map_id = 1;
inline bool CSMessageBattleBegin::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageBattleBegin::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageBattleBegin::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageBattleBegin::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 CSMessageBattleBegin::map_id() const {
  return map_id_;
}
inline void CSMessageBattleBegin::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 difficult = 2;
inline bool CSMessageBattleBegin::has_difficult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageBattleBegin::set_has_difficult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageBattleBegin::clear_has_difficult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageBattleBegin::clear_difficult() {
  difficult_ = 0u;
  clear_has_difficult();
}
inline ::google::protobuf::uint32 CSMessageBattleBegin::difficult() const {
  return difficult_;
}
inline void CSMessageBattleBegin::set_difficult(::google::protobuf::uint32 value) {
  set_has_difficult();
  difficult_ = value;
}

// optional uint32 catlog = 3;
inline bool CSMessageBattleBegin::has_catlog() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageBattleBegin::set_has_catlog() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageBattleBegin::clear_has_catlog() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageBattleBegin::clear_catlog() {
  catlog_ = 0u;
  clear_has_catlog();
}
inline ::google::protobuf::uint32 CSMessageBattleBegin::catlog() const {
  return catlog_;
}
inline void CSMessageBattleBegin::set_catlog(::google::protobuf::uint32 value) {
  set_has_catlog();
  catlog_ = value;
}

// optional .jynetwork.proto.sCharactorInit ci = 4;
inline bool CSMessageBattleBegin::has_ci() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessageBattleBegin::set_has_ci() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessageBattleBegin::clear_has_ci() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessageBattleBegin::clear_ci() {
  if (ci_ != NULL) ci_->::jynetwork::proto::sCharactorInit::Clear();
  clear_has_ci();
}
inline const ::jynetwork::proto::sCharactorInit& CSMessageBattleBegin::ci() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ci_ != NULL ? *ci_ : *default_instance().ci_;
#else
  return ci_ != NULL ? *ci_ : *default_instance_->ci_;
#endif
}
inline ::jynetwork::proto::sCharactorInit* CSMessageBattleBegin::mutable_ci() {
  set_has_ci();
  if (ci_ == NULL) ci_ = new ::jynetwork::proto::sCharactorInit;
  return ci_;
}
inline ::jynetwork::proto::sCharactorInit* CSMessageBattleBegin::release_ci() {
  clear_has_ci();
  ::jynetwork::proto::sCharactorInit* temp = ci_;
  ci_ = NULL;
  return temp;
}
inline void CSMessageBattleBegin::set_allocated_ci(::jynetwork::proto::sCharactorInit* ci) {
  delete ci_;
  ci_ = ci;
  if (ci) {
    set_has_ci();
  } else {
    clear_has_ci();
  }
}

// optional uint32 endless_continue = 5;
inline bool CSMessageBattleBegin::has_endless_continue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMessageBattleBegin::set_has_endless_continue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMessageBattleBegin::clear_has_endless_continue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMessageBattleBegin::clear_endless_continue() {
  endless_continue_ = 0u;
  clear_has_endless_continue();
}
inline ::google::protobuf::uint32 CSMessageBattleBegin::endless_continue() const {
  return endless_continue_;
}
inline void CSMessageBattleBegin::set_endless_continue(::google::protobuf::uint32 value) {
  set_has_endless_continue();
  endless_continue_ = value;
}

// -------------------------------------------------------------------

// BattleTime

// optional uint32 time = 1;
inline bool BattleTime::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleTime::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleTime::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleTime::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 BattleTime::time() const {
  return time_;
}
inline void BattleTime::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 net_time = 2;
inline bool BattleTime::has_net_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleTime::set_has_net_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleTime::clear_has_net_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleTime::clear_net_time() {
  net_time_ = 0u;
  clear_has_net_time();
}
inline ::google::protobuf::uint32 BattleTime::net_time() const {
  return net_time_;
}
inline void BattleTime::set_net_time(::google::protobuf::uint32 value) {
  set_has_net_time();
  net_time_ = value;
}

// -------------------------------------------------------------------

// BattleAttr

// optional uint32 attr_id = 1;
inline bool BattleAttr::has_attr_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleAttr::set_has_attr_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleAttr::clear_has_attr_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleAttr::clear_attr_id() {
  attr_id_ = 0u;
  clear_has_attr_id();
}
inline ::google::protobuf::uint32 BattleAttr::attr_id() const {
  return attr_id_;
}
inline void BattleAttr::set_attr_id(::google::protobuf::uint32 value) {
  set_has_attr_id();
  attr_id_ = value;
}

// repeated uint32 attr_value = 2;
inline int BattleAttr::attr_value_size() const {
  return attr_value_.size();
}
inline void BattleAttr::clear_attr_value() {
  attr_value_.Clear();
}
inline ::google::protobuf::uint32 BattleAttr::attr_value(int index) const {
  return attr_value_.Get(index);
}
inline void BattleAttr::set_attr_value(int index, ::google::protobuf::uint32 value) {
  attr_value_.Set(index, value);
}
inline void BattleAttr::add_attr_value(::google::protobuf::uint32 value) {
  attr_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BattleAttr::attr_value() const {
  return attr_value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BattleAttr::mutable_attr_value() {
  return &attr_value_;
}

// -------------------------------------------------------------------

// CSMessageBattleCheck

// optional uint32 check_id = 1;
inline bool CSMessageBattleCheck::has_check_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageBattleCheck::set_has_check_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageBattleCheck::clear_has_check_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageBattleCheck::clear_check_id() {
  check_id_ = 0u;
  clear_has_check_id();
}
inline ::google::protobuf::uint32 CSMessageBattleCheck::check_id() const {
  return check_id_;
}
inline void CSMessageBattleCheck::set_check_id(::google::protobuf::uint32 value) {
  set_has_check_id();
  check_id_ = value;
}

// repeated .jynetwork.proto.BattleTime battle_time = 2;
inline int CSMessageBattleCheck::battle_time_size() const {
  return battle_time_.size();
}
inline void CSMessageBattleCheck::clear_battle_time() {
  battle_time_.Clear();
}
inline const ::jynetwork::proto::BattleTime& CSMessageBattleCheck::battle_time(int index) const {
  return battle_time_.Get(index);
}
inline ::jynetwork::proto::BattleTime* CSMessageBattleCheck::mutable_battle_time(int index) {
  return battle_time_.Mutable(index);
}
inline ::jynetwork::proto::BattleTime* CSMessageBattleCheck::add_battle_time() {
  return battle_time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime >&
CSMessageBattleCheck::battle_time() const {
  return battle_time_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime >*
CSMessageBattleCheck::mutable_battle_time() {
  return &battle_time_;
}

// repeated .jynetwork.proto.BattleAttr battle_attr = 3;
inline int CSMessageBattleCheck::battle_attr_size() const {
  return battle_attr_.size();
}
inline void CSMessageBattleCheck::clear_battle_attr() {
  battle_attr_.Clear();
}
inline const ::jynetwork::proto::BattleAttr& CSMessageBattleCheck::battle_attr(int index) const {
  return battle_attr_.Get(index);
}
inline ::jynetwork::proto::BattleAttr* CSMessageBattleCheck::mutable_battle_attr(int index) {
  return battle_attr_.Mutable(index);
}
inline ::jynetwork::proto::BattleAttr* CSMessageBattleCheck::add_battle_attr() {
  return battle_attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleAttr >&
CSMessageBattleCheck::battle_attr() const {
  return battle_attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleAttr >*
CSMessageBattleCheck::mutable_battle_attr() {
  return &battle_attr_;
}

// optional .jynetwork.proto.sGameStats gamestats = 4;
inline bool CSMessageBattleCheck::has_gamestats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessageBattleCheck::set_has_gamestats() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessageBattleCheck::clear_has_gamestats() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessageBattleCheck::clear_gamestats() {
  if (gamestats_ != NULL) gamestats_->::jynetwork::proto::sGameStats::Clear();
  clear_has_gamestats();
}
inline const ::jynetwork::proto::sGameStats& CSMessageBattleCheck::gamestats() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gamestats_ != NULL ? *gamestats_ : *default_instance().gamestats_;
#else
  return gamestats_ != NULL ? *gamestats_ : *default_instance_->gamestats_;
#endif
}
inline ::jynetwork::proto::sGameStats* CSMessageBattleCheck::mutable_gamestats() {
  set_has_gamestats();
  if (gamestats_ == NULL) gamestats_ = new ::jynetwork::proto::sGameStats;
  return gamestats_;
}
inline ::jynetwork::proto::sGameStats* CSMessageBattleCheck::release_gamestats() {
  clear_has_gamestats();
  ::jynetwork::proto::sGameStats* temp = gamestats_;
  gamestats_ = NULL;
  return temp;
}
inline void CSMessageBattleCheck::set_allocated_gamestats(::jynetwork::proto::sGameStats* gamestats) {
  delete gamestats_;
  gamestats_ = gamestats;
  if (gamestats) {
    set_has_gamestats();
  } else {
    clear_has_gamestats();
  }
}

// optional float battle_modify = 5;
inline bool CSMessageBattleCheck::has_battle_modify() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMessageBattleCheck::set_has_battle_modify() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMessageBattleCheck::clear_has_battle_modify() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMessageBattleCheck::clear_battle_modify() {
  battle_modify_ = 0;
  clear_has_battle_modify();
}
inline float CSMessageBattleCheck::battle_modify() const {
  return battle_modify_;
}
inline void CSMessageBattleCheck::set_battle_modify(float value) {
  set_has_battle_modify();
  battle_modify_ = value;
}

// -------------------------------------------------------------------

// BatttleSkillStatistics

// optional uint32 skill_id = 1;
inline bool BatttleSkillStatistics::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatttleSkillStatistics::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatttleSkillStatistics::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatttleSkillStatistics::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 BatttleSkillStatistics::skill_id() const {
  return skill_id_;
}
inline void BatttleSkillStatistics::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional uint32 skill_auto = 2;
inline bool BatttleSkillStatistics::has_skill_auto() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatttleSkillStatistics::set_has_skill_auto() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatttleSkillStatistics::clear_has_skill_auto() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatttleSkillStatistics::clear_skill_auto() {
  skill_auto_ = 0u;
  clear_has_skill_auto();
}
inline ::google::protobuf::uint32 BatttleSkillStatistics::skill_auto() const {
  return skill_auto_;
}
inline void BatttleSkillStatistics::set_skill_auto(::google::protobuf::uint32 value) {
  set_has_skill_auto();
  skill_auto_ = value;
}

// optional uint32 skill_manual = 3;
inline bool BatttleSkillStatistics::has_skill_manual() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatttleSkillStatistics::set_has_skill_manual() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatttleSkillStatistics::clear_has_skill_manual() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatttleSkillStatistics::clear_skill_manual() {
  skill_manual_ = 0u;
  clear_has_skill_manual();
}
inline ::google::protobuf::uint32 BatttleSkillStatistics::skill_manual() const {
  return skill_manual_;
}
inline void BatttleSkillStatistics::set_skill_manual(::google::protobuf::uint32 value) {
  set_has_skill_manual();
  skill_manual_ = value;
}

// -------------------------------------------------------------------

// DamageScore

// optional uint32 uid = 1;
inline bool DamageScore::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DamageScore::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DamageScore::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DamageScore::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 DamageScore::uid() const {
  return uid_;
}
inline void DamageScore::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// optional float score = 2;
inline bool DamageScore::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DamageScore::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DamageScore::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DamageScore::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float DamageScore::score() const {
  return score_;
}
inline void DamageScore::set_score(float value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// CSMessageBattleResult

// optional uint32 map_id = 1;
inline bool CSMessageBattleResult::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageBattleResult::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageBattleResult::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageBattleResult::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::map_id() const {
  return map_id_;
}
inline void CSMessageBattleResult::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 result = 2;
inline bool CSMessageBattleResult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageBattleResult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageBattleResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageBattleResult::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::result() const {
  return result_;
}
inline void CSMessageBattleResult::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// optional bytes battle_data = 3;
inline bool CSMessageBattleResult::has_battle_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageBattleResult::set_has_battle_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageBattleResult::clear_has_battle_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageBattleResult::clear_battle_data() {
  if (battle_data_ != &::google::protobuf::internal::kEmptyString) {
    battle_data_->clear();
  }
  clear_has_battle_data();
}
inline const ::std::string& CSMessageBattleResult::battle_data() const {
  return *battle_data_;
}
inline void CSMessageBattleResult::set_battle_data(const ::std::string& value) {
  set_has_battle_data();
  if (battle_data_ == &::google::protobuf::internal::kEmptyString) {
    battle_data_ = new ::std::string;
  }
  battle_data_->assign(value);
}
inline void CSMessageBattleResult::set_battle_data(const char* value) {
  set_has_battle_data();
  if (battle_data_ == &::google::protobuf::internal::kEmptyString) {
    battle_data_ = new ::std::string;
  }
  battle_data_->assign(value);
}
inline void CSMessageBattleResult::set_battle_data(const void* value, size_t size) {
  set_has_battle_data();
  if (battle_data_ == &::google::protobuf::internal::kEmptyString) {
    battle_data_ = new ::std::string;
  }
  battle_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageBattleResult::mutable_battle_data() {
  set_has_battle_data();
  if (battle_data_ == &::google::protobuf::internal::kEmptyString) {
    battle_data_ = new ::std::string;
  }
  return battle_data_;
}
inline ::std::string* CSMessageBattleResult::release_battle_data() {
  clear_has_battle_data();
  if (battle_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = battle_data_;
    battle_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageBattleResult::set_allocated_battle_data(::std::string* battle_data) {
  if (battle_data_ != &::google::protobuf::internal::kEmptyString) {
    delete battle_data_;
  }
  if (battle_data) {
    set_has_battle_data();
    battle_data_ = battle_data;
  } else {
    clear_has_battle_data();
    battle_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 battle_score = 4;
inline bool CSMessageBattleResult::has_battle_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessageBattleResult::set_has_battle_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessageBattleResult::clear_has_battle_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessageBattleResult::clear_battle_score() {
  battle_score_ = 0u;
  clear_has_battle_score();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::battle_score() const {
  return battle_score_;
}
inline void CSMessageBattleResult::set_battle_score(::google::protobuf::uint32 value) {
  set_has_battle_score();
  battle_score_ = value;
}

// optional uint32 battle_money = 5;
inline bool CSMessageBattleResult::has_battle_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMessageBattleResult::set_has_battle_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMessageBattleResult::clear_has_battle_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMessageBattleResult::clear_battle_money() {
  battle_money_ = 0u;
  clear_has_battle_money();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::battle_money() const {
  return battle_money_;
}
inline void CSMessageBattleResult::set_battle_money(::google::protobuf::uint32 value) {
  set_has_battle_money();
  battle_money_ = value;
}

// optional uint32 difficult = 6;
inline bool CSMessageBattleResult::has_difficult() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSMessageBattleResult::set_has_difficult() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSMessageBattleResult::clear_has_difficult() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSMessageBattleResult::clear_difficult() {
  difficult_ = 0u;
  clear_has_difficult();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::difficult() const {
  return difficult_;
}
inline void CSMessageBattleResult::set_difficult(::google::protobuf::uint32 value) {
  set_has_difficult();
  difficult_ = value;
}

// optional uint32 battle_star = 7;
inline bool CSMessageBattleResult::has_battle_star() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSMessageBattleResult::set_has_battle_star() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSMessageBattleResult::clear_has_battle_star() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSMessageBattleResult::clear_battle_star() {
  battle_star_ = 0u;
  clear_has_battle_star();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::battle_star() const {
  return battle_star_;
}
inline void CSMessageBattleResult::set_battle_star(::google::protobuf::uint32 value) {
  set_has_battle_star();
  battle_star_ = value;
}

// optional uint32 rand_num = 8;
inline bool CSMessageBattleResult::has_rand_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSMessageBattleResult::set_has_rand_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSMessageBattleResult::clear_has_rand_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSMessageBattleResult::clear_rand_num() {
  rand_num_ = 0u;
  clear_has_rand_num();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::rand_num() const {
  return rand_num_;
}
inline void CSMessageBattleResult::set_rand_num(::google::protobuf::uint32 value) {
  set_has_rand_num();
  rand_num_ = value;
}

// optional uint32 is_sweep = 9;
inline bool CSMessageBattleResult::has_is_sweep() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSMessageBattleResult::set_has_is_sweep() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSMessageBattleResult::clear_has_is_sweep() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSMessageBattleResult::clear_is_sweep() {
  is_sweep_ = 0u;
  clear_has_is_sweep();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::is_sweep() const {
  return is_sweep_;
}
inline void CSMessageBattleResult::set_is_sweep(::google::protobuf::uint32 value) {
  set_has_is_sweep();
  is_sweep_ = value;
}

// optional uint32 sweep_times = 10;
inline bool CSMessageBattleResult::has_sweep_times() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSMessageBattleResult::set_has_sweep_times() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSMessageBattleResult::clear_has_sweep_times() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSMessageBattleResult::clear_sweep_times() {
  sweep_times_ = 0u;
  clear_has_sweep_times();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::sweep_times() const {
  return sweep_times_;
}
inline void CSMessageBattleResult::set_sweep_times(::google::protobuf::uint32 value) {
  set_has_sweep_times();
  sweep_times_ = value;
}

// optional uint32 dropmiddle = 11;
inline bool CSMessageBattleResult::has_dropmiddle() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSMessageBattleResult::set_has_dropmiddle() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSMessageBattleResult::clear_has_dropmiddle() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSMessageBattleResult::clear_dropmiddle() {
  dropmiddle_ = 0u;
  clear_has_dropmiddle();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::dropmiddle() const {
  return dropmiddle_;
}
inline void CSMessageBattleResult::set_dropmiddle(::google::protobuf::uint32 value) {
  set_has_dropmiddle();
  dropmiddle_ = value;
}

// optional uint32 dropgolin = 12;
inline bool CSMessageBattleResult::has_dropgolin() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSMessageBattleResult::set_has_dropgolin() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSMessageBattleResult::clear_has_dropgolin() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSMessageBattleResult::clear_dropgolin() {
  dropgolin_ = 0u;
  clear_has_dropgolin();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::dropgolin() const {
  return dropgolin_;
}
inline void CSMessageBattleResult::set_dropgolin(::google::protobuf::uint32 value) {
  set_has_dropgolin();
  dropgolin_ = value;
}

// optional bytes battle_data_type = 13;
inline bool CSMessageBattleResult::has_battle_data_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSMessageBattleResult::set_has_battle_data_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSMessageBattleResult::clear_has_battle_data_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSMessageBattleResult::clear_battle_data_type() {
  if (battle_data_type_ != &::google::protobuf::internal::kEmptyString) {
    battle_data_type_->clear();
  }
  clear_has_battle_data_type();
}
inline const ::std::string& CSMessageBattleResult::battle_data_type() const {
  return *battle_data_type_;
}
inline void CSMessageBattleResult::set_battle_data_type(const ::std::string& value) {
  set_has_battle_data_type();
  if (battle_data_type_ == &::google::protobuf::internal::kEmptyString) {
    battle_data_type_ = new ::std::string;
  }
  battle_data_type_->assign(value);
}
inline void CSMessageBattleResult::set_battle_data_type(const char* value) {
  set_has_battle_data_type();
  if (battle_data_type_ == &::google::protobuf::internal::kEmptyString) {
    battle_data_type_ = new ::std::string;
  }
  battle_data_type_->assign(value);
}
inline void CSMessageBattleResult::set_battle_data_type(const void* value, size_t size) {
  set_has_battle_data_type();
  if (battle_data_type_ == &::google::protobuf::internal::kEmptyString) {
    battle_data_type_ = new ::std::string;
  }
  battle_data_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageBattleResult::mutable_battle_data_type() {
  set_has_battle_data_type();
  if (battle_data_type_ == &::google::protobuf::internal::kEmptyString) {
    battle_data_type_ = new ::std::string;
  }
  return battle_data_type_;
}
inline ::std::string* CSMessageBattleResult::release_battle_data_type() {
  clear_has_battle_data_type();
  if (battle_data_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = battle_data_type_;
    battle_data_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageBattleResult::set_allocated_battle_data_type(::std::string* battle_data_type) {
  if (battle_data_type_ != &::google::protobuf::internal::kEmptyString) {
    delete battle_data_type_;
  }
  if (battle_data_type) {
    set_has_battle_data_type();
    battle_data_type_ = battle_data_type;
  } else {
    clear_has_battle_data_type();
    battle_data_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .jynetwork.proto.BattleTime battle_time = 14;
inline int CSMessageBattleResult::battle_time_size() const {
  return battle_time_.size();
}
inline void CSMessageBattleResult::clear_battle_time() {
  battle_time_.Clear();
}
inline const ::jynetwork::proto::BattleTime& CSMessageBattleResult::battle_time(int index) const {
  return battle_time_.Get(index);
}
inline ::jynetwork::proto::BattleTime* CSMessageBattleResult::mutable_battle_time(int index) {
  return battle_time_.Mutable(index);
}
inline ::jynetwork::proto::BattleTime* CSMessageBattleResult::add_battle_time() {
  return battle_time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime >&
CSMessageBattleResult::battle_time() const {
  return battle_time_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BattleTime >*
CSMessageBattleResult::mutable_battle_time() {
  return &battle_time_;
}

// optional uint32 hit_score = 15;
inline bool CSMessageBattleResult::has_hit_score() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSMessageBattleResult::set_has_hit_score() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSMessageBattleResult::clear_has_hit_score() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSMessageBattleResult::clear_hit_score() {
  hit_score_ = 0u;
  clear_has_hit_score();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::hit_score() const {
  return hit_score_;
}
inline void CSMessageBattleResult::set_hit_score(::google::protobuf::uint32 value) {
  set_has_hit_score();
  hit_score_ = value;
}

// optional uint32 time_score = 16;
inline bool CSMessageBattleResult::has_time_score() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSMessageBattleResult::set_has_time_score() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSMessageBattleResult::clear_has_time_score() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSMessageBattleResult::clear_time_score() {
  time_score_ = 0u;
  clear_has_time_score();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::time_score() const {
  return time_score_;
}
inline void CSMessageBattleResult::set_time_score(::google::protobuf::uint32 value) {
  set_has_time_score();
  time_score_ = value;
}

// repeated .jynetwork.proto.BatttleSkillStatistics battle_skill_statistics = 17;
inline int CSMessageBattleResult::battle_skill_statistics_size() const {
  return battle_skill_statistics_.size();
}
inline void CSMessageBattleResult::clear_battle_skill_statistics() {
  battle_skill_statistics_.Clear();
}
inline const ::jynetwork::proto::BatttleSkillStatistics& CSMessageBattleResult::battle_skill_statistics(int index) const {
  return battle_skill_statistics_.Get(index);
}
inline ::jynetwork::proto::BatttleSkillStatistics* CSMessageBattleResult::mutable_battle_skill_statistics(int index) {
  return battle_skill_statistics_.Mutable(index);
}
inline ::jynetwork::proto::BatttleSkillStatistics* CSMessageBattleResult::add_battle_skill_statistics() {
  return battle_skill_statistics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BatttleSkillStatistics >&
CSMessageBattleResult::battle_skill_statistics() const {
  return battle_skill_statistics_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::BatttleSkillStatistics >*
CSMessageBattleResult::mutable_battle_skill_statistics() {
  return &battle_skill_statistics_;
}

// optional uint32 hp = 18;
inline bool CSMessageBattleResult::has_hp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CSMessageBattleResult::set_has_hp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CSMessageBattleResult::clear_has_hp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CSMessageBattleResult::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::hp() const {
  return hp_;
}
inline void CSMessageBattleResult::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// optional uint32 catlog = 19;
inline bool CSMessageBattleResult::has_catlog() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CSMessageBattleResult::set_has_catlog() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CSMessageBattleResult::clear_has_catlog() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CSMessageBattleResult::clear_catlog() {
  catlog_ = 0u;
  clear_has_catlog();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::catlog() const {
  return catlog_;
}
inline void CSMessageBattleResult::set_catlog(::google::protobuf::uint32 value) {
  set_has_catlog();
  catlog_ = value;
}

// repeated .jynetwork.proto.CSMessageBattleCheck check = 20;
inline int CSMessageBattleResult::check_size() const {
  return check_.size();
}
inline void CSMessageBattleResult::clear_check() {
  check_.Clear();
}
inline const ::jynetwork::proto::CSMessageBattleCheck& CSMessageBattleResult::check(int index) const {
  return check_.Get(index);
}
inline ::jynetwork::proto::CSMessageBattleCheck* CSMessageBattleResult::mutable_check(int index) {
  return check_.Mutable(index);
}
inline ::jynetwork::proto::CSMessageBattleCheck* CSMessageBattleResult::add_check() {
  return check_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::CSMessageBattleCheck >&
CSMessageBattleResult::check() const {
  return check_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::CSMessageBattleCheck >*
CSMessageBattleResult::mutable_check() {
  return &check_;
}

// optional uint32 battle_wave = 21;
inline bool CSMessageBattleResult::has_battle_wave() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CSMessageBattleResult::set_has_battle_wave() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CSMessageBattleResult::clear_has_battle_wave() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CSMessageBattleResult::clear_battle_wave() {
  battle_wave_ = 0u;
  clear_has_battle_wave();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::battle_wave() const {
  return battle_wave_;
}
inline void CSMessageBattleResult::set_battle_wave(::google::protobuf::uint32 value) {
  set_has_battle_wave();
  battle_wave_ = value;
}

// repeated float hurts = 22;
inline int CSMessageBattleResult::hurts_size() const {
  return hurts_.size();
}
inline void CSMessageBattleResult::clear_hurts() {
  hurts_.Clear();
}
inline float CSMessageBattleResult::hurts(int index) const {
  return hurts_.Get(index);
}
inline void CSMessageBattleResult::set_hurts(int index, float value) {
  hurts_.Set(index, value);
}
inline void CSMessageBattleResult::add_hurts(float value) {
  hurts_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
CSMessageBattleResult::hurts() const {
  return hurts_;
}
inline ::google::protobuf::RepeatedField< float >*
CSMessageBattleResult::mutable_hurts() {
  return &hurts_;
}

// repeated .jynetwork.proto.DamageScore damage_score = 23;
inline int CSMessageBattleResult::damage_score_size() const {
  return damage_score_.size();
}
inline void CSMessageBattleResult::clear_damage_score() {
  damage_score_.Clear();
}
inline const ::jynetwork::proto::DamageScore& CSMessageBattleResult::damage_score(int index) const {
  return damage_score_.Get(index);
}
inline ::jynetwork::proto::DamageScore* CSMessageBattleResult::mutable_damage_score(int index) {
  return damage_score_.Mutable(index);
}
inline ::jynetwork::proto::DamageScore* CSMessageBattleResult::add_damage_score() {
  return damage_score_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore >&
CSMessageBattleResult::damage_score() const {
  return damage_score_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore >*
CSMessageBattleResult::mutable_damage_score() {
  return &damage_score_;
}

// repeated .jynetwork.proto.DamageScore solo_score = 24;
inline int CSMessageBattleResult::solo_score_size() const {
  return solo_score_.size();
}
inline void CSMessageBattleResult::clear_solo_score() {
  solo_score_.Clear();
}
inline const ::jynetwork::proto::DamageScore& CSMessageBattleResult::solo_score(int index) const {
  return solo_score_.Get(index);
}
inline ::jynetwork::proto::DamageScore* CSMessageBattleResult::mutable_solo_score(int index) {
  return solo_score_.Mutable(index);
}
inline ::jynetwork::proto::DamageScore* CSMessageBattleResult::add_solo_score() {
  return solo_score_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore >&
CSMessageBattleResult::solo_score() const {
  return solo_score_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::DamageScore >*
CSMessageBattleResult::mutable_solo_score() {
  return &solo_score_;
}

// optional uint32 endless_check_wave = 25;
inline bool CSMessageBattleResult::has_endless_check_wave() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CSMessageBattleResult::set_has_endless_check_wave() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CSMessageBattleResult::clear_has_endless_check_wave() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CSMessageBattleResult::clear_endless_check_wave() {
  endless_check_wave_ = 0u;
  clear_has_endless_check_wave();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::endless_check_wave() const {
  return endless_check_wave_;
}
inline void CSMessageBattleResult::set_endless_check_wave(::google::protobuf::uint32 value) {
  set_has_endless_check_wave();
  endless_check_wave_ = value;
}

// optional uint32 endless_check_score = 26;
inline bool CSMessageBattleResult::has_endless_check_score() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CSMessageBattleResult::set_has_endless_check_score() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CSMessageBattleResult::clear_has_endless_check_score() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CSMessageBattleResult::clear_endless_check_score() {
  endless_check_score_ = 0u;
  clear_has_endless_check_score();
}
inline ::google::protobuf::uint32 CSMessageBattleResult::endless_check_score() const {
  return endless_check_score_;
}
inline void CSMessageBattleResult::set_endless_check_score(::google::protobuf::uint32 value) {
  set_has_endless_check_score();
  endless_check_score_ = value;
}

// -------------------------------------------------------------------

// CSMessagePing

// optional uint32 timestamp = 1;
inline bool CSMessagePing::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessagePing::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessagePing::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessagePing::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CSMessagePing::timestamp() const {
  return timestamp_;
}
inline void CSMessagePing::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// CSMessageGMCommond

// optional bytes cmd = 1;
inline bool CSMessageGMCommond::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageGMCommond::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageGMCommond::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageGMCommond::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& CSMessageGMCommond::cmd() const {
  return *cmd_;
}
inline void CSMessageGMCommond::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void CSMessageGMCommond::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void CSMessageGMCommond::set_cmd(const void* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageGMCommond::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* CSMessageGMCommond::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageGMCommond::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSMessageRankList

// required uint32 rank_type = 1;
inline bool CSMessageRankList::has_rank_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageRankList::set_has_rank_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageRankList::clear_has_rank_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageRankList::clear_rank_type() {
  rank_type_ = 0u;
  clear_has_rank_type();
}
inline ::google::protobuf::uint32 CSMessageRankList::rank_type() const {
  return rank_type_;
}
inline void CSMessageRankList::set_rank_type(::google::protobuf::uint32 value) {
  set_has_rank_type();
  rank_type_ = value;
}

// optional uint32 page = 2;
inline bool CSMessageRankList::has_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageRankList::set_has_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageRankList::clear_has_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageRankList::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 CSMessageRankList::page() const {
  return page_;
}
inline void CSMessageRankList::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// -------------------------------------------------------------------

// CSMessagePlayerQuery

// optional uint32 query_type = 1;
inline bool CSMessagePlayerQuery::has_query_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessagePlayerQuery::set_has_query_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessagePlayerQuery::clear_has_query_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessagePlayerQuery::clear_query_type() {
  query_type_ = 0u;
  clear_has_query_type();
}
inline ::google::protobuf::uint32 CSMessagePlayerQuery::query_type() const {
  return query_type_;
}
inline void CSMessagePlayerQuery::set_query_type(::google::protobuf::uint32 value) {
  set_has_query_type();
  query_type_ = value;
}

// optional uint32 acc_id = 2;
inline bool CSMessagePlayerQuery::has_acc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessagePlayerQuery::set_has_acc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessagePlayerQuery::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessagePlayerQuery::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 CSMessagePlayerQuery::acc_id() const {
  return acc_id_;
}
inline void CSMessagePlayerQuery::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// optional uint32 job = 3;
inline bool CSMessagePlayerQuery::has_job() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessagePlayerQuery::set_has_job() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessagePlayerQuery::clear_has_job() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessagePlayerQuery::clear_job() {
  job_ = 0u;
  clear_has_job();
}
inline ::google::protobuf::uint32 CSMessagePlayerQuery::job() const {
  return job_;
}
inline void CSMessagePlayerQuery::set_job(::google::protobuf::uint32 value) {
  set_has_job();
  job_ = value;
}

// optional uint32 my_acc_id = 4;
inline bool CSMessagePlayerQuery::has_my_acc_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessagePlayerQuery::set_has_my_acc_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessagePlayerQuery::clear_has_my_acc_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessagePlayerQuery::clear_my_acc_id() {
  my_acc_id_ = 0u;
  clear_has_my_acc_id();
}
inline ::google::protobuf::uint32 CSMessagePlayerQuery::my_acc_id() const {
  return my_acc_id_;
}
inline void CSMessagePlayerQuery::set_my_acc_id(::google::protobuf::uint32 value) {
  set_has_my_acc_id();
  my_acc_id_ = value;
}

// -------------------------------------------------------------------

// CSMessageCorpsOper

// required .jynetwork.proto.eCorpsOpertionType oper = 1;
inline bool CSMessageCorpsOper::has_oper() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageCorpsOper::set_has_oper() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageCorpsOper::clear_has_oper() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageCorpsOper::clear_oper() {
  oper_ = 1;
  clear_has_oper();
}
inline ::jynetwork::proto::eCorpsOpertionType CSMessageCorpsOper::oper() const {
  return static_cast< ::jynetwork::proto::eCorpsOpertionType >(oper_);
}
inline void CSMessageCorpsOper::set_oper(::jynetwork::proto::eCorpsOpertionType value) {
  assert(::jynetwork::proto::eCorpsOpertionType_IsValid(value));
  set_has_oper();
  oper_ = value;
}

// optional uint32 corps_id = 2;
inline bool CSMessageCorpsOper::has_corps_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageCorpsOper::set_has_corps_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageCorpsOper::clear_has_corps_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageCorpsOper::clear_corps_id() {
  corps_id_ = 0u;
  clear_has_corps_id();
}
inline ::google::protobuf::uint32 CSMessageCorpsOper::corps_id() const {
  return corps_id_;
}
inline void CSMessageCorpsOper::set_corps_id(::google::protobuf::uint32 value) {
  set_has_corps_id();
  corps_id_ = value;
}

// optional uint32 char_id = 3;
inline bool CSMessageCorpsOper::has_char_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageCorpsOper::set_has_char_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageCorpsOper::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageCorpsOper::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 CSMessageCorpsOper::char_id() const {
  return char_id_;
}
inline void CSMessageCorpsOper::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// optional bytes name = 4;
inline bool CSMessageCorpsOper::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessageCorpsOper::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessageCorpsOper::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessageCorpsOper::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSMessageCorpsOper::name() const {
  return *name_;
}
inline void CSMessageCorpsOper::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSMessageCorpsOper::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSMessageCorpsOper::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageCorpsOper::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSMessageCorpsOper::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageCorpsOper::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 page = 5;
inline bool CSMessageCorpsOper::has_page() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMessageCorpsOper::set_has_page() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMessageCorpsOper::clear_has_page() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMessageCorpsOper::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 CSMessageCorpsOper::page() const {
  return page_;
}
inline void CSMessageCorpsOper::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// optional uint32 fight_power = 6;
inline bool CSMessageCorpsOper::has_fight_power() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSMessageCorpsOper::set_has_fight_power() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSMessageCorpsOper::clear_has_fight_power() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSMessageCorpsOper::clear_fight_power() {
  fight_power_ = 0u;
  clear_has_fight_power();
}
inline ::google::protobuf::uint32 CSMessageCorpsOper::fight_power() const {
  return fight_power_;
}
inline void CSMessageCorpsOper::set_fight_power(::google::protobuf::uint32 value) {
  set_has_fight_power();
  fight_power_ = value;
}

// optional bytes info = 7;
inline bool CSMessageCorpsOper::has_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSMessageCorpsOper::set_has_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSMessageCorpsOper::clear_has_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSMessageCorpsOper::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& CSMessageCorpsOper::info() const {
  return *info_;
}
inline void CSMessageCorpsOper::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void CSMessageCorpsOper::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void CSMessageCorpsOper::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageCorpsOper::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* CSMessageCorpsOper::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageCorpsOper::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSMessageChat

// optional uint32 chat_type = 1;
inline bool CSMessageChat::has_chat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageChat::set_has_chat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageChat::clear_has_chat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageChat::clear_chat_type() {
  chat_type_ = 0u;
  clear_has_chat_type();
}
inline ::google::protobuf::uint32 CSMessageChat::chat_type() const {
  return chat_type_;
}
inline void CSMessageChat::set_chat_type(::google::protobuf::uint32 value) {
  set_has_chat_type();
  chat_type_ = value;
}

// optional string from_char = 2;
inline bool CSMessageChat::has_from_char() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageChat::set_has_from_char() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageChat::clear_has_from_char() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageChat::clear_from_char() {
  if (from_char_ != &::google::protobuf::internal::kEmptyString) {
    from_char_->clear();
  }
  clear_has_from_char();
}
inline const ::std::string& CSMessageChat::from_char() const {
  return *from_char_;
}
inline void CSMessageChat::set_from_char(const ::std::string& value) {
  set_has_from_char();
  if (from_char_ == &::google::protobuf::internal::kEmptyString) {
    from_char_ = new ::std::string;
  }
  from_char_->assign(value);
}
inline void CSMessageChat::set_from_char(const char* value) {
  set_has_from_char();
  if (from_char_ == &::google::protobuf::internal::kEmptyString) {
    from_char_ = new ::std::string;
  }
  from_char_->assign(value);
}
inline void CSMessageChat::set_from_char(const char* value, size_t size) {
  set_has_from_char();
  if (from_char_ == &::google::protobuf::internal::kEmptyString) {
    from_char_ = new ::std::string;
  }
  from_char_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageChat::mutable_from_char() {
  set_has_from_char();
  if (from_char_ == &::google::protobuf::internal::kEmptyString) {
    from_char_ = new ::std::string;
  }
  return from_char_;
}
inline ::std::string* CSMessageChat::release_from_char() {
  clear_has_from_char();
  if (from_char_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_char_;
    from_char_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageChat::set_allocated_from_char(::std::string* from_char) {
  if (from_char_ != &::google::protobuf::internal::kEmptyString) {
    delete from_char_;
  }
  if (from_char) {
    set_has_from_char();
    from_char_ = from_char;
  } else {
    clear_has_from_char();
    from_char_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_char = 3;
inline bool CSMessageChat::has_to_char() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageChat::set_has_to_char() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageChat::clear_has_to_char() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageChat::clear_to_char() {
  if (to_char_ != &::google::protobuf::internal::kEmptyString) {
    to_char_->clear();
  }
  clear_has_to_char();
}
inline const ::std::string& CSMessageChat::to_char() const {
  return *to_char_;
}
inline void CSMessageChat::set_to_char(const ::std::string& value) {
  set_has_to_char();
  if (to_char_ == &::google::protobuf::internal::kEmptyString) {
    to_char_ = new ::std::string;
  }
  to_char_->assign(value);
}
inline void CSMessageChat::set_to_char(const char* value) {
  set_has_to_char();
  if (to_char_ == &::google::protobuf::internal::kEmptyString) {
    to_char_ = new ::std::string;
  }
  to_char_->assign(value);
}
inline void CSMessageChat::set_to_char(const char* value, size_t size) {
  set_has_to_char();
  if (to_char_ == &::google::protobuf::internal::kEmptyString) {
    to_char_ = new ::std::string;
  }
  to_char_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageChat::mutable_to_char() {
  set_has_to_char();
  if (to_char_ == &::google::protobuf::internal::kEmptyString) {
    to_char_ = new ::std::string;
  }
  return to_char_;
}
inline ::std::string* CSMessageChat::release_to_char() {
  clear_has_to_char();
  if (to_char_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_char_;
    to_char_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageChat::set_allocated_to_char(::std::string* to_char) {
  if (to_char_ != &::google::protobuf::internal::kEmptyString) {
    delete to_char_;
  }
  if (to_char) {
    set_has_to_char();
    to_char_ = to_char;
  } else {
    clear_has_to_char();
    to_char_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string chat_string = 4;
inline bool CSMessageChat::has_chat_string() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMessageChat::set_has_chat_string() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMessageChat::clear_has_chat_string() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMessageChat::clear_chat_string() {
  if (chat_string_ != &::google::protobuf::internal::kEmptyString) {
    chat_string_->clear();
  }
  clear_has_chat_string();
}
inline const ::std::string& CSMessageChat::chat_string() const {
  return *chat_string_;
}
inline void CSMessageChat::set_chat_string(const ::std::string& value) {
  set_has_chat_string();
  if (chat_string_ == &::google::protobuf::internal::kEmptyString) {
    chat_string_ = new ::std::string;
  }
  chat_string_->assign(value);
}
inline void CSMessageChat::set_chat_string(const char* value) {
  set_has_chat_string();
  if (chat_string_ == &::google::protobuf::internal::kEmptyString) {
    chat_string_ = new ::std::string;
  }
  chat_string_->assign(value);
}
inline void CSMessageChat::set_chat_string(const char* value, size_t size) {
  set_has_chat_string();
  if (chat_string_ == &::google::protobuf::internal::kEmptyString) {
    chat_string_ = new ::std::string;
  }
  chat_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessageChat::mutable_chat_string() {
  set_has_chat_string();
  if (chat_string_ == &::google::protobuf::internal::kEmptyString) {
    chat_string_ = new ::std::string;
  }
  return chat_string_;
}
inline ::std::string* CSMessageChat::release_chat_string() {
  clear_has_chat_string();
  if (chat_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chat_string_;
    chat_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessageChat::set_allocated_chat_string(::std::string* chat_string) {
  if (chat_string_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_string_;
  }
  if (chat_string) {
    set_has_chat_string();
    chat_string_ = chat_string;
  } else {
    clear_has_chat_string();
    chat_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .jynetwork.proto.sPersonEquipStats item = 5;
inline int CSMessageChat::item_size() const {
  return item_.size();
}
inline void CSMessageChat::clear_item() {
  item_.Clear();
}
inline const ::jynetwork::proto::sPersonEquipStats& CSMessageChat::item(int index) const {
  return item_.Get(index);
}
inline ::jynetwork::proto::sPersonEquipStats* CSMessageChat::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::jynetwork::proto::sPersonEquipStats* CSMessageChat::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::sPersonEquipStats >&
CSMessageChat::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::sPersonEquipStats >*
CSMessageChat::mutable_item() {
  return &item_;
}

// optional uint64 except_id = 6;
inline bool CSMessageChat::has_except_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSMessageChat::set_has_except_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSMessageChat::clear_has_except_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSMessageChat::clear_except_id() {
  except_id_ = GOOGLE_ULONGLONG(0);
  clear_has_except_id();
}
inline ::google::protobuf::uint64 CSMessageChat::except_id() const {
  return except_id_;
}
inline void CSMessageChat::set_except_id(::google::protobuf::uint64 value) {
  set_has_except_id();
  except_id_ = value;
}

// -------------------------------------------------------------------

// CSMessageArenaBattleBegin

// optional uint32 map_id = 1;
inline bool CSMessageArenaBattleBegin::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessageArenaBattleBegin::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessageArenaBattleBegin::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessageArenaBattleBegin::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 CSMessageArenaBattleBegin::map_id() const {
  return map_id_;
}
inline void CSMessageArenaBattleBegin::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 net_type = 2;
inline bool CSMessageArenaBattleBegin::has_net_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessageArenaBattleBegin::set_has_net_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessageArenaBattleBegin::clear_has_net_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessageArenaBattleBegin::clear_net_type() {
  net_type_ = 0u;
  clear_has_net_type();
}
inline ::google::protobuf::uint32 CSMessageArenaBattleBegin::net_type() const {
  return net_type_;
}
inline void CSMessageArenaBattleBegin::set_net_type(::google::protobuf::uint32 value) {
  set_has_net_type();
  net_type_ = value;
}

// optional .jynetwork.proto.sCharactorInit ci = 4;
inline bool CSMessageArenaBattleBegin::has_ci() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMessageArenaBattleBegin::set_has_ci() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMessageArenaBattleBegin::clear_has_ci() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMessageArenaBattleBegin::clear_ci() {
  if (ci_ != NULL) ci_->::jynetwork::proto::sCharactorInit::Clear();
  clear_has_ci();
}
inline const ::jynetwork::proto::sCharactorInit& CSMessageArenaBattleBegin::ci() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ci_ != NULL ? *ci_ : *default_instance().ci_;
#else
  return ci_ != NULL ? *ci_ : *default_instance_->ci_;
#endif
}
inline ::jynetwork::proto::sCharactorInit* CSMessageArenaBattleBegin::mutable_ci() {
  set_has_ci();
  if (ci_ == NULL) ci_ = new ::jynetwork::proto::sCharactorInit;
  return ci_;
}
inline ::jynetwork::proto::sCharactorInit* CSMessageArenaBattleBegin::release_ci() {
  clear_has_ci();
  ::jynetwork::proto::sCharactorInit* temp = ci_;
  ci_ = NULL;
  return temp;
}
inline void CSMessageArenaBattleBegin::set_allocated_ci(::jynetwork::proto::sCharactorInit* ci) {
  delete ci_;
  ci_ = ci;
  if (ci) {
    set_has_ci();
  } else {
    clear_has_ci();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace jynetwork

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSMessage_2eproto__INCLUDED
