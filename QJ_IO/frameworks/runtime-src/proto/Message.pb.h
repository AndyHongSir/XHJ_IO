// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class GateIpPortInfo;
class VersionInfoRequest;
class VersionInfoResponse;
class LoginAuthSys;
class LoginCenterAuthReq;
class CenterGateState;
class CenterGateState_CenterGateStateInfo;
class LoginCenterAuthAck;
class LoginCenterCharInfo;
class LoginCenterCharInfo_LoginServerCharInfo;
class LoginAuthAck;
class LoginAuthNack;
class LoginServerList;
class LoginServerList_LoginServerInfo;
class LoginServerChoose;
class CenterServerChoose;
class GateInfoSys;
class GateInfoNack;
class GateInfoAck;
class UserDisconnect;
class GateGetNonceSys;
class GateAuchNonce;
class GateAuthSys;
class CenterAuthSys;
class CenterAuthAck;
class CenterAuthNack;
class CenterAuthLogout;
class GetPlayerRoleList;
class PlayerRoleListData;
class EnterSceneSys;
class EnterSceneNack;
class ChooseSceneCmd;
class ServerInfoConnected;
class MapServerInfo;
class CreateUserInfo;
class CreateUserResult;
class SaveUserInfo;
class GetUserDetailInfo;
class UserDetailInfo;
class EnterSceneMapSys;
class EnterSceneMapNack;
class EnterSceneMapAck;
class ClientCreateSenceCmd;
class ClientEnterSenceSys;
class AddPlayerSys;
class AddNpcSys;
class DelPlayerSys;
class DelNpcSys;
class GateInfoID;
class GateLogoutCmd;
class Move;
class PlayerJumpMap;
class NPCTeleport;
class PlayerAttack;
class QTEResult;
class ClearSkill;
class AddSkill;
class SkillSequence;
class BattleCharInfo;
class BattleCharInfo_CharInfo;
class BattleActionInfo;
class BattleActionInfo_StartStopEvent;
class BattleActionInfo_TargetEvent;
class BattleActionInfo_AttackEvent;
class BattleActionInfo_AttrChangeEvent;
class BattleActionInfo_SummonEvent;
class BattleActionInfo_SufferEvent;
class BattleActionInfo_CastAreaEvent;
class BattleActionInfo_ActionInfo;
class BattleProcess;
class BattleProcess_AttackEvent;
class BattleProcess_AttrChangeEvent;
class BattleProcess_ActionInfo;
class BattleManualSkill;
class BattleOperation;
class BattleOperationResult;
class BattleResultInfo;
class BattleRepeat;
class BattleQTEInfo;
class BattleReward;
class BattleRepeatReward;
class BattleRepeatReward_RewardInfo;
class ExitBattle;
class NPCTalk;
class NPCTalkResult;
class NPCFunction;
class AddItem;
class DeleteItem;
class UpdateItem;
class EquipItem;
class UseItem;
class OtherEquipItem;
class ChangeAttr;
class ChangeTask;
class CheckTime;
class MercenaryGet;
class MercenaryCardGet;
class MercenaryCardGetResult;
class MercenaryAttrAdd;
class MercenaryToExp;
class AddMercenary;
class UpdateMercenary;
class MercenaryDel;
class AddCharBuff;
class DelCharBuff;
class Chat;
class ChangeRemainVar;
class ChangeClientData;
class ReqFriendData;
class AckFriendData;
class AckFriendData_DBFriendInfo;
class FriendData;
class FriendData_FriendInfo;
class SocietyOperationData;
class SocietyOperationData_SocietyOperationInfo;
class GetPvPData;
class PvpOpeResult;
class ReqPVPData;
class AckPVPData;
class AckPVPData_DBPVPInfo;
class PVPData;
class PVPData_MercInfo;
class PVPData_PVPInfo;
class PVPBattle;
class StartLadder;
class BuyLadderTimes;
class BuyPvPTimes;
class UpdateLadder;
class UpdateLadderReward;
class UpdateLadderReward_RewardInfo;
class GetLadderReward;
class GetRoleData;
class RoleData;
class RoleData_MercInfo;
class ReqRoleData;
class AckRoleData;
class GetShopItemFromDB;
class GetShopItemAck;
class OpenShopUiReq;
class OpenShopUiAck;
class BuyItem;
class RefreshShopReq;
class SellItem;
class ChangeSkill;
class SkillLevelUp;
class ReqLevelUpStar;
class UpgradeItem;
class ReqRankList;
class AckRankList;
class AckRankList_RankInfo;
class ReqServerRank;
class AckServerRank;
class AckServerRank_RankInfo;
class ReqChessData;
class AckChessData;
class ReqRunChess;
class AckRunChess;
class AckChessRank;
class AckChessRank_RankInfo;
class UnlockTrainMercenary;
class TrainMercenary;
class ReqTrainMercenaryTime;
class AckTrainMercenaryTime;
class ReqFriendTrainMercenaryTime;
class ReqAccelerateTrainMercenary;
class AckFriendTrainMercenaryTime;
class AckFriendTrainMercenaryTime_FriendTrainInfo;
class BuyMallItem;
class DailyWeekOnline;
class GetMonthSignInDataReq;
class GetMonthSignInDataAck;
class DailyMonthOnline;
class ReqDailyMonthOnlineData;
class AckDailyMonthOnlineData;
class ReqSoulBag;
class ReqQuickSoulBag;
class ReqChangeType;
class AckSoulBag;
class ReqSoulBagAction;
class AckSoulBagAction;
class ReqSoulCombine;
class ReqPlatMoney;
class ReqPlatOrderID;
class AckPlatOrderID;
class ReqAddStamina;
class OfflineTrainMercenary;
class OfflineOper;
class ReqOfflineOperList;
class AckOfflineOperList;
class ReqActiveCode;
class ReqServerActiveCode;
class AckServerActiveCode;
class ReqRefreshGate;
class RefreshGateCost;
class RefreshGate;
class ReqGateLevelUp;
class ReqChooseBigGate;
class ReqMercenaryUpgrade;
class ReqLadderReward;
class ReqGetLevelReward;
class ReqGetActiveReward;
class RechargeLogInfo;
class ResetByDay;
class UserBehaviorLogInfo;
class OnlineNumberInfo;
class ReqVIPOperation;
class UserFeedback;
class UserFeedback_UserFeedbackInfo;
class SystemReward;
class GMFreezeSystem;
class GMFreezeSystem_GMFreezeSystemInfo;
class LoginSystemNotice;
class GMOperationResult;
class AckGetInviteCode;
class ReqDrawLottery;
class GetLotteryReward;
class GiveUpHighGradeDrawLottery;
class LotteryReward;
class LotteryRewardData;
class ReqQuickDrawLottery;
class ReqGetInviteReward;
class AckGetInviteNum;
class ReqGetInviteNum;
class ReqAddMoney;
class AddMoneyCost;
class ChooseAddMoney;
class RightPosition;
class OpenBowl;
class AddMoneyReward;
class GetFirstRechargeGift;
class ReqAccelerateAction;
class ReqBuyTimesAction;
class ReqIsMercTraining;
class AckOtherLevelUp;
class SendHeartBeatMsg;
class SendStoneMsg;
class ReqWorldBossInfo;
class AckWorldBossInfo;
class ExecuteSQL;
class LoadAllActivityDataReq;
class LoadAllActivityDataAck;
class LoadAllActivityDataAck_ActivityData;
class CanGetFirstRechargeReward;
class LoadAllSysBroadcastDataReq;
class LoadAllSysBroadcastDataAck;
class LoadAllSysBroadcastDataAck_SysBroadcastData;
class QueryAccidByAccnameReq;
class QueryAccidByAccnameAck;
class PkBattle;
class HorseData;
class HorseData_HorseAttr;
class GetHorseDataReq;
class GetHorseDataAck;
class HorseGroomReq;
class HorseGroomAck;
class BuyHorseFeedCountReq;
class BuyHorseFeedCountAck;
class HorseShowChangeReq;
class HorseShowChangeAck;
class HorseChangeSys;
class LoadAllHorseDataReq;
class LoadAllHorseDataAck;
class ReqStopQuickDestiny;
class PlatScrollReq;
class PlatScrollAck;
class ReqGetVipLevelReward;
class SaveBattleInfo;
class ReqViewBattleHistory;
class ReqGetBattleHistoryData;
class BattleHistoryInfo;
class EnterActiveReq;
class EnterActiveAck;
class OpenTreasureUIReq;
class OpenTreasureUIAck;
class GetTreasureReq;
class GetTreasureAck;
class ResetAck;
class AddEquipStarReq;
class AddEquipStarAck;
class GetRoleMailInfoReq;
class SelectMailInfoReq;
class RoleMailInfo;
class ReadMailReq;
class ReadMailAck;
class GetMailRewardReq;
class GetMailRewardAck;
class SendGMMailReq;
class SendGMMailAck;
class NewMailNotice;
class SelectMailInfoAck;
class GetSkillInfoReq;
class GetSkillInfoAck;
class EquipUpgradeItemReq;
class UnlockedSkill;
class ReqGetLastPvpRewardTime;
class PvpRewardTimeAck;
class GetClimbTowerEnemyReq;
class SelectClimbTowerEnemy;
class ClimbTowerEnemyData;
class GetClimbTowerEnemyAck;
class GetClimbTowerEnemyAck_MercInfo;
class GetClimbTowerRewardReq;
class GetClimbTowerRewardAck;
class ReliveMercReq;
class ReliveMercAck;
class ResetClimbTowerReq;
class ClimbTowerBattleResult;
class ClimbTowerBattleResult_SaveData;
class SaveCTEnemyInfo;
class SendPvpRankRiseAwards;
class VipOperResult;
class ItemCombineReq;

enum MessageNode {
  MESSAGE_NODE_NONE = 1,
  MESSAGE_NODE_DEFAULT = 2,
  MESSAGE_NODE_NEIGHBOUR = 3,
  MESSAGE_NODE_CLIENT = 4,
  MESSAGE_NODE_LOGIN = 5,
  MESSAGE_NODE_GATE = 6,
  MESSAGE_NODE_MAP = 7,
  MESSAGE_NODE_CENTER = 8
};
bool MessageNode_IsValid(int value);
const MessageNode MessageNode_MIN = MESSAGE_NODE_NONE;
const MessageNode MessageNode_MAX = MESSAGE_NODE_CENTER;
const int MessageNode_ARRAYSIZE = MessageNode_MAX + 1;

// ===================================================================

class GateIpPortInfo : public ::google::protobuf::MessageLite {
 public:
  GateIpPortInfo();
  virtual ~GateIpPortInfo();

  GateIpPortInfo(const GateIpPortInfo& from);

  inline GateIpPortInfo& operator=(const GateIpPortInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateIpPortInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateIpPortInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateIpPortInfo* other);

  // implements Message ----------------------------------------------

  GateIpPortInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateIpPortInfo& from);
  void MergeFrom(const GateIpPortInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gate_id = 1;
  inline bool has_gate_id() const;
  inline void clear_gate_id();
  static const int kGateIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gate_id() const;
  inline void set_gate_id(::google::protobuf::uint32 value);

  // required string gate_ip = 2;
  inline bool has_gate_ip() const;
  inline void clear_gate_ip();
  static const int kGateIpFieldNumber = 2;
  inline const ::std::string& gate_ip() const;
  inline void set_gate_ip(const ::std::string& value);
  inline void set_gate_ip(const char* value);
  inline void set_gate_ip(const char* value, size_t size);
  inline ::std::string* mutable_gate_ip();
  inline ::std::string* release_gate_ip();
  inline void set_allocated_gate_ip(::std::string* gate_ip);

  // required uint32 gate_port = 3;
  inline bool has_gate_port() const;
  inline void clear_gate_port();
  static const int kGatePortFieldNumber = 3;
  inline ::google::protobuf::uint32 gate_port() const;
  inline void set_gate_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GateIpPortInfo)
 private:
  inline void set_has_gate_id();
  inline void clear_has_gate_id();
  inline void set_has_gate_ip();
  inline void clear_has_gate_ip();
  inline void set_has_gate_port();
  inline void clear_has_gate_port();

  ::std::string* gate_ip_;
  ::google::protobuf::uint32 gate_id_;
  ::google::protobuf::uint32 gate_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateIpPortInfo* default_instance_;
};
// -------------------------------------------------------------------

class VersionInfoRequest : public ::google::protobuf::MessageLite {
 public:
  VersionInfoRequest();
  virtual ~VersionInfoRequest();

  VersionInfoRequest(const VersionInfoRequest& from);

  inline VersionInfoRequest& operator=(const VersionInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const VersionInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VersionInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VersionInfoRequest* other);

  // implements Message ----------------------------------------------

  VersionInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VersionInfoRequest& from);
  void MergeFrom(const VersionInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ver_release = 1;
  inline bool has_ver_release() const;
  inline void clear_ver_release();
  static const int kVerReleaseFieldNumber = 1;
  inline ::google::protobuf::uint32 ver_release() const;
  inline void set_ver_release(::google::protobuf::uint32 value);

  // required uint32 ver_freeze = 2;
  inline bool has_ver_freeze() const;
  inline void clear_ver_freeze();
  static const int kVerFreezeFieldNumber = 2;
  inline ::google::protobuf::uint32 ver_freeze() const;
  inline void set_ver_freeze(::google::protobuf::uint32 value);

  // required uint32 ver_development = 3;
  inline bool has_ver_development() const;
  inline void clear_ver_development();
  static const int kVerDevelopmentFieldNumber = 3;
  inline ::google::protobuf::uint32 ver_development() const;
  inline void set_ver_development(::google::protobuf::uint32 value);

  // required uint32 ver_patch = 4;
  inline bool has_ver_patch() const;
  inline void clear_ver_patch();
  static const int kVerPatchFieldNumber = 4;
  inline ::google::protobuf::uint32 ver_patch() const;
  inline void set_ver_patch(::google::protobuf::uint32 value);

  // optional uint32 ver_type = 5;
  inline bool has_ver_type() const;
  inline void clear_ver_type();
  static const int kVerTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 ver_type() const;
  inline void set_ver_type(::google::protobuf::uint32 value);

  // optional uint32 ver_no = 6;
  inline bool has_ver_no() const;
  inline void clear_ver_no();
  static const int kVerNoFieldNumber = 6;
  inline ::google::protobuf::uint32 ver_no() const;
  inline void set_ver_no(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.VersionInfoRequest)
 private:
  inline void set_has_ver_release();
  inline void clear_has_ver_release();
  inline void set_has_ver_freeze();
  inline void clear_has_ver_freeze();
  inline void set_has_ver_development();
  inline void clear_has_ver_development();
  inline void set_has_ver_patch();
  inline void clear_has_ver_patch();
  inline void set_has_ver_type();
  inline void clear_has_ver_type();
  inline void set_has_ver_no();
  inline void clear_has_ver_no();

  ::google::protobuf::uint32 ver_release_;
  ::google::protobuf::uint32 ver_freeze_;
  ::google::protobuf::uint32 ver_development_;
  ::google::protobuf::uint32 ver_patch_;
  ::google::protobuf::uint32 ver_type_;
  ::google::protobuf::uint32 ver_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static VersionInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class VersionInfoResponse : public ::google::protobuf::MessageLite {
 public:
  VersionInfoResponse();
  virtual ~VersionInfoResponse();

  VersionInfoResponse(const VersionInfoResponse& from);

  inline VersionInfoResponse& operator=(const VersionInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const VersionInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VersionInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VersionInfoResponse* other);

  // implements Message ----------------------------------------------

  VersionInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VersionInfoResponse& from);
  void MergeFrom(const VersionInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.VersionInfoResponse)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static VersionInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginAuthSys : public ::google::protobuf::MessageLite {
 public:
  LoginAuthSys();
  virtual ~LoginAuthSys();

  LoginAuthSys(const LoginAuthSys& from);

  inline LoginAuthSys& operator=(const LoginAuthSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginAuthSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginAuthSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginAuthSys* other);

  // implements Message ----------------------------------------------

  LoginAuthSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginAuthSys& from);
  void MergeFrom(const LoginAuthSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::int32 acc_id() const;
  inline void set_acc_id(::google::protobuf::int32 value);

  // required string session_str = 2;
  inline bool has_session_str() const;
  inline void clear_session_str();
  static const int kSessionStrFieldNumber = 2;
  inline const ::std::string& session_str() const;
  inline void set_session_str(const ::std::string& value);
  inline void set_session_str(const char* value);
  inline void set_session_str(const char* value, size_t size);
  inline ::std::string* mutable_session_str();
  inline ::std::string* release_session_str();
  inline void set_allocated_session_str(::std::string* session_str);

  // optional bytes user_name = 3;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const void* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional bytes user_pass = 4;
  inline bool has_user_pass() const;
  inline void clear_user_pass();
  static const int kUserPassFieldNumber = 4;
  inline const ::std::string& user_pass() const;
  inline void set_user_pass(const ::std::string& value);
  inline void set_user_pass(const char* value);
  inline void set_user_pass(const void* value, size_t size);
  inline ::std::string* mutable_user_pass();
  inline ::std::string* release_user_pass();
  inline void set_allocated_user_pass(::std::string* user_pass);

  // optional uint32 gm_check = 5;
  inline bool has_gm_check() const;
  inline void clear_gm_check();
  static const int kGmCheckFieldNumber = 5;
  inline ::google::protobuf::uint32 gm_check() const;
  inline void set_gm_check(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoginAuthSys)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_session_str();
  inline void clear_has_session_str();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_pass();
  inline void clear_has_user_pass();
  inline void set_has_gm_check();
  inline void clear_has_gm_check();

  ::std::string* session_str_;
  ::std::string* user_name_;
  ::google::protobuf::int32 acc_id_;
  ::google::protobuf::uint32 gm_check_;
  ::std::string* user_pass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginAuthSys* default_instance_;
};
// -------------------------------------------------------------------

class LoginCenterAuthReq : public ::google::protobuf::MessageLite {
 public:
  LoginCenterAuthReq();
  virtual ~LoginCenterAuthReq();

  LoginCenterAuthReq(const LoginCenterAuthReq& from);

  inline LoginCenterAuthReq& operator=(const LoginCenterAuthReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginCenterAuthReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginCenterAuthReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginCenterAuthReq* other);

  // implements Message ----------------------------------------------

  LoginCenterAuthReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginCenterAuthReq& from);
  void MergeFrom(const LoginCenterAuthReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const void* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional bytes user_pass = 2;
  inline bool has_user_pass() const;
  inline void clear_user_pass();
  static const int kUserPassFieldNumber = 2;
  inline const ::std::string& user_pass() const;
  inline void set_user_pass(const ::std::string& value);
  inline void set_user_pass(const char* value);
  inline void set_user_pass(const void* value, size_t size);
  inline ::std::string* mutable_user_pass();
  inline ::std::string* release_user_pass();
  inline void set_allocated_user_pass(::std::string* user_pass);

  // optional bytes user_ip = 3;
  inline bool has_user_ip() const;
  inline void clear_user_ip();
  static const int kUserIpFieldNumber = 3;
  inline const ::std::string& user_ip() const;
  inline void set_user_ip(const ::std::string& value);
  inline void set_user_ip(const char* value);
  inline void set_user_ip(const void* value, size_t size);
  inline ::std::string* mutable_user_ip();
  inline ::std::string* release_user_ip();
  inline void set_allocated_user_ip(::std::string* user_ip);

  // optional uint32 gm_check = 4;
  inline bool has_gm_check() const;
  inline void clear_gm_check();
  static const int kGmCheckFieldNumber = 4;
  inline ::google::protobuf::uint32 gm_check() const;
  inline void set_gm_check(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoginCenterAuthReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_pass();
  inline void clear_has_user_pass();
  inline void set_has_user_ip();
  inline void clear_has_user_ip();
  inline void set_has_gm_check();
  inline void clear_has_gm_check();

  ::std::string* user_name_;
  ::std::string* user_pass_;
  ::std::string* user_ip_;
  ::google::protobuf::uint32 gm_check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginCenterAuthReq* default_instance_;
};
// -------------------------------------------------------------------

class CenterGateState_CenterGateStateInfo : public ::google::protobuf::MessageLite {
 public:
  CenterGateState_CenterGateStateInfo();
  virtual ~CenterGateState_CenterGateStateInfo();

  CenterGateState_CenterGateStateInfo(const CenterGateState_CenterGateStateInfo& from);

  inline CenterGateState_CenterGateStateInfo& operator=(const CenterGateState_CenterGateStateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CenterGateState_CenterGateStateInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CenterGateState_CenterGateStateInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CenterGateState_CenterGateStateInfo* other);

  // implements Message ----------------------------------------------

  CenterGateState_CenterGateStateInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CenterGateState_CenterGateStateInfo& from);
  void MergeFrom(const CenterGateState_CenterGateStateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // required uint32 server_state = 2;
  inline bool has_server_state() const;
  inline void clear_server_state();
  static const int kServerStateFieldNumber = 2;
  inline ::google::protobuf::uint32 server_state() const;
  inline void set_server_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CenterGateState.CenterGateStateInfo)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_server_state();
  inline void clear_has_server_state();

  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 server_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CenterGateState_CenterGateStateInfo* default_instance_;
};
// -------------------------------------------------------------------

class CenterGateState : public ::google::protobuf::MessageLite {
 public:
  CenterGateState();
  virtual ~CenterGateState();

  CenterGateState(const CenterGateState& from);

  inline CenterGateState& operator=(const CenterGateState& from) {
    CopyFrom(from);
    return *this;
  }

  static const CenterGateState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CenterGateState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CenterGateState* other);

  // implements Message ----------------------------------------------

  CenterGateState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CenterGateState& from);
  void MergeFrom(const CenterGateState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CenterGateState_CenterGateStateInfo CenterGateStateInfo;

  // accessors -------------------------------------------------------

  // repeated .message.CenterGateState.CenterGateStateInfo server_state_info = 1;
  inline int server_state_info_size() const;
  inline void clear_server_state_info();
  static const int kServerStateInfoFieldNumber = 1;
  inline const ::message::CenterGateState_CenterGateStateInfo& server_state_info(int index) const;
  inline ::message::CenterGateState_CenterGateStateInfo* mutable_server_state_info(int index);
  inline ::message::CenterGateState_CenterGateStateInfo* add_server_state_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::CenterGateState_CenterGateStateInfo >&
      server_state_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::CenterGateState_CenterGateStateInfo >*
      mutable_server_state_info();

  // @@protoc_insertion_point(class_scope:message.CenterGateState)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::CenterGateState_CenterGateStateInfo > server_state_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CenterGateState* default_instance_;
};
// -------------------------------------------------------------------

class LoginCenterAuthAck : public ::google::protobuf::MessageLite {
 public:
  LoginCenterAuthAck();
  virtual ~LoginCenterAuthAck();

  LoginCenterAuthAck(const LoginCenterAuthAck& from);

  inline LoginCenterAuthAck& operator=(const LoginCenterAuthAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginCenterAuthAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginCenterAuthAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginCenterAuthAck* other);

  // implements Message ----------------------------------------------

  LoginCenterAuthAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginCenterAuthAck& from);
  void MergeFrom(const LoginCenterAuthAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::int32 acc_id() const;
  inline void set_acc_id(::google::protobuf::int32 value);

  // optional bytes user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const void* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 last_server = 4;
  inline bool has_last_server() const;
  inline void clear_last_server();
  static const int kLastServerFieldNumber = 4;
  inline ::google::protobuf::int32 last_server() const;
  inline void set_last_server(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.LoginCenterAuthAck)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_last_server();
  inline void clear_has_last_server();

  ::std::string* user_name_;
  ::google::protobuf::int32 acc_id_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 last_server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginCenterAuthAck* default_instance_;
};
// -------------------------------------------------------------------

class LoginCenterCharInfo_LoginServerCharInfo : public ::google::protobuf::MessageLite {
 public:
  LoginCenterCharInfo_LoginServerCharInfo();
  virtual ~LoginCenterCharInfo_LoginServerCharInfo();

  LoginCenterCharInfo_LoginServerCharInfo(const LoginCenterCharInfo_LoginServerCharInfo& from);

  inline LoginCenterCharInfo_LoginServerCharInfo& operator=(const LoginCenterCharInfo_LoginServerCharInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginCenterCharInfo_LoginServerCharInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginCenterCharInfo_LoginServerCharInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginCenterCharInfo_LoginServerCharInfo* other);

  // implements Message ----------------------------------------------

  LoginCenterCharInfo_LoginServerCharInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginCenterCharInfo_LoginServerCharInfo& from);
  void MergeFrom(const LoginCenterCharInfo_LoginServerCharInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // required uint32 char_job = 2;
  inline bool has_char_job() const;
  inline void clear_char_job();
  static const int kCharJobFieldNumber = 2;
  inline ::google::protobuf::uint32 char_job() const;
  inline void set_char_job(::google::protobuf::uint32 value);

  // required uint32 char_level = 3;
  inline bool has_char_level() const;
  inline void clear_char_level();
  static const int kCharLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 char_level() const;
  inline void set_char_level(::google::protobuf::uint32 value);

  // required uint32 char_sex = 4;
  inline bool has_char_sex() const;
  inline void clear_char_sex();
  static const int kCharSexFieldNumber = 4;
  inline ::google::protobuf::uint32 char_sex() const;
  inline void set_char_sex(::google::protobuf::uint32 value);

  // required uint32 gm_type = 5;
  inline bool has_gm_type() const;
  inline void clear_gm_type();
  static const int kGmTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 gm_type() const;
  inline void set_gm_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoginCenterCharInfo.LoginServerCharInfo)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_char_job();
  inline void clear_has_char_job();
  inline void set_has_char_level();
  inline void clear_has_char_level();
  inline void set_has_char_sex();
  inline void clear_has_char_sex();
  inline void set_has_gm_type();
  inline void clear_has_gm_type();

  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 char_job_;
  ::google::protobuf::uint32 char_level_;
  ::google::protobuf::uint32 char_sex_;
  ::google::protobuf::uint32 gm_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginCenterCharInfo_LoginServerCharInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginCenterCharInfo : public ::google::protobuf::MessageLite {
 public:
  LoginCenterCharInfo();
  virtual ~LoginCenterCharInfo();

  LoginCenterCharInfo(const LoginCenterCharInfo& from);

  inline LoginCenterCharInfo& operator=(const LoginCenterCharInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginCenterCharInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginCenterCharInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginCenterCharInfo* other);

  // implements Message ----------------------------------------------

  LoginCenterCharInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginCenterCharInfo& from);
  void MergeFrom(const LoginCenterCharInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoginCenterCharInfo_LoginServerCharInfo LoginServerCharInfo;

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // optional bytes acc_name = 2;
  inline bool has_acc_name() const;
  inline void clear_acc_name();
  static const int kAccNameFieldNumber = 2;
  inline const ::std::string& acc_name() const;
  inline void set_acc_name(const ::std::string& value);
  inline void set_acc_name(const char* value);
  inline void set_acc_name(const void* value, size_t size);
  inline ::std::string* mutable_acc_name();
  inline ::std::string* release_acc_name();
  inline void set_allocated_acc_name(::std::string* acc_name);

  // repeated .message.LoginCenterCharInfo.LoginServerCharInfo server_char_info = 3;
  inline int server_char_info_size() const;
  inline void clear_server_char_info();
  static const int kServerCharInfoFieldNumber = 3;
  inline const ::message::LoginCenterCharInfo_LoginServerCharInfo& server_char_info(int index) const;
  inline ::message::LoginCenterCharInfo_LoginServerCharInfo* mutable_server_char_info(int index);
  inline ::message::LoginCenterCharInfo_LoginServerCharInfo* add_server_char_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::LoginCenterCharInfo_LoginServerCharInfo >&
      server_char_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::LoginCenterCharInfo_LoginServerCharInfo >*
      mutable_server_char_info();

  // @@protoc_insertion_point(class_scope:message.LoginCenterCharInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_acc_name();
  inline void clear_has_acc_name();

  ::std::string* acc_name_;
  ::google::protobuf::RepeatedPtrField< ::message::LoginCenterCharInfo_LoginServerCharInfo > server_char_info_;
  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginCenterCharInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginAuthAck : public ::google::protobuf::MessageLite {
 public:
  LoginAuthAck();
  virtual ~LoginAuthAck();

  LoginAuthAck(const LoginAuthAck& from);

  inline LoginAuthAck& operator=(const LoginAuthAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginAuthAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginAuthAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginAuthAck* other);

  // implements Message ----------------------------------------------

  LoginAuthAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginAuthAck& from);
  void MergeFrom(const LoginAuthAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoginAuthAck)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginAuthAck* default_instance_;
};
// -------------------------------------------------------------------

class LoginAuthNack : public ::google::protobuf::MessageLite {
 public:
  LoginAuthNack();
  virtual ~LoginAuthNack();

  LoginAuthNack(const LoginAuthNack& from);

  inline LoginAuthNack& operator=(const LoginAuthNack& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginAuthNack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginAuthNack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginAuthNack* other);

  // implements Message ----------------------------------------------

  LoginAuthNack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginAuthNack& from);
  void MergeFrom(const LoginAuthNack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoginAuthNack)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginAuthNack* default_instance_;
};
// -------------------------------------------------------------------

class LoginServerList_LoginServerInfo : public ::google::protobuf::MessageLite {
 public:
  LoginServerList_LoginServerInfo();
  virtual ~LoginServerList_LoginServerInfo();

  LoginServerList_LoginServerInfo(const LoginServerList_LoginServerInfo& from);

  inline LoginServerList_LoginServerInfo& operator=(const LoginServerList_LoginServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginServerList_LoginServerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginServerList_LoginServerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginServerList_LoginServerInfo* other);

  // implements Message ----------------------------------------------

  LoginServerList_LoginServerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginServerList_LoginServerInfo& from);
  void MergeFrom(const LoginServerList_LoginServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional bytes server_name = 2;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 2;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const void* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional uint32 server_state = 3;
  inline bool has_server_state() const;
  inline void clear_server_state();
  static const int kServerStateFieldNumber = 3;
  inline ::google::protobuf::uint32 server_state() const;
  inline void set_server_state(::google::protobuf::uint32 value);

  // optional uint32 server_new = 4;
  inline bool has_server_new() const;
  inline void clear_server_new();
  static const int kServerNewFieldNumber = 4;
  inline ::google::protobuf::uint32 server_new() const;
  inline void set_server_new(::google::protobuf::uint32 value);

  // optional uint32 char_job = 5;
  inline bool has_char_job() const;
  inline void clear_char_job();
  static const int kCharJobFieldNumber = 5;
  inline ::google::protobuf::uint32 char_job() const;
  inline void set_char_job(::google::protobuf::uint32 value);

  // optional uint32 char_level = 6;
  inline bool has_char_level() const;
  inline void clear_char_level();
  static const int kCharLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 char_level() const;
  inline void set_char_level(::google::protobuf::uint32 value);

  // optional uint32 server_player_count = 7;
  inline bool has_server_player_count() const;
  inline void clear_server_player_count();
  static const int kServerPlayerCountFieldNumber = 7;
  inline ::google::protobuf::uint32 server_player_count() const;
  inline void set_server_player_count(::google::protobuf::uint32 value);

  // optional uint32 char_sex = 8;
  inline bool has_char_sex() const;
  inline void clear_char_sex();
  static const int kCharSexFieldNumber = 8;
  inline ::google::protobuf::uint32 char_sex() const;
  inline void set_char_sex(::google::protobuf::uint32 value);

  // optional uint32 gm_type = 9;
  inline bool has_gm_type() const;
  inline void clear_gm_type();
  static const int kGmTypeFieldNumber = 9;
  inline ::google::protobuf::uint32 gm_type() const;
  inline void set_gm_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoginServerList.LoginServerInfo)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_server_state();
  inline void clear_has_server_state();
  inline void set_has_server_new();
  inline void clear_has_server_new();
  inline void set_has_char_job();
  inline void clear_has_char_job();
  inline void set_has_char_level();
  inline void clear_has_char_level();
  inline void set_has_server_player_count();
  inline void clear_has_server_player_count();
  inline void set_has_char_sex();
  inline void clear_has_char_sex();
  inline void set_has_gm_type();
  inline void clear_has_gm_type();

  ::std::string* server_name_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 server_state_;
  ::google::protobuf::uint32 server_new_;
  ::google::protobuf::uint32 char_job_;
  ::google::protobuf::uint32 char_level_;
  ::google::protobuf::uint32 server_player_count_;
  ::google::protobuf::uint32 char_sex_;
  ::google::protobuf::uint32 gm_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginServerList_LoginServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginServerList : public ::google::protobuf::MessageLite {
 public:
  LoginServerList();
  virtual ~LoginServerList();

  LoginServerList(const LoginServerList& from);

  inline LoginServerList& operator=(const LoginServerList& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginServerList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginServerList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginServerList* other);

  // implements Message ----------------------------------------------

  LoginServerList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginServerList& from);
  void MergeFrom(const LoginServerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoginServerList_LoginServerInfo LoginServerInfo;

  // accessors -------------------------------------------------------

  // repeated .message.LoginServerList.LoginServerInfo server_info = 1;
  inline int server_info_size() const;
  inline void clear_server_info();
  static const int kServerInfoFieldNumber = 1;
  inline const ::message::LoginServerList_LoginServerInfo& server_info(int index) const;
  inline ::message::LoginServerList_LoginServerInfo* mutable_server_info(int index);
  inline ::message::LoginServerList_LoginServerInfo* add_server_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::LoginServerList_LoginServerInfo >&
      server_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::LoginServerList_LoginServerInfo >*
      mutable_server_info();

  // optional uint32 last_server = 2;
  inline bool has_last_server() const;
  inline void clear_last_server();
  static const int kLastServerFieldNumber = 2;
  inline ::google::protobuf::uint32 last_server() const;
  inline void set_last_server(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoginServerList)
 private:
  inline void set_has_last_server();
  inline void clear_has_last_server();

  ::google::protobuf::RepeatedPtrField< ::message::LoginServerList_LoginServerInfo > server_info_;
  ::google::protobuf::uint32 last_server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginServerList* default_instance_;
};
// -------------------------------------------------------------------

class LoginServerChoose : public ::google::protobuf::MessageLite {
 public:
  LoginServerChoose();
  virtual ~LoginServerChoose();

  LoginServerChoose(const LoginServerChoose& from);

  inline LoginServerChoose& operator=(const LoginServerChoose& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginServerChoose& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginServerChoose* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginServerChoose* other);

  // implements Message ----------------------------------------------

  LoginServerChoose* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginServerChoose& from);
  void MergeFrom(const LoginServerChoose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoginServerChoose)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginServerChoose* default_instance_;
};
// -------------------------------------------------------------------

class CenterServerChoose : public ::google::protobuf::MessageLite {
 public:
  CenterServerChoose();
  virtual ~CenterServerChoose();

  CenterServerChoose(const CenterServerChoose& from);

  inline CenterServerChoose& operator=(const CenterServerChoose& from) {
    CopyFrom(from);
    return *this;
  }

  static const CenterServerChoose& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CenterServerChoose* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CenterServerChoose* other);

  // implements Message ----------------------------------------------

  CenterServerChoose* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CenterServerChoose& from);
  void MergeFrom(const CenterServerChoose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CenterServerChoose)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CenterServerChoose* default_instance_;
};
// -------------------------------------------------------------------

class GateInfoSys : public ::google::protobuf::MessageLite {
 public:
  GateInfoSys();
  virtual ~GateInfoSys();

  GateInfoSys(const GateInfoSys& from);

  inline GateInfoSys& operator=(const GateInfoSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateInfoSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateInfoSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateInfoSys* other);

  // implements Message ----------------------------------------------

  GateInfoSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateInfoSys& from);
  void MergeFrom(const GateInfoSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional uint32 sever_id = 3;
  inline bool has_sever_id() const;
  inline void clear_sever_id();
  static const int kSeverIdFieldNumber = 3;
  inline ::google::protobuf::uint32 sever_id() const;
  inline void set_sever_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GateInfoSys)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_sever_id();
  inline void clear_has_sever_id();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 sever_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateInfoSys* default_instance_;
};
// -------------------------------------------------------------------

class GateInfoNack : public ::google::protobuf::MessageLite {
 public:
  GateInfoNack();
  virtual ~GateInfoNack();

  GateInfoNack(const GateInfoNack& from);

  inline GateInfoNack& operator=(const GateInfoNack& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateInfoNack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateInfoNack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateInfoNack* other);

  // implements Message ----------------------------------------------

  GateInfoNack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateInfoNack& from);
  void MergeFrom(const GateInfoNack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required uint32 error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GateInfoNack)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateInfoNack* default_instance_;
};
// -------------------------------------------------------------------

class GateInfoAck : public ::google::protobuf::MessageLite {
 public:
  GateInfoAck();
  virtual ~GateInfoAck();

  GateInfoAck(const GateInfoAck& from);

  inline GateInfoAck& operator=(const GateInfoAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateInfoAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateInfoAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateInfoAck* other);

  // implements Message ----------------------------------------------

  GateInfoAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateInfoAck& from);
  void MergeFrom(const GateInfoAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required uint32 acc_id = 2;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 2;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 nPort = 3;
  inline bool has_nport() const;
  inline void clear_nport();
  static const int kNPortFieldNumber = 3;
  inline ::google::protobuf::uint32 nport() const;
  inline void set_nport(::google::protobuf::uint32 value);

  // required string sGateIp = 4;
  inline bool has_sgateip() const;
  inline void clear_sgateip();
  static const int kSGateIpFieldNumber = 4;
  inline const ::std::string& sgateip() const;
  inline void set_sgateip(const ::std::string& value);
  inline void set_sgateip(const char* value);
  inline void set_sgateip(const char* value, size_t size);
  inline ::std::string* mutable_sgateip();
  inline ::std::string* release_sgateip();
  inline void set_allocated_sgateip(::std::string* sgateip);

  // @@protoc_insertion_point(class_scope:message.GateInfoAck)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_nport();
  inline void clear_has_nport();
  inline void set_has_sgateip();
  inline void clear_has_sgateip();

  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 acc_id_;
  ::std::string* sgateip_;
  ::google::protobuf::uint32 nport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateInfoAck* default_instance_;
};
// -------------------------------------------------------------------

class UserDisconnect : public ::google::protobuf::MessageLite {
 public:
  UserDisconnect();
  virtual ~UserDisconnect();

  UserDisconnect(const UserDisconnect& from);

  inline UserDisconnect& operator=(const UserDisconnect& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserDisconnect& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserDisconnect* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserDisconnect* other);

  // implements Message ----------------------------------------------

  UserDisconnect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserDisconnect& from);
  void MergeFrom(const UserDisconnect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UserDisconnect)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UserDisconnect* default_instance_;
};
// -------------------------------------------------------------------

class GateGetNonceSys : public ::google::protobuf::MessageLite {
 public:
  GateGetNonceSys();
  virtual ~GateGetNonceSys();

  GateGetNonceSys(const GateGetNonceSys& from);

  inline GateGetNonceSys& operator=(const GateGetNonceSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateGetNonceSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateGetNonceSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateGetNonceSys* other);

  // implements Message ----------------------------------------------

  GateGetNonceSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateGetNonceSys& from);
  void MergeFrom(const GateGetNonceSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.GateGetNonceSys)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateGetNonceSys* default_instance_;
};
// -------------------------------------------------------------------

class GateAuchNonce : public ::google::protobuf::MessageLite {
 public:
  GateAuchNonce();
  virtual ~GateAuchNonce();

  GateAuchNonce(const GateAuchNonce& from);

  inline GateAuchNonce& operator=(const GateAuchNonce& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateAuchNonce& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateAuchNonce* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateAuchNonce* other);

  // implements Message ----------------------------------------------

  GateAuchNonce* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateAuchNonce& from);
  void MergeFrom(const GateAuchNonce& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nonce = 1;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 1;
  inline ::google::protobuf::uint32 nonce() const;
  inline void set_nonce(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GateAuchNonce)
 private:
  inline void set_has_nonce();
  inline void clear_has_nonce();

  ::google::protobuf::uint32 nonce_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateAuchNonce* default_instance_;
};
// -------------------------------------------------------------------

class GateAuthSys : public ::google::protobuf::MessageLite {
 public:
  GateAuthSys();
  virtual ~GateAuthSys();

  GateAuthSys(const GateAuthSys& from);

  inline GateAuthSys& operator=(const GateAuthSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateAuthSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateAuthSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateAuthSys* other);

  // implements Message ----------------------------------------------

  GateAuthSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateAuthSys& from);
  void MergeFrom(const GateAuthSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 client_nonce = 2;
  inline bool has_client_nonce() const;
  inline void clear_client_nonce();
  static const int kClientNonceFieldNumber = 2;
  inline ::google::protobuf::uint32 client_nonce() const;
  inline void set_client_nonce(::google::protobuf::uint32 value);

  // required bytes digest = 3;
  inline bool has_digest() const;
  inline void clear_digest();
  static const int kDigestFieldNumber = 3;
  inline const ::std::string& digest() const;
  inline void set_digest(const ::std::string& value);
  inline void set_digest(const char* value);
  inline void set_digest(const void* value, size_t size);
  inline ::std::string* mutable_digest();
  inline ::std::string* release_digest();
  inline void set_allocated_digest(::std::string* digest);

  // @@protoc_insertion_point(class_scope:message.GateAuthSys)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_client_nonce();
  inline void clear_has_client_nonce();
  inline void set_has_digest();
  inline void clear_has_digest();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 client_nonce_;
  ::std::string* digest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateAuthSys* default_instance_;
};
// -------------------------------------------------------------------

class CenterAuthSys : public ::google::protobuf::MessageLite {
 public:
  CenterAuthSys();
  virtual ~CenterAuthSys();

  CenterAuthSys(const CenterAuthSys& from);

  inline CenterAuthSys& operator=(const CenterAuthSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const CenterAuthSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CenterAuthSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CenterAuthSys* other);

  // implements Message ----------------------------------------------

  CenterAuthSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CenterAuthSys& from);
  void MergeFrom(const CenterAuthSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 client_nonce = 2;
  inline bool has_client_nonce() const;
  inline void clear_client_nonce();
  static const int kClientNonceFieldNumber = 2;
  inline ::google::protobuf::uint32 client_nonce() const;
  inline void set_client_nonce(::google::protobuf::uint32 value);

  // required uint32 server_nonce = 3;
  inline bool has_server_nonce() const;
  inline void clear_server_nonce();
  static const int kServerNonceFieldNumber = 3;
  inline ::google::protobuf::uint32 server_nonce() const;
  inline void set_server_nonce(::google::protobuf::uint32 value);

  // required bytes digest = 4;
  inline bool has_digest() const;
  inline void clear_digest();
  static const int kDigestFieldNumber = 4;
  inline const ::std::string& digest() const;
  inline void set_digest(const ::std::string& value);
  inline void set_digest(const char* value);
  inline void set_digest(const void* value, size_t size);
  inline ::std::string* mutable_digest();
  inline ::std::string* release_digest();
  inline void set_allocated_digest(::std::string* digest);

  // required uint32 temp_user_key = 5;
  inline bool has_temp_user_key() const;
  inline void clear_temp_user_key();
  static const int kTempUserKeyFieldNumber = 5;
  inline ::google::protobuf::uint32 temp_user_key() const;
  inline void set_temp_user_key(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CenterAuthSys)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_client_nonce();
  inline void clear_has_client_nonce();
  inline void set_has_server_nonce();
  inline void clear_has_server_nonce();
  inline void set_has_digest();
  inline void clear_has_digest();
  inline void set_has_temp_user_key();
  inline void clear_has_temp_user_key();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 client_nonce_;
  ::std::string* digest_;
  ::google::protobuf::uint32 server_nonce_;
  ::google::protobuf::uint32 temp_user_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CenterAuthSys* default_instance_;
};
// -------------------------------------------------------------------

class CenterAuthAck : public ::google::protobuf::MessageLite {
 public:
  CenterAuthAck();
  virtual ~CenterAuthAck();

  CenterAuthAck(const CenterAuthAck& from);

  inline CenterAuthAck& operator=(const CenterAuthAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const CenterAuthAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CenterAuthAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CenterAuthAck* other);

  // implements Message ----------------------------------------------

  CenterAuthAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CenterAuthAck& from);
  void MergeFrom(const CenterAuthAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 temp_user_key = 2;
  inline bool has_temp_user_key() const;
  inline void clear_temp_user_key();
  static const int kTempUserKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 temp_user_key() const;
  inline void set_temp_user_key(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CenterAuthAck)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_temp_user_key();
  inline void clear_has_temp_user_key();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 temp_user_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CenterAuthAck* default_instance_;
};
// -------------------------------------------------------------------

class CenterAuthNack : public ::google::protobuf::MessageLite {
 public:
  CenterAuthNack();
  virtual ~CenterAuthNack();

  CenterAuthNack(const CenterAuthNack& from);

  inline CenterAuthNack& operator=(const CenterAuthNack& from) {
    CopyFrom(from);
    return *this;
  }

  static const CenterAuthNack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CenterAuthNack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CenterAuthNack* other);

  // implements Message ----------------------------------------------

  CenterAuthNack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CenterAuthNack& from);
  void MergeFrom(const CenterAuthNack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional uint32 temp_user_key = 2;
  inline bool has_temp_user_key() const;
  inline void clear_temp_user_key();
  static const int kTempUserKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 temp_user_key() const;
  inline void set_temp_user_key(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CenterAuthNack)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_temp_user_key();
  inline void clear_has_temp_user_key();

  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::uint32 temp_user_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CenterAuthNack* default_instance_;
};
// -------------------------------------------------------------------

class CenterAuthLogout : public ::google::protobuf::MessageLite {
 public:
  CenterAuthLogout();
  virtual ~CenterAuthLogout();

  CenterAuthLogout(const CenterAuthLogout& from);

  inline CenterAuthLogout& operator=(const CenterAuthLogout& from) {
    CopyFrom(from);
    return *this;
  }

  static const CenterAuthLogout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CenterAuthLogout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CenterAuthLogout* other);

  // implements Message ----------------------------------------------

  CenterAuthLogout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CenterAuthLogout& from);
  void MergeFrom(const CenterAuthLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CenterAuthLogout)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CenterAuthLogout* default_instance_;
};
// -------------------------------------------------------------------

class GetPlayerRoleList : public ::google::protobuf::MessageLite {
 public:
  GetPlayerRoleList();
  virtual ~GetPlayerRoleList();

  GetPlayerRoleList(const GetPlayerRoleList& from);

  inline GetPlayerRoleList& operator=(const GetPlayerRoleList& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetPlayerRoleList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetPlayerRoleList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetPlayerRoleList* other);

  // implements Message ----------------------------------------------

  GetPlayerRoleList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetPlayerRoleList& from);
  void MergeFrom(const GetPlayerRoleList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetPlayerRoleList)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetPlayerRoleList* default_instance_;
};
// -------------------------------------------------------------------

class PlayerRoleListData : public ::google::protobuf::MessageLite {
 public:
  PlayerRoleListData();
  virtual ~PlayerRoleListData();

  PlayerRoleListData(const PlayerRoleListData& from);

  inline PlayerRoleListData& operator=(const PlayerRoleListData& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerRoleListData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerRoleListData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerRoleListData* other);

  // implements Message ----------------------------------------------

  PlayerRoleListData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerRoleListData& from);
  void MergeFrom(const PlayerRoleListData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes role_data = 1;
  inline int role_data_size() const;
  inline void clear_role_data();
  static const int kRoleDataFieldNumber = 1;
  inline const ::std::string& role_data(int index) const;
  inline ::std::string* mutable_role_data(int index);
  inline void set_role_data(int index, const ::std::string& value);
  inline void set_role_data(int index, const char* value);
  inline void set_role_data(int index, const void* value, size_t size);
  inline ::std::string* add_role_data();
  inline void add_role_data(const ::std::string& value);
  inline void add_role_data(const char* value);
  inline void add_role_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& role_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_role_data();

  // optional uint32 acc_id = 2;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 2;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PlayerRoleListData)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::RepeatedPtrField< ::std::string> role_data_;
  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PlayerRoleListData* default_instance_;
};
// -------------------------------------------------------------------

class EnterSceneSys : public ::google::protobuf::MessageLite {
 public:
  EnterSceneSys();
  virtual ~EnterSceneSys();

  EnterSceneSys(const EnterSceneSys& from);

  inline EnterSceneSys& operator=(const EnterSceneSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterSceneSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterSceneSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterSceneSys* other);

  // implements Message ----------------------------------------------

  EnterSceneSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterSceneSys& from);
  void MergeFrom(const EnterSceneSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 avater_index = 1;
  inline bool has_avater_index() const;
  inline void clear_avater_index();
  static const int kAvaterIndexFieldNumber = 1;
  inline ::google::protobuf::int32 avater_index() const;
  inline void set_avater_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.EnterSceneSys)
 private:
  inline void set_has_avater_index();
  inline void clear_has_avater_index();

  ::google::protobuf::int32 avater_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EnterSceneSys* default_instance_;
};
// -------------------------------------------------------------------

class EnterSceneNack : public ::google::protobuf::MessageLite {
 public:
  EnterSceneNack();
  virtual ~EnterSceneNack();

  EnterSceneNack(const EnterSceneNack& from);

  inline EnterSceneNack& operator=(const EnterSceneNack& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterSceneNack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterSceneNack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterSceneNack* other);

  // implements Message ----------------------------------------------

  EnterSceneNack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterSceneNack& from);
  void MergeFrom(const EnterSceneNack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.EnterSceneNack)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EnterSceneNack* default_instance_;
};
// -------------------------------------------------------------------

class ChooseSceneCmd : public ::google::protobuf::MessageLite {
 public:
  ChooseSceneCmd();
  virtual ~ChooseSceneCmd();

  ChooseSceneCmd(const ChooseSceneCmd& from);

  inline ChooseSceneCmd& operator=(const ChooseSceneCmd& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChooseSceneCmd& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChooseSceneCmd* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChooseSceneCmd* other);

  // implements Message ----------------------------------------------

  ChooseSceneCmd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChooseSceneCmd& from);
  void MergeFrom(const ChooseSceneCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // required uint32 map_id = 3;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 3;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 slot_index = 4;
  inline bool has_slot_index() const;
  inline void clear_slot_index();
  static const int kSlotIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 slot_index() const;
  inline void set_slot_index(::google::protobuf::uint32 value);

  // required float pos_x = 5;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 5;
  inline float pos_x() const;
  inline void set_pos_x(float value);

  // required float pos_y = 6;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 6;
  inline float pos_y() const;
  inline void set_pos_y(float value);

  // @@protoc_insertion_point(class_scope:message.ChooseSceneCmd)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_slot_index();
  inline void clear_has_slot_index();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 slot_index_;
  float pos_x_;
  float pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ChooseSceneCmd* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfoConnected : public ::google::protobuf::MessageLite {
 public:
  ServerInfoConnected();
  virtual ~ServerInfoConnected();

  ServerInfoConnected(const ServerInfoConnected& from);

  inline ServerInfoConnected& operator=(const ServerInfoConnected& from) {
    CopyFrom(from);
    return *this;
  }

  static const ServerInfoConnected& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerInfoConnected* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerInfoConnected* other);

  // implements Message ----------------------------------------------

  ServerInfoConnected* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerInfoConnected& from);
  void MergeFrom(const ServerInfoConnected& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.ServerInfoConnected)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ServerInfoConnected* default_instance_;
};
// -------------------------------------------------------------------

class MapServerInfo : public ::google::protobuf::MessageLite {
 public:
  MapServerInfo();
  virtual ~MapServerInfo();

  MapServerInfo(const MapServerInfo& from);

  inline MapServerInfo& operator=(const MapServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapServerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapServerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapServerInfo* other);

  // implements Message ----------------------------------------------

  MapServerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapServerInfo& from);
  void MergeFrom(const MapServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // repeated bytes mapinfo_data = 2;
  inline int mapinfo_data_size() const;
  inline void clear_mapinfo_data();
  static const int kMapinfoDataFieldNumber = 2;
  inline const ::std::string& mapinfo_data(int index) const;
  inline ::std::string* mutable_mapinfo_data(int index);
  inline void set_mapinfo_data(int index, const ::std::string& value);
  inline void set_mapinfo_data(int index, const char* value);
  inline void set_mapinfo_data(int index, const void* value, size_t size);
  inline ::std::string* add_mapinfo_data();
  inline void add_mapinfo_data(const ::std::string& value);
  inline void add_mapinfo_data(const char* value);
  inline void add_mapinfo_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mapinfo_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mapinfo_data();

  // @@protoc_insertion_point(class_scope:message.MapServerInfo)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::RepeatedPtrField< ::std::string> mapinfo_data_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static MapServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CreateUserInfo : public ::google::protobuf::MessageLite {
 public:
  CreateUserInfo();
  virtual ~CreateUserInfo();

  CreateUserInfo(const CreateUserInfo& from);

  inline CreateUserInfo& operator=(const CreateUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateUserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateUserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateUserInfo* other);

  // implements Message ----------------------------------------------

  CreateUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateUserInfo& from);
  void MergeFrom(const CreateUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // repeated bytes user_data = 2;
  inline int user_data_size() const;
  inline void clear_user_data();
  static const int kUserDataFieldNumber = 2;
  inline const ::std::string& user_data(int index) const;
  inline ::std::string* mutable_user_data(int index);
  inline void set_user_data(int index, const ::std::string& value);
  inline void set_user_data(int index, const char* value);
  inline void set_user_data(int index, const void* value, size_t size);
  inline ::std::string* add_user_data();
  inline void add_user_data(const ::std::string& value);
  inline void add_user_data(const char* value);
  inline void add_user_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_data();

  // optional uint32 server_id = 3;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 is_robot = 4;
  inline bool has_is_robot() const;
  inline void clear_is_robot();
  static const int kIsRobotFieldNumber = 4;
  inline ::google::protobuf::uint32 is_robot() const;
  inline void set_is_robot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CreateUserInfo)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_is_robot();
  inline void clear_has_is_robot();

  ::google::protobuf::RepeatedPtrField< ::std::string> user_data_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 is_robot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CreateUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class CreateUserResult : public ::google::protobuf::MessageLite {
 public:
  CreateUserResult();
  virtual ~CreateUserResult();

  CreateUserResult(const CreateUserResult& from);

  inline CreateUserResult& operator=(const CreateUserResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateUserResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateUserResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateUserResult* other);

  // implements Message ----------------------------------------------

  CreateUserResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateUserResult& from);
  void MergeFrom(const CreateUserResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // required uint32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CreateUserResult)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CreateUserResult* default_instance_;
};
// -------------------------------------------------------------------

class SaveUserInfo : public ::google::protobuf::MessageLite {
 public:
  SaveUserInfo();
  virtual ~SaveUserInfo();

  SaveUserInfo(const SaveUserInfo& from);

  inline SaveUserInfo& operator=(const SaveUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SaveUserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SaveUserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SaveUserInfo* other);

  // implements Message ----------------------------------------------

  SaveUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SaveUserInfo& from);
  void MergeFrom(const SaveUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // repeated bytes user_data = 2;
  inline int user_data_size() const;
  inline void clear_user_data();
  static const int kUserDataFieldNumber = 2;
  inline const ::std::string& user_data(int index) const;
  inline ::std::string* mutable_user_data(int index);
  inline void set_user_data(int index, const ::std::string& value);
  inline void set_user_data(int index, const char* value);
  inline void set_user_data(int index, const void* value, size_t size);
  inline ::std::string* add_user_data();
  inline void add_user_data(const ::std::string& value);
  inline void add_user_data(const char* value);
  inline void add_user_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_data();

  // optional uint32 sequence_id = 3;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 3;
  inline ::google::protobuf::uint32 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SaveUserInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();

  ::google::protobuf::RepeatedPtrField< ::std::string> user_data_;
  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 sequence_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SaveUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetUserDetailInfo : public ::google::protobuf::MessageLite {
 public:
  GetUserDetailInfo();
  virtual ~GetUserDetailInfo();

  GetUserDetailInfo(const GetUserDetailInfo& from);

  inline GetUserDetailInfo& operator=(const GetUserDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetUserDetailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserDetailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserDetailInfo* other);

  // implements Message ----------------------------------------------

  GetUserDetailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserDetailInfo& from);
  void MergeFrom(const GetUserDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetUserDetailInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetUserDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserDetailInfo : public ::google::protobuf::MessageLite {
 public:
  UserDetailInfo();
  virtual ~UserDetailInfo();

  UserDetailInfo(const UserDetailInfo& from);

  inline UserDetailInfo& operator=(const UserDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserDetailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserDetailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserDetailInfo* other);

  // implements Message ----------------------------------------------

  UserDetailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserDetailInfo& from);
  void MergeFrom(const UserDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 sequence_id = 2;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::uint32 value);

  // repeated bytes user_data = 3;
  inline int user_data_size() const;
  inline void clear_user_data();
  static const int kUserDataFieldNumber = 3;
  inline const ::std::string& user_data(int index) const;
  inline ::std::string* mutable_user_data(int index);
  inline void set_user_data(int index, const ::std::string& value);
  inline void set_user_data(int index, const char* value);
  inline void set_user_data(int index, const void* value, size_t size);
  inline ::std::string* add_user_data();
  inline void add_user_data(const ::std::string& value);
  inline void add_user_data(const char* value);
  inline void add_user_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_data();

  // @@protoc_insertion_point(class_scope:message.UserDetailInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 sequence_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UserDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class EnterSceneMapSys : public ::google::protobuf::MessageLite {
 public:
  EnterSceneMapSys();
  virtual ~EnterSceneMapSys();

  EnterSceneMapSys(const EnterSceneMapSys& from);

  inline EnterSceneMapSys& operator=(const EnterSceneMapSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterSceneMapSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterSceneMapSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterSceneMapSys* other);

  // implements Message ----------------------------------------------

  EnterSceneMapSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterSceneMapSys& from);
  void MergeFrom(const EnterSceneMapSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gate_id = 1;
  inline bool has_gate_id() const;
  inline void clear_gate_id();
  static const int kGateIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gate_id() const;
  inline void set_gate_id(::google::protobuf::uint32 value);

  // required uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // required uint32 acc_id = 3;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 3;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 map_id = 4;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 4;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 slot_index = 5;
  inline bool has_slot_index() const;
  inline void clear_slot_index();
  static const int kSlotIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 slot_index() const;
  inline void set_slot_index(::google::protobuf::uint32 value);

  // required uint32 instance_id = 6;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 6;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);

  // required float pos_x = 7;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 7;
  inline float pos_x() const;
  inline void set_pos_x(float value);

  // required float pos_y = 8;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 8;
  inline float pos_y() const;
  inline void set_pos_y(float value);

  // required uint32 bchange_scene = 9;
  inline bool has_bchange_scene() const;
  inline void clear_bchange_scene();
  static const int kBchangeSceneFieldNumber = 9;
  inline ::google::protobuf::uint32 bchange_scene() const;
  inline void set_bchange_scene(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.EnterSceneMapSys)
 private:
  inline void set_has_gate_id();
  inline void clear_has_gate_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_slot_index();
  inline void clear_has_slot_index();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();
  inline void set_has_bchange_scene();
  inline void clear_has_bchange_scene();

  ::google::protobuf::uint32 gate_id_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 slot_index_;
  ::google::protobuf::uint32 instance_id_;
  float pos_x_;
  float pos_y_;
  ::google::protobuf::uint32 bchange_scene_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EnterSceneMapSys* default_instance_;
};
// -------------------------------------------------------------------

class EnterSceneMapNack : public ::google::protobuf::MessageLite {
 public:
  EnterSceneMapNack();
  virtual ~EnterSceneMapNack();

  EnterSceneMapNack(const EnterSceneMapNack& from);

  inline EnterSceneMapNack& operator=(const EnterSceneMapNack& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterSceneMapNack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterSceneMapNack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterSceneMapNack* other);

  // implements Message ----------------------------------------------

  EnterSceneMapNack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterSceneMapNack& from);
  void MergeFrom(const EnterSceneMapNack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.EnterSceneMapNack)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EnterSceneMapNack* default_instance_;
};
// -------------------------------------------------------------------

class EnterSceneMapAck : public ::google::protobuf::MessageLite {
 public:
  EnterSceneMapAck();
  virtual ~EnterSceneMapAck();

  EnterSceneMapAck(const EnterSceneMapAck& from);

  inline EnterSceneMapAck& operator=(const EnterSceneMapAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterSceneMapAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterSceneMapAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterSceneMapAck* other);

  // implements Message ----------------------------------------------

  EnterSceneMapAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterSceneMapAck& from);
  void MergeFrom(const EnterSceneMapAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.EnterSceneMapAck)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EnterSceneMapAck* default_instance_;
};
// -------------------------------------------------------------------

class ClientCreateSenceCmd : public ::google::protobuf::MessageLite {
 public:
  ClientCreateSenceCmd();
  virtual ~ClientCreateSenceCmd();

  ClientCreateSenceCmd(const ClientCreateSenceCmd& from);

  inline ClientCreateSenceCmd& operator=(const ClientCreateSenceCmd& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientCreateSenceCmd& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientCreateSenceCmd* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientCreateSenceCmd* other);

  // implements Message ----------------------------------------------

  ClientCreateSenceCmd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientCreateSenceCmd& from);
  void MergeFrom(const ClientCreateSenceCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required float pos_x = 2;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 2;
  inline float pos_x() const;
  inline void set_pos_x(float value);

  // required float pos_y = 3;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 3;
  inline float pos_y() const;
  inline void set_pos_y(float value);

  // @@protoc_insertion_point(class_scope:message.ClientCreateSenceCmd)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();

  ::google::protobuf::uint32 map_id_;
  float pos_x_;
  float pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ClientCreateSenceCmd* default_instance_;
};
// -------------------------------------------------------------------

class ClientEnterSenceSys : public ::google::protobuf::MessageLite {
 public:
  ClientEnterSenceSys();
  virtual ~ClientEnterSenceSys();

  ClientEnterSenceSys(const ClientEnterSenceSys& from);

  inline ClientEnterSenceSys& operator=(const ClientEnterSenceSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientEnterSenceSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientEnterSenceSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientEnterSenceSys* other);

  // implements Message ----------------------------------------------

  ClientEnterSenceSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientEnterSenceSys& from);
  void MergeFrom(const ClientEnterSenceSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.ClientEnterSenceSys)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ClientEnterSenceSys* default_instance_;
};
// -------------------------------------------------------------------

class AddPlayerSys : public ::google::protobuf::MessageLite {
 public:
  AddPlayerSys();
  virtual ~AddPlayerSys();

  AddPlayerSys(const AddPlayerSys& from);

  inline AddPlayerSys& operator=(const AddPlayerSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddPlayerSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddPlayerSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddPlayerSys* other);

  // implements Message ----------------------------------------------

  AddPlayerSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddPlayerSys& from);
  void MergeFrom(const AddPlayerSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // required uint32 pos_x = 2;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 2;
  inline ::google::protobuf::uint32 pos_x() const;
  inline void set_pos_x(::google::protobuf::uint32 value);

  // required uint32 pos_y = 3;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 3;
  inline ::google::protobuf::uint32 pos_y() const;
  inline void set_pos_y(::google::protobuf::uint32 value);

  // required uint32 pos_o = 4;
  inline bool has_pos_o() const;
  inline void clear_pos_o();
  static const int kPosOFieldNumber = 4;
  inline ::google::protobuf::uint32 pos_o() const;
  inline void set_pos_o(::google::protobuf::uint32 value);

  // required uint32 char_job = 5;
  inline bool has_char_job() const;
  inline void clear_char_job();
  static const int kCharJobFieldNumber = 5;
  inline ::google::protobuf::uint32 char_job() const;
  inline void set_char_job(::google::protobuf::uint32 value);

  // required uint32 char_sex = 6;
  inline bool has_char_sex() const;
  inline void clear_char_sex();
  static const int kCharSexFieldNumber = 6;
  inline ::google::protobuf::uint32 char_sex() const;
  inline void set_char_sex(::google::protobuf::uint32 value);

  // required bytes char_name = 7;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 7;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // required uint32 char_weapon = 8;
  inline bool has_char_weapon() const;
  inline void clear_char_weapon();
  static const int kCharWeaponFieldNumber = 8;
  inline ::google::protobuf::uint32 char_weapon() const;
  inline void set_char_weapon(::google::protobuf::uint32 value);

  // required uint32 char_level = 9;
  inline bool has_char_level() const;
  inline void clear_char_level();
  static const int kCharLevelFieldNumber = 9;
  inline ::google::protobuf::uint32 char_level() const;
  inline void set_char_level(::google::protobuf::uint32 value);

  // optional uint32 horse_id = 10;
  inline bool has_horse_id() const;
  inline void clear_horse_id();
  static const int kHorseIdFieldNumber = 10;
  inline ::google::protobuf::uint32 horse_id() const;
  inline void set_horse_id(::google::protobuf::uint32 value);

  // optional uint32 horse_image = 11;
  inline bool has_horse_image() const;
  inline void clear_horse_image();
  static const int kHorseImageFieldNumber = 11;
  inline ::google::protobuf::uint32 horse_image() const;
  inline void set_horse_image(::google::protobuf::uint32 value);

  // optional bytes horse_name = 12;
  inline bool has_horse_name() const;
  inline void clear_horse_name();
  static const int kHorseNameFieldNumber = 12;
  inline const ::std::string& horse_name() const;
  inline void set_horse_name(const ::std::string& value);
  inline void set_horse_name(const char* value);
  inline void set_horse_name(const void* value, size_t size);
  inline ::std::string* mutable_horse_name();
  inline ::std::string* release_horse_name();
  inline void set_allocated_horse_name(::std::string* horse_name);

  // @@protoc_insertion_point(class_scope:message.AddPlayerSys)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();
  inline void set_has_pos_o();
  inline void clear_has_pos_o();
  inline void set_has_char_job();
  inline void clear_has_char_job();
  inline void set_has_char_sex();
  inline void clear_has_char_sex();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_char_weapon();
  inline void clear_has_char_weapon();
  inline void set_has_char_level();
  inline void clear_has_char_level();
  inline void set_has_horse_id();
  inline void clear_has_horse_id();
  inline void set_has_horse_image();
  inline void clear_has_horse_image();
  inline void set_has_horse_name();
  inline void clear_has_horse_name();

  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 pos_x_;
  ::google::protobuf::uint32 pos_y_;
  ::google::protobuf::uint32 pos_o_;
  ::google::protobuf::uint32 char_job_;
  ::google::protobuf::uint32 char_sex_;
  ::std::string* char_name_;
  ::google::protobuf::uint32 char_weapon_;
  ::google::protobuf::uint32 char_level_;
  ::google::protobuf::uint32 horse_id_;
  ::google::protobuf::uint32 horse_image_;
  ::std::string* horse_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddPlayerSys* default_instance_;
};
// -------------------------------------------------------------------

class AddNpcSys : public ::google::protobuf::MessageLite {
 public:
  AddNpcSys();
  virtual ~AddNpcSys();

  AddNpcSys(const AddNpcSys& from);

  inline AddNpcSys& operator=(const AddNpcSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddNpcSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddNpcSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddNpcSys* other);

  // implements Message ----------------------------------------------

  AddNpcSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddNpcSys& from);
  void MergeFrom(const AddNpcSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 npc_id = 1;
  inline bool has_npc_id() const;
  inline void clear_npc_id();
  static const int kNpcIdFieldNumber = 1;
  inline ::google::protobuf::uint32 npc_id() const;
  inline void set_npc_id(::google::protobuf::uint32 value);

  // required uint32 npc_only_id = 2;
  inline bool has_npc_only_id() const;
  inline void clear_npc_only_id();
  static const int kNpcOnlyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 npc_only_id() const;
  inline void set_npc_only_id(::google::protobuf::uint32 value);

  // required uint32 npc_mode_id = 3;
  inline bool has_npc_mode_id() const;
  inline void clear_npc_mode_id();
  static const int kNpcModeIdFieldNumber = 3;
  inline ::google::protobuf::uint32 npc_mode_id() const;
  inline void set_npc_mode_id(::google::protobuf::uint32 value);

  // required uint32 npc_type_id = 4;
  inline bool has_npc_type_id() const;
  inline void clear_npc_type_id();
  static const int kNpcTypeIdFieldNumber = 4;
  inline ::google::protobuf::uint32 npc_type_id() const;
  inline void set_npc_type_id(::google::protobuf::uint32 value);

  // required uint32 pos_x = 5;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 5;
  inline ::google::protobuf::uint32 pos_x() const;
  inline void set_pos_x(::google::protobuf::uint32 value);

  // required uint32 pos_y = 6;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 6;
  inline ::google::protobuf::uint32 pos_y() const;
  inline void set_pos_y(::google::protobuf::uint32 value);

  // required uint32 pos_o = 7;
  inline bool has_pos_o() const;
  inline void clear_pos_o();
  static const int kPosOFieldNumber = 7;
  inline ::google::protobuf::uint32 pos_o() const;
  inline void set_pos_o(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AddNpcSys)
 private:
  inline void set_has_npc_id();
  inline void clear_has_npc_id();
  inline void set_has_npc_only_id();
  inline void clear_has_npc_only_id();
  inline void set_has_npc_mode_id();
  inline void clear_has_npc_mode_id();
  inline void set_has_npc_type_id();
  inline void clear_has_npc_type_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();
  inline void set_has_pos_o();
  inline void clear_has_pos_o();

  ::google::protobuf::uint32 npc_id_;
  ::google::protobuf::uint32 npc_only_id_;
  ::google::protobuf::uint32 npc_mode_id_;
  ::google::protobuf::uint32 npc_type_id_;
  ::google::protobuf::uint32 pos_x_;
  ::google::protobuf::uint32 pos_y_;
  ::google::protobuf::uint32 pos_o_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddNpcSys* default_instance_;
};
// -------------------------------------------------------------------

class DelPlayerSys : public ::google::protobuf::MessageLite {
 public:
  DelPlayerSys();
  virtual ~DelPlayerSys();

  DelPlayerSys(const DelPlayerSys& from);

  inline DelPlayerSys& operator=(const DelPlayerSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const DelPlayerSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DelPlayerSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DelPlayerSys* other);

  // implements Message ----------------------------------------------

  DelPlayerSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DelPlayerSys& from);
  void MergeFrom(const DelPlayerSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.DelPlayerSys)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static DelPlayerSys* default_instance_;
};
// -------------------------------------------------------------------

class DelNpcSys : public ::google::protobuf::MessageLite {
 public:
  DelNpcSys();
  virtual ~DelNpcSys();

  DelNpcSys(const DelNpcSys& from);

  inline DelNpcSys& operator=(const DelNpcSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const DelNpcSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DelNpcSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DelNpcSys* other);

  // implements Message ----------------------------------------------

  DelNpcSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DelNpcSys& from);
  void MergeFrom(const DelNpcSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 npc_id = 1;
  inline bool has_npc_id() const;
  inline void clear_npc_id();
  static const int kNpcIdFieldNumber = 1;
  inline ::google::protobuf::uint32 npc_id() const;
  inline void set_npc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.DelNpcSys)
 private:
  inline void set_has_npc_id();
  inline void clear_has_npc_id();

  ::google::protobuf::uint32 npc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static DelNpcSys* default_instance_;
};
// -------------------------------------------------------------------

class GateInfoID : public ::google::protobuf::MessageLite {
 public:
  GateInfoID();
  virtual ~GateInfoID();

  GateInfoID(const GateInfoID& from);

  inline GateInfoID& operator=(const GateInfoID& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateInfoID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateInfoID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateInfoID* other);

  // implements Message ----------------------------------------------

  GateInfoID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateInfoID& from);
  void MergeFrom(const GateInfoID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gate_id = 1;
  inline bool has_gate_id() const;
  inline void clear_gate_id();
  static const int kGateIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gate_id() const;
  inline void set_gate_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GateInfoID)
 private:
  inline void set_has_gate_id();
  inline void clear_has_gate_id();

  ::google::protobuf::uint32 gate_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateInfoID* default_instance_;
};
// -------------------------------------------------------------------

class GateLogoutCmd : public ::google::protobuf::MessageLite {
 public:
  GateLogoutCmd();
  virtual ~GateLogoutCmd();

  GateLogoutCmd(const GateLogoutCmd& from);

  inline GateLogoutCmd& operator=(const GateLogoutCmd& from) {
    CopyFrom(from);
    return *this;
  }

  static const GateLogoutCmd& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GateLogoutCmd* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GateLogoutCmd* other);

  // implements Message ----------------------------------------------

  GateLogoutCmd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GateLogoutCmd& from);
  void MergeFrom(const GateLogoutCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::int32 acc_id() const;
  inline void set_acc_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.GateLogoutCmd)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::int32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GateLogoutCmd* default_instance_;
};
// -------------------------------------------------------------------

class Move : public ::google::protobuf::MessageLite {
 public:
  Move();
  virtual ~Move();

  Move(const Move& from);

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }

  static const Move& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Move* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Move* other);

  // implements Message ----------------------------------------------

  Move* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // required uint32 orient = 2;
  inline bool has_orient() const;
  inline void clear_orient();
  static const int kOrientFieldNumber = 2;
  inline ::google::protobuf::uint32 orient() const;
  inline void set_orient(::google::protobuf::uint32 value);

  // required float x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:message.Move)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_orient();
  inline void clear_has_orient();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 orient_;
  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static Move* default_instance_;
};
// -------------------------------------------------------------------

class PlayerJumpMap : public ::google::protobuf::MessageLite {
 public:
  PlayerJumpMap();
  virtual ~PlayerJumpMap();

  PlayerJumpMap(const PlayerJumpMap& from);

  inline PlayerJumpMap& operator=(const PlayerJumpMap& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerJumpMap& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerJumpMap* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerJumpMap* other);

  // implements Message ----------------------------------------------

  PlayerJumpMap* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerJumpMap& from);
  void MergeFrom(const PlayerJumpMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 jump_id = 2;
  inline bool has_jump_id() const;
  inline void clear_jump_id();
  static const int kJumpIdFieldNumber = 2;
  inline ::google::protobuf::uint32 jump_id() const;
  inline void set_jump_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PlayerJumpMap)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_jump_id();
  inline void clear_has_jump_id();

  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 jump_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PlayerJumpMap* default_instance_;
};
// -------------------------------------------------------------------

class NPCTeleport : public ::google::protobuf::MessageLite {
 public:
  NPCTeleport();
  virtual ~NPCTeleport();

  NPCTeleport(const NPCTeleport& from);

  inline NPCTeleport& operator=(const NPCTeleport& from) {
    CopyFrom(from);
    return *this;
  }

  static const NPCTeleport& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NPCTeleport* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NPCTeleport* other);

  // implements Message ----------------------------------------------

  NPCTeleport* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NPCTeleport& from);
  void MergeFrom(const NPCTeleport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 npc_id = 1;
  inline bool has_npc_id() const;
  inline void clear_npc_id();
  static const int kNpcIdFieldNumber = 1;
  inline ::google::protobuf::uint32 npc_id() const;
  inline void set_npc_id(::google::protobuf::uint32 value);

  // required uint32 big_stage_id = 2;
  inline bool has_big_stage_id() const;
  inline void clear_big_stage_id();
  static const int kBigStageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 big_stage_id() const;
  inline void set_big_stage_id(::google::protobuf::uint32 value);

  // required uint32 small_stage_id = 3;
  inline bool has_small_stage_id() const;
  inline void clear_small_stage_id();
  static const int kSmallStageIdFieldNumber = 3;
  inline ::google::protobuf::uint32 small_stage_id() const;
  inline void set_small_stage_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.NPCTeleport)
 private:
  inline void set_has_npc_id();
  inline void clear_has_npc_id();
  inline void set_has_big_stage_id();
  inline void clear_has_big_stage_id();
  inline void set_has_small_stage_id();
  inline void clear_has_small_stage_id();

  ::google::protobuf::uint32 npc_id_;
  ::google::protobuf::uint32 big_stage_id_;
  ::google::protobuf::uint32 small_stage_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static NPCTeleport* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAttack : public ::google::protobuf::MessageLite {
 public:
  PlayerAttack();
  virtual ~PlayerAttack();

  PlayerAttack(const PlayerAttack& from);

  inline PlayerAttack& operator=(const PlayerAttack& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerAttack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerAttack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerAttack* other);

  // implements Message ----------------------------------------------

  PlayerAttack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerAttack& from);
  void MergeFrom(const PlayerAttack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 attack_id = 2;
  inline bool has_attack_id() const;
  inline void clear_attack_id();
  static const int kAttackIdFieldNumber = 2;
  inline ::google::protobuf::uint32 attack_id() const;
  inline void set_attack_id(::google::protobuf::uint32 value);

  // optional uint32 battle_type = 3;
  inline bool has_battle_type() const;
  inline void clear_battle_type();
  static const int kBattleTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 battle_type() const;
  inline void set_battle_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PlayerAttack)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_attack_id();
  inline void clear_has_attack_id();
  inline void set_has_battle_type();
  inline void clear_has_battle_type();

  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 attack_id_;
  ::google::protobuf::uint32 battle_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PlayerAttack* default_instance_;
};
// -------------------------------------------------------------------

class QTEResult : public ::google::protobuf::MessageLite {
 public:
  QTEResult();
  virtual ~QTEResult();

  QTEResult(const QTEResult& from);

  inline QTEResult& operator=(const QTEResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const QTEResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QTEResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QTEResult* other);

  // implements Message ----------------------------------------------

  QTEResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QTEResult& from);
  void MergeFrom(const QTEResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 QTE_id = 2;
  inline bool has_qte_id() const;
  inline void clear_qte_id();
  static const int kQTEIdFieldNumber = 2;
  inline ::google::protobuf::uint32 qte_id() const;
  inline void set_qte_id(::google::protobuf::uint32 value);

  // required uint32 QTE_result = 3;
  inline bool has_qte_result() const;
  inline void clear_qte_result();
  static const int kQTEResultFieldNumber = 3;
  inline ::google::protobuf::uint32 qte_result() const;
  inline void set_qte_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.QTEResult)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_qte_id();
  inline void clear_has_qte_id();
  inline void set_has_qte_result();
  inline void clear_has_qte_result();

  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 qte_id_;
  ::google::protobuf::uint32 qte_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static QTEResult* default_instance_;
};
// -------------------------------------------------------------------

class ClearSkill : public ::google::protobuf::MessageLite {
 public:
  ClearSkill();
  virtual ~ClearSkill();

  ClearSkill(const ClearSkill& from);

  inline ClearSkill& operator=(const ClearSkill& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClearSkill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClearSkill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClearSkill* other);

  // implements Message ----------------------------------------------

  ClearSkill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClearSkill& from);
  void MergeFrom(const ClearSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ClearSkill)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::uint32 player_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ClearSkill* default_instance_;
};
// -------------------------------------------------------------------

class AddSkill : public ::google::protobuf::MessageLite {
 public:
  AddSkill();
  virtual ~AddSkill();

  AddSkill(const AddSkill& from);

  inline AddSkill& operator=(const AddSkill& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddSkill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddSkill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddSkill* other);

  // implements Message ----------------------------------------------

  AddSkill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddSkill& from);
  void MergeFrom(const AddSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 skill_id = 2;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AddSkill)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();

  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 skill_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddSkill* default_instance_;
};
// -------------------------------------------------------------------

class SkillSequence : public ::google::protobuf::MessageLite {
 public:
  SkillSequence();
  virtual ~SkillSequence();

  SkillSequence(const SkillSequence& from);

  inline SkillSequence& operator=(const SkillSequence& from) {
    CopyFrom(from);
    return *this;
  }

  static const SkillSequence& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SkillSequence* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SkillSequence* other);

  // implements Message ----------------------------------------------

  SkillSequence* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SkillSequence& from);
  void MergeFrom(const SkillSequence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 skill_id1 = 2;
  inline bool has_skill_id1() const;
  inline void clear_skill_id1();
  static const int kSkillId1FieldNumber = 2;
  inline ::google::protobuf::uint32 skill_id1() const;
  inline void set_skill_id1(::google::protobuf::uint32 value);

  // required uint32 skill_id2 = 3;
  inline bool has_skill_id2() const;
  inline void clear_skill_id2();
  static const int kSkillId2FieldNumber = 3;
  inline ::google::protobuf::uint32 skill_id2() const;
  inline void set_skill_id2(::google::protobuf::uint32 value);

  // required uint32 skill_id3 = 4;
  inline bool has_skill_id3() const;
  inline void clear_skill_id3();
  static const int kSkillId3FieldNumber = 4;
  inline ::google::protobuf::uint32 skill_id3() const;
  inline void set_skill_id3(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SkillSequence)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_skill_id1();
  inline void clear_has_skill_id1();
  inline void set_has_skill_id2();
  inline void clear_has_skill_id2();
  inline void set_has_skill_id3();
  inline void clear_has_skill_id3();

  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 skill_id1_;
  ::google::protobuf::uint32 skill_id2_;
  ::google::protobuf::uint32 skill_id3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SkillSequence* default_instance_;
};
// -------------------------------------------------------------------

class BattleCharInfo_CharInfo : public ::google::protobuf::MessageLite {
 public:
  BattleCharInfo_CharInfo();
  virtual ~BattleCharInfo_CharInfo();

  BattleCharInfo_CharInfo(const BattleCharInfo_CharInfo& from);

  inline BattleCharInfo_CharInfo& operator=(const BattleCharInfo_CharInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleCharInfo_CharInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleCharInfo_CharInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleCharInfo_CharInfo* other);

  // implements Message ----------------------------------------------

  BattleCharInfo_CharInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleCharInfo_CharInfo& from);
  void MergeFrom(const BattleCharInfo_CharInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 mode_id = 2;
  inline bool has_mode_id() const;
  inline void clear_mode_id();
  static const int kModeIdFieldNumber = 2;
  inline ::google::protobuf::int32 mode_id() const;
  inline void set_mode_id(::google::protobuf::int32 value);

  // required int32 pos_x = 3;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 3;
  inline ::google::protobuf::int32 pos_x() const;
  inline void set_pos_x(::google::protobuf::int32 value);

  // required int32 hp = 4;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 4;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // required int32 move_speed = 5;
  inline bool has_move_speed() const;
  inline void clear_move_speed();
  static const int kMoveSpeedFieldNumber = 5;
  inline ::google::protobuf::int32 move_speed() const;
  inline void set_move_speed(::google::protobuf::int32 value);

  // optional int32 sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int32 weapon = 7;
  inline bool has_weapon() const;
  inline void clear_weapon();
  static const int kWeaponFieldNumber = 7;
  inline ::google::protobuf::int32 weapon() const;
  inline void set_weapon(::google::protobuf::int32 value);

  // optional int32 mp = 8;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 8;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);

  // optional int32 is_boss = 9;
  inline bool has_is_boss() const;
  inline void clear_is_boss();
  static const int kIsBossFieldNumber = 9;
  inline ::google::protobuf::int32 is_boss() const;
  inline void set_is_boss(::google::protobuf::int32 value);

  // optional bytes boss_name = 10;
  inline bool has_boss_name() const;
  inline void clear_boss_name();
  static const int kBossNameFieldNumber = 10;
  inline const ::std::string& boss_name() const;
  inline void set_boss_name(const ::std::string& value);
  inline void set_boss_name(const char* value);
  inline void set_boss_name(const void* value, size_t size);
  inline ::std::string* mutable_boss_name();
  inline ::std::string* release_boss_name();
  inline void set_allocated_boss_name(::std::string* boss_name);

  // @@protoc_insertion_point(class_scope:message.BattleCharInfo.CharInfo)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_mode_id();
  inline void clear_has_mode_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_move_speed();
  inline void clear_has_move_speed();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_weapon();
  inline void clear_has_weapon();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_is_boss();
  inline void clear_has_is_boss();
  inline void set_has_boss_name();
  inline void clear_has_boss_name();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 mode_id_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 move_speed_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 weapon_;
  ::google::protobuf::int32 mp_;
  ::std::string* boss_name_;
  ::google::protobuf::int32 is_boss_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleCharInfo_CharInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleCharInfo : public ::google::protobuf::MessageLite {
 public:
  BattleCharInfo();
  virtual ~BattleCharInfo();

  BattleCharInfo(const BattleCharInfo& from);

  inline BattleCharInfo& operator=(const BattleCharInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleCharInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleCharInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleCharInfo* other);

  // implements Message ----------------------------------------------

  BattleCharInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleCharInfo& from);
  void MergeFrom(const BattleCharInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BattleCharInfo_CharInfo CharInfo;

  // accessors -------------------------------------------------------

  // repeated .message.BattleCharInfo.CharInfo charinfo = 1;
  inline int charinfo_size() const;
  inline void clear_charinfo();
  static const int kCharinfoFieldNumber = 1;
  inline const ::message::BattleCharInfo_CharInfo& charinfo(int index) const;
  inline ::message::BattleCharInfo_CharInfo* mutable_charinfo(int index);
  inline ::message::BattleCharInfo_CharInfo* add_charinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::message::BattleCharInfo_CharInfo >&
      charinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::BattleCharInfo_CharInfo >*
      mutable_charinfo();

  // @@protoc_insertion_point(class_scope:message.BattleCharInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::BattleCharInfo_CharInfo > charinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleCharInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo_StartStopEvent : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo_StartStopEvent();
  virtual ~BattleActionInfo_StartStopEvent();

  BattleActionInfo_StartStopEvent(const BattleActionInfo_StartStopEvent& from);

  inline BattleActionInfo_StartStopEvent& operator=(const BattleActionInfo_StartStopEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo_StartStopEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo_StartStopEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo_StartStopEvent* other);

  // implements Message ----------------------------------------------

  BattleActionInfo_StartStopEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo_StartStopEvent& from);
  void MergeFrom(const BattleActionInfo_StartStopEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 event_type_id = 2;
  inline bool has_event_type_id() const;
  inline void clear_event_type_id();
  static const int kEventTypeIdFieldNumber = 2;
  inline ::google::protobuf::int32 event_type_id() const;
  inline void set_event_type_id(::google::protobuf::int32 value);

  // required int32 event_start_end = 3;
  inline bool has_event_start_end() const;
  inline void clear_event_start_end();
  static const int kEventStartEndFieldNumber = 3;
  inline ::google::protobuf::int32 event_start_end() const;
  inline void set_event_start_end(::google::protobuf::int32 value);

  // optional int32 event_value = 4;
  inline bool has_event_value() const;
  inline void clear_event_value();
  static const int kEventValueFieldNumber = 4;
  inline ::google::protobuf::int32 event_value() const;
  inline void set_event_value(::google::protobuf::int32 value);

  // optional int32 move_to_x = 5;
  inline bool has_move_to_x() const;
  inline void clear_move_to_x();
  static const int kMoveToXFieldNumber = 5;
  inline ::google::protobuf::int32 move_to_x() const;
  inline void set_move_to_x(::google::protobuf::int32 value);

  // optional int32 target_id = 6;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 6;
  inline ::google::protobuf::int32 target_id() const;
  inline void set_target_id(::google::protobuf::int32 value);

  // optional int32 next_x = 7;
  inline bool has_next_x() const;
  inline void clear_next_x();
  static const int kNextXFieldNumber = 7;
  inline ::google::protobuf::int32 next_x() const;
  inline void set_next_x(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo.StartStopEvent)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_event_type_id();
  inline void clear_has_event_type_id();
  inline void set_has_event_start_end();
  inline void clear_has_event_start_end();
  inline void set_has_event_value();
  inline void clear_has_event_value();
  inline void set_has_move_to_x();
  inline void clear_has_move_to_x();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_next_x();
  inline void clear_has_next_x();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 event_type_id_;
  ::google::protobuf::int32 event_start_end_;
  ::google::protobuf::int32 event_value_;
  ::google::protobuf::int32 move_to_x_;
  ::google::protobuf::int32 target_id_;
  ::google::protobuf::int32 next_x_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo_StartStopEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo_TargetEvent : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo_TargetEvent();
  virtual ~BattleActionInfo_TargetEvent();

  BattleActionInfo_TargetEvent(const BattleActionInfo_TargetEvent& from);

  inline BattleActionInfo_TargetEvent& operator=(const BattleActionInfo_TargetEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo_TargetEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo_TargetEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo_TargetEvent* other);

  // implements Message ----------------------------------------------

  BattleActionInfo_TargetEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo_TargetEvent& from);
  void MergeFrom(const BattleActionInfo_TargetEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 target_char_id = 1;
  inline bool has_target_char_id() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 target_char_id() const;
  inline void set_target_char_id(::google::protobuf::int32 value);

  // required int32 damage = 2;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 2;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo.TargetEvent)
 private:
  inline void set_has_target_char_id();
  inline void clear_has_target_char_id();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::int32 target_char_id_;
  ::google::protobuf::int32 damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo_TargetEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo_AttackEvent : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo_AttackEvent();
  virtual ~BattleActionInfo_AttackEvent();

  BattleActionInfo_AttackEvent(const BattleActionInfo_AttackEvent& from);

  inline BattleActionInfo_AttackEvent& operator=(const BattleActionInfo_AttackEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo_AttackEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo_AttackEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo_AttackEvent* other);

  // implements Message ----------------------------------------------

  BattleActionInfo_AttackEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo_AttackEvent& from);
  void MergeFrom(const BattleActionInfo_AttackEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 skill_id = 2;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::int32 skill_id() const;
  inline void set_skill_id(::google::protobuf::int32 value);

  // repeated int32 target_char_id = 3;
  inline int target_char_id_size() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 3;
  inline ::google::protobuf::int32 target_char_id(int index) const;
  inline void set_target_char_id(int index, ::google::protobuf::int32 value);
  inline void add_target_char_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      target_char_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_target_char_id();

  // optional int32 change_value = 4;
  inline bool has_change_value() const;
  inline void clear_change_value();
  static const int kChangeValueFieldNumber = 4;
  inline ::google::protobuf::int32 change_value() const;
  inline void set_change_value(::google::protobuf::int32 value);

  // optional int32 is_critical = 5;
  inline bool has_is_critical() const;
  inline void clear_is_critical();
  static const int kIsCriticalFieldNumber = 5;
  inline ::google::protobuf::int32 is_critical() const;
  inline void set_is_critical(::google::protobuf::int32 value);

  // optional int32 time_info = 6;
  inline bool has_time_info() const;
  inline void clear_time_info();
  static const int kTimeInfoFieldNumber = 6;
  inline ::google::protobuf::int32 time_info() const;
  inline void set_time_info(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo.AttackEvent)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_change_value();
  inline void clear_has_change_value();
  inline void set_has_is_critical();
  inline void clear_has_is_critical();
  inline void set_has_time_info();
  inline void clear_has_time_info();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 skill_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > target_char_id_;
  ::google::protobuf::int32 change_value_;
  ::google::protobuf::int32 is_critical_;
  ::google::protobuf::int32 time_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo_AttackEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo_AttrChangeEvent : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo_AttrChangeEvent();
  virtual ~BattleActionInfo_AttrChangeEvent();

  BattleActionInfo_AttrChangeEvent(const BattleActionInfo_AttrChangeEvent& from);

  inline BattleActionInfo_AttrChangeEvent& operator=(const BattleActionInfo_AttrChangeEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo_AttrChangeEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo_AttrChangeEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo_AttrChangeEvent* other);

  // implements Message ----------------------------------------------

  BattleActionInfo_AttrChangeEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo_AttrChangeEvent& from);
  void MergeFrom(const BattleActionInfo_AttrChangeEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 change_type = 2;
  inline bool has_change_type() const;
  inline void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  inline ::google::protobuf::int32 change_type() const;
  inline void set_change_type(::google::protobuf::int32 value);

  // required int32 change_value = 3;
  inline bool has_change_value() const;
  inline void clear_change_value();
  static const int kChangeValueFieldNumber = 3;
  inline ::google::protobuf::int32 change_value() const;
  inline void set_change_value(::google::protobuf::int32 value);

  // optional int32 skill_damage = 4;
  inline bool has_skill_damage() const;
  inline void clear_skill_damage();
  static const int kSkillDamageFieldNumber = 4;
  inline ::google::protobuf::int32 skill_damage() const;
  inline void set_skill_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo.AttrChangeEvent)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_change_type();
  inline void clear_has_change_type();
  inline void set_has_change_value();
  inline void clear_has_change_value();
  inline void set_has_skill_damage();
  inline void clear_has_skill_damage();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 change_type_;
  ::google::protobuf::int32 change_value_;
  ::google::protobuf::int32 skill_damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo_AttrChangeEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo_SummonEvent : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo_SummonEvent();
  virtual ~BattleActionInfo_SummonEvent();

  BattleActionInfo_SummonEvent(const BattleActionInfo_SummonEvent& from);

  inline BattleActionInfo_SummonEvent& operator=(const BattleActionInfo_SummonEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo_SummonEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo_SummonEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo_SummonEvent* other);

  // implements Message ----------------------------------------------

  BattleActionInfo_SummonEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo_SummonEvent& from);
  void MergeFrom(const BattleActionInfo_SummonEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 mode_id = 2;
  inline bool has_mode_id() const;
  inline void clear_mode_id();
  static const int kModeIdFieldNumber = 2;
  inline ::google::protobuf::int32 mode_id() const;
  inline void set_mode_id(::google::protobuf::int32 value);

  // required int32 pos_x = 3;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 3;
  inline ::google::protobuf::int32 pos_x() const;
  inline void set_pos_x(::google::protobuf::int32 value);

  // required int32 hp = 4;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 4;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo.SummonEvent)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_mode_id();
  inline void clear_has_mode_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 mode_id_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo_SummonEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo_SufferEvent : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo_SufferEvent();
  virtual ~BattleActionInfo_SufferEvent();

  BattleActionInfo_SufferEvent(const BattleActionInfo_SufferEvent& from);

  inline BattleActionInfo_SufferEvent& operator=(const BattleActionInfo_SufferEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo_SufferEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo_SufferEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo_SufferEvent* other);

  // implements Message ----------------------------------------------

  BattleActionInfo_SufferEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo_SufferEvent& from);
  void MergeFrom(const BattleActionInfo_SufferEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 skill_id = 2;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::int32 skill_id() const;
  inline void set_skill_id(::google::protobuf::int32 value);

  // repeated int32 target_char_id = 3;
  inline int target_char_id_size() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 3;
  inline ::google::protobuf::int32 target_char_id(int index) const;
  inline void set_target_char_id(int index, ::google::protobuf::int32 value);
  inline void add_target_char_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      target_char_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_target_char_id();

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo.SufferEvent)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 skill_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > target_char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo_SufferEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo_CastAreaEvent : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo_CastAreaEvent();
  virtual ~BattleActionInfo_CastAreaEvent();

  BattleActionInfo_CastAreaEvent(const BattleActionInfo_CastAreaEvent& from);

  inline BattleActionInfo_CastAreaEvent& operator=(const BattleActionInfo_CastAreaEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo_CastAreaEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo_CastAreaEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo_CastAreaEvent* other);

  // implements Message ----------------------------------------------

  BattleActionInfo_CastAreaEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo_CastAreaEvent& from);
  void MergeFrom(const BattleActionInfo_CastAreaEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 event_start_end = 1;
  inline bool has_event_start_end() const;
  inline void clear_event_start_end();
  static const int kEventStartEndFieldNumber = 1;
  inline ::google::protobuf::int32 event_start_end() const;
  inline void set_event_start_end(::google::protobuf::int32 value);

  // required int32 pos_x = 2;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 2;
  inline ::google::protobuf::int32 pos_x() const;
  inline void set_pos_x(::google::protobuf::int32 value);

  // required int32 area = 3;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 3;
  inline ::google::protobuf::int32 area() const;
  inline void set_area(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo.CastAreaEvent)
 private:
  inline void set_has_event_start_end();
  inline void clear_has_event_start_end();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_area();
  inline void clear_has_area();

  ::google::protobuf::int32 event_start_end_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 area_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo_CastAreaEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo_ActionInfo : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo_ActionInfo();
  virtual ~BattleActionInfo_ActionInfo();

  BattleActionInfo_ActionInfo(const BattleActionInfo_ActionInfo& from);

  inline BattleActionInfo_ActionInfo& operator=(const BattleActionInfo_ActionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo_ActionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo_ActionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo_ActionInfo* other);

  // implements Message ----------------------------------------------

  BattleActionInfo_ActionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo_ActionInfo& from);
  void MergeFrom(const BattleActionInfo_ActionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .message.BattleActionInfo.StartStopEvent start_stop_event = 1;
  inline bool has_start_stop_event() const;
  inline void clear_start_stop_event();
  static const int kStartStopEventFieldNumber = 1;
  inline const ::message::BattleActionInfo_StartStopEvent& start_stop_event() const;
  inline ::message::BattleActionInfo_StartStopEvent* mutable_start_stop_event();
  inline ::message::BattleActionInfo_StartStopEvent* release_start_stop_event();
  inline void set_allocated_start_stop_event(::message::BattleActionInfo_StartStopEvent* start_stop_event);

  // optional .message.BattleActionInfo.AttackEvent attack_event = 2;
  inline bool has_attack_event() const;
  inline void clear_attack_event();
  static const int kAttackEventFieldNumber = 2;
  inline const ::message::BattleActionInfo_AttackEvent& attack_event() const;
  inline ::message::BattleActionInfo_AttackEvent* mutable_attack_event();
  inline ::message::BattleActionInfo_AttackEvent* release_attack_event();
  inline void set_allocated_attack_event(::message::BattleActionInfo_AttackEvent* attack_event);

  // optional .message.BattleActionInfo.AttrChangeEvent attr_change_event = 3;
  inline bool has_attr_change_event() const;
  inline void clear_attr_change_event();
  static const int kAttrChangeEventFieldNumber = 3;
  inline const ::message::BattleActionInfo_AttrChangeEvent& attr_change_event() const;
  inline ::message::BattleActionInfo_AttrChangeEvent* mutable_attr_change_event();
  inline ::message::BattleActionInfo_AttrChangeEvent* release_attr_change_event();
  inline void set_allocated_attr_change_event(::message::BattleActionInfo_AttrChangeEvent* attr_change_event);

  // optional .message.BattleActionInfo.SummonEvent summon_event = 4;
  inline bool has_summon_event() const;
  inline void clear_summon_event();
  static const int kSummonEventFieldNumber = 4;
  inline const ::message::BattleActionInfo_SummonEvent& summon_event() const;
  inline ::message::BattleActionInfo_SummonEvent* mutable_summon_event();
  inline ::message::BattleActionInfo_SummonEvent* release_summon_event();
  inline void set_allocated_summon_event(::message::BattleActionInfo_SummonEvent* summon_event);

  // optional .message.BattleActionInfo.SufferEvent suffer_event = 5;
  inline bool has_suffer_event() const;
  inline void clear_suffer_event();
  static const int kSufferEventFieldNumber = 5;
  inline const ::message::BattleActionInfo_SufferEvent& suffer_event() const;
  inline ::message::BattleActionInfo_SufferEvent* mutable_suffer_event();
  inline ::message::BattleActionInfo_SufferEvent* release_suffer_event();
  inline void set_allocated_suffer_event(::message::BattleActionInfo_SufferEvent* suffer_event);

  // optional .message.BattleActionInfo.CastAreaEvent cast_area_event = 6;
  inline bool has_cast_area_event() const;
  inline void clear_cast_area_event();
  static const int kCastAreaEventFieldNumber = 6;
  inline const ::message::BattleActionInfo_CastAreaEvent& cast_area_event() const;
  inline ::message::BattleActionInfo_CastAreaEvent* mutable_cast_area_event();
  inline ::message::BattleActionInfo_CastAreaEvent* release_cast_area_event();
  inline void set_allocated_cast_area_event(::message::BattleActionInfo_CastAreaEvent* cast_area_event);

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo.ActionInfo)
 private:
  inline void set_has_start_stop_event();
  inline void clear_has_start_stop_event();
  inline void set_has_attack_event();
  inline void clear_has_attack_event();
  inline void set_has_attr_change_event();
  inline void clear_has_attr_change_event();
  inline void set_has_summon_event();
  inline void clear_has_summon_event();
  inline void set_has_suffer_event();
  inline void clear_has_suffer_event();
  inline void set_has_cast_area_event();
  inline void clear_has_cast_area_event();

  ::message::BattleActionInfo_StartStopEvent* start_stop_event_;
  ::message::BattleActionInfo_AttackEvent* attack_event_;
  ::message::BattleActionInfo_AttrChangeEvent* attr_change_event_;
  ::message::BattleActionInfo_SummonEvent* summon_event_;
  ::message::BattleActionInfo_SufferEvent* suffer_event_;
  ::message::BattleActionInfo_CastAreaEvent* cast_area_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo_ActionInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleActionInfo : public ::google::protobuf::MessageLite {
 public:
  BattleActionInfo();
  virtual ~BattleActionInfo();

  BattleActionInfo(const BattleActionInfo& from);

  inline BattleActionInfo& operator=(const BattleActionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleActionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleActionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleActionInfo* other);

  // implements Message ----------------------------------------------

  BattleActionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleActionInfo& from);
  void MergeFrom(const BattleActionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BattleActionInfo_StartStopEvent StartStopEvent;
  typedef BattleActionInfo_TargetEvent TargetEvent;
  typedef BattleActionInfo_AttackEvent AttackEvent;
  typedef BattleActionInfo_AttrChangeEvent AttrChangeEvent;
  typedef BattleActionInfo_SummonEvent SummonEvent;
  typedef BattleActionInfo_SufferEvent SufferEvent;
  typedef BattleActionInfo_CastAreaEvent CastAreaEvent;
  typedef BattleActionInfo_ActionInfo ActionInfo;

  // accessors -------------------------------------------------------

  // repeated .message.BattleActionInfo.ActionInfo action_info = 1;
  inline int action_info_size() const;
  inline void clear_action_info();
  static const int kActionInfoFieldNumber = 1;
  inline const ::message::BattleActionInfo_ActionInfo& action_info(int index) const;
  inline ::message::BattleActionInfo_ActionInfo* mutable_action_info(int index);
  inline ::message::BattleActionInfo_ActionInfo* add_action_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::BattleActionInfo_ActionInfo >&
      action_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::BattleActionInfo_ActionInfo >*
      mutable_action_info();

  // @@protoc_insertion_point(class_scope:message.BattleActionInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::BattleActionInfo_ActionInfo > action_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleActionInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleProcess_AttackEvent : public ::google::protobuf::MessageLite {
 public:
  BattleProcess_AttackEvent();
  virtual ~BattleProcess_AttackEvent();

  BattleProcess_AttackEvent(const BattleProcess_AttackEvent& from);

  inline BattleProcess_AttackEvent& operator=(const BattleProcess_AttackEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleProcess_AttackEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleProcess_AttackEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleProcess_AttackEvent* other);

  // implements Message ----------------------------------------------

  BattleProcess_AttackEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleProcess_AttackEvent& from);
  void MergeFrom(const BattleProcess_AttackEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 skill_id = 2;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::int32 skill_id() const;
  inline void set_skill_id(::google::protobuf::int32 value);

  // repeated int32 target_char_id = 3;
  inline int target_char_id_size() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 3;
  inline ::google::protobuf::int32 target_char_id(int index) const;
  inline void set_target_char_id(int index, ::google::protobuf::int32 value);
  inline void add_target_char_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      target_char_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_target_char_id();

  // optional int32 change_value = 4;
  inline bool has_change_value() const;
  inline void clear_change_value();
  static const int kChangeValueFieldNumber = 4;
  inline ::google::protobuf::int32 change_value() const;
  inline void set_change_value(::google::protobuf::int32 value);

  // optional int32 is_critical = 5;
  inline bool has_is_critical() const;
  inline void clear_is_critical();
  static const int kIsCriticalFieldNumber = 5;
  inline ::google::protobuf::int32 is_critical() const;
  inline void set_is_critical(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleProcess.AttackEvent)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_change_value();
  inline void clear_has_change_value();
  inline void set_has_is_critical();
  inline void clear_has_is_critical();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 skill_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > target_char_id_;
  ::google::protobuf::int32 change_value_;
  ::google::protobuf::int32 is_critical_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleProcess_AttackEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleProcess_AttrChangeEvent : public ::google::protobuf::MessageLite {
 public:
  BattleProcess_AttrChangeEvent();
  virtual ~BattleProcess_AttrChangeEvent();

  BattleProcess_AttrChangeEvent(const BattleProcess_AttrChangeEvent& from);

  inline BattleProcess_AttrChangeEvent& operator=(const BattleProcess_AttrChangeEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleProcess_AttrChangeEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleProcess_AttrChangeEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleProcess_AttrChangeEvent* other);

  // implements Message ----------------------------------------------

  BattleProcess_AttrChangeEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleProcess_AttrChangeEvent& from);
  void MergeFrom(const BattleProcess_AttrChangeEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 change_type = 2;
  inline bool has_change_type() const;
  inline void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  inline ::google::protobuf::int32 change_type() const;
  inline void set_change_type(::google::protobuf::int32 value);

  // required int32 change_value = 3;
  inline bool has_change_value() const;
  inline void clear_change_value();
  static const int kChangeValueFieldNumber = 3;
  inline ::google::protobuf::int32 change_value() const;
  inline void set_change_value(::google::protobuf::int32 value);

  // optional int32 skill_damage = 4;
  inline bool has_skill_damage() const;
  inline void clear_skill_damage();
  static const int kSkillDamageFieldNumber = 4;
  inline ::google::protobuf::int32 skill_damage() const;
  inline void set_skill_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleProcess.AttrChangeEvent)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_change_type();
  inline void clear_has_change_type();
  inline void set_has_change_value();
  inline void clear_has_change_value();
  inline void set_has_skill_damage();
  inline void clear_has_skill_damage();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 change_type_;
  ::google::protobuf::int32 change_value_;
  ::google::protobuf::int32 skill_damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleProcess_AttrChangeEvent* default_instance_;
};
// -------------------------------------------------------------------

class BattleProcess_ActionInfo : public ::google::protobuf::MessageLite {
 public:
  BattleProcess_ActionInfo();
  virtual ~BattleProcess_ActionInfo();

  BattleProcess_ActionInfo(const BattleProcess_ActionInfo& from);

  inline BattleProcess_ActionInfo& operator=(const BattleProcess_ActionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleProcess_ActionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleProcess_ActionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleProcess_ActionInfo* other);

  // implements Message ----------------------------------------------

  BattleProcess_ActionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleProcess_ActionInfo& from);
  void MergeFrom(const BattleProcess_ActionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .message.BattleProcess.AttackEvent attack_event = 1;
  inline bool has_attack_event() const;
  inline void clear_attack_event();
  static const int kAttackEventFieldNumber = 1;
  inline const ::message::BattleProcess_AttackEvent& attack_event() const;
  inline ::message::BattleProcess_AttackEvent* mutable_attack_event();
  inline ::message::BattleProcess_AttackEvent* release_attack_event();
  inline void set_allocated_attack_event(::message::BattleProcess_AttackEvent* attack_event);

  // optional .message.BattleProcess.AttrChangeEvent attr_change_event = 2;
  inline bool has_attr_change_event() const;
  inline void clear_attr_change_event();
  static const int kAttrChangeEventFieldNumber = 2;
  inline const ::message::BattleProcess_AttrChangeEvent& attr_change_event() const;
  inline ::message::BattleProcess_AttrChangeEvent* mutable_attr_change_event();
  inline ::message::BattleProcess_AttrChangeEvent* release_attr_change_event();
  inline void set_allocated_attr_change_event(::message::BattleProcess_AttrChangeEvent* attr_change_event);

  // @@protoc_insertion_point(class_scope:message.BattleProcess.ActionInfo)
 private:
  inline void set_has_attack_event();
  inline void clear_has_attack_event();
  inline void set_has_attr_change_event();
  inline void clear_has_attr_change_event();

  ::message::BattleProcess_AttackEvent* attack_event_;
  ::message::BattleProcess_AttrChangeEvent* attr_change_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleProcess_ActionInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleProcess : public ::google::protobuf::MessageLite {
 public:
  BattleProcess();
  virtual ~BattleProcess();

  BattleProcess(const BattleProcess& from);

  inline BattleProcess& operator=(const BattleProcess& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleProcess& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleProcess* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleProcess* other);

  // implements Message ----------------------------------------------

  BattleProcess* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleProcess& from);
  void MergeFrom(const BattleProcess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BattleProcess_AttackEvent AttackEvent;
  typedef BattleProcess_AttrChangeEvent AttrChangeEvent;
  typedef BattleProcess_ActionInfo ActionInfo;

  // accessors -------------------------------------------------------

  // repeated .message.BattleProcess.ActionInfo action_info = 1;
  inline int action_info_size() const;
  inline void clear_action_info();
  static const int kActionInfoFieldNumber = 1;
  inline const ::message::BattleProcess_ActionInfo& action_info(int index) const;
  inline ::message::BattleProcess_ActionInfo* mutable_action_info(int index);
  inline ::message::BattleProcess_ActionInfo* add_action_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::BattleProcess_ActionInfo >&
      action_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::BattleProcess_ActionInfo >*
      mutable_action_info();

  // @@protoc_insertion_point(class_scope:message.BattleProcess)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::BattleProcess_ActionInfo > action_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleProcess* default_instance_;
};
// -------------------------------------------------------------------

class BattleManualSkill : public ::google::protobuf::MessageLite {
 public:
  BattleManualSkill();
  virtual ~BattleManualSkill();

  BattleManualSkill(const BattleManualSkill& from);

  inline BattleManualSkill& operator=(const BattleManualSkill& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleManualSkill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleManualSkill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleManualSkill* other);

  // implements Message ----------------------------------------------

  BattleManualSkill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleManualSkill& from);
  void MergeFrom(const BattleManualSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 manual_skill = 2;
  inline bool has_manual_skill() const;
  inline void clear_manual_skill();
  static const int kManualSkillFieldNumber = 2;
  inline ::google::protobuf::int32 manual_skill() const;
  inline void set_manual_skill(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleManualSkill)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_manual_skill();
  inline void clear_has_manual_skill();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 manual_skill_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleManualSkill* default_instance_;
};
// -------------------------------------------------------------------

class BattleOperation : public ::google::protobuf::MessageLite {
 public:
  BattleOperation();
  virtual ~BattleOperation();

  BattleOperation(const BattleOperation& from);

  inline BattleOperation& operator=(const BattleOperation& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleOperation* other);

  // implements Message ----------------------------------------------

  BattleOperation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleOperation& from);
  void MergeFrom(const BattleOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 operation_id = 2;
  inline bool has_operation_id() const;
  inline void clear_operation_id();
  static const int kOperationIdFieldNumber = 2;
  inline ::google::protobuf::int32 operation_id() const;
  inline void set_operation_id(::google::protobuf::int32 value);

  // optional int32 pos_x = 3;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 3;
  inline ::google::protobuf::int32 pos_x() const;
  inline void set_pos_x(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleOperation)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_operation_id();
  inline void clear_has_operation_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 operation_id_;
  ::google::protobuf::int32 pos_x_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleOperation* default_instance_;
};
// -------------------------------------------------------------------

class BattleOperationResult : public ::google::protobuf::MessageLite {
 public:
  BattleOperationResult();
  virtual ~BattleOperationResult();

  BattleOperationResult(const BattleOperationResult& from);

  inline BattleOperationResult& operator=(const BattleOperationResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleOperationResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleOperationResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleOperationResult* other);

  // implements Message ----------------------------------------------

  BattleOperationResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleOperationResult& from);
  void MergeFrom(const BattleOperationResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // required int32 operation_id = 2;
  inline bool has_operation_id() const;
  inline void clear_operation_id();
  static const int kOperationIdFieldNumber = 2;
  inline ::google::protobuf::int32 operation_id() const;
  inline void set_operation_id(::google::protobuf::int32 value);

  // required int32 operation_result = 3;
  inline bool has_operation_result() const;
  inline void clear_operation_result();
  static const int kOperationResultFieldNumber = 3;
  inline ::google::protobuf::int32 operation_result() const;
  inline void set_operation_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleOperationResult)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_operation_id();
  inline void clear_has_operation_id();
  inline void set_has_operation_result();
  inline void clear_has_operation_result();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 operation_id_;
  ::google::protobuf::int32 operation_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleOperationResult* default_instance_;
};
// -------------------------------------------------------------------

class BattleResultInfo : public ::google::protobuf::MessageLite {
 public:
  BattleResultInfo();
  virtual ~BattleResultInfo();

  BattleResultInfo(const BattleResultInfo& from);

  inline BattleResultInfo& operator=(const BattleResultInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleResultInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleResultInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleResultInfo* other);

  // implements Message ----------------------------------------------

  BattleResultInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleResultInfo& from);
  void MergeFrom(const BattleResultInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 battle_result = 1;
  inline bool has_battle_result() const;
  inline void clear_battle_result();
  static const int kBattleResultFieldNumber = 1;
  inline ::google::protobuf::uint32 battle_result() const;
  inline void set_battle_result(::google::protobuf::uint32 value);

  // optional uint32 battle_star = 2;
  inline bool has_battle_star() const;
  inline void clear_battle_star();
  static const int kBattleStarFieldNumber = 2;
  inline ::google::protobuf::uint32 battle_star() const;
  inline void set_battle_star(::google::protobuf::uint32 value);

  // optional uint32 pvp_char_id = 3;
  inline bool has_pvp_char_id() const;
  inline void clear_pvp_char_id();
  static const int kPvpCharIdFieldNumber = 3;
  inline ::google::protobuf::uint32 pvp_char_id() const;
  inline void set_pvp_char_id(::google::protobuf::uint32 value);

  // optional uint32 skill_exp = 4;
  inline bool has_skill_exp() const;
  inline void clear_skill_exp();
  static const int kSkillExpFieldNumber = 4;
  inline ::google::protobuf::uint32 skill_exp() const;
  inline void set_skill_exp(::google::protobuf::uint32 value);

  // optional uint32 map_id = 5;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 5;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 is_pk = 7;
  inline bool has_is_pk() const;
  inline void clear_is_pk();
  static const int kIsPkFieldNumber = 7;
  inline ::google::protobuf::uint32 is_pk() const;
  inline void set_is_pk(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BattleResultInfo)
 private:
  inline void set_has_battle_result();
  inline void clear_has_battle_result();
  inline void set_has_battle_star();
  inline void clear_has_battle_star();
  inline void set_has_pvp_char_id();
  inline void clear_has_pvp_char_id();
  inline void set_has_skill_exp();
  inline void clear_has_skill_exp();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_is_pk();
  inline void clear_has_is_pk();

  ::google::protobuf::uint32 battle_result_;
  ::google::protobuf::uint32 battle_star_;
  ::google::protobuf::uint32 pvp_char_id_;
  ::google::protobuf::uint32 skill_exp_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 is_pk_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleResultInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleRepeat : public ::google::protobuf::MessageLite {
 public:
  BattleRepeat();
  virtual ~BattleRepeat();

  BattleRepeat(const BattleRepeat& from);

  inline BattleRepeat& operator=(const BattleRepeat& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleRepeat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleRepeat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleRepeat* other);

  // implements Message ----------------------------------------------

  BattleRepeat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleRepeat& from);
  void MergeFrom(const BattleRepeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 battle_times = 2;
  inline bool has_battle_times() const;
  inline void clear_battle_times();
  static const int kBattleTimesFieldNumber = 2;
  inline ::google::protobuf::uint32 battle_times() const;
  inline void set_battle_times(::google::protobuf::uint32 value);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 auto_sell_material = 4;
  inline bool has_auto_sell_material() const;
  inline void clear_auto_sell_material();
  static const int kAutoSellMaterialFieldNumber = 4;
  inline ::google::protobuf::uint32 auto_sell_material() const;
  inline void set_auto_sell_material(::google::protobuf::uint32 value);

  // optional uint32 auto_sell_equip = 5;
  inline bool has_auto_sell_equip() const;
  inline void clear_auto_sell_equip();
  static const int kAutoSellEquipFieldNumber = 5;
  inline ::google::protobuf::uint32 auto_sell_equip() const;
  inline void set_auto_sell_equip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BattleRepeat)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_battle_times();
  inline void clear_has_battle_times();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_auto_sell_material();
  inline void clear_has_auto_sell_material();
  inline void set_has_auto_sell_equip();
  inline void clear_has_auto_sell_equip();

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 battle_times_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 auto_sell_material_;
  ::google::protobuf::uint32 auto_sell_equip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleRepeat* default_instance_;
};
// -------------------------------------------------------------------

class BattleQTEInfo : public ::google::protobuf::MessageLite {
 public:
  BattleQTEInfo();
  virtual ~BattleQTEInfo();

  BattleQTEInfo(const BattleQTEInfo& from);

  inline BattleQTEInfo& operator=(const BattleQTEInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleQTEInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleQTEInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleQTEInfo* other);

  // implements Message ----------------------------------------------

  BattleQTEInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleQTEInfo& from);
  void MergeFrom(const BattleQTEInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 QTE_id = 1;
  inline bool has_qte_id() const;
  inline void clear_qte_id();
  static const int kQTEIdFieldNumber = 1;
  inline ::google::protobuf::int32 qte_id() const;
  inline void set_qte_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.BattleQTEInfo)
 private:
  inline void set_has_qte_id();
  inline void clear_has_qte_id();

  ::google::protobuf::int32 qte_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleQTEInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleReward : public ::google::protobuf::MessageLite {
 public:
  BattleReward();
  virtual ~BattleReward();

  BattleReward(const BattleReward& from);

  inline BattleReward& operator=(const BattleReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleReward* other);

  // implements Message ----------------------------------------------

  BattleReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleReward& from);
  void MergeFrom(const BattleReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 battle_map = 1;
  inline bool has_battle_map() const;
  inline void clear_battle_map();
  static const int kBattleMapFieldNumber = 1;
  inline ::google::protobuf::uint32 battle_map() const;
  inline void set_battle_map(::google::protobuf::uint32 value);

  // optional uint32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional uint32 exp_additional = 3;
  inline bool has_exp_additional() const;
  inline void clear_exp_additional();
  static const int kExpAdditionalFieldNumber = 3;
  inline ::google::protobuf::uint32 exp_additional() const;
  inline void set_exp_additional(::google::protobuf::uint32 value);

  // optional uint32 team_exp = 4;
  inline bool has_team_exp() const;
  inline void clear_team_exp();
  static const int kTeamExpFieldNumber = 4;
  inline ::google::protobuf::uint32 team_exp() const;
  inline void set_team_exp(::google::protobuf::uint32 value);

  // optional uint32 team_exp_additional = 5;
  inline bool has_team_exp_additional() const;
  inline void clear_team_exp_additional();
  static const int kTeamExpAdditionalFieldNumber = 5;
  inline ::google::protobuf::uint32 team_exp_additional() const;
  inline void set_team_exp_additional(::google::protobuf::uint32 value);

  // optional uint32 money = 6;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 6;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // optional uint32 money_additional = 7;
  inline bool has_money_additional() const;
  inline void clear_money_additional();
  static const int kMoneyAdditionalFieldNumber = 7;
  inline ::google::protobuf::uint32 money_additional() const;
  inline void set_money_additional(::google::protobuf::uint32 value);

  // repeated uint32 reward_item = 8;
  inline int reward_item_size() const;
  inline void clear_reward_item();
  static const int kRewardItemFieldNumber = 8;
  inline ::google::protobuf::uint32 reward_item(int index) const;
  inline void set_reward_item(int index, ::google::protobuf::uint32 value);
  inline void add_reward_item(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reward_item() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reward_item();

  // repeated uint32 reward_item_num = 9;
  inline int reward_item_num_size() const;
  inline void clear_reward_item_num();
  static const int kRewardItemNumFieldNumber = 9;
  inline ::google::protobuf::uint32 reward_item_num(int index) const;
  inline void set_reward_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_reward_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reward_item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reward_item_num();

  // optional uint32 is_repeat = 10;
  inline bool has_is_repeat() const;
  inline void clear_is_repeat();
  static const int kIsRepeatFieldNumber = 10;
  inline ::google::protobuf::uint32 is_repeat() const;
  inline void set_is_repeat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BattleReward)
 private:
  inline void set_has_battle_map();
  inline void clear_has_battle_map();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_exp_additional();
  inline void clear_has_exp_additional();
  inline void set_has_team_exp();
  inline void clear_has_team_exp();
  inline void set_has_team_exp_additional();
  inline void clear_has_team_exp_additional();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_money_additional();
  inline void clear_has_money_additional();
  inline void set_has_is_repeat();
  inline void clear_has_is_repeat();

  ::google::protobuf::uint32 battle_map_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 exp_additional_;
  ::google::protobuf::uint32 team_exp_;
  ::google::protobuf::uint32 team_exp_additional_;
  ::google::protobuf::uint32 money_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reward_item_;
  ::google::protobuf::uint32 money_additional_;
  ::google::protobuf::uint32 is_repeat_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reward_item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleReward* default_instance_;
};
// -------------------------------------------------------------------

class BattleRepeatReward_RewardInfo : public ::google::protobuf::MessageLite {
 public:
  BattleRepeatReward_RewardInfo();
  virtual ~BattleRepeatReward_RewardInfo();

  BattleRepeatReward_RewardInfo(const BattleRepeatReward_RewardInfo& from);

  inline BattleRepeatReward_RewardInfo& operator=(const BattleRepeatReward_RewardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleRepeatReward_RewardInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleRepeatReward_RewardInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleRepeatReward_RewardInfo* other);

  // implements Message ----------------------------------------------

  BattleRepeatReward_RewardInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleRepeatReward_RewardInfo& from);
  void MergeFrom(const BattleRepeatReward_RewardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 exp = 1;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 1;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional uint32 team_exp = 2;
  inline bool has_team_exp() const;
  inline void clear_team_exp();
  static const int kTeamExpFieldNumber = 2;
  inline ::google::protobuf::uint32 team_exp() const;
  inline void set_team_exp(::google::protobuf::uint32 value);

  // optional uint32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // repeated uint32 item_id = 4;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 4;
  inline ::google::protobuf::uint32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::uint32 value);
  inline void add_item_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_id();

  // repeated uint32 item_num = 5;
  inline int item_num_size() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 5;
  inline ::google::protobuf::uint32 item_num(int index) const;
  inline void set_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_num();

  // @@protoc_insertion_point(class_scope:message.BattleRepeatReward.RewardInfo)
 private:
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_team_exp();
  inline void clear_has_team_exp();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 team_exp_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_num_;
  ::google::protobuf::uint32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleRepeatReward_RewardInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleRepeatReward : public ::google::protobuf::MessageLite {
 public:
  BattleRepeatReward();
  virtual ~BattleRepeatReward();

  BattleRepeatReward(const BattleRepeatReward& from);

  inline BattleRepeatReward& operator=(const BattleRepeatReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleRepeatReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleRepeatReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleRepeatReward* other);

  // implements Message ----------------------------------------------

  BattleRepeatReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleRepeatReward& from);
  void MergeFrom(const BattleRepeatReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BattleRepeatReward_RewardInfo RewardInfo;

  // accessors -------------------------------------------------------

  // required uint32 battle_map = 1;
  inline bool has_battle_map() const;
  inline void clear_battle_map();
  static const int kBattleMapFieldNumber = 1;
  inline ::google::protobuf::uint32 battle_map() const;
  inline void set_battle_map(::google::protobuf::uint32 value);

  // repeated .message.BattleRepeatReward.RewardInfo reward_data = 2;
  inline int reward_data_size() const;
  inline void clear_reward_data();
  static const int kRewardDataFieldNumber = 2;
  inline const ::message::BattleRepeatReward_RewardInfo& reward_data(int index) const;
  inline ::message::BattleRepeatReward_RewardInfo* mutable_reward_data(int index);
  inline ::message::BattleRepeatReward_RewardInfo* add_reward_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::BattleRepeatReward_RewardInfo >&
      reward_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::BattleRepeatReward_RewardInfo >*
      mutable_reward_data();

  // optional uint32 exp_additional = 3;
  inline bool has_exp_additional() const;
  inline void clear_exp_additional();
  static const int kExpAdditionalFieldNumber = 3;
  inline ::google::protobuf::uint32 exp_additional() const;
  inline void set_exp_additional(::google::protobuf::uint32 value);

  // optional uint32 team_exp_additional = 4;
  inline bool has_team_exp_additional() const;
  inline void clear_team_exp_additional();
  static const int kTeamExpAdditionalFieldNumber = 4;
  inline ::google::protobuf::uint32 team_exp_additional() const;
  inline void set_team_exp_additional(::google::protobuf::uint32 value);

  // optional uint32 money_additional = 5;
  inline bool has_money_additional() const;
  inline void clear_money_additional();
  static const int kMoneyAdditionalFieldNumber = 5;
  inline ::google::protobuf::uint32 money_additional() const;
  inline void set_money_additional(::google::protobuf::uint32 value);

  // repeated uint32 item_id_additional = 6;
  inline int item_id_additional_size() const;
  inline void clear_item_id_additional();
  static const int kItemIdAdditionalFieldNumber = 6;
  inline ::google::protobuf::uint32 item_id_additional(int index) const;
  inline void set_item_id_additional(int index, ::google::protobuf::uint32 value);
  inline void add_item_id_additional(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_id_additional() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_id_additional();

  // repeated uint32 item_num_additional = 7;
  inline int item_num_additional_size() const;
  inline void clear_item_num_additional();
  static const int kItemNumAdditionalFieldNumber = 7;
  inline ::google::protobuf::uint32 item_num_additional(int index) const;
  inline void set_item_num_additional(int index, ::google::protobuf::uint32 value);
  inline void add_item_num_additional(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_num_additional() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_num_additional();

  // optional uint32 ticket_num = 8;
  inline bool has_ticket_num() const;
  inline void clear_ticket_num();
  static const int kTicketNumFieldNumber = 8;
  inline ::google::protobuf::uint32 ticket_num() const;
  inline void set_ticket_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BattleRepeatReward)
 private:
  inline void set_has_battle_map();
  inline void clear_has_battle_map();
  inline void set_has_exp_additional();
  inline void clear_has_exp_additional();
  inline void set_has_team_exp_additional();
  inline void clear_has_team_exp_additional();
  inline void set_has_money_additional();
  inline void clear_has_money_additional();
  inline void set_has_ticket_num();
  inline void clear_has_ticket_num();

  ::google::protobuf::RepeatedPtrField< ::message::BattleRepeatReward_RewardInfo > reward_data_;
  ::google::protobuf::uint32 battle_map_;
  ::google::protobuf::uint32 exp_additional_;
  ::google::protobuf::uint32 team_exp_additional_;
  ::google::protobuf::uint32 money_additional_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_id_additional_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_num_additional_;
  ::google::protobuf::uint32 ticket_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleRepeatReward* default_instance_;
};
// -------------------------------------------------------------------

class ExitBattle : public ::google::protobuf::MessageLite {
 public:
  ExitBattle();
  virtual ~ExitBattle();

  ExitBattle(const ExitBattle& from);

  inline ExitBattle& operator=(const ExitBattle& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExitBattle& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExitBattle* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExitBattle* other);

  // implements Message ----------------------------------------------

  ExitBattle* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExitBattle& from);
  void MergeFrom(const ExitBattle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ExitBattle)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::uint32 player_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ExitBattle* default_instance_;
};
// -------------------------------------------------------------------

class NPCTalk : public ::google::protobuf::MessageLite {
 public:
  NPCTalk();
  virtual ~NPCTalk();

  NPCTalk(const NPCTalk& from);

  inline NPCTalk& operator=(const NPCTalk& from) {
    CopyFrom(from);
    return *this;
  }

  static const NPCTalk& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NPCTalk* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NPCTalk* other);

  // implements Message ----------------------------------------------

  NPCTalk* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NPCTalk& from);
  void MergeFrom(const NPCTalk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 npc_id = 1;
  inline bool has_npc_id() const;
  inline void clear_npc_id();
  static const int kNpcIdFieldNumber = 1;
  inline ::google::protobuf::uint32 npc_id() const;
  inline void set_npc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.NPCTalk)
 private:
  inline void set_has_npc_id();
  inline void clear_has_npc_id();

  ::google::protobuf::uint32 npc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static NPCTalk* default_instance_;
};
// -------------------------------------------------------------------

class NPCTalkResult : public ::google::protobuf::MessageLite {
 public:
  NPCTalkResult();
  virtual ~NPCTalkResult();

  NPCTalkResult(const NPCTalkResult& from);

  inline NPCTalkResult& operator=(const NPCTalkResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const NPCTalkResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NPCTalkResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NPCTalkResult* other);

  // implements Message ----------------------------------------------

  NPCTalkResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NPCTalkResult& from);
  void MergeFrom(const NPCTalkResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 func_type = 1;
  inline int func_type_size() const;
  inline void clear_func_type();
  static const int kFuncTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 func_type(int index) const;
  inline void set_func_type(int index, ::google::protobuf::uint32 value);
  inline void add_func_type(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      func_type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_func_type();

  // repeated uint32 func_value = 2;
  inline int func_value_size() const;
  inline void clear_func_value();
  static const int kFuncValueFieldNumber = 2;
  inline ::google::protobuf::uint32 func_value(int index) const;
  inline void set_func_value(int index, ::google::protobuf::uint32 value);
  inline void add_func_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      func_value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_func_value();

  // @@protoc_insertion_point(class_scope:message.NPCTalkResult)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > func_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > func_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static NPCTalkResult* default_instance_;
};
// -------------------------------------------------------------------

class NPCFunction : public ::google::protobuf::MessageLite {
 public:
  NPCFunction();
  virtual ~NPCFunction();

  NPCFunction(const NPCFunction& from);

  inline NPCFunction& operator=(const NPCFunction& from) {
    CopyFrom(from);
    return *this;
  }

  static const NPCFunction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NPCFunction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NPCFunction* other);

  // implements Message ----------------------------------------------

  NPCFunction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NPCFunction& from);
  void MergeFrom(const NPCFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 func_type = 1;
  inline bool has_func_type() const;
  inline void clear_func_type();
  static const int kFuncTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 func_type() const;
  inline void set_func_type(::google::protobuf::uint32 value);

  // required uint32 func_value = 2;
  inline bool has_func_value() const;
  inline void clear_func_value();
  static const int kFuncValueFieldNumber = 2;
  inline ::google::protobuf::uint32 func_value() const;
  inline void set_func_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.NPCFunction)
 private:
  inline void set_has_func_type();
  inline void clear_has_func_type();
  inline void set_has_func_value();
  inline void clear_has_func_value();

  ::google::protobuf::uint32 func_type_;
  ::google::protobuf::uint32 func_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static NPCFunction* default_instance_;
};
// -------------------------------------------------------------------

class AddItem : public ::google::protobuf::MessageLite {
 public:
  AddItem();
  virtual ~AddItem();

  AddItem(const AddItem& from);

  inline AddItem& operator=(const AddItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddItem* other);

  // implements Message ----------------------------------------------

  AddItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddItem& from);
  void MergeFrom(const AddItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 item_only_id = 1;
  inline bool has_item_only_id() const;
  inline void clear_item_only_id();
  static const int kItemOnlyIdFieldNumber = 1;
  inline ::google::protobuf::uint64 item_only_id() const;
  inline void set_item_only_id(::google::protobuf::uint64 value);

  // required uint32 item_type = 2;
  inline bool has_item_type() const;
  inline void clear_item_type();
  static const int kItemTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 item_type() const;
  inline void set_item_type(::google::protobuf::uint32 value);

  // required uint32 item_num = 3;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 3;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // optional uint32 item_upgrade = 4;
  inline bool has_item_upgrade() const;
  inline void clear_item_upgrade();
  static const int kItemUpgradeFieldNumber = 4;
  inline ::google::protobuf::uint32 item_upgrade() const;
  inline void set_item_upgrade(::google::protobuf::uint32 value);

  // repeated uint32 item_hole = 5;
  inline int item_hole_size() const;
  inline void clear_item_hole();
  static const int kItemHoleFieldNumber = 5;
  inline ::google::protobuf::uint32 item_hole(int index) const;
  inline void set_item_hole(int index, ::google::protobuf::uint32 value);
  inline void add_item_hole(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_hole() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_hole();

  // optional uint32 is_battle = 6;
  inline bool has_is_battle() const;
  inline void clear_is_battle();
  static const int kIsBattleFieldNumber = 6;
  inline ::google::protobuf::uint32 is_battle() const;
  inline void set_is_battle(::google::protobuf::uint32 value);

  // optional uint32 is_equip = 7;
  inline bool has_is_equip() const;
  inline void clear_is_equip();
  static const int kIsEquipFieldNumber = 7;
  inline ::google::protobuf::uint32 is_equip() const;
  inline void set_is_equip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AddItem)
 private:
  inline void set_has_item_only_id();
  inline void clear_has_item_only_id();
  inline void set_has_item_type();
  inline void clear_has_item_type();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_item_upgrade();
  inline void clear_has_item_upgrade();
  inline void set_has_is_battle();
  inline void clear_has_is_battle();
  inline void set_has_is_equip();
  inline void clear_has_is_equip();

  ::google::protobuf::uint64 item_only_id_;
  ::google::protobuf::uint32 item_type_;
  ::google::protobuf::uint32 item_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_hole_;
  ::google::protobuf::uint32 item_upgrade_;
  ::google::protobuf::uint32 is_battle_;
  ::google::protobuf::uint32 is_equip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddItem* default_instance_;
};
// -------------------------------------------------------------------

class DeleteItem : public ::google::protobuf::MessageLite {
 public:
  DeleteItem();
  virtual ~DeleteItem();

  DeleteItem(const DeleteItem& from);

  inline DeleteItem& operator=(const DeleteItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const DeleteItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteItem* other);

  // implements Message ----------------------------------------------

  DeleteItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteItem& from);
  void MergeFrom(const DeleteItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 item_only_id = 1;
  inline bool has_item_only_id() const;
  inline void clear_item_only_id();
  static const int kItemOnlyIdFieldNumber = 1;
  inline ::google::protobuf::uint64 item_only_id() const;
  inline void set_item_only_id(::google::protobuf::uint64 value);

  // required uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // optional uint32 is_equip = 3;
  inline bool has_is_equip() const;
  inline void clear_is_equip();
  static const int kIsEquipFieldNumber = 3;
  inline ::google::protobuf::uint32 is_equip() const;
  inline void set_is_equip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.DeleteItem)
 private:
  inline void set_has_item_only_id();
  inline void clear_has_item_only_id();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_is_equip();
  inline void clear_has_is_equip();

  ::google::protobuf::uint64 item_only_id_;
  ::google::protobuf::uint32 item_num_;
  ::google::protobuf::uint32 is_equip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static DeleteItem* default_instance_;
};
// -------------------------------------------------------------------

class UpdateItem : public ::google::protobuf::MessageLite {
 public:
  UpdateItem();
  virtual ~UpdateItem();

  UpdateItem(const UpdateItem& from);

  inline UpdateItem& operator=(const UpdateItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateItem* other);

  // implements Message ----------------------------------------------

  UpdateItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateItem& from);
  void MergeFrom(const UpdateItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 item_only_id = 1;
  inline bool has_item_only_id() const;
  inline void clear_item_only_id();
  static const int kItemOnlyIdFieldNumber = 1;
  inline ::google::protobuf::uint64 item_only_id() const;
  inline void set_item_only_id(::google::protobuf::uint64 value);

  // optional uint32 item_type = 2;
  inline bool has_item_type() const;
  inline void clear_item_type();
  static const int kItemTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 item_type() const;
  inline void set_item_type(::google::protobuf::uint32 value);

  // optional uint32 item_num = 3;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 3;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // optional uint32 item_upgrade = 4;
  inline bool has_item_upgrade() const;
  inline void clear_item_upgrade();
  static const int kItemUpgradeFieldNumber = 4;
  inline ::google::protobuf::uint32 item_upgrade() const;
  inline void set_item_upgrade(::google::protobuf::uint32 value);

  // repeated uint32 item_hole = 5;
  inline int item_hole_size() const;
  inline void clear_item_hole();
  static const int kItemHoleFieldNumber = 5;
  inline ::google::protobuf::uint32 item_hole(int index) const;
  inline void set_item_hole(int index, ::google::protobuf::uint32 value);
  inline void add_item_hole(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_hole() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_hole();

  // optional uint32 is_equip = 6;
  inline bool has_is_equip() const;
  inline void clear_is_equip();
  static const int kIsEquipFieldNumber = 6;
  inline ::google::protobuf::uint32 is_equip() const;
  inline void set_is_equip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UpdateItem)
 private:
  inline void set_has_item_only_id();
  inline void clear_has_item_only_id();
  inline void set_has_item_type();
  inline void clear_has_item_type();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_item_upgrade();
  inline void clear_has_item_upgrade();
  inline void set_has_is_equip();
  inline void clear_has_is_equip();

  ::google::protobuf::uint64 item_only_id_;
  ::google::protobuf::uint32 item_type_;
  ::google::protobuf::uint32 item_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_hole_;
  ::google::protobuf::uint32 item_upgrade_;
  ::google::protobuf::uint32 is_equip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UpdateItem* default_instance_;
};
// -------------------------------------------------------------------

class EquipItem : public ::google::protobuf::MessageLite {
 public:
  EquipItem();
  virtual ~EquipItem();

  EquipItem(const EquipItem& from);

  inline EquipItem& operator=(const EquipItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const EquipItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EquipItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EquipItem* other);

  // implements Message ----------------------------------------------

  EquipItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EquipItem& from);
  void MergeFrom(const EquipItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 item_only_id = 1;
  inline bool has_item_only_id() const;
  inline void clear_item_only_id();
  static const int kItemOnlyIdFieldNumber = 1;
  inline ::google::protobuf::uint64 item_only_id() const;
  inline void set_item_only_id(::google::protobuf::uint64 value);

  // optional uint32 merc_pos = 2;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 2;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // optional bool is_unequip = 3;
  inline bool has_is_unequip() const;
  inline void clear_is_unequip();
  static const int kIsUnequipFieldNumber = 3;
  inline bool is_unequip() const;
  inline void set_is_unequip(bool value);

  // optional bool is_dest = 4;
  inline bool has_is_dest() const;
  inline void clear_is_dest();
  static const int kIsDestFieldNumber = 4;
  inline bool is_dest() const;
  inline void set_is_dest(bool value);

  // optional uint32 pos = 5;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 5;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.EquipItem)
 private:
  inline void set_has_item_only_id();
  inline void clear_has_item_only_id();
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_is_unequip();
  inline void clear_has_is_unequip();
  inline void set_has_is_dest();
  inline void clear_has_is_dest();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::uint64 item_only_id_;
  ::google::protobuf::uint32 merc_pos_;
  bool is_unequip_;
  bool is_dest_;
  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EquipItem* default_instance_;
};
// -------------------------------------------------------------------

class UseItem : public ::google::protobuf::MessageLite {
 public:
  UseItem();
  virtual ~UseItem();

  UseItem(const UseItem& from);

  inline UseItem& operator=(const UseItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const UseItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UseItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UseItem* other);

  // implements Message ----------------------------------------------

  UseItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UseItem& from);
  void MergeFrom(const UseItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 item_only_id = 1;
  inline bool has_item_only_id() const;
  inline void clear_item_only_id();
  static const int kItemOnlyIdFieldNumber = 1;
  inline ::google::protobuf::uint64 item_only_id() const;
  inline void set_item_only_id(::google::protobuf::uint64 value);

  // optional uint32 merc_pos = 2;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 2;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // optional uint32 item_num = 3;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 3;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UseItem)
 private:
  inline void set_has_item_only_id();
  inline void clear_has_item_only_id();
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_item_num();
  inline void clear_has_item_num();

  ::google::protobuf::uint64 item_only_id_;
  ::google::protobuf::uint32 merc_pos_;
  ::google::protobuf::uint32 item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UseItem* default_instance_;
};
// -------------------------------------------------------------------

class OtherEquipItem : public ::google::protobuf::MessageLite {
 public:
  OtherEquipItem();
  virtual ~OtherEquipItem();

  OtherEquipItem(const OtherEquipItem& from);

  inline OtherEquipItem& operator=(const OtherEquipItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const OtherEquipItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OtherEquipItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OtherEquipItem* other);

  // implements Message ----------------------------------------------

  OtherEquipItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OtherEquipItem& from);
  void MergeFrom(const OtherEquipItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 item_type = 2;
  inline bool has_item_type() const;
  inline void clear_item_type();
  static const int kItemTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 item_type() const;
  inline void set_item_type(::google::protobuf::uint32 value);

  // optional bool is_unequip = 3;
  inline bool has_is_unequip() const;
  inline void clear_is_unequip();
  static const int kIsUnequipFieldNumber = 3;
  inline bool is_unequip() const;
  inline void set_is_unequip(bool value);

  // @@protoc_insertion_point(class_scope:message.OtherEquipItem)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_item_type();
  inline void clear_has_item_type();
  inline void set_has_is_unequip();
  inline void clear_has_is_unequip();

  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 item_type_;
  bool is_unequip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OtherEquipItem* default_instance_;
};
// -------------------------------------------------------------------

class ChangeAttr : public ::google::protobuf::MessageLite {
 public:
  ChangeAttr();
  virtual ~ChangeAttr();

  ChangeAttr(const ChangeAttr& from);

  inline ChangeAttr& operator=(const ChangeAttr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeAttr& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeAttr* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeAttr* other);

  // implements Message ----------------------------------------------

  ChangeAttr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeAttr& from);
  void MergeFrom(const ChangeAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 attr_type = 1;
  inline int attr_type_size() const;
  inline void clear_attr_type();
  static const int kAttrTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 attr_type(int index) const;
  inline void set_attr_type(int index, ::google::protobuf::uint32 value);
  inline void add_attr_type(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attr_type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attr_type();

  // repeated uint32 attr_value = 2;
  inline int attr_value_size() const;
  inline void clear_attr_value();
  static const int kAttrValueFieldNumber = 2;
  inline ::google::protobuf::uint32 attr_value(int index) const;
  inline void set_attr_value(int index, ::google::protobuf::uint32 value);
  inline void add_attr_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attr_value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attr_value();

  // optional uint32 attr_value_type = 3;
  inline bool has_attr_value_type() const;
  inline void clear_attr_value_type();
  static const int kAttrValueTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 attr_value_type() const;
  inline void set_attr_value_type(::google::protobuf::uint32 value);

  // optional uint32 merc_pos = 4;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 4;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // optional uint32 is_battle = 5;
  inline bool has_is_battle() const;
  inline void clear_is_battle();
  static const int kIsBattleFieldNumber = 5;
  inline ::google::protobuf::uint32 is_battle() const;
  inline void set_is_battle(::google::protobuf::uint32 value);

  // repeated uint32 cost_channel = 6;
  inline int cost_channel_size() const;
  inline void clear_cost_channel();
  static const int kCostChannelFieldNumber = 6;
  inline ::google::protobuf::uint32 cost_channel(int index) const;
  inline void set_cost_channel(int index, ::google::protobuf::uint32 value);
  inline void add_cost_channel(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cost_channel() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cost_channel();

  // @@protoc_insertion_point(class_scope:message.ChangeAttr)
 private:
  inline void set_has_attr_value_type();
  inline void clear_has_attr_value_type();
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_is_battle();
  inline void clear_has_is_battle();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attr_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attr_value_;
  ::google::protobuf::uint32 attr_value_type_;
  ::google::protobuf::uint32 merc_pos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cost_channel_;
  ::google::protobuf::uint32 is_battle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ChangeAttr* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTask : public ::google::protobuf::MessageLite {
 public:
  ChangeTask();
  virtual ~ChangeTask();

  ChangeTask(const ChangeTask& from);

  inline ChangeTask& operator=(const ChangeTask& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeTask& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeTask* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeTask* other);

  // implements Message ----------------------------------------------

  ChangeTask* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeTask& from);
  void MergeFrom(const ChangeTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 task_var = 1;
  inline int task_var_size() const;
  inline void clear_task_var();
  static const int kTaskVarFieldNumber = 1;
  inline ::google::protobuf::uint32 task_var(int index) const;
  inline void set_task_var(int index, ::google::protobuf::uint32 value);
  inline void add_task_var(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      task_var() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_task_var();

  // repeated uint32 task_value = 2;
  inline int task_value_size() const;
  inline void clear_task_value();
  static const int kTaskValueFieldNumber = 2;
  inline ::google::protobuf::uint32 task_value(int index) const;
  inline void set_task_value(int index, ::google::protobuf::uint32 value);
  inline void add_task_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      task_value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_task_value();

  // @@protoc_insertion_point(class_scope:message.ChangeTask)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > task_var_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > task_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ChangeTask* default_instance_;
};
// -------------------------------------------------------------------

class CheckTime : public ::google::protobuf::MessageLite {
 public:
  CheckTime();
  virtual ~CheckTime();

  CheckTime(const CheckTime& from);

  inline CheckTime& operator=(const CheckTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const CheckTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CheckTime* other);

  // implements Message ----------------------------------------------

  CheckTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckTime& from);
  void MergeFrom(const CheckTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 month = 1;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 1;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);

  // required uint32 day = 2;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 2;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // required uint32 hour = 3;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 3;
  inline ::google::protobuf::uint32 hour() const;
  inline void set_hour(::google::protobuf::uint32 value);

  // required uint32 minute = 4;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 4;
  inline ::google::protobuf::uint32 minute() const;
  inline void set_minute(::google::protobuf::uint32 value);

  // required uint32 second = 5;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 5;
  inline ::google::protobuf::uint32 second() const;
  inline void set_second(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CheckTime)
 private:
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_second();
  inline void clear_has_second();

  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 hour_;
  ::google::protobuf::uint32 minute_;
  ::google::protobuf::uint32 second_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CheckTime* default_instance_;
};
// -------------------------------------------------------------------

class MercenaryGet : public ::google::protobuf::MessageLite {
 public:
  MercenaryGet();
  virtual ~MercenaryGet();

  MercenaryGet(const MercenaryGet& from);

  inline MercenaryGet& operator=(const MercenaryGet& from) {
    CopyFrom(from);
    return *this;
  }

  static const MercenaryGet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MercenaryGet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MercenaryGet* other);

  // implements Message ----------------------------------------------

  MercenaryGet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MercenaryGet& from);
  void MergeFrom(const MercenaryGet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_card = 1;
  inline bool has_merc_card() const;
  inline void clear_merc_card();
  static const int kMercCardFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_card() const;
  inline void set_merc_card(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.MercenaryGet)
 private:
  inline void set_has_merc_card();
  inline void clear_has_merc_card();

  ::google::protobuf::uint32 merc_card_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static MercenaryGet* default_instance_;
};
// -------------------------------------------------------------------

class MercenaryCardGet : public ::google::protobuf::MessageLite {
 public:
  MercenaryCardGet();
  virtual ~MercenaryCardGet();

  MercenaryCardGet(const MercenaryCardGet& from);

  inline MercenaryCardGet& operator=(const MercenaryCardGet& from) {
    CopyFrom(from);
    return *this;
  }

  static const MercenaryCardGet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MercenaryCardGet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MercenaryCardGet* other);

  // implements Message ----------------------------------------------

  MercenaryCardGet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MercenaryCardGet& from);
  void MergeFrom(const MercenaryCardGet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_card = 1;
  inline bool has_merc_card() const;
  inline void clear_merc_card();
  static const int kMercCardFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_card() const;
  inline void set_merc_card(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.MercenaryCardGet)
 private:
  inline void set_has_merc_card();
  inline void clear_has_merc_card();

  ::google::protobuf::uint32 merc_card_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static MercenaryCardGet* default_instance_;
};
// -------------------------------------------------------------------

class MercenaryCardGetResult : public ::google::protobuf::MessageLite {
 public:
  MercenaryCardGetResult();
  virtual ~MercenaryCardGetResult();

  MercenaryCardGetResult(const MercenaryCardGetResult& from);

  inline MercenaryCardGetResult& operator=(const MercenaryCardGetResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const MercenaryCardGetResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MercenaryCardGetResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MercenaryCardGetResult* other);

  // implements Message ----------------------------------------------

  MercenaryCardGetResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MercenaryCardGetResult& from);
  void MergeFrom(const MercenaryCardGetResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 oper_result = 1;
  inline bool has_oper_result() const;
  inline void clear_oper_result();
  static const int kOperResultFieldNumber = 1;
  inline ::google::protobuf::uint32 oper_result() const;
  inline void set_oper_result(::google::protobuf::uint32 value);

  // required uint32 merc_card = 2;
  inline bool has_merc_card() const;
  inline void clear_merc_card();
  static const int kMercCardFieldNumber = 2;
  inline ::google::protobuf::uint32 merc_card() const;
  inline void set_merc_card(::google::protobuf::uint32 value);

  // required uint32 merc_id = 3;
  inline bool has_merc_id() const;
  inline void clear_merc_id();
  static const int kMercIdFieldNumber = 3;
  inline ::google::protobuf::uint32 merc_id() const;
  inline void set_merc_id(::google::protobuf::uint32 value);

  // required uint32 merc_chip_now = 4;
  inline bool has_merc_chip_now() const;
  inline void clear_merc_chip_now();
  static const int kMercChipNowFieldNumber = 4;
  inline ::google::protobuf::uint32 merc_chip_now() const;
  inline void set_merc_chip_now(::google::protobuf::uint32 value);

  // required uint32 merc_chip_max = 5;
  inline bool has_merc_chip_max() const;
  inline void clear_merc_chip_max();
  static const int kMercChipMaxFieldNumber = 5;
  inline ::google::protobuf::uint32 merc_chip_max() const;
  inline void set_merc_chip_max(::google::protobuf::uint32 value);

  // required uint32 free_merc = 6;
  inline bool has_free_merc() const;
  inline void clear_free_merc();
  static const int kFreeMercFieldNumber = 6;
  inline ::google::protobuf::uint32 free_merc() const;
  inline void set_free_merc(::google::protobuf::uint32 value);

  // required uint32 free_chip = 7;
  inline bool has_free_chip() const;
  inline void clear_free_chip();
  static const int kFreeChipFieldNumber = 7;
  inline ::google::protobuf::uint32 free_chip() const;
  inline void set_free_chip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.MercenaryCardGetResult)
 private:
  inline void set_has_oper_result();
  inline void clear_has_oper_result();
  inline void set_has_merc_card();
  inline void clear_has_merc_card();
  inline void set_has_merc_id();
  inline void clear_has_merc_id();
  inline void set_has_merc_chip_now();
  inline void clear_has_merc_chip_now();
  inline void set_has_merc_chip_max();
  inline void clear_has_merc_chip_max();
  inline void set_has_free_merc();
  inline void clear_has_free_merc();
  inline void set_has_free_chip();
  inline void clear_has_free_chip();

  ::google::protobuf::uint32 oper_result_;
  ::google::protobuf::uint32 merc_card_;
  ::google::protobuf::uint32 merc_id_;
  ::google::protobuf::uint32 merc_chip_now_;
  ::google::protobuf::uint32 merc_chip_max_;
  ::google::protobuf::uint32 free_merc_;
  ::google::protobuf::uint32 free_chip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static MercenaryCardGetResult* default_instance_;
};
// -------------------------------------------------------------------

class MercenaryAttrAdd : public ::google::protobuf::MessageLite {
 public:
  MercenaryAttrAdd();
  virtual ~MercenaryAttrAdd();

  MercenaryAttrAdd(const MercenaryAttrAdd& from);

  inline MercenaryAttrAdd& operator=(const MercenaryAttrAdd& from) {
    CopyFrom(from);
    return *this;
  }

  static const MercenaryAttrAdd& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MercenaryAttrAdd* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MercenaryAttrAdd* other);

  // implements Message ----------------------------------------------

  MercenaryAttrAdd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MercenaryAttrAdd& from);
  void MergeFrom(const MercenaryAttrAdd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // required uint32 attr_type = 2;
  inline bool has_attr_type() const;
  inline void clear_attr_type();
  static const int kAttrTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 attr_type() const;
  inline void set_attr_type(::google::protobuf::uint32 value);

  // required uint32 attr_value = 3;
  inline bool has_attr_value() const;
  inline void clear_attr_value();
  static const int kAttrValueFieldNumber = 3;
  inline ::google::protobuf::uint32 attr_value() const;
  inline void set_attr_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.MercenaryAttrAdd)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_attr_type();
  inline void clear_has_attr_type();
  inline void set_has_attr_value();
  inline void clear_has_attr_value();

  ::google::protobuf::uint32 merc_pos_;
  ::google::protobuf::uint32 attr_type_;
  ::google::protobuf::uint32 attr_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static MercenaryAttrAdd* default_instance_;
};
// -------------------------------------------------------------------

class MercenaryToExp : public ::google::protobuf::MessageLite {
 public:
  MercenaryToExp();
  virtual ~MercenaryToExp();

  MercenaryToExp(const MercenaryToExp& from);

  inline MercenaryToExp& operator=(const MercenaryToExp& from) {
    CopyFrom(from);
    return *this;
  }

  static const MercenaryToExp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MercenaryToExp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MercenaryToExp* other);

  // implements Message ----------------------------------------------

  MercenaryToExp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MercenaryToExp& from);
  void MergeFrom(const MercenaryToExp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_from_pos = 1;
  inline bool has_merc_from_pos() const;
  inline void clear_merc_from_pos();
  static const int kMercFromPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_from_pos() const;
  inline void set_merc_from_pos(::google::protobuf::uint32 value);

  // required uint32 merc_to_pos = 2;
  inline bool has_merc_to_pos() const;
  inline void clear_merc_to_pos();
  static const int kMercToPosFieldNumber = 2;
  inline ::google::protobuf::uint32 merc_to_pos() const;
  inline void set_merc_to_pos(::google::protobuf::uint32 value);

  // optional uint32 is_cost_money = 3;
  inline bool has_is_cost_money() const;
  inline void clear_is_cost_money();
  static const int kIsCostMoneyFieldNumber = 3;
  inline ::google::protobuf::uint32 is_cost_money() const;
  inline void set_is_cost_money(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.MercenaryToExp)
 private:
  inline void set_has_merc_from_pos();
  inline void clear_has_merc_from_pos();
  inline void set_has_merc_to_pos();
  inline void clear_has_merc_to_pos();
  inline void set_has_is_cost_money();
  inline void clear_has_is_cost_money();

  ::google::protobuf::uint32 merc_from_pos_;
  ::google::protobuf::uint32 merc_to_pos_;
  ::google::protobuf::uint32 is_cost_money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static MercenaryToExp* default_instance_;
};
// -------------------------------------------------------------------

class AddMercenary : public ::google::protobuf::MessageLite {
 public:
  AddMercenary();
  virtual ~AddMercenary();

  AddMercenary(const AddMercenary& from);

  inline AddMercenary& operator=(const AddMercenary& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddMercenary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddMercenary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddMercenary* other);

  // implements Message ----------------------------------------------

  AddMercenary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddMercenary& from);
  void MergeFrom(const AddMercenary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // repeated bytes merc_data = 2;
  inline int merc_data_size() const;
  inline void clear_merc_data();
  static const int kMercDataFieldNumber = 2;
  inline const ::std::string& merc_data(int index) const;
  inline ::std::string* mutable_merc_data(int index);
  inline void set_merc_data(int index, const ::std::string& value);
  inline void set_merc_data(int index, const char* value);
  inline void set_merc_data(int index, const void* value, size_t size);
  inline ::std::string* add_merc_data();
  inline void add_merc_data(const ::std::string& value);
  inline void add_merc_data(const char* value);
  inline void add_merc_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& merc_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_merc_data();

  // @@protoc_insertion_point(class_scope:message.AddMercenary)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();

  ::google::protobuf::RepeatedPtrField< ::std::string> merc_data_;
  ::google::protobuf::uint32 merc_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddMercenary* default_instance_;
};
// -------------------------------------------------------------------

class UpdateMercenary : public ::google::protobuf::MessageLite {
 public:
  UpdateMercenary();
  virtual ~UpdateMercenary();

  UpdateMercenary(const UpdateMercenary& from);

  inline UpdateMercenary& operator=(const UpdateMercenary& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateMercenary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateMercenary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateMercenary* other);

  // implements Message ----------------------------------------------

  UpdateMercenary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateMercenary& from);
  void MergeFrom(const UpdateMercenary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // repeated bytes merc_data = 2;
  inline int merc_data_size() const;
  inline void clear_merc_data();
  static const int kMercDataFieldNumber = 2;
  inline const ::std::string& merc_data(int index) const;
  inline ::std::string* mutable_merc_data(int index);
  inline void set_merc_data(int index, const ::std::string& value);
  inline void set_merc_data(int index, const char* value);
  inline void set_merc_data(int index, const void* value, size_t size);
  inline ::std::string* add_merc_data();
  inline void add_merc_data(const ::std::string& value);
  inline void add_merc_data(const char* value);
  inline void add_merc_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& merc_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_merc_data();

  // @@protoc_insertion_point(class_scope:message.UpdateMercenary)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();

  ::google::protobuf::RepeatedPtrField< ::std::string> merc_data_;
  ::google::protobuf::uint32 merc_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UpdateMercenary* default_instance_;
};
// -------------------------------------------------------------------

class MercenaryDel : public ::google::protobuf::MessageLite {
 public:
  MercenaryDel();
  virtual ~MercenaryDel();

  MercenaryDel(const MercenaryDel& from);

  inline MercenaryDel& operator=(const MercenaryDel& from) {
    CopyFrom(from);
    return *this;
  }

  static const MercenaryDel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MercenaryDel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MercenaryDel* other);

  // implements Message ----------------------------------------------

  MercenaryDel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MercenaryDel& from);
  void MergeFrom(const MercenaryDel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.MercenaryDel)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();

  ::google::protobuf::uint32 merc_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static MercenaryDel* default_instance_;
};
// -------------------------------------------------------------------

class AddCharBuff : public ::google::protobuf::MessageLite {
 public:
  AddCharBuff();
  virtual ~AddCharBuff();

  AddCharBuff(const AddCharBuff& from);

  inline AddCharBuff& operator=(const AddCharBuff& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddCharBuff& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddCharBuff* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddCharBuff* other);

  // implements Message ----------------------------------------------

  AddCharBuff* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddCharBuff& from);
  void MergeFrom(const AddCharBuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 buff_id = 1;
  inline bool has_buff_id() const;
  inline void clear_buff_id();
  static const int kBuffIdFieldNumber = 1;
  inline ::google::protobuf::uint32 buff_id() const;
  inline void set_buff_id(::google::protobuf::uint32 value);

  // optional uint32 buff_value = 2;
  inline bool has_buff_value() const;
  inline void clear_buff_value();
  static const int kBuffValueFieldNumber = 2;
  inline ::google::protobuf::uint32 buff_value() const;
  inline void set_buff_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AddCharBuff)
 private:
  inline void set_has_buff_id();
  inline void clear_has_buff_id();
  inline void set_has_buff_value();
  inline void clear_has_buff_value();

  ::google::protobuf::uint32 buff_id_;
  ::google::protobuf::uint32 buff_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddCharBuff* default_instance_;
};
// -------------------------------------------------------------------

class DelCharBuff : public ::google::protobuf::MessageLite {
 public:
  DelCharBuff();
  virtual ~DelCharBuff();

  DelCharBuff(const DelCharBuff& from);

  inline DelCharBuff& operator=(const DelCharBuff& from) {
    CopyFrom(from);
    return *this;
  }

  static const DelCharBuff& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DelCharBuff* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DelCharBuff* other);

  // implements Message ----------------------------------------------

  DelCharBuff* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DelCharBuff& from);
  void MergeFrom(const DelCharBuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 buff_id = 1;
  inline bool has_buff_id() const;
  inline void clear_buff_id();
  static const int kBuffIdFieldNumber = 1;
  inline ::google::protobuf::uint32 buff_id() const;
  inline void set_buff_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.DelCharBuff)
 private:
  inline void set_has_buff_id();
  inline void clear_has_buff_id();

  ::google::protobuf::uint32 buff_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static DelCharBuff* default_instance_;
};
// -------------------------------------------------------------------

class Chat : public ::google::protobuf::MessageLite {
 public:
  Chat();
  virtual ~Chat();

  Chat(const Chat& from);

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }

  static const Chat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Chat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Chat* other);

  // implements Message ----------------------------------------------

  Chat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Chat& from);
  void MergeFrom(const Chat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 chat_type = 1;
  inline bool has_chat_type() const;
  inline void clear_chat_type();
  static const int kChatTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 chat_type() const;
  inline void set_chat_type(::google::protobuf::uint32 value);

  // repeated bytes chat_data = 2;
  inline int chat_data_size() const;
  inline void clear_chat_data();
  static const int kChatDataFieldNumber = 2;
  inline const ::std::string& chat_data(int index) const;
  inline ::std::string* mutable_chat_data(int index);
  inline void set_chat_data(int index, const ::std::string& value);
  inline void set_chat_data(int index, const char* value);
  inline void set_chat_data(int index, const void* value, size_t size);
  inline ::std::string* add_chat_data();
  inline void add_chat_data(const ::std::string& value);
  inline void add_chat_data(const char* value);
  inline void add_chat_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& chat_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_chat_data();

  // repeated bytes from_name = 3;
  inline int from_name_size() const;
  inline void clear_from_name();
  static const int kFromNameFieldNumber = 3;
  inline const ::std::string& from_name(int index) const;
  inline ::std::string* mutable_from_name(int index);
  inline void set_from_name(int index, const ::std::string& value);
  inline void set_from_name(int index, const char* value);
  inline void set_from_name(int index, const void* value, size_t size);
  inline ::std::string* add_from_name();
  inline void add_from_name(const ::std::string& value);
  inline void add_from_name(const char* value);
  inline void add_from_name(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& from_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_from_name();

  // repeated bytes to_name = 4;
  inline int to_name_size() const;
  inline void clear_to_name();
  static const int kToNameFieldNumber = 4;
  inline const ::std::string& to_name(int index) const;
  inline ::std::string* mutable_to_name(int index);
  inline void set_to_name(int index, const ::std::string& value);
  inline void set_to_name(int index, const char* value);
  inline void set_to_name(int index, const void* value, size_t size);
  inline ::std::string* add_to_name();
  inline void add_to_name(const ::std::string& value);
  inline void add_to_name(const char* value);
  inline void add_to_name(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& to_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_to_name();

  // repeated bytes item_info = 5;
  inline int item_info_size() const;
  inline void clear_item_info();
  static const int kItemInfoFieldNumber = 5;
  inline const ::std::string& item_info(int index) const;
  inline ::std::string* mutable_item_info(int index);
  inline void set_item_info(int index, const ::std::string& value);
  inline void set_item_info(int index, const char* value);
  inline void set_item_info(int index, const void* value, size_t size);
  inline ::std::string* add_item_info();
  inline void add_item_info(const ::std::string& value);
  inline void add_item_info(const char* value);
  inline void add_item_info(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item_info();

  // repeated bytes equip_info = 6;
  inline int equip_info_size() const;
  inline void clear_equip_info();
  static const int kEquipInfoFieldNumber = 6;
  inline const ::std::string& equip_info(int index) const;
  inline ::std::string* mutable_equip_info(int index);
  inline void set_equip_info(int index, const ::std::string& value);
  inline void set_equip_info(int index, const char* value);
  inline void set_equip_info(int index, const void* value, size_t size);
  inline ::std::string* add_equip_info();
  inline void add_equip_info(const ::std::string& value);
  inline void add_equip_info(const char* value);
  inline void add_equip_info(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& equip_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_equip_info();

  // repeated bytes role_info = 7;
  inline int role_info_size() const;
  inline void clear_role_info();
  static const int kRoleInfoFieldNumber = 7;
  inline const ::std::string& role_info(int index) const;
  inline ::std::string* mutable_role_info(int index);
  inline void set_role_info(int index, const ::std::string& value);
  inline void set_role_info(int index, const char* value);
  inline void set_role_info(int index, const void* value, size_t size);
  inline ::std::string* add_role_info();
  inline void add_role_info(const ::std::string& value);
  inline void add_role_info(const char* value);
  inline void add_role_info(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& role_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_role_info();

  // repeated bytes merc_info = 8;
  inline int merc_info_size() const;
  inline void clear_merc_info();
  static const int kMercInfoFieldNumber = 8;
  inline const ::std::string& merc_info(int index) const;
  inline ::std::string* mutable_merc_info(int index);
  inline void set_merc_info(int index, const ::std::string& value);
  inline void set_merc_info(int index, const char* value);
  inline void set_merc_info(int index, const void* value, size_t size);
  inline ::std::string* add_merc_info();
  inline void add_merc_info(const ::std::string& value);
  inline void add_merc_info(const char* value);
  inline void add_merc_info(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& merc_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_merc_info();

  // optional uint32 sex = 9;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 9;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 vip_lv = 10;
  inline bool has_vip_lv() const;
  inline void clear_vip_lv();
  static const int kVipLvFieldNumber = 10;
  inline ::google::protobuf::uint32 vip_lv() const;
  inline void set_vip_lv(::google::protobuf::uint32 value);

  // optional uint32 notice_type = 11;
  inline bool has_notice_type() const;
  inline void clear_notice_type();
  static const int kNoticeTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 notice_type() const;
  inline void set_notice_type(::google::protobuf::uint32 value);

  // optional uint32 server_id = 12;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 12;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.Chat)
 private:
  inline void set_has_chat_type();
  inline void clear_has_chat_type();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_vip_lv();
  inline void clear_has_vip_lv();
  inline void set_has_notice_type();
  inline void clear_has_notice_type();
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::RepeatedPtrField< ::std::string> chat_data_;
  ::google::protobuf::RepeatedPtrField< ::std::string> from_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> to_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_info_;
  ::google::protobuf::uint32 chat_type_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::RepeatedPtrField< ::std::string> equip_info_;
  ::google::protobuf::RepeatedPtrField< ::std::string> role_info_;
  ::google::protobuf::RepeatedPtrField< ::std::string> merc_info_;
  ::google::protobuf::uint32 vip_lv_;
  ::google::protobuf::uint32 notice_type_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static Chat* default_instance_;
};
// -------------------------------------------------------------------

class ChangeRemainVar : public ::google::protobuf::MessageLite {
 public:
  ChangeRemainVar();
  virtual ~ChangeRemainVar();

  ChangeRemainVar(const ChangeRemainVar& from);

  inline ChangeRemainVar& operator=(const ChangeRemainVar& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeRemainVar& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeRemainVar* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeRemainVar* other);

  // implements Message ----------------------------------------------

  ChangeRemainVar* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeRemainVar& from);
  void MergeFrom(const ChangeRemainVar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 remain_type = 1;
  inline bool has_remain_type() const;
  inline void clear_remain_type();
  static const int kRemainTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 remain_type() const;
  inline void set_remain_type(::google::protobuf::uint32 value);

  // required uint32 remain_value = 2;
  inline bool has_remain_value() const;
  inline void clear_remain_value();
  static const int kRemainValueFieldNumber = 2;
  inline ::google::protobuf::uint32 remain_value() const;
  inline void set_remain_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ChangeRemainVar)
 private:
  inline void set_has_remain_type();
  inline void clear_has_remain_type();
  inline void set_has_remain_value();
  inline void clear_has_remain_value();

  ::google::protobuf::uint32 remain_type_;
  ::google::protobuf::uint32 remain_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ChangeRemainVar* default_instance_;
};
// -------------------------------------------------------------------

class ChangeClientData : public ::google::protobuf::MessageLite {
 public:
  ChangeClientData();
  virtual ~ChangeClientData();

  ChangeClientData(const ChangeClientData& from);

  inline ChangeClientData& operator=(const ChangeClientData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeClientData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeClientData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeClientData* other);

  // implements Message ----------------------------------------------

  ChangeClientData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeClientData& from);
  void MergeFrom(const ChangeClientData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes clie_data = 1;
  inline int clie_data_size() const;
  inline void clear_clie_data();
  static const int kClieDataFieldNumber = 1;
  inline const ::std::string& clie_data(int index) const;
  inline ::std::string* mutable_clie_data(int index);
  inline void set_clie_data(int index, const ::std::string& value);
  inline void set_clie_data(int index, const char* value);
  inline void set_clie_data(int index, const void* value, size_t size);
  inline ::std::string* add_clie_data();
  inline void add_clie_data(const ::std::string& value);
  inline void add_clie_data(const char* value);
  inline void add_clie_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& clie_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_clie_data();

  // @@protoc_insertion_point(class_scope:message.ChangeClientData)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> clie_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ChangeClientData* default_instance_;
};
// -------------------------------------------------------------------

class ReqFriendData : public ::google::protobuf::MessageLite {
 public:
  ReqFriendData();
  virtual ~ReqFriendData();

  ReqFriendData(const ReqFriendData& from);

  inline ReqFriendData& operator=(const ReqFriendData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqFriendData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqFriendData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqFriendData* other);

  // implements Message ----------------------------------------------

  ReqFriendData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqFriendData& from);
  void MergeFrom(const ReqFriendData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqFriendData)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqFriendData* default_instance_;
};
// -------------------------------------------------------------------

class AckFriendData_DBFriendInfo : public ::google::protobuf::MessageLite {
 public:
  AckFriendData_DBFriendInfo();
  virtual ~AckFriendData_DBFriendInfo();

  AckFriendData_DBFriendInfo(const AckFriendData_DBFriendInfo& from);

  inline AckFriendData_DBFriendInfo& operator=(const AckFriendData_DBFriendInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckFriendData_DBFriendInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckFriendData_DBFriendInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckFriendData_DBFriendInfo* other);

  // implements Message ----------------------------------------------

  AckFriendData_DBFriendInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckFriendData_DBFriendInfo& from);
  void MergeFrom(const AckFriendData_DBFriendInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // required uint32 target_char_id = 2;
  inline bool has_target_char_id() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 target_char_id() const;
  inline void set_target_char_id(::google::protobuf::uint32 value);

  // required bytes target_char_name = 3;
  inline bool has_target_char_name() const;
  inline void clear_target_char_name();
  static const int kTargetCharNameFieldNumber = 3;
  inline const ::std::string& target_char_name() const;
  inline void set_target_char_name(const ::std::string& value);
  inline void set_target_char_name(const char* value);
  inline void set_target_char_name(const void* value, size_t size);
  inline ::std::string* mutable_target_char_name();
  inline ::std::string* release_target_char_name();
  inline void set_allocated_target_char_name(::std::string* target_char_name);

  // required uint32 friend_type = 4;
  inline bool has_friend_type() const;
  inline void clear_friend_type();
  static const int kFriendTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 friend_type() const;
  inline void set_friend_type(::google::protobuf::uint32 value);

  // required uint32 love = 5;
  inline bool has_love() const;
  inline void clear_love();
  static const int kLoveFieldNumber = 5;
  inline ::google::protobuf::uint32 love() const;
  inline void set_love(::google::protobuf::uint32 value);

  // required bytes last_love_date = 6;
  inline bool has_last_love_date() const;
  inline void clear_last_love_date();
  static const int kLastLoveDateFieldNumber = 6;
  inline const ::std::string& last_love_date() const;
  inline void set_last_love_date(const ::std::string& value);
  inline void set_last_love_date(const char* value);
  inline void set_last_love_date(const void* value, size_t size);
  inline ::std::string* mutable_last_love_date();
  inline ::std::string* release_last_love_date();
  inline void set_allocated_last_love_date(::std::string* last_love_date);

  // optional bytes fight_data = 7;
  inline bool has_fight_data() const;
  inline void clear_fight_data();
  static const int kFightDataFieldNumber = 7;
  inline const ::std::string& fight_data() const;
  inline void set_fight_data(const ::std::string& value);
  inline void set_fight_data(const char* value);
  inline void set_fight_data(const void* value, size_t size);
  inline ::std::string* mutable_fight_data();
  inline ::std::string* release_fight_data();
  inline void set_allocated_fight_data(::std::string* fight_data);

  // optional bytes mercenary_data = 8;
  inline bool has_mercenary_data() const;
  inline void clear_mercenary_data();
  static const int kMercenaryDataFieldNumber = 8;
  inline const ::std::string& mercenary_data() const;
  inline void set_mercenary_data(const ::std::string& value);
  inline void set_mercenary_data(const char* value);
  inline void set_mercenary_data(const void* value, size_t size);
  inline ::std::string* mutable_mercenary_data();
  inline ::std::string* release_mercenary_data();
  inline void set_allocated_mercenary_data(::std::string* mercenary_data);

  // optional bytes other_data = 9;
  inline bool has_other_data() const;
  inline void clear_other_data();
  static const int kOtherDataFieldNumber = 9;
  inline const ::std::string& other_data() const;
  inline void set_other_data(const ::std::string& value);
  inline void set_other_data(const char* value);
  inline void set_other_data(const void* value, size_t size);
  inline ::std::string* mutable_other_data();
  inline ::std::string* release_other_data();
  inline void set_allocated_other_data(::std::string* other_data);

  // optional uint32 job = 10;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 10;
  inline ::google::protobuf::uint32 job() const;
  inline void set_job(::google::protobuf::uint32 value);

  // optional uint32 sex = 11;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 11;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 level = 12;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 12;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckFriendData.DBFriendInfo)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_target_char_id();
  inline void clear_has_target_char_id();
  inline void set_has_target_char_name();
  inline void clear_has_target_char_name();
  inline void set_has_friend_type();
  inline void clear_has_friend_type();
  inline void set_has_love();
  inline void clear_has_love();
  inline void set_has_last_love_date();
  inline void clear_has_last_love_date();
  inline void set_has_fight_data();
  inline void clear_has_fight_data();
  inline void set_has_mercenary_data();
  inline void clear_has_mercenary_data();
  inline void set_has_other_data();
  inline void clear_has_other_data();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 target_char_id_;
  ::std::string* target_char_name_;
  ::google::protobuf::uint32 friend_type_;
  ::google::protobuf::uint32 love_;
  ::std::string* last_love_date_;
  ::std::string* fight_data_;
  ::std::string* mercenary_data_;
  ::std::string* other_data_;
  ::google::protobuf::uint32 job_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckFriendData_DBFriendInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckFriendData : public ::google::protobuf::MessageLite {
 public:
  AckFriendData();
  virtual ~AckFriendData();

  AckFriendData(const AckFriendData& from);

  inline AckFriendData& operator=(const AckFriendData& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckFriendData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckFriendData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckFriendData* other);

  // implements Message ----------------------------------------------

  AckFriendData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckFriendData& from);
  void MergeFrom(const AckFriendData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AckFriendData_DBFriendInfo DBFriendInfo;

  // accessors -------------------------------------------------------

  // repeated .message.AckFriendData.DBFriendInfo friend_info = 1;
  inline int friend_info_size() const;
  inline void clear_friend_info();
  static const int kFriendInfoFieldNumber = 1;
  inline const ::message::AckFriendData_DBFriendInfo& friend_info(int index) const;
  inline ::message::AckFriendData_DBFriendInfo* mutable_friend_info(int index);
  inline ::message::AckFriendData_DBFriendInfo* add_friend_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::AckFriendData_DBFriendInfo >&
      friend_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::AckFriendData_DBFriendInfo >*
      mutable_friend_info();

  // @@protoc_insertion_point(class_scope:message.AckFriendData)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::AckFriendData_DBFriendInfo > friend_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckFriendData* default_instance_;
};
// -------------------------------------------------------------------

class FriendData_FriendInfo : public ::google::protobuf::MessageLite {
 public:
  FriendData_FriendInfo();
  virtual ~FriendData_FriendInfo();

  FriendData_FriendInfo(const FriendData_FriendInfo& from);

  inline FriendData_FriendInfo& operator=(const FriendData_FriendInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendData_FriendInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendData_FriendInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendData_FriendInfo* other);

  // implements Message ----------------------------------------------

  FriendData_FriendInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendData_FriendInfo& from);
  void MergeFrom(const FriendData_FriendInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 friend_id = 1;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 1;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // optional bytes friend_name = 2;
  inline bool has_friend_name() const;
  inline void clear_friend_name();
  static const int kFriendNameFieldNumber = 2;
  inline const ::std::string& friend_name() const;
  inline void set_friend_name(const ::std::string& value);
  inline void set_friend_name(const char* value);
  inline void set_friend_name(const void* value, size_t size);
  inline ::std::string* mutable_friend_name();
  inline ::std::string* release_friend_name();
  inline void set_allocated_friend_name(::std::string* friend_name);

  // optional uint32 friend_type = 3;
  inline bool has_friend_type() const;
  inline void clear_friend_type();
  static const int kFriendTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 friend_type() const;
  inline void set_friend_type(::google::protobuf::uint32 value);

  // optional uint32 friend_lv = 4;
  inline bool has_friend_lv() const;
  inline void clear_friend_lv();
  static const int kFriendLvFieldNumber = 4;
  inline ::google::protobuf::uint32 friend_lv() const;
  inline void set_friend_lv(::google::protobuf::uint32 value);

  // optional uint32 friend_job = 5;
  inline bool has_friend_job() const;
  inline void clear_friend_job();
  static const int kFriendJobFieldNumber = 5;
  inline ::google::protobuf::uint32 friend_job() const;
  inline void set_friend_job(::google::protobuf::uint32 value);

  // optional uint32 friend_sex = 6;
  inline bool has_friend_sex() const;
  inline void clear_friend_sex();
  static const int kFriendSexFieldNumber = 6;
  inline ::google::protobuf::uint32 friend_sex() const;
  inline void set_friend_sex(::google::protobuf::uint32 value);

  // optional uint32 friend_love = 7;
  inline bool has_friend_love() const;
  inline void clear_friend_love();
  static const int kFriendLoveFieldNumber = 7;
  inline ::google::protobuf::uint32 friend_love() const;
  inline void set_friend_love(::google::protobuf::uint32 value);

  // optional uint32 friend_online = 8;
  inline bool has_friend_online() const;
  inline void clear_friend_online();
  static const int kFriendOnlineFieldNumber = 8;
  inline ::google::protobuf::uint32 friend_online() const;
  inline void set_friend_online(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.FriendData.FriendInfo)
 private:
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_friend_name();
  inline void clear_has_friend_name();
  inline void set_has_friend_type();
  inline void clear_has_friend_type();
  inline void set_has_friend_lv();
  inline void clear_has_friend_lv();
  inline void set_has_friend_job();
  inline void clear_has_friend_job();
  inline void set_has_friend_sex();
  inline void clear_has_friend_sex();
  inline void set_has_friend_love();
  inline void clear_has_friend_love();
  inline void set_has_friend_online();
  inline void clear_has_friend_online();

  ::std::string* friend_name_;
  ::google::protobuf::uint32 friend_id_;
  ::google::protobuf::uint32 friend_type_;
  ::google::protobuf::uint32 friend_lv_;
  ::google::protobuf::uint32 friend_job_;
  ::google::protobuf::uint32 friend_sex_;
  ::google::protobuf::uint32 friend_love_;
  ::google::protobuf::uint32 friend_online_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static FriendData_FriendInfo* default_instance_;
};
// -------------------------------------------------------------------

class FriendData : public ::google::protobuf::MessageLite {
 public:
  FriendData();
  virtual ~FriendData();

  FriendData(const FriendData& from);

  inline FriendData& operator=(const FriendData& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendData* other);

  // implements Message ----------------------------------------------

  FriendData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendData& from);
  void MergeFrom(const FriendData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FriendData_FriendInfo FriendInfo;

  // accessors -------------------------------------------------------

  // repeated .message.FriendData.FriendInfo friend_info = 1;
  inline int friend_info_size() const;
  inline void clear_friend_info();
  static const int kFriendInfoFieldNumber = 1;
  inline const ::message::FriendData_FriendInfo& friend_info(int index) const;
  inline ::message::FriendData_FriendInfo* mutable_friend_info(int index);
  inline ::message::FriendData_FriendInfo* add_friend_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::FriendData_FriendInfo >&
      friend_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::FriendData_FriendInfo >*
      mutable_friend_info();

  // optional uint32 friend_operation = 2;
  inline bool has_friend_operation() const;
  inline void clear_friend_operation();
  static const int kFriendOperationFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_operation() const;
  inline void set_friend_operation(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.FriendData)
 private:
  inline void set_has_friend_operation();
  inline void clear_has_friend_operation();

  ::google::protobuf::RepeatedPtrField< ::message::FriendData_FriendInfo > friend_info_;
  ::google::protobuf::uint32 friend_operation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static FriendData* default_instance_;
};
// -------------------------------------------------------------------

class SocietyOperationData_SocietyOperationInfo : public ::google::protobuf::MessageLite {
 public:
  SocietyOperationData_SocietyOperationInfo();
  virtual ~SocietyOperationData_SocietyOperationInfo();

  SocietyOperationData_SocietyOperationInfo(const SocietyOperationData_SocietyOperationInfo& from);

  inline SocietyOperationData_SocietyOperationInfo& operator=(const SocietyOperationData_SocietyOperationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SocietyOperationData_SocietyOperationInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocietyOperationData_SocietyOperationInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocietyOperationData_SocietyOperationInfo* other);

  // implements Message ----------------------------------------------

  SocietyOperationData_SocietyOperationInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocietyOperationData_SocietyOperationInfo& from);
  void MergeFrom(const SocietyOperationData_SocietyOperationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const void* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional uint32 source_id = 2;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 source_id() const;
  inline void set_source_id(::google::protobuf::uint32 value);

  // optional bytes source_name = 3;
  inline bool has_source_name() const;
  inline void clear_source_name();
  static const int kSourceNameFieldNumber = 3;
  inline const ::std::string& source_name() const;
  inline void set_source_name(const ::std::string& value);
  inline void set_source_name(const char* value);
  inline void set_source_name(const void* value, size_t size);
  inline ::std::string* mutable_source_name();
  inline ::std::string* release_source_name();
  inline void set_allocated_source_name(::std::string* source_name);

  // optional uint32 target_id = 4;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 4;
  inline ::google::protobuf::uint32 target_id() const;
  inline void set_target_id(::google::protobuf::uint32 value);

  // optional bytes target_name = 5;
  inline bool has_target_name() const;
  inline void clear_target_name();
  static const int kTargetNameFieldNumber = 5;
  inline const ::std::string& target_name() const;
  inline void set_target_name(const ::std::string& value);
  inline void set_target_name(const char* value);
  inline void set_target_name(const void* value, size_t size);
  inline ::std::string* mutable_target_name();
  inline ::std::string* release_target_name();
  inline void set_allocated_target_name(::std::string* target_name);

  // optional uint32 operation_type = 6;
  inline bool has_operation_type() const;
  inline void clear_operation_type();
  static const int kOperationTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 operation_type() const;
  inline void set_operation_type(::google::protobuf::uint32 value);

  // optional uint32 operation_result = 7;
  inline bool has_operation_result() const;
  inline void clear_operation_result();
  static const int kOperationResultFieldNumber = 7;
  inline ::google::protobuf::uint32 operation_result() const;
  inline void set_operation_result(::google::protobuf::uint32 value);

  // repeated uint32 operation_value = 8;
  inline int operation_value_size() const;
  inline void clear_operation_value();
  static const int kOperationValueFieldNumber = 8;
  inline ::google::protobuf::uint32 operation_value(int index) const;
  inline void set_operation_value(int index, ::google::protobuf::uint32 value);
  inline void add_operation_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      operation_value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_operation_value();

  // optional uint32 job = 9;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 9;
  inline ::google::protobuf::uint32 job() const;
  inline void set_job(::google::protobuf::uint32 value);

  // optional uint32 sex = 10;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 10;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 level = 11;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 11;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SocietyOperationData.SocietyOperationInfo)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_source_id();
  inline void clear_has_source_id();
  inline void set_has_source_name();
  inline void clear_has_source_name();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_target_name();
  inline void clear_has_target_name();
  inline void set_has_operation_type();
  inline void clear_has_operation_type();
  inline void set_has_operation_result();
  inline void clear_has_operation_result();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_level();
  inline void clear_has_level();

  ::std::string* time_;
  ::std::string* source_name_;
  ::google::protobuf::uint32 source_id_;
  ::google::protobuf::uint32 target_id_;
  ::std::string* target_name_;
  ::google::protobuf::uint32 operation_type_;
  ::google::protobuf::uint32 operation_result_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > operation_value_;
  ::google::protobuf::uint32 job_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SocietyOperationData_SocietyOperationInfo* default_instance_;
};
// -------------------------------------------------------------------

class SocietyOperationData : public ::google::protobuf::MessageLite {
 public:
  SocietyOperationData();
  virtual ~SocietyOperationData();

  SocietyOperationData(const SocietyOperationData& from);

  inline SocietyOperationData& operator=(const SocietyOperationData& from) {
    CopyFrom(from);
    return *this;
  }

  static const SocietyOperationData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocietyOperationData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocietyOperationData* other);

  // implements Message ----------------------------------------------

  SocietyOperationData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocietyOperationData& from);
  void MergeFrom(const SocietyOperationData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SocietyOperationData_SocietyOperationInfo SocietyOperationInfo;

  // accessors -------------------------------------------------------

  // repeated .message.SocietyOperationData.SocietyOperationInfo society_info = 1;
  inline int society_info_size() const;
  inline void clear_society_info();
  static const int kSocietyInfoFieldNumber = 1;
  inline const ::message::SocietyOperationData_SocietyOperationInfo& society_info(int index) const;
  inline ::message::SocietyOperationData_SocietyOperationInfo* mutable_society_info(int index);
  inline ::message::SocietyOperationData_SocietyOperationInfo* add_society_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::SocietyOperationData_SocietyOperationInfo >&
      society_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::SocietyOperationData_SocietyOperationInfo >*
      mutable_society_info();

  // @@protoc_insertion_point(class_scope:message.SocietyOperationData)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::SocietyOperationData_SocietyOperationInfo > society_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SocietyOperationData* default_instance_;
};
// -------------------------------------------------------------------

class GetPvPData : public ::google::protobuf::MessageLite {
 public:
  GetPvPData();
  virtual ~GetPvPData();

  GetPvPData(const GetPvPData& from);

  inline GetPvPData& operator=(const GetPvPData& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetPvPData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetPvPData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetPvPData* other);

  // implements Message ----------------------------------------------

  GetPvPData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetPvPData& from);
  void MergeFrom(const GetPvPData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pvp_type = 1;
  inline bool has_pvp_type() const;
  inline void clear_pvp_type();
  static const int kPvpTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 pvp_type() const;
  inline void set_pvp_type(::google::protobuf::uint32 value);

  // optional uint32 is_ladder = 2;
  inline bool has_is_ladder() const;
  inline void clear_is_ladder();
  static const int kIsLadderFieldNumber = 2;
  inline ::google::protobuf::uint32 is_ladder() const;
  inline void set_is_ladder(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetPvPData)
 private:
  inline void set_has_pvp_type();
  inline void clear_has_pvp_type();
  inline void set_has_is_ladder();
  inline void clear_has_is_ladder();

  ::google::protobuf::uint32 pvp_type_;
  ::google::protobuf::uint32 is_ladder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetPvPData* default_instance_;
};
// -------------------------------------------------------------------

class PvpOpeResult : public ::google::protobuf::MessageLite {
 public:
  PvpOpeResult();
  virtual ~PvpOpeResult();

  PvpOpeResult(const PvpOpeResult& from);

  inline PvpOpeResult& operator=(const PvpOpeResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const PvpOpeResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PvpOpeResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PvpOpeResult* other);

  // implements Message ----------------------------------------------

  PvpOpeResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PvpOpeResult& from);
  void MergeFrom(const PvpOpeResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ope_type = 1;
  inline bool has_ope_type() const;
  inline void clear_ope_type();
  static const int kOpeTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 ope_type() const;
  inline void set_ope_type(::google::protobuf::uint32 value);

  // optional uint32 ope_result = 2;
  inline bool has_ope_result() const;
  inline void clear_ope_result();
  static const int kOpeResultFieldNumber = 2;
  inline ::google::protobuf::uint32 ope_result() const;
  inline void set_ope_result(::google::protobuf::uint32 value);

  // optional uint32 remain_time = 3;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 remain_time() const;
  inline void set_remain_time(::google::protobuf::uint32 value);

  // optional uint32 left_times = 4;
  inline bool has_left_times() const;
  inline void clear_left_times();
  static const int kLeftTimesFieldNumber = 4;
  inline ::google::protobuf::uint32 left_times() const;
  inline void set_left_times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PvpOpeResult)
 private:
  inline void set_has_ope_type();
  inline void clear_has_ope_type();
  inline void set_has_ope_result();
  inline void clear_has_ope_result();
  inline void set_has_remain_time();
  inline void clear_has_remain_time();
  inline void set_has_left_times();
  inline void clear_has_left_times();

  ::google::protobuf::uint32 ope_type_;
  ::google::protobuf::uint32 ope_result_;
  ::google::protobuf::uint32 remain_time_;
  ::google::protobuf::uint32 left_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PvpOpeResult* default_instance_;
};
// -------------------------------------------------------------------

class ReqPVPData : public ::google::protobuf::MessageLite {
 public:
  ReqPVPData();
  virtual ~ReqPVPData();

  ReqPVPData(const ReqPVPData& from);

  inline ReqPVPData& operator=(const ReqPVPData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqPVPData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqPVPData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqPVPData* other);

  // implements Message ----------------------------------------------

  ReqPVPData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqPVPData& from);
  void MergeFrom(const ReqPVPData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 target_id = 1;
  inline int target_id_size() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 1;
  inline ::google::protobuf::uint32 target_id(int index) const;
  inline void set_target_id(int index, ::google::protobuf::uint32 value);
  inline void add_target_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      target_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_target_id();

  // @@protoc_insertion_point(class_scope:message.ReqPVPData)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > target_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqPVPData* default_instance_;
};
// -------------------------------------------------------------------

class AckPVPData_DBPVPInfo : public ::google::protobuf::MessageLite {
 public:
  AckPVPData_DBPVPInfo();
  virtual ~AckPVPData_DBPVPInfo();

  AckPVPData_DBPVPInfo(const AckPVPData_DBPVPInfo& from);

  inline AckPVPData_DBPVPInfo& operator=(const AckPVPData_DBPVPInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckPVPData_DBPVPInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckPVPData_DBPVPInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckPVPData_DBPVPInfo* other);

  // implements Message ----------------------------------------------

  AckPVPData_DBPVPInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckPVPData_DBPVPInfo& from);
  void MergeFrom(const AckPVPData_DBPVPInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 target_char_id = 1;
  inline bool has_target_char_id() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 target_char_id() const;
  inline void set_target_char_id(::google::protobuf::uint32 value);

  // optional uint32 target_job = 2;
  inline bool has_target_job() const;
  inline void clear_target_job();
  static const int kTargetJobFieldNumber = 2;
  inline ::google::protobuf::uint32 target_job() const;
  inline void set_target_job(::google::protobuf::uint32 value);

  // optional uint32 target_sex = 3;
  inline bool has_target_sex() const;
  inline void clear_target_sex();
  static const int kTargetSexFieldNumber = 3;
  inline ::google::protobuf::uint32 target_sex() const;
  inline void set_target_sex(::google::protobuf::uint32 value);

  // optional bytes target_char_name = 4;
  inline bool has_target_char_name() const;
  inline void clear_target_char_name();
  static const int kTargetCharNameFieldNumber = 4;
  inline const ::std::string& target_char_name() const;
  inline void set_target_char_name(const ::std::string& value);
  inline void set_target_char_name(const char* value);
  inline void set_target_char_name(const void* value, size_t size);
  inline ::std::string* mutable_target_char_name();
  inline ::std::string* release_target_char_name();
  inline void set_allocated_target_char_name(::std::string* target_char_name);

  // optional uint32 target_lv = 5;
  inline bool has_target_lv() const;
  inline void clear_target_lv();
  static const int kTargetLvFieldNumber = 5;
  inline ::google::protobuf::uint32 target_lv() const;
  inline void set_target_lv(::google::protobuf::uint32 value);

  // optional uint32 success_num = 6;
  inline bool has_success_num() const;
  inline void clear_success_num();
  static const int kSuccessNumFieldNumber = 6;
  inline ::google::protobuf::uint32 success_num() const;
  inline void set_success_num(::google::protobuf::uint32 value);

  // optional uint32 target_rank = 7;
  inline bool has_target_rank() const;
  inline void clear_target_rank();
  static const int kTargetRankFieldNumber = 7;
  inline ::google::protobuf::uint32 target_rank() const;
  inline void set_target_rank(::google::protobuf::uint32 value);

  // optional uint32 fight_score = 8;
  inline bool has_fight_score() const;
  inline void clear_fight_score();
  static const int kFightScoreFieldNumber = 8;
  inline ::google::protobuf::uint32 fight_score() const;
  inline void set_fight_score(::google::protobuf::uint32 value);

  // optional bytes merc_bag = 9;
  inline bool has_merc_bag() const;
  inline void clear_merc_bag();
  static const int kMercBagFieldNumber = 9;
  inline const ::std::string& merc_bag() const;
  inline void set_merc_bag(const ::std::string& value);
  inline void set_merc_bag(const char* value);
  inline void set_merc_bag(const void* value, size_t size);
  inline ::std::string* mutable_merc_bag();
  inline ::std::string* release_merc_bag();
  inline void set_allocated_merc_bag(::std::string* merc_bag);

  // optional bytes equip_pos = 10;
  inline bool has_equip_pos() const;
  inline void clear_equip_pos();
  static const int kEquipPosFieldNumber = 10;
  inline const ::std::string& equip_pos() const;
  inline void set_equip_pos(const ::std::string& value);
  inline void set_equip_pos(const char* value);
  inline void set_equip_pos(const void* value, size_t size);
  inline ::std::string* mutable_equip_pos();
  inline ::std::string* release_equip_pos();
  inline void set_allocated_equip_pos(::std::string* equip_pos);

  // @@protoc_insertion_point(class_scope:message.AckPVPData.DBPVPInfo)
 private:
  inline void set_has_target_char_id();
  inline void clear_has_target_char_id();
  inline void set_has_target_job();
  inline void clear_has_target_job();
  inline void set_has_target_sex();
  inline void clear_has_target_sex();
  inline void set_has_target_char_name();
  inline void clear_has_target_char_name();
  inline void set_has_target_lv();
  inline void clear_has_target_lv();
  inline void set_has_success_num();
  inline void clear_has_success_num();
  inline void set_has_target_rank();
  inline void clear_has_target_rank();
  inline void set_has_fight_score();
  inline void clear_has_fight_score();
  inline void set_has_merc_bag();
  inline void clear_has_merc_bag();
  inline void set_has_equip_pos();
  inline void clear_has_equip_pos();

  ::google::protobuf::uint32 target_char_id_;
  ::google::protobuf::uint32 target_job_;
  ::std::string* target_char_name_;
  ::google::protobuf::uint32 target_sex_;
  ::google::protobuf::uint32 target_lv_;
  ::google::protobuf::uint32 success_num_;
  ::google::protobuf::uint32 target_rank_;
  ::std::string* merc_bag_;
  ::std::string* equip_pos_;
  ::google::protobuf::uint32 fight_score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckPVPData_DBPVPInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckPVPData : public ::google::protobuf::MessageLite {
 public:
  AckPVPData();
  virtual ~AckPVPData();

  AckPVPData(const AckPVPData& from);

  inline AckPVPData& operator=(const AckPVPData& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckPVPData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckPVPData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckPVPData* other);

  // implements Message ----------------------------------------------

  AckPVPData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckPVPData& from);
  void MergeFrom(const AckPVPData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AckPVPData_DBPVPInfo DBPVPInfo;

  // accessors -------------------------------------------------------

  // repeated .message.AckPVPData.DBPVPInfo pvp_info = 1;
  inline int pvp_info_size() const;
  inline void clear_pvp_info();
  static const int kPvpInfoFieldNumber = 1;
  inline const ::message::AckPVPData_DBPVPInfo& pvp_info(int index) const;
  inline ::message::AckPVPData_DBPVPInfo* mutable_pvp_info(int index);
  inline ::message::AckPVPData_DBPVPInfo* add_pvp_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::AckPVPData_DBPVPInfo >&
      pvp_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::AckPVPData_DBPVPInfo >*
      mutable_pvp_info();

  // optional uint32 my_ladder = 2;
  inline bool has_my_ladder() const;
  inline void clear_my_ladder();
  static const int kMyLadderFieldNumber = 2;
  inline ::google::protobuf::uint32 my_ladder() const;
  inline void set_my_ladder(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckPVPData)
 private:
  inline void set_has_my_ladder();
  inline void clear_has_my_ladder();

  ::google::protobuf::RepeatedPtrField< ::message::AckPVPData_DBPVPInfo > pvp_info_;
  ::google::protobuf::uint32 my_ladder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckPVPData* default_instance_;
};
// -------------------------------------------------------------------

class PVPData_MercInfo : public ::google::protobuf::MessageLite {
 public:
  PVPData_MercInfo();
  virtual ~PVPData_MercInfo();

  PVPData_MercInfo(const PVPData_MercInfo& from);

  inline PVPData_MercInfo& operator=(const PVPData_MercInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PVPData_MercInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PVPData_MercInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PVPData_MercInfo* other);

  // implements Message ----------------------------------------------

  PVPData_MercInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PVPData_MercInfo& from);
  void MergeFrom(const PVPData_MercInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_id = 1;
  inline bool has_merc_id() const;
  inline void clear_merc_id();
  static const int kMercIdFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_id() const;
  inline void set_merc_id(::google::protobuf::uint32 value);

  // required uint32 merc_lv = 2;
  inline bool has_merc_lv() const;
  inline void clear_merc_lv();
  static const int kMercLvFieldNumber = 2;
  inline ::google::protobuf::uint32 merc_lv() const;
  inline void set_merc_lv(::google::protobuf::uint32 value);

  // required uint32 merc_color = 3;
  inline bool has_merc_color() const;
  inline void clear_merc_color();
  static const int kMercColorFieldNumber = 3;
  inline ::google::protobuf::uint32 merc_color() const;
  inline void set_merc_color(::google::protobuf::uint32 value);

  // required uint32 merc_star = 4;
  inline bool has_merc_star() const;
  inline void clear_merc_star();
  static const int kMercStarFieldNumber = 4;
  inline ::google::protobuf::uint32 merc_star() const;
  inline void set_merc_star(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PVPData.MercInfo)
 private:
  inline void set_has_merc_id();
  inline void clear_has_merc_id();
  inline void set_has_merc_lv();
  inline void clear_has_merc_lv();
  inline void set_has_merc_color();
  inline void clear_has_merc_color();
  inline void set_has_merc_star();
  inline void clear_has_merc_star();

  ::google::protobuf::uint32 merc_id_;
  ::google::protobuf::uint32 merc_lv_;
  ::google::protobuf::uint32 merc_color_;
  ::google::protobuf::uint32 merc_star_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PVPData_MercInfo* default_instance_;
};
// -------------------------------------------------------------------

class PVPData_PVPInfo : public ::google::protobuf::MessageLite {
 public:
  PVPData_PVPInfo();
  virtual ~PVPData_PVPInfo();

  PVPData_PVPInfo(const PVPData_PVPInfo& from);

  inline PVPData_PVPInfo& operator=(const PVPData_PVPInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PVPData_PVPInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PVPData_PVPInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PVPData_PVPInfo* other);

  // implements Message ----------------------------------------------

  PVPData_PVPInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PVPData_PVPInfo& from);
  void MergeFrom(const PVPData_PVPInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 target_char_id = 1;
  inline bool has_target_char_id() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 target_char_id() const;
  inline void set_target_char_id(::google::protobuf::uint32 value);

  // optional uint32 target_job = 2;
  inline bool has_target_job() const;
  inline void clear_target_job();
  static const int kTargetJobFieldNumber = 2;
  inline ::google::protobuf::uint32 target_job() const;
  inline void set_target_job(::google::protobuf::uint32 value);

  // optional uint32 target_sex = 3;
  inline bool has_target_sex() const;
  inline void clear_target_sex();
  static const int kTargetSexFieldNumber = 3;
  inline ::google::protobuf::uint32 target_sex() const;
  inline void set_target_sex(::google::protobuf::uint32 value);

  // optional uint32 target_level = 4;
  inline bool has_target_level() const;
  inline void clear_target_level();
  static const int kTargetLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 target_level() const;
  inline void set_target_level(::google::protobuf::uint32 value);

  // optional bytes target_name = 5;
  inline bool has_target_name() const;
  inline void clear_target_name();
  static const int kTargetNameFieldNumber = 5;
  inline const ::std::string& target_name() const;
  inline void set_target_name(const ::std::string& value);
  inline void set_target_name(const char* value);
  inline void set_target_name(const void* value, size_t size);
  inline ::std::string* mutable_target_name();
  inline ::std::string* release_target_name();
  inline void set_allocated_target_name(::std::string* target_name);

  // optional uint32 target_pvp_rank = 6;
  inline bool has_target_pvp_rank() const;
  inline void clear_target_pvp_rank();
  static const int kTargetPvpRankFieldNumber = 6;
  inline ::google::protobuf::uint32 target_pvp_rank() const;
  inline void set_target_pvp_rank(::google::protobuf::uint32 value);

  // optional uint32 target_fight_score = 7;
  inline bool has_target_fight_score() const;
  inline void clear_target_fight_score();
  static const int kTargetFightScoreFieldNumber = 7;
  inline ::google::protobuf::uint32 target_fight_score() const;
  inline void set_target_fight_score(::google::protobuf::uint32 value);

  // optional uint32 target_success_times = 8;
  inline bool has_target_success_times() const;
  inline void clear_target_success_times();
  static const int kTargetSuccessTimesFieldNumber = 8;
  inline ::google::protobuf::uint32 target_success_times() const;
  inline void set_target_success_times(::google::protobuf::uint32 value);

  // repeated .message.PVPData.MercInfo target_merc_data = 9;
  inline int target_merc_data_size() const;
  inline void clear_target_merc_data();
  static const int kTargetMercDataFieldNumber = 9;
  inline const ::message::PVPData_MercInfo& target_merc_data(int index) const;
  inline ::message::PVPData_MercInfo* mutable_target_merc_data(int index);
  inline ::message::PVPData_MercInfo* add_target_merc_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::PVPData_MercInfo >&
      target_merc_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::PVPData_MercInfo >*
      mutable_target_merc_data();

  // @@protoc_insertion_point(class_scope:message.PVPData.PVPInfo)
 private:
  inline void set_has_target_char_id();
  inline void clear_has_target_char_id();
  inline void set_has_target_job();
  inline void clear_has_target_job();
  inline void set_has_target_sex();
  inline void clear_has_target_sex();
  inline void set_has_target_level();
  inline void clear_has_target_level();
  inline void set_has_target_name();
  inline void clear_has_target_name();
  inline void set_has_target_pvp_rank();
  inline void clear_has_target_pvp_rank();
  inline void set_has_target_fight_score();
  inline void clear_has_target_fight_score();
  inline void set_has_target_success_times();
  inline void clear_has_target_success_times();

  ::google::protobuf::uint32 target_char_id_;
  ::google::protobuf::uint32 target_job_;
  ::google::protobuf::uint32 target_sex_;
  ::google::protobuf::uint32 target_level_;
  ::std::string* target_name_;
  ::google::protobuf::uint32 target_pvp_rank_;
  ::google::protobuf::uint32 target_fight_score_;
  ::google::protobuf::RepeatedPtrField< ::message::PVPData_MercInfo > target_merc_data_;
  ::google::protobuf::uint32 target_success_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PVPData_PVPInfo* default_instance_;
};
// -------------------------------------------------------------------

class PVPData : public ::google::protobuf::MessageLite {
 public:
  PVPData();
  virtual ~PVPData();

  PVPData(const PVPData& from);

  inline PVPData& operator=(const PVPData& from) {
    CopyFrom(from);
    return *this;
  }

  static const PVPData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PVPData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PVPData* other);

  // implements Message ----------------------------------------------

  PVPData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PVPData& from);
  void MergeFrom(const PVPData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PVPData_MercInfo MercInfo;
  typedef PVPData_PVPInfo PVPInfo;

  // accessors -------------------------------------------------------

  // repeated .message.PVPData.PVPInfo pvp_info = 1;
  inline int pvp_info_size() const;
  inline void clear_pvp_info();
  static const int kPvpInfoFieldNumber = 1;
  inline const ::message::PVPData_PVPInfo& pvp_info(int index) const;
  inline ::message::PVPData_PVPInfo* mutable_pvp_info(int index);
  inline ::message::PVPData_PVPInfo* add_pvp_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::PVPData_PVPInfo >&
      pvp_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::PVPData_PVPInfo >*
      mutable_pvp_info();

  // optional uint32 remain_time = 2;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 remain_time() const;
  inline void set_remain_time(::google::protobuf::uint32 value);

  // optional uint32 left_pvp_times = 3;
  inline bool has_left_pvp_times() const;
  inline void clear_left_pvp_times();
  static const int kLeftPvpTimesFieldNumber = 3;
  inline ::google::protobuf::uint32 left_pvp_times() const;
  inline void set_left_pvp_times(::google::protobuf::uint32 value);

  // optional uint32 my_rank = 4;
  inline bool has_my_rank() const;
  inline void clear_my_rank();
  static const int kMyRankFieldNumber = 4;
  inline ::google::protobuf::uint32 my_rank() const;
  inline void set_my_rank(::google::protobuf::uint32 value);

  // optional uint32 error_code = 5;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 5;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PVPData)
 private:
  inline void set_has_remain_time();
  inline void clear_has_remain_time();
  inline void set_has_left_pvp_times();
  inline void clear_has_left_pvp_times();
  inline void set_has_my_rank();
  inline void clear_has_my_rank();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::RepeatedPtrField< ::message::PVPData_PVPInfo > pvp_info_;
  ::google::protobuf::uint32 remain_time_;
  ::google::protobuf::uint32 left_pvp_times_;
  ::google::protobuf::uint32 my_rank_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PVPData* default_instance_;
};
// -------------------------------------------------------------------

class PVPBattle : public ::google::protobuf::MessageLite {
 public:
  PVPBattle();
  virtual ~PVPBattle();

  PVPBattle(const PVPBattle& from);

  inline PVPBattle& operator=(const PVPBattle& from) {
    CopyFrom(from);
    return *this;
  }

  static const PVPBattle& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PVPBattle* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PVPBattle* other);

  // implements Message ----------------------------------------------

  PVPBattle* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PVPBattle& from);
  void MergeFrom(const PVPBattle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 target_id = 1;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 1;
  inline ::google::protobuf::uint32 target_id() const;
  inline void set_target_id(::google::protobuf::uint32 value);

  // optional uint32 is_ladder = 2;
  inline bool has_is_ladder() const;
  inline void clear_is_ladder();
  static const int kIsLadderFieldNumber = 2;
  inline ::google::protobuf::uint32 is_ladder() const;
  inline void set_is_ladder(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PVPBattle)
 private:
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_is_ladder();
  inline void clear_has_is_ladder();

  ::google::protobuf::uint32 target_id_;
  ::google::protobuf::uint32 is_ladder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PVPBattle* default_instance_;
};
// -------------------------------------------------------------------

class StartLadder : public ::google::protobuf::MessageLite {
 public:
  StartLadder();
  virtual ~StartLadder();

  StartLadder(const StartLadder& from);

  inline StartLadder& operator=(const StartLadder& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartLadder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartLadder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartLadder* other);

  // implements Message ----------------------------------------------

  StartLadder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartLadder& from);
  void MergeFrom(const StartLadder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.StartLadder)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static StartLadder* default_instance_;
};
// -------------------------------------------------------------------

class BuyLadderTimes : public ::google::protobuf::MessageLite {
 public:
  BuyLadderTimes();
  virtual ~BuyLadderTimes();

  BuyLadderTimes(const BuyLadderTimes& from);

  inline BuyLadderTimes& operator=(const BuyLadderTimes& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuyLadderTimes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuyLadderTimes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuyLadderTimes* other);

  // implements Message ----------------------------------------------

  BuyLadderTimes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuyLadderTimes& from);
  void MergeFrom(const BuyLadderTimes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BuyLadderTimes)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BuyLadderTimes* default_instance_;
};
// -------------------------------------------------------------------

class BuyPvPTimes : public ::google::protobuf::MessageLite {
 public:
  BuyPvPTimes();
  virtual ~BuyPvPTimes();

  BuyPvPTimes(const BuyPvPTimes& from);

  inline BuyPvPTimes& operator=(const BuyPvPTimes& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuyPvPTimes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuyPvPTimes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuyPvPTimes* other);

  // implements Message ----------------------------------------------

  BuyPvPTimes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuyPvPTimes& from);
  void MergeFrom(const BuyPvPTimes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BuyPvPTimes)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BuyPvPTimes* default_instance_;
};
// -------------------------------------------------------------------

class UpdateLadder : public ::google::protobuf::MessageLite {
 public:
  UpdateLadder();
  virtual ~UpdateLadder();

  UpdateLadder(const UpdateLadder& from);

  inline UpdateLadder& operator=(const UpdateLadder& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateLadder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateLadder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateLadder* other);

  // implements Message ----------------------------------------------

  UpdateLadder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateLadder& from);
  void MergeFrom(const UpdateLadder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // optional uint32 target_char_id = 2;
  inline bool has_target_char_id() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 target_char_id() const;
  inline void set_target_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UpdateLadder)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_target_char_id();
  inline void clear_has_target_char_id();

  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 target_char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UpdateLadder* default_instance_;
};
// -------------------------------------------------------------------

class UpdateLadderReward_RewardInfo : public ::google::protobuf::MessageLite {
 public:
  UpdateLadderReward_RewardInfo();
  virtual ~UpdateLadderReward_RewardInfo();

  UpdateLadderReward_RewardInfo(const UpdateLadderReward_RewardInfo& from);

  inline UpdateLadderReward_RewardInfo& operator=(const UpdateLadderReward_RewardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateLadderReward_RewardInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateLadderReward_RewardInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateLadderReward_RewardInfo* other);

  // implements Message ----------------------------------------------

  UpdateLadderReward_RewardInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateLadderReward_RewardInfo& from);
  void MergeFrom(const UpdateLadderReward_RewardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_ladder = 1;
  inline bool has_from_ladder() const;
  inline void clear_from_ladder();
  static const int kFromLadderFieldNumber = 1;
  inline ::google::protobuf::uint32 from_ladder() const;
  inline void set_from_ladder(::google::protobuf::uint32 value);

  // required uint32 to_ladder = 2;
  inline bool has_to_ladder() const;
  inline void clear_to_ladder();
  static const int kToLadderFieldNumber = 2;
  inline ::google::protobuf::uint32 to_ladder() const;
  inline void set_to_ladder(::google::protobuf::uint32 value);

  // required uint32 reward_ladder = 3;
  inline bool has_reward_ladder() const;
  inline void clear_reward_ladder();
  static const int kRewardLadderFieldNumber = 3;
  inline ::google::protobuf::uint32 reward_ladder() const;
  inline void set_reward_ladder(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UpdateLadderReward.RewardInfo)
 private:
  inline void set_has_from_ladder();
  inline void clear_has_from_ladder();
  inline void set_has_to_ladder();
  inline void clear_has_to_ladder();
  inline void set_has_reward_ladder();
  inline void clear_has_reward_ladder();

  ::google::protobuf::uint32 from_ladder_;
  ::google::protobuf::uint32 to_ladder_;
  ::google::protobuf::uint32 reward_ladder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UpdateLadderReward_RewardInfo* default_instance_;
};
// -------------------------------------------------------------------

class UpdateLadderReward : public ::google::protobuf::MessageLite {
 public:
  UpdateLadderReward();
  virtual ~UpdateLadderReward();

  UpdateLadderReward(const UpdateLadderReward& from);

  inline UpdateLadderReward& operator=(const UpdateLadderReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateLadderReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateLadderReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateLadderReward* other);

  // implements Message ----------------------------------------------

  UpdateLadderReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateLadderReward& from);
  void MergeFrom(const UpdateLadderReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UpdateLadderReward_RewardInfo RewardInfo;

  // accessors -------------------------------------------------------

  // repeated .message.UpdateLadderReward.RewardInfo reward_info = 1;
  inline int reward_info_size() const;
  inline void clear_reward_info();
  static const int kRewardInfoFieldNumber = 1;
  inline const ::message::UpdateLadderReward_RewardInfo& reward_info(int index) const;
  inline ::message::UpdateLadderReward_RewardInfo* mutable_reward_info(int index);
  inline ::message::UpdateLadderReward_RewardInfo* add_reward_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::UpdateLadderReward_RewardInfo >&
      reward_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::UpdateLadderReward_RewardInfo >*
      mutable_reward_info();

  // optional uint32 acc_id = 2;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 2;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UpdateLadderReward)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::RepeatedPtrField< ::message::UpdateLadderReward_RewardInfo > reward_info_;
  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UpdateLadderReward* default_instance_;
};
// -------------------------------------------------------------------

class GetLadderReward : public ::google::protobuf::MessageLite {
 public:
  GetLadderReward();
  virtual ~GetLadderReward();

  GetLadderReward(const GetLadderReward& from);

  inline GetLadderReward& operator=(const GetLadderReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetLadderReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetLadderReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetLadderReward* other);

  // implements Message ----------------------------------------------

  GetLadderReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetLadderReward& from);
  void MergeFrom(const GetLadderReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetLadderReward)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();

  ::google::protobuf::uint32 item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetLadderReward* default_instance_;
};
// -------------------------------------------------------------------

class GetRoleData : public ::google::protobuf::MessageLite {
 public:
  GetRoleData();
  virtual ~GetRoleData();

  GetRoleData(const GetRoleData& from);

  inline GetRoleData& operator=(const GetRoleData& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetRoleData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetRoleData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetRoleData* other);

  // implements Message ----------------------------------------------

  GetRoleData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetRoleData& from);
  void MergeFrom(const GetRoleData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required bytes char_name = 2;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 2;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // optional bytes mer_name = 3;
  inline bool has_mer_name() const;
  inline void clear_mer_name();
  static const int kMerNameFieldNumber = 3;
  inline const ::std::string& mer_name() const;
  inline void set_mer_name(const ::std::string& value);
  inline void set_mer_name(const char* value);
  inline void set_mer_name(const void* value, size_t size);
  inline ::std::string* mutable_mer_name();
  inline ::std::string* release_mer_name();
  inline void set_allocated_mer_name(::std::string* mer_name);

  // optional uint32 is_pk = 4;
  inline bool has_is_pk() const;
  inline void clear_is_pk();
  static const int kIsPkFieldNumber = 4;
  inline ::google::protobuf::uint32 is_pk() const;
  inline void set_is_pk(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetRoleData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_mer_name();
  inline void clear_has_mer_name();
  inline void set_has_is_pk();
  inline void clear_has_is_pk();

  ::std::string* char_name_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 is_pk_;
  ::std::string* mer_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetRoleData* default_instance_;
};
// -------------------------------------------------------------------

class RoleData_MercInfo : public ::google::protobuf::MessageLite {
 public:
  RoleData_MercInfo();
  virtual ~RoleData_MercInfo();

  RoleData_MercInfo(const RoleData_MercInfo& from);

  inline RoleData_MercInfo& operator=(const RoleData_MercInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoleData_MercInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoleData_MercInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoleData_MercInfo* other);

  // implements Message ----------------------------------------------

  RoleData_MercInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoleData_MercInfo& from);
  void MergeFrom(const RoleData_MercInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // optional bytes merc_data = 2;
  inline bool has_merc_data() const;
  inline void clear_merc_data();
  static const int kMercDataFieldNumber = 2;
  inline const ::std::string& merc_data() const;
  inline void set_merc_data(const ::std::string& value);
  inline void set_merc_data(const char* value);
  inline void set_merc_data(const void* value, size_t size);
  inline ::std::string* mutable_merc_data();
  inline ::std::string* release_merc_data();
  inline void set_allocated_merc_data(::std::string* merc_data);

  // optional bytes equip_data = 3;
  inline bool has_equip_data() const;
  inline void clear_equip_data();
  static const int kEquipDataFieldNumber = 3;
  inline const ::std::string& equip_data() const;
  inline void set_equip_data(const ::std::string& value);
  inline void set_equip_data(const char* value);
  inline void set_equip_data(const void* value, size_t size);
  inline ::std::string* mutable_equip_data();
  inline ::std::string* release_equip_data();
  inline void set_allocated_equip_data(::std::string* equip_data);

  // @@protoc_insertion_point(class_scope:message.RoleData.MercInfo)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_merc_data();
  inline void clear_has_merc_data();
  inline void set_has_equip_data();
  inline void clear_has_equip_data();

  ::std::string* merc_data_;
  ::std::string* equip_data_;
  ::google::protobuf::uint32 merc_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RoleData_MercInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoleData : public ::google::protobuf::MessageLite {
 public:
  RoleData();
  virtual ~RoleData();

  RoleData(const RoleData& from);

  inline RoleData& operator=(const RoleData& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoleData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoleData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoleData* other);

  // implements Message ----------------------------------------------

  RoleData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoleData& from);
  void MergeFrom(const RoleData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RoleData_MercInfo MercInfo;

  // accessors -------------------------------------------------------

  // optional uint32 target_char_id = 1;
  inline bool has_target_char_id() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 target_char_id() const;
  inline void set_target_char_id(::google::protobuf::uint32 value);

  // optional uint32 target_lv = 2;
  inline bool has_target_lv() const;
  inline void clear_target_lv();
  static const int kTargetLvFieldNumber = 2;
  inline ::google::protobuf::uint32 target_lv() const;
  inline void set_target_lv(::google::protobuf::uint32 value);

  // optional bytes target_name = 3;
  inline bool has_target_name() const;
  inline void clear_target_name();
  static const int kTargetNameFieldNumber = 3;
  inline const ::std::string& target_name() const;
  inline void set_target_name(const ::std::string& value);
  inline void set_target_name(const char* value);
  inline void set_target_name(const void* value, size_t size);
  inline ::std::string* mutable_target_name();
  inline ::std::string* release_target_name();
  inline void set_allocated_target_name(::std::string* target_name);

  // optional uint32 target_job = 4;
  inline bool has_target_job() const;
  inline void clear_target_job();
  static const int kTargetJobFieldNumber = 4;
  inline ::google::protobuf::uint32 target_job() const;
  inline void set_target_job(::google::protobuf::uint32 value);

  // optional uint32 target_sex = 5;
  inline bool has_target_sex() const;
  inline void clear_target_sex();
  static const int kTargetSexFieldNumber = 5;
  inline ::google::protobuf::uint32 target_sex() const;
  inline void set_target_sex(::google::protobuf::uint32 value);

  // optional uint32 success_num = 6;
  inline bool has_success_num() const;
  inline void clear_success_num();
  static const int kSuccessNumFieldNumber = 6;
  inline ::google::protobuf::uint32 success_num() const;
  inline void set_success_num(::google::protobuf::uint32 value);

  // optional uint32 fight_score = 7;
  inline bool has_fight_score() const;
  inline void clear_fight_score();
  static const int kFightScoreFieldNumber = 7;
  inline ::google::protobuf::uint32 fight_score() const;
  inline void set_fight_score(::google::protobuf::uint32 value);

  // repeated .message.RoleData.MercInfo merc_info = 8;
  inline int merc_info_size() const;
  inline void clear_merc_info();
  static const int kMercInfoFieldNumber = 8;
  inline const ::message::RoleData_MercInfo& merc_info(int index) const;
  inline ::message::RoleData_MercInfo* mutable_merc_info(int index);
  inline ::message::RoleData_MercInfo* add_merc_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::RoleData_MercInfo >&
      merc_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::RoleData_MercInfo >*
      mutable_merc_info();

  // optional uint32 error_code = 9;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 9;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.RoleData)
 private:
  inline void set_has_target_char_id();
  inline void clear_has_target_char_id();
  inline void set_has_target_lv();
  inline void clear_has_target_lv();
  inline void set_has_target_name();
  inline void clear_has_target_name();
  inline void set_has_target_job();
  inline void clear_has_target_job();
  inline void set_has_target_sex();
  inline void clear_has_target_sex();
  inline void set_has_success_num();
  inline void clear_has_success_num();
  inline void set_has_fight_score();
  inline void clear_has_fight_score();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::uint32 target_char_id_;
  ::google::protobuf::uint32 target_lv_;
  ::std::string* target_name_;
  ::google::protobuf::uint32 target_job_;
  ::google::protobuf::uint32 target_sex_;
  ::google::protobuf::uint32 success_num_;
  ::google::protobuf::uint32 fight_score_;
  ::google::protobuf::RepeatedPtrField< ::message::RoleData_MercInfo > merc_info_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RoleData* default_instance_;
};
// -------------------------------------------------------------------

class ReqRoleData : public ::google::protobuf::MessageLite {
 public:
  ReqRoleData();
  virtual ~ReqRoleData();

  ReqRoleData(const ReqRoleData& from);

  inline ReqRoleData& operator=(const ReqRoleData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqRoleData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqRoleData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqRoleData* other);

  // implements Message ----------------------------------------------

  ReqRoleData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqRoleData& from);
  void MergeFrom(const ReqRoleData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes char_name = 1;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 1;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqRoleData)
 private:
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string* char_name_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqRoleData* default_instance_;
};
// -------------------------------------------------------------------

class AckRoleData : public ::google::protobuf::MessageLite {
 public:
  AckRoleData();
  virtual ~AckRoleData();

  AckRoleData(const AckRoleData& from);

  inline AckRoleData& operator=(const AckRoleData& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckRoleData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckRoleData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckRoleData* other);

  // implements Message ----------------------------------------------

  AckRoleData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckRoleData& from);
  void MergeFrom(const AckRoleData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 target_char_id = 1;
  inline bool has_target_char_id() const;
  inline void clear_target_char_id();
  static const int kTargetCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 target_char_id() const;
  inline void set_target_char_id(::google::protobuf::uint32 value);

  // optional uint32 target_job = 2;
  inline bool has_target_job() const;
  inline void clear_target_job();
  static const int kTargetJobFieldNumber = 2;
  inline ::google::protobuf::uint32 target_job() const;
  inline void set_target_job(::google::protobuf::uint32 value);

  // optional uint32 target_sex = 3;
  inline bool has_target_sex() const;
  inline void clear_target_sex();
  static const int kTargetSexFieldNumber = 3;
  inline ::google::protobuf::uint32 target_sex() const;
  inline void set_target_sex(::google::protobuf::uint32 value);

  // optional bytes target_name = 4;
  inline bool has_target_name() const;
  inline void clear_target_name();
  static const int kTargetNameFieldNumber = 4;
  inline const ::std::string& target_name() const;
  inline void set_target_name(const ::std::string& value);
  inline void set_target_name(const char* value);
  inline void set_target_name(const void* value, size_t size);
  inline ::std::string* mutable_target_name();
  inline ::std::string* release_target_name();
  inline void set_allocated_target_name(::std::string* target_name);

  // optional uint32 target_level = 5;
  inline bool has_target_level() const;
  inline void clear_target_level();
  static const int kTargetLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 target_level() const;
  inline void set_target_level(::google::protobuf::uint32 value);

  // optional uint32 success_num = 6;
  inline bool has_success_num() const;
  inline void clear_success_num();
  static const int kSuccessNumFieldNumber = 6;
  inline ::google::protobuf::uint32 success_num() const;
  inline void set_success_num(::google::protobuf::uint32 value);

  // optional uint32 fight_score = 7;
  inline bool has_fight_score() const;
  inline void clear_fight_score();
  static const int kFightScoreFieldNumber = 7;
  inline ::google::protobuf::uint32 fight_score() const;
  inline void set_fight_score(::google::protobuf::uint32 value);

  // optional uint32 target_rank = 8;
  inline bool has_target_rank() const;
  inline void clear_target_rank();
  static const int kTargetRankFieldNumber = 8;
  inline ::google::protobuf::uint32 target_rank() const;
  inline void set_target_rank(::google::protobuf::uint32 value);

  // optional bytes char_merc = 9;
  inline bool has_char_merc() const;
  inline void clear_char_merc();
  static const int kCharMercFieldNumber = 9;
  inline const ::std::string& char_merc() const;
  inline void set_char_merc(const ::std::string& value);
  inline void set_char_merc(const char* value);
  inline void set_char_merc(const void* value, size_t size);
  inline ::std::string* mutable_char_merc();
  inline ::std::string* release_char_merc();
  inline void set_allocated_char_merc(::std::string* char_merc);

  // optional bytes char_equip = 10;
  inline bool has_char_equip() const;
  inline void clear_char_equip();
  static const int kCharEquipFieldNumber = 10;
  inline const ::std::string& char_equip() const;
  inline void set_char_equip(const ::std::string& value);
  inline void set_char_equip(const char* value);
  inline void set_char_equip(const void* value, size_t size);
  inline ::std::string* mutable_char_equip();
  inline ::std::string* release_char_equip();
  inline void set_allocated_char_equip(::std::string* char_equip);

  // optional uint32 source_rank = 11;
  inline bool has_source_rank() const;
  inline void clear_source_rank();
  static const int kSourceRankFieldNumber = 11;
  inline ::google::protobuf::uint32 source_rank() const;
  inline void set_source_rank(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckRoleData)
 private:
  inline void set_has_target_char_id();
  inline void clear_has_target_char_id();
  inline void set_has_target_job();
  inline void clear_has_target_job();
  inline void set_has_target_sex();
  inline void clear_has_target_sex();
  inline void set_has_target_name();
  inline void clear_has_target_name();
  inline void set_has_target_level();
  inline void clear_has_target_level();
  inline void set_has_success_num();
  inline void clear_has_success_num();
  inline void set_has_fight_score();
  inline void clear_has_fight_score();
  inline void set_has_target_rank();
  inline void clear_has_target_rank();
  inline void set_has_char_merc();
  inline void clear_has_char_merc();
  inline void set_has_char_equip();
  inline void clear_has_char_equip();
  inline void set_has_source_rank();
  inline void clear_has_source_rank();

  ::google::protobuf::uint32 target_char_id_;
  ::google::protobuf::uint32 target_job_;
  ::std::string* target_name_;
  ::google::protobuf::uint32 target_sex_;
  ::google::protobuf::uint32 target_level_;
  ::google::protobuf::uint32 success_num_;
  ::google::protobuf::uint32 fight_score_;
  ::std::string* char_merc_;
  ::google::protobuf::uint32 target_rank_;
  ::google::protobuf::uint32 source_rank_;
  ::std::string* char_equip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckRoleData* default_instance_;
};
// -------------------------------------------------------------------

class GetShopItemFromDB : public ::google::protobuf::MessageLite {
 public:
  GetShopItemFromDB();
  virtual ~GetShopItemFromDB();

  GetShopItemFromDB(const GetShopItemFromDB& from);

  inline GetShopItemFromDB& operator=(const GetShopItemFromDB& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetShopItemFromDB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetShopItemFromDB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetShopItemFromDB* other);

  // implements Message ----------------------------------------------

  GetShopItemFromDB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetShopItemFromDB& from);
  void MergeFrom(const GetShopItemFromDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetShopItemFromDB)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetShopItemFromDB* default_instance_;
};
// -------------------------------------------------------------------

class GetShopItemAck : public ::google::protobuf::MessageLite {
 public:
  GetShopItemAck();
  virtual ~GetShopItemAck();

  GetShopItemAck(const GetShopItemAck& from);

  inline GetShopItemAck& operator=(const GetShopItemAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetShopItemAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetShopItemAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetShopItemAck* other);

  // implements Message ----------------------------------------------

  GetShopItemAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetShopItemAck& from);
  void MergeFrom(const GetShopItemAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 shop_type = 1;
  inline int shop_type_size() const;
  inline void clear_shop_type();
  static const int kShopTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_type(int index) const;
  inline void set_shop_type(int index, ::google::protobuf::uint32 value);
  inline void add_shop_type(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      shop_type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_shop_type();

  // repeated bytes item_data = 2;
  inline int item_data_size() const;
  inline void clear_item_data();
  static const int kItemDataFieldNumber = 2;
  inline const ::std::string& item_data(int index) const;
  inline ::std::string* mutable_item_data(int index);
  inline void set_item_data(int index, const ::std::string& value);
  inline void set_item_data(int index, const char* value);
  inline void set_item_data(int index, const void* value, size_t size);
  inline ::std::string* add_item_data();
  inline void add_item_data(const ::std::string& value);
  inline void add_item_data(const char* value);
  inline void add_item_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item_data();

  // optional uint32 is_empty = 3;
  inline bool has_is_empty() const;
  inline void clear_is_empty();
  static const int kIsEmptyFieldNumber = 3;
  inline ::google::protobuf::uint32 is_empty() const;
  inline void set_is_empty(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetShopItemAck)
 private:
  inline void set_has_is_empty();
  inline void clear_has_is_empty();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > shop_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_data_;
  ::google::protobuf::uint32 is_empty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetShopItemAck* default_instance_;
};
// -------------------------------------------------------------------

class OpenShopUiReq : public ::google::protobuf::MessageLite {
 public:
  OpenShopUiReq();
  virtual ~OpenShopUiReq();

  OpenShopUiReq(const OpenShopUiReq& from);

  inline OpenShopUiReq& operator=(const OpenShopUiReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const OpenShopUiReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenShopUiReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenShopUiReq* other);

  // implements Message ----------------------------------------------

  OpenShopUiReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenShopUiReq& from);
  void MergeFrom(const OpenShopUiReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shop_type = 1;
  inline bool has_shop_type() const;
  inline void clear_shop_type();
  static const int kShopTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_type() const;
  inline void set_shop_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.OpenShopUiReq)
 private:
  inline void set_has_shop_type();
  inline void clear_has_shop_type();

  ::google::protobuf::uint32 shop_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OpenShopUiReq* default_instance_;
};
// -------------------------------------------------------------------

class OpenShopUiAck : public ::google::protobuf::MessageLite {
 public:
  OpenShopUiAck();
  virtual ~OpenShopUiAck();

  OpenShopUiAck(const OpenShopUiAck& from);

  inline OpenShopUiAck& operator=(const OpenShopUiAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const OpenShopUiAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenShopUiAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenShopUiAck* other);

  // implements Message ----------------------------------------------

  OpenShopUiAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenShopUiAck& from);
  void MergeFrom(const OpenShopUiAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional uint32 oper_type = 2;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 oper_type() const;
  inline void set_oper_type(::google::protobuf::uint32 value);

  // repeated bytes item_data = 3;
  inline int item_data_size() const;
  inline void clear_item_data();
  static const int kItemDataFieldNumber = 3;
  inline const ::std::string& item_data(int index) const;
  inline ::std::string* mutable_item_data(int index);
  inline void set_item_data(int index, const ::std::string& value);
  inline void set_item_data(int index, const char* value);
  inline void set_item_data(int index, const void* value, size_t size);
  inline ::std::string* add_item_data();
  inline void add_item_data(const ::std::string& value);
  inline void add_item_data(const char* value);
  inline void add_item_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item_data();

  // @@protoc_insertion_point(class_scope:message.OpenShopUiAck)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();

  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::uint32 oper_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OpenShopUiAck* default_instance_;
};
// -------------------------------------------------------------------

class BuyItem : public ::google::protobuf::MessageLite {
 public:
  BuyItem();
  virtual ~BuyItem();

  BuyItem(const BuyItem& from);

  inline BuyItem& operator=(const BuyItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuyItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuyItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuyItem* other);

  // implements Message ----------------------------------------------

  BuyItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuyItem& from);
  void MergeFrom(const BuyItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shop_type = 1;
  inline bool has_shop_type() const;
  inline void clear_shop_type();
  static const int kShopTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_type() const;
  inline void set_shop_type(::google::protobuf::uint32 value);

  // optional uint32 item_pos = 2;
  inline bool has_item_pos() const;
  inline void clear_item_pos();
  static const int kItemPosFieldNumber = 2;
  inline ::google::protobuf::uint32 item_pos() const;
  inline void set_item_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BuyItem)
 private:
  inline void set_has_shop_type();
  inline void clear_has_shop_type();
  inline void set_has_item_pos();
  inline void clear_has_item_pos();

  ::google::protobuf::uint32 shop_type_;
  ::google::protobuf::uint32 item_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BuyItem* default_instance_;
};
// -------------------------------------------------------------------

class RefreshShopReq : public ::google::protobuf::MessageLite {
 public:
  RefreshShopReq();
  virtual ~RefreshShopReq();

  RefreshShopReq(const RefreshShopReq& from);

  inline RefreshShopReq& operator=(const RefreshShopReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RefreshShopReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RefreshShopReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RefreshShopReq* other);

  // implements Message ----------------------------------------------

  RefreshShopReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RefreshShopReq& from);
  void MergeFrom(const RefreshShopReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shop_type = 1;
  inline bool has_shop_type() const;
  inline void clear_shop_type();
  static const int kShopTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_type() const;
  inline void set_shop_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.RefreshShopReq)
 private:
  inline void set_has_shop_type();
  inline void clear_has_shop_type();

  ::google::protobuf::uint32 shop_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RefreshShopReq* default_instance_;
};
// -------------------------------------------------------------------

class SellItem : public ::google::protobuf::MessageLite {
 public:
  SellItem();
  virtual ~SellItem();

  SellItem(const SellItem& from);

  inline SellItem& operator=(const SellItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const SellItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SellItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SellItem* other);

  // implements Message ----------------------------------------------

  SellItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SellItem& from);
  void MergeFrom(const SellItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 item_only_id = 1;
  inline bool has_item_only_id() const;
  inline void clear_item_only_id();
  static const int kItemOnlyIdFieldNumber = 1;
  inline ::google::protobuf::uint64 item_only_id() const;
  inline void set_item_only_id(::google::protobuf::uint64 value);

  // required uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // optional uint32 is_choose = 3;
  inline bool has_is_choose() const;
  inline void clear_is_choose();
  static const int kIsChooseFieldNumber = 3;
  inline ::google::protobuf::uint32 is_choose() const;
  inline void set_is_choose(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SellItem)
 private:
  inline void set_has_item_only_id();
  inline void clear_has_item_only_id();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_is_choose();
  inline void clear_has_is_choose();

  ::google::protobuf::uint64 item_only_id_;
  ::google::protobuf::uint32 item_num_;
  ::google::protobuf::uint32 is_choose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SellItem* default_instance_;
};
// -------------------------------------------------------------------

class ChangeSkill : public ::google::protobuf::MessageLite {
 public:
  ChangeSkill();
  virtual ~ChangeSkill();

  ChangeSkill(const ChangeSkill& from);

  inline ChangeSkill& operator=(const ChangeSkill& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeSkill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeSkill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeSkill* other);

  // implements Message ----------------------------------------------

  ChangeSkill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeSkill& from);
  void MergeFrom(const ChangeSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // required uint32 skill_id = 2;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ChangeSkill)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();

  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 skill_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ChangeSkill* default_instance_;
};
// -------------------------------------------------------------------

class SkillLevelUp : public ::google::protobuf::MessageLite {
 public:
  SkillLevelUp();
  virtual ~SkillLevelUp();

  SkillLevelUp(const SkillLevelUp& from);

  inline SkillLevelUp& operator=(const SkillLevelUp& from) {
    CopyFrom(from);
    return *this;
  }

  static const SkillLevelUp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SkillLevelUp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SkillLevelUp* other);

  // implements Message ----------------------------------------------

  SkillLevelUp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SkillLevelUp& from);
  void MergeFrom(const SkillLevelUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // required uint32 skill_id = 2;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SkillLevelUp)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();

  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 skill_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SkillLevelUp* default_instance_;
};
// -------------------------------------------------------------------

class ReqLevelUpStar : public ::google::protobuf::MessageLite {
 public:
  ReqLevelUpStar();
  virtual ~ReqLevelUpStar();

  ReqLevelUpStar(const ReqLevelUpStar& from);

  inline ReqLevelUpStar& operator=(const ReqLevelUpStar& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqLevelUpStar& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqLevelUpStar* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqLevelUpStar* other);

  // implements Message ----------------------------------------------

  ReqLevelUpStar* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqLevelUpStar& from);
  void MergeFrom(const ReqLevelUpStar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional uint32 is_choose = 2;
  inline bool has_is_choose() const;
  inline void clear_is_choose();
  static const int kIsChooseFieldNumber = 2;
  inline ::google::protobuf::uint32 is_choose() const;
  inline void set_is_choose(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqLevelUpStar)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_is_choose();
  inline void clear_has_is_choose();

  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 is_choose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqLevelUpStar* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeItem : public ::google::protobuf::MessageLite {
 public:
  UpgradeItem();
  virtual ~UpgradeItem();

  UpgradeItem(const UpgradeItem& from);

  inline UpgradeItem& operator=(const UpgradeItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpgradeItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpgradeItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpgradeItem* other);

  // implements Message ----------------------------------------------

  UpgradeItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpgradeItem& from);
  void MergeFrom(const UpgradeItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_pos = 1;
  inline bool has_char_pos() const;
  inline void clear_char_pos();
  static const int kCharPosFieldNumber = 1;
  inline ::google::protobuf::uint32 char_pos() const;
  inline void set_char_pos(::google::protobuf::uint32 value);

  // required uint32 item_pos = 2;
  inline bool has_item_pos() const;
  inline void clear_item_pos();
  static const int kItemPosFieldNumber = 2;
  inline ::google::protobuf::uint32 item_pos() const;
  inline void set_item_pos(::google::protobuf::uint32 value);

  // required uint64 item_only_id = 3;
  inline bool has_item_only_id() const;
  inline void clear_item_only_id();
  static const int kItemOnlyIdFieldNumber = 3;
  inline ::google::protobuf::uint64 item_only_id() const;
  inline void set_item_only_id(::google::protobuf::uint64 value);

  // optional uint32 is_dest = 4;
  inline bool has_is_dest() const;
  inline void clear_is_dest();
  static const int kIsDestFieldNumber = 4;
  inline ::google::protobuf::uint32 is_dest() const;
  inline void set_is_dest(::google::protobuf::uint32 value);

  // optional uint32 quick_upgrade = 5;
  inline bool has_quick_upgrade() const;
  inline void clear_quick_upgrade();
  static const int kQuickUpgradeFieldNumber = 5;
  inline ::google::protobuf::uint32 quick_upgrade() const;
  inline void set_quick_upgrade(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UpgradeItem)
 private:
  inline void set_has_char_pos();
  inline void clear_has_char_pos();
  inline void set_has_item_pos();
  inline void clear_has_item_pos();
  inline void set_has_item_only_id();
  inline void clear_has_item_only_id();
  inline void set_has_is_dest();
  inline void clear_has_is_dest();
  inline void set_has_quick_upgrade();
  inline void clear_has_quick_upgrade();

  ::google::protobuf::uint32 char_pos_;
  ::google::protobuf::uint32 item_pos_;
  ::google::protobuf::uint64 item_only_id_;
  ::google::protobuf::uint32 is_dest_;
  ::google::protobuf::uint32 quick_upgrade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UpgradeItem* default_instance_;
};
// -------------------------------------------------------------------

class ReqRankList : public ::google::protobuf::MessageLite {
 public:
  ReqRankList();
  virtual ~ReqRankList();

  ReqRankList(const ReqRankList& from);

  inline ReqRankList& operator=(const ReqRankList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqRankList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqRankList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqRankList* other);

  // implements Message ----------------------------------------------

  ReqRankList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqRankList& from);
  void MergeFrom(const ReqRankList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rank_type = 1;
  inline bool has_rank_type() const;
  inline void clear_rank_type();
  static const int kRankTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 rank_type() const;
  inline void set_rank_type(::google::protobuf::uint32 value);

  // optional uint32 page = 2;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 2;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqRankList)
 private:
  inline void set_has_rank_type();
  inline void clear_has_rank_type();
  inline void set_has_page();
  inline void clear_has_page();

  ::google::protobuf::uint32 rank_type_;
  ::google::protobuf::uint32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqRankList* default_instance_;
};
// -------------------------------------------------------------------

class AckRankList_RankInfo : public ::google::protobuf::MessageLite {
 public:
  AckRankList_RankInfo();
  virtual ~AckRankList_RankInfo();

  AckRankList_RankInfo(const AckRankList_RankInfo& from);

  inline AckRankList_RankInfo& operator=(const AckRankList_RankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckRankList_RankInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckRankList_RankInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckRankList_RankInfo* other);

  // implements Message ----------------------------------------------

  AckRankList_RankInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckRankList_RankInfo& from);
  void MergeFrom(const AckRankList_RankInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rank_id = 1;
  inline bool has_rank_id() const;
  inline void clear_rank_id();
  static const int kRankIdFieldNumber = 1;
  inline ::google::protobuf::uint32 rank_id() const;
  inline void set_rank_id(::google::protobuf::uint32 value);

  // required bytes char_name = 2;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 2;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // required uint32 char_rank = 3;
  inline bool has_char_rank() const;
  inline void clear_char_rank();
  static const int kCharRankFieldNumber = 3;
  inline ::google::protobuf::uint32 char_rank() const;
  inline void set_char_rank(::google::protobuf::uint32 value);

  // required uint32 rank_value = 4;
  inline bool has_rank_value() const;
  inline void clear_rank_value();
  static const int kRankValueFieldNumber = 4;
  inline ::google::protobuf::uint32 rank_value() const;
  inline void set_rank_value(::google::protobuf::uint32 value);

  // optional uint32 is_myself = 5;
  inline bool has_is_myself() const;
  inline void clear_is_myself();
  static const int kIsMyselfFieldNumber = 5;
  inline ::google::protobuf::uint32 is_myself() const;
  inline void set_is_myself(::google::protobuf::uint32 value);

  // optional uint32 fight_score = 6;
  inline bool has_fight_score() const;
  inline void clear_fight_score();
  static const int kFightScoreFieldNumber = 6;
  inline ::google::protobuf::uint32 fight_score() const;
  inline void set_fight_score(::google::protobuf::uint32 value);

  // optional uint32 char_level = 7;
  inline bool has_char_level() const;
  inline void clear_char_level();
  static const int kCharLevelFieldNumber = 7;
  inline ::google::protobuf::uint32 char_level() const;
  inline void set_char_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckRankList.RankInfo)
 private:
  inline void set_has_rank_id();
  inline void clear_has_rank_id();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_char_rank();
  inline void clear_has_char_rank();
  inline void set_has_rank_value();
  inline void clear_has_rank_value();
  inline void set_has_is_myself();
  inline void clear_has_is_myself();
  inline void set_has_fight_score();
  inline void clear_has_fight_score();
  inline void set_has_char_level();
  inline void clear_has_char_level();

  ::std::string* char_name_;
  ::google::protobuf::uint32 rank_id_;
  ::google::protobuf::uint32 char_rank_;
  ::google::protobuf::uint32 rank_value_;
  ::google::protobuf::uint32 is_myself_;
  ::google::protobuf::uint32 fight_score_;
  ::google::protobuf::uint32 char_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckRankList_RankInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckRankList : public ::google::protobuf::MessageLite {
 public:
  AckRankList();
  virtual ~AckRankList();

  AckRankList(const AckRankList& from);

  inline AckRankList& operator=(const AckRankList& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckRankList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckRankList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckRankList* other);

  // implements Message ----------------------------------------------

  AckRankList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckRankList& from);
  void MergeFrom(const AckRankList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AckRankList_RankInfo RankInfo;

  // accessors -------------------------------------------------------

  // repeated .message.AckRankList.RankInfo rank_info = 1;
  inline int rank_info_size() const;
  inline void clear_rank_info();
  static const int kRankInfoFieldNumber = 1;
  inline const ::message::AckRankList_RankInfo& rank_info(int index) const;
  inline ::message::AckRankList_RankInfo* mutable_rank_info(int index);
  inline ::message::AckRankList_RankInfo* add_rank_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::AckRankList_RankInfo >&
      rank_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::AckRankList_RankInfo >*
      mutable_rank_info();

  // optional bytes rank_time = 2;
  inline bool has_rank_time() const;
  inline void clear_rank_time();
  static const int kRankTimeFieldNumber = 2;
  inline const ::std::string& rank_time() const;
  inline void set_rank_time(const ::std::string& value);
  inline void set_rank_time(const char* value);
  inline void set_rank_time(const void* value, size_t size);
  inline ::std::string* mutable_rank_time();
  inline ::std::string* release_rank_time();
  inline void set_allocated_rank_time(::std::string* rank_time);

  // optional uint32 my_rank = 3;
  inline bool has_my_rank() const;
  inline void clear_my_rank();
  static const int kMyRankFieldNumber = 3;
  inline ::google::protobuf::uint32 my_rank() const;
  inline void set_my_rank(::google::protobuf::uint32 value);

  // optional uint32 page = 4;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 4;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckRankList)
 private:
  inline void set_has_rank_time();
  inline void clear_has_rank_time();
  inline void set_has_my_rank();
  inline void clear_has_my_rank();
  inline void set_has_page();
  inline void clear_has_page();

  ::google::protobuf::RepeatedPtrField< ::message::AckRankList_RankInfo > rank_info_;
  ::std::string* rank_time_;
  ::google::protobuf::uint32 my_rank_;
  ::google::protobuf::uint32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckRankList* default_instance_;
};
// -------------------------------------------------------------------

class ReqServerRank : public ::google::protobuf::MessageLite {
 public:
  ReqServerRank();
  virtual ~ReqServerRank();

  ReqServerRank(const ReqServerRank& from);

  inline ReqServerRank& operator=(const ReqServerRank& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqServerRank& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqServerRank* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqServerRank* other);

  // implements Message ----------------------------------------------

  ReqServerRank* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqServerRank& from);
  void MergeFrom(const ReqServerRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rank_id = 1;
  inline bool has_rank_id() const;
  inline void clear_rank_id();
  static const int kRankIdFieldNumber = 1;
  inline ::google::protobuf::uint32 rank_id() const;
  inline void set_rank_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqServerRank)
 private:
  inline void set_has_rank_id();
  inline void clear_has_rank_id();

  ::google::protobuf::uint32 rank_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqServerRank* default_instance_;
};
// -------------------------------------------------------------------

class AckServerRank_RankInfo : public ::google::protobuf::MessageLite {
 public:
  AckServerRank_RankInfo();
  virtual ~AckServerRank_RankInfo();

  AckServerRank_RankInfo(const AckServerRank_RankInfo& from);

  inline AckServerRank_RankInfo& operator=(const AckServerRank_RankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckServerRank_RankInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckServerRank_RankInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckServerRank_RankInfo* other);

  // implements Message ----------------------------------------------

  AckServerRank_RankInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckServerRank_RankInfo& from);
  void MergeFrom(const AckServerRank_RankInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 rank = 3;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 3;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 job = 6;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 6;
  inline ::google::protobuf::uint32 job() const;
  inline void set_job(::google::protobuf::uint32 value);

  // optional uint32 rank_value = 7;
  inline bool has_rank_value() const;
  inline void clear_rank_value();
  static const int kRankValueFieldNumber = 7;
  inline ::google::protobuf::uint32 rank_value() const;
  inline void set_rank_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckServerRank.RankInfo)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_rank_value();
  inline void clear_has_rank_value();

  ::std::string* name_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 job_;
  ::google::protobuf::uint32 rank_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckServerRank_RankInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckServerRank : public ::google::protobuf::MessageLite {
 public:
  AckServerRank();
  virtual ~AckServerRank();

  AckServerRank(const AckServerRank& from);

  inline AckServerRank& operator=(const AckServerRank& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckServerRank& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckServerRank* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckServerRank* other);

  // implements Message ----------------------------------------------

  AckServerRank* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckServerRank& from);
  void MergeFrom(const AckServerRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AckServerRank_RankInfo RankInfo;

  // accessors -------------------------------------------------------

  // repeated .message.AckServerRank.RankInfo rank_info = 1;
  inline int rank_info_size() const;
  inline void clear_rank_info();
  static const int kRankInfoFieldNumber = 1;
  inline const ::message::AckServerRank_RankInfo& rank_info(int index) const;
  inline ::message::AckServerRank_RankInfo* mutable_rank_info(int index);
  inline ::message::AckServerRank_RankInfo* add_rank_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::AckServerRank_RankInfo >&
      rank_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::AckServerRank_RankInfo >*
      mutable_rank_info();

  // optional uint32 rank_type = 2;
  inline bool has_rank_type() const;
  inline void clear_rank_type();
  static const int kRankTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 rank_type() const;
  inline void set_rank_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckServerRank)
 private:
  inline void set_has_rank_type();
  inline void clear_has_rank_type();

  ::google::protobuf::RepeatedPtrField< ::message::AckServerRank_RankInfo > rank_info_;
  ::google::protobuf::uint32 rank_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckServerRank* default_instance_;
};
// -------------------------------------------------------------------

class ReqChessData : public ::google::protobuf::MessageLite {
 public:
  ReqChessData();
  virtual ~ReqChessData();

  ReqChessData(const ReqChessData& from);

  inline ReqChessData& operator=(const ReqChessData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqChessData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqChessData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqChessData* other);

  // implements Message ----------------------------------------------

  ReqChessData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqChessData& from);
  void MergeFrom(const ReqChessData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 chess_type = 1;
  inline bool has_chess_type() const;
  inline void clear_chess_type();
  static const int kChessTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 chess_type() const;
  inline void set_chess_type(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqChessData)
 private:
  inline void set_has_chess_type();
  inline void clear_has_chess_type();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();

  ::google::protobuf::uint32 chess_type_;
  ::google::protobuf::uint32 friend_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqChessData* default_instance_;
};
// -------------------------------------------------------------------

class AckChessData : public ::google::protobuf::MessageLite {
 public:
  AckChessData();
  virtual ~AckChessData();

  AckChessData(const AckChessData& from);

  inline AckChessData& operator=(const AckChessData& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckChessData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckChessData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckChessData* other);

  // implements Message ----------------------------------------------

  AckChessData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckChessData& from);
  void MergeFrom(const AckChessData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 remain_time = 1;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 remain_time() const;
  inline void set_remain_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckChessData)
 private:
  inline void set_has_remain_time();
  inline void clear_has_remain_time();

  ::google::protobuf::uint32 remain_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckChessData* default_instance_;
};
// -------------------------------------------------------------------

class ReqRunChess : public ::google::protobuf::MessageLite {
 public:
  ReqRunChess();
  virtual ~ReqRunChess();

  ReqRunChess(const ReqRunChess& from);

  inline ReqRunChess& operator=(const ReqRunChess& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqRunChess& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqRunChess* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqRunChess* other);

  // implements Message ----------------------------------------------

  ReqRunChess* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqRunChess& from);
  void MergeFrom(const ReqRunChess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 chess_type = 1;
  inline bool has_chess_type() const;
  inline void clear_chess_type();
  static const int kChessTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 chess_type() const;
  inline void set_chess_type(::google::protobuf::uint32 value);

  // optional bytes friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline const ::std::string& friend_id() const;
  inline void set_friend_id(const ::std::string& value);
  inline void set_friend_id(const char* value);
  inline void set_friend_id(const void* value, size_t size);
  inline ::std::string* mutable_friend_id();
  inline ::std::string* release_friend_id();
  inline void set_allocated_friend_id(::std::string* friend_id);

  // optional uint32 is_fast = 3;
  inline bool has_is_fast() const;
  inline void clear_is_fast();
  static const int kIsFastFieldNumber = 3;
  inline ::google::protobuf::uint32 is_fast() const;
  inline void set_is_fast(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqRunChess)
 private:
  inline void set_has_chess_type();
  inline void clear_has_chess_type();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_is_fast();
  inline void clear_has_is_fast();

  ::std::string* friend_id_;
  ::google::protobuf::uint32 chess_type_;
  ::google::protobuf::uint32 is_fast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqRunChess* default_instance_;
};
// -------------------------------------------------------------------

class AckRunChess : public ::google::protobuf::MessageLite {
 public:
  AckRunChess();
  virtual ~AckRunChess();

  AckRunChess(const AckRunChess& from);

  inline AckRunChess& operator=(const AckRunChess& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckRunChess& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckRunChess* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckRunChess* other);

  // implements Message ----------------------------------------------

  AckRunChess* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckRunChess& from);
  void MergeFrom(const AckRunChess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 chess_type = 1;
  inline bool has_chess_type() const;
  inline void clear_chess_type();
  static const int kChessTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 chess_type() const;
  inline void set_chess_type(::google::protobuf::uint32 value);

  // required uint32 chess_move = 2;
  inline bool has_chess_move() const;
  inline void clear_chess_move();
  static const int kChessMoveFieldNumber = 2;
  inline ::google::protobuf::uint32 chess_move() const;
  inline void set_chess_move(::google::protobuf::uint32 value);

  // repeated uint32 reward_item = 3;
  inline int reward_item_size() const;
  inline void clear_reward_item();
  static const int kRewardItemFieldNumber = 3;
  inline ::google::protobuf::uint32 reward_item(int index) const;
  inline void set_reward_item(int index, ::google::protobuf::uint32 value);
  inline void add_reward_item(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reward_item() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reward_item();

  // repeated uint32 reward_item_num = 4;
  inline int reward_item_num_size() const;
  inline void clear_reward_item_num();
  static const int kRewardItemNumFieldNumber = 4;
  inline ::google::protobuf::uint32 reward_item_num(int index) const;
  inline void set_reward_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_reward_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reward_item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reward_item_num();

  // optional uint32 event_id = 5;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 5;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint32 is_friend = 6;
  inline bool has_is_friend() const;
  inline void clear_is_friend();
  static const int kIsFriendFieldNumber = 6;
  inline ::google::protobuf::uint32 is_friend() const;
  inline void set_is_friend(::google::protobuf::uint32 value);

  // optional uint32 is_fast = 7;
  inline bool has_is_fast() const;
  inline void clear_is_fast();
  static const int kIsFastFieldNumber = 7;
  inline ::google::protobuf::uint32 is_fast() const;
  inline void set_is_fast(::google::protobuf::uint32 value);

  // optional uint32 is_big = 8;
  inline bool has_is_big() const;
  inline void clear_is_big();
  static const int kIsBigFieldNumber = 8;
  inline ::google::protobuf::uint32 is_big() const;
  inline void set_is_big(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckRunChess)
 private:
  inline void set_has_chess_type();
  inline void clear_has_chess_type();
  inline void set_has_chess_move();
  inline void clear_has_chess_move();
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_is_friend();
  inline void clear_has_is_friend();
  inline void set_has_is_fast();
  inline void clear_has_is_fast();
  inline void set_has_is_big();
  inline void clear_has_is_big();

  ::google::protobuf::uint32 chess_type_;
  ::google::protobuf::uint32 chess_move_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reward_item_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reward_item_num_;
  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 is_friend_;
  ::google::protobuf::uint32 is_fast_;
  ::google::protobuf::uint32 is_big_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckRunChess* default_instance_;
};
// -------------------------------------------------------------------

class AckChessRank_RankInfo : public ::google::protobuf::MessageLite {
 public:
  AckChessRank_RankInfo();
  virtual ~AckChessRank_RankInfo();

  AckChessRank_RankInfo(const AckChessRank_RankInfo& from);

  inline AckChessRank_RankInfo& operator=(const AckChessRank_RankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckChessRank_RankInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckChessRank_RankInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckChessRank_RankInfo* other);

  // implements Message ----------------------------------------------

  AckChessRank_RankInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckChessRank_RankInfo& from);
  void MergeFrom(const AckChessRank_RankInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // required bytes char_name = 2;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 2;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // required uint32 char_rank = 3;
  inline bool has_char_rank() const;
  inline void clear_char_rank();
  static const int kCharRankFieldNumber = 3;
  inline ::google::protobuf::uint32 char_rank() const;
  inline void set_char_rank(::google::protobuf::uint32 value);

  // required uint32 rank_value = 4;
  inline bool has_rank_value() const;
  inline void clear_rank_value();
  static const int kRankValueFieldNumber = 4;
  inline ::google::protobuf::uint32 rank_value() const;
  inline void set_rank_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckChessRank.RankInfo)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_char_rank();
  inline void clear_has_char_rank();
  inline void set_has_rank_value();
  inline void clear_has_rank_value();

  ::std::string* char_name_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 char_rank_;
  ::google::protobuf::uint32 rank_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckChessRank_RankInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckChessRank : public ::google::protobuf::MessageLite {
 public:
  AckChessRank();
  virtual ~AckChessRank();

  AckChessRank(const AckChessRank& from);

  inline AckChessRank& operator=(const AckChessRank& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckChessRank& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckChessRank* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckChessRank* other);

  // implements Message ----------------------------------------------

  AckChessRank* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckChessRank& from);
  void MergeFrom(const AckChessRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AckChessRank_RankInfo RankInfo;

  // accessors -------------------------------------------------------

  // repeated .message.AckChessRank.RankInfo rank_info = 1;
  inline int rank_info_size() const;
  inline void clear_rank_info();
  static const int kRankInfoFieldNumber = 1;
  inline const ::message::AckChessRank_RankInfo& rank_info(int index) const;
  inline ::message::AckChessRank_RankInfo* mutable_rank_info(int index);
  inline ::message::AckChessRank_RankInfo* add_rank_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::AckChessRank_RankInfo >&
      rank_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::AckChessRank_RankInfo >*
      mutable_rank_info();

  // required uint32 chess_type = 2;
  inline bool has_chess_type() const;
  inline void clear_chess_type();
  static const int kChessTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 chess_type() const;
  inline void set_chess_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckChessRank)
 private:
  inline void set_has_chess_type();
  inline void clear_has_chess_type();

  ::google::protobuf::RepeatedPtrField< ::message::AckChessRank_RankInfo > rank_info_;
  ::google::protobuf::uint32 chess_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckChessRank* default_instance_;
};
// -------------------------------------------------------------------

class UnlockTrainMercenary : public ::google::protobuf::MessageLite {
 public:
  UnlockTrainMercenary();
  virtual ~UnlockTrainMercenary();

  UnlockTrainMercenary(const UnlockTrainMercenary& from);

  inline UnlockTrainMercenary& operator=(const UnlockTrainMercenary& from) {
    CopyFrom(from);
    return *this;
  }

  static const UnlockTrainMercenary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnlockTrainMercenary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnlockTrainMercenary* other);

  // implements Message ----------------------------------------------

  UnlockTrainMercenary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnlockTrainMercenary& from);
  void MergeFrom(const UnlockTrainMercenary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UnlockTrainMercenary)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UnlockTrainMercenary* default_instance_;
};
// -------------------------------------------------------------------

class TrainMercenary : public ::google::protobuf::MessageLite {
 public:
  TrainMercenary();
  virtual ~TrainMercenary();

  TrainMercenary(const TrainMercenary& from);

  inline TrainMercenary& operator=(const TrainMercenary& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrainMercenary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrainMercenary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrainMercenary* other);

  // implements Message ----------------------------------------------

  TrainMercenary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrainMercenary& from);
  void MergeFrom(const TrainMercenary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // required uint32 train_type = 2;
  inline bool has_train_type() const;
  inline void clear_train_type();
  static const int kTrainTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 train_type() const;
  inline void set_train_type(::google::protobuf::uint32 value);

  // optional uint32 friend_id = 3;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 3;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.TrainMercenary)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_train_type();
  inline void clear_has_train_type();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();

  ::google::protobuf::uint32 merc_pos_;
  ::google::protobuf::uint32 train_type_;
  ::google::protobuf::uint32 friend_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TrainMercenary* default_instance_;
};
// -------------------------------------------------------------------

class ReqTrainMercenaryTime : public ::google::protobuf::MessageLite {
 public:
  ReqTrainMercenaryTime();
  virtual ~ReqTrainMercenaryTime();

  ReqTrainMercenaryTime(const ReqTrainMercenaryTime& from);

  inline ReqTrainMercenaryTime& operator=(const ReqTrainMercenaryTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqTrainMercenaryTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqTrainMercenaryTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqTrainMercenaryTime* other);

  // implements Message ----------------------------------------------

  ReqTrainMercenaryTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqTrainMercenaryTime& from);
  void MergeFrom(const ReqTrainMercenaryTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 train_id = 1;
  inline bool has_train_id() const;
  inline void clear_train_id();
  static const int kTrainIdFieldNumber = 1;
  inline ::google::protobuf::uint32 train_id() const;
  inline void set_train_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqTrainMercenaryTime)
 private:
  inline void set_has_train_id();
  inline void clear_has_train_id();

  ::google::protobuf::uint32 train_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqTrainMercenaryTime* default_instance_;
};
// -------------------------------------------------------------------

class AckTrainMercenaryTime : public ::google::protobuf::MessageLite {
 public:
  AckTrainMercenaryTime();
  virtual ~AckTrainMercenaryTime();

  AckTrainMercenaryTime(const AckTrainMercenaryTime& from);

  inline AckTrainMercenaryTime& operator=(const AckTrainMercenaryTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckTrainMercenaryTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckTrainMercenaryTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckTrainMercenaryTime* other);

  // implements Message ----------------------------------------------

  AckTrainMercenaryTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckTrainMercenaryTime& from);
  void MergeFrom(const AckTrainMercenaryTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 merc_pos = 1;
  inline int merc_pos_size() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos(int index) const;
  inline void set_merc_pos(int index, ::google::protobuf::uint32 value);
  inline void add_merc_pos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      merc_pos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_merc_pos();

  // repeated uint32 remain_time = 2;
  inline int remain_time_size() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 remain_time(int index) const;
  inline void set_remain_time(int index, ::google::protobuf::uint32 value);
  inline void add_remain_time(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      remain_time() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_remain_time();

  // @@protoc_insertion_point(class_scope:message.AckTrainMercenaryTime)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > merc_pos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > remain_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckTrainMercenaryTime* default_instance_;
};
// -------------------------------------------------------------------

class ReqFriendTrainMercenaryTime : public ::google::protobuf::MessageLite {
 public:
  ReqFriendTrainMercenaryTime();
  virtual ~ReqFriendTrainMercenaryTime();

  ReqFriendTrainMercenaryTime(const ReqFriendTrainMercenaryTime& from);

  inline ReqFriendTrainMercenaryTime& operator=(const ReqFriendTrainMercenaryTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqFriendTrainMercenaryTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqFriendTrainMercenaryTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqFriendTrainMercenaryTime* other);

  // implements Message ----------------------------------------------

  ReqFriendTrainMercenaryTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqFriendTrainMercenaryTime& from);
  void MergeFrom(const ReqFriendTrainMercenaryTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 train_id = 1;
  inline bool has_train_id() const;
  inline void clear_train_id();
  static const int kTrainIdFieldNumber = 1;
  inline ::google::protobuf::uint32 train_id() const;
  inline void set_train_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqFriendTrainMercenaryTime)
 private:
  inline void set_has_train_id();
  inline void clear_has_train_id();

  ::google::protobuf::uint32 train_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqFriendTrainMercenaryTime* default_instance_;
};
// -------------------------------------------------------------------

class ReqAccelerateTrainMercenary : public ::google::protobuf::MessageLite {
 public:
  ReqAccelerateTrainMercenary();
  virtual ~ReqAccelerateTrainMercenary();

  ReqAccelerateTrainMercenary(const ReqAccelerateTrainMercenary& from);

  inline ReqAccelerateTrainMercenary& operator=(const ReqAccelerateTrainMercenary& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqAccelerateTrainMercenary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqAccelerateTrainMercenary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqAccelerateTrainMercenary* other);

  // implements Message ----------------------------------------------

  ReqAccelerateTrainMercenary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqAccelerateTrainMercenary& from);
  void MergeFrom(const ReqAccelerateTrainMercenary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqAccelerateTrainMercenary)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();

  ::google::protobuf::uint32 merc_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqAccelerateTrainMercenary* default_instance_;
};
// -------------------------------------------------------------------

class AckFriendTrainMercenaryTime_FriendTrainInfo : public ::google::protobuf::MessageLite {
 public:
  AckFriendTrainMercenaryTime_FriendTrainInfo();
  virtual ~AckFriendTrainMercenaryTime_FriendTrainInfo();

  AckFriendTrainMercenaryTime_FriendTrainInfo(const AckFriendTrainMercenaryTime_FriendTrainInfo& from);

  inline AckFriendTrainMercenaryTime_FriendTrainInfo& operator=(const AckFriendTrainMercenaryTime_FriendTrainInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckFriendTrainMercenaryTime_FriendTrainInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckFriendTrainMercenaryTime_FriendTrainInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckFriendTrainMercenaryTime_FriendTrainInfo* other);

  // implements Message ----------------------------------------------

  AckFriendTrainMercenaryTime_FriendTrainInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckFriendTrainMercenaryTime_FriendTrainInfo& from);
  void MergeFrom(const AckFriendTrainMercenaryTime_FriendTrainInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type_id = 1;
  inline bool has_type_id() const;
  inline void clear_type_id();
  static const int kTypeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 type_id() const;
  inline void set_type_id(::google::protobuf::uint32 value);

  // required uint32 merc_pos = 2;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 2;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // required bool is_help = 3;
  inline bool has_is_help() const;
  inline void clear_is_help();
  static const int kIsHelpFieldNumber = 3;
  inline bool is_help() const;
  inline void set_is_help(bool value);

  // @@protoc_insertion_point(class_scope:message.AckFriendTrainMercenaryTime.FriendTrainInfo)
 private:
  inline void set_has_type_id();
  inline void clear_has_type_id();
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_is_help();
  inline void clear_has_is_help();

  ::google::protobuf::uint32 type_id_;
  ::google::protobuf::uint32 merc_pos_;
  bool is_help_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckFriendTrainMercenaryTime_FriendTrainInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckFriendTrainMercenaryTime : public ::google::protobuf::MessageLite {
 public:
  AckFriendTrainMercenaryTime();
  virtual ~AckFriendTrainMercenaryTime();

  AckFriendTrainMercenaryTime(const AckFriendTrainMercenaryTime& from);

  inline AckFriendTrainMercenaryTime& operator=(const AckFriendTrainMercenaryTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckFriendTrainMercenaryTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckFriendTrainMercenaryTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckFriendTrainMercenaryTime* other);

  // implements Message ----------------------------------------------

  AckFriendTrainMercenaryTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckFriendTrainMercenaryTime& from);
  void MergeFrom(const AckFriendTrainMercenaryTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AckFriendTrainMercenaryTime_FriendTrainInfo FriendTrainInfo;

  // accessors -------------------------------------------------------

  // repeated .message.AckFriendTrainMercenaryTime.FriendTrainInfo friend_train_info = 1;
  inline int friend_train_info_size() const;
  inline void clear_friend_train_info();
  static const int kFriendTrainInfoFieldNumber = 1;
  inline const ::message::AckFriendTrainMercenaryTime_FriendTrainInfo& friend_train_info(int index) const;
  inline ::message::AckFriendTrainMercenaryTime_FriendTrainInfo* mutable_friend_train_info(int index);
  inline ::message::AckFriendTrainMercenaryTime_FriendTrainInfo* add_friend_train_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::AckFriendTrainMercenaryTime_FriendTrainInfo >&
      friend_train_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::AckFriendTrainMercenaryTime_FriendTrainInfo >*
      mutable_friend_train_info();

  // @@protoc_insertion_point(class_scope:message.AckFriendTrainMercenaryTime)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::AckFriendTrainMercenaryTime_FriendTrainInfo > friend_train_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckFriendTrainMercenaryTime* default_instance_;
};
// -------------------------------------------------------------------

class BuyMallItem : public ::google::protobuf::MessageLite {
 public:
  BuyMallItem();
  virtual ~BuyMallItem();

  BuyMallItem(const BuyMallItem& from);

  inline BuyMallItem& operator=(const BuyMallItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuyMallItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuyMallItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuyMallItem* other);

  // implements Message ----------------------------------------------

  BuyMallItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuyMallItem& from);
  void MergeFrom(const BuyMallItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mall_id = 1;
  inline bool has_mall_id() const;
  inline void clear_mall_id();
  static const int kMallIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mall_id() const;
  inline void set_mall_id(::google::protobuf::uint32 value);

  // required uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BuyMallItem)
 private:
  inline void set_has_mall_id();
  inline void clear_has_mall_id();
  inline void set_has_item_num();
  inline void clear_has_item_num();

  ::google::protobuf::uint32 mall_id_;
  ::google::protobuf::uint32 item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BuyMallItem* default_instance_;
};
// -------------------------------------------------------------------

class DailyWeekOnline : public ::google::protobuf::MessageLite {
 public:
  DailyWeekOnline();
  virtual ~DailyWeekOnline();

  DailyWeekOnline(const DailyWeekOnline& from);

  inline DailyWeekOnline& operator=(const DailyWeekOnline& from) {
    CopyFrom(from);
    return *this;
  }

  static const DailyWeekOnline& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DailyWeekOnline* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DailyWeekOnline* other);

  // implements Message ----------------------------------------------

  DailyWeekOnline* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DailyWeekOnline& from);
  void MergeFrom(const DailyWeekOnline& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 day_id = 1;
  inline bool has_day_id() const;
  inline void clear_day_id();
  static const int kDayIdFieldNumber = 1;
  inline ::google::protobuf::uint32 day_id() const;
  inline void set_day_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.DailyWeekOnline)
 private:
  inline void set_has_day_id();
  inline void clear_has_day_id();

  ::google::protobuf::uint32 day_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static DailyWeekOnline* default_instance_;
};
// -------------------------------------------------------------------

class GetMonthSignInDataReq : public ::google::protobuf::MessageLite {
 public:
  GetMonthSignInDataReq();
  virtual ~GetMonthSignInDataReq();

  GetMonthSignInDataReq(const GetMonthSignInDataReq& from);

  inline GetMonthSignInDataReq& operator=(const GetMonthSignInDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetMonthSignInDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMonthSignInDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetMonthSignInDataReq* other);

  // implements Message ----------------------------------------------

  GetMonthSignInDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMonthSignInDataReq& from);
  void MergeFrom(const GetMonthSignInDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetMonthSignInDataReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetMonthSignInDataReq* default_instance_;
};
// -------------------------------------------------------------------

class GetMonthSignInDataAck : public ::google::protobuf::MessageLite {
 public:
  GetMonthSignInDataAck();
  virtual ~GetMonthSignInDataAck();

  GetMonthSignInDataAck(const GetMonthSignInDataAck& from);

  inline GetMonthSignInDataAck& operator=(const GetMonthSignInDataAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetMonthSignInDataAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMonthSignInDataAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetMonthSignInDataAck* other);

  // implements Message ----------------------------------------------

  GetMonthSignInDataAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMonthSignInDataAck& from);
  void MergeFrom(const GetMonthSignInDataAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 refresh_time = 1;
  inline bool has_refresh_time() const;
  inline void clear_refresh_time();
  static const int kRefreshTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 refresh_time() const;
  inline void set_refresh_time(::google::protobuf::uint32 value);

  // repeated uint32 item_id = 2;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::uint32 value);
  inline void add_item_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_id();

  // repeated uint32 item_num = 3;
  inline int item_num_size() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 3;
  inline ::google::protobuf::uint32 item_num(int index) const;
  inline void set_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_num();

  // repeated uint32 vip_limit = 4;
  inline int vip_limit_size() const;
  inline void clear_vip_limit();
  static const int kVipLimitFieldNumber = 4;
  inline ::google::protobuf::uint32 vip_limit(int index) const;
  inline void set_vip_limit(int index, ::google::protobuf::uint32 value);
  inline void add_vip_limit(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      vip_limit() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_vip_limit();

  // repeated uint32 reward_times = 5;
  inline int reward_times_size() const;
  inline void clear_reward_times();
  static const int kRewardTimesFieldNumber = 5;
  inline ::google::protobuf::uint32 reward_times(int index) const;
  inline void set_reward_times(int index, ::google::protobuf::uint32 value);
  inline void add_reward_times(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reward_times() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reward_times();

  // repeated uint32 week_item_id = 6;
  inline int week_item_id_size() const;
  inline void clear_week_item_id();
  static const int kWeekItemIdFieldNumber = 6;
  inline ::google::protobuf::uint32 week_item_id(int index) const;
  inline void set_week_item_id(int index, ::google::protobuf::uint32 value);
  inline void add_week_item_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      week_item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_week_item_id();

  // repeated uint32 week_item_num = 7;
  inline int week_item_num_size() const;
  inline void clear_week_item_num();
  static const int kWeekItemNumFieldNumber = 7;
  inline ::google::protobuf::uint32 week_item_num(int index) const;
  inline void set_week_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_week_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      week_item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_week_item_num();

  // @@protoc_insertion_point(class_scope:message.GetMonthSignInDataAck)
 private:
  inline void set_has_refresh_time();
  inline void clear_has_refresh_time();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > vip_limit_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reward_times_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > week_item_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > week_item_num_;
  ::google::protobuf::uint32 refresh_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetMonthSignInDataAck* default_instance_;
};
// -------------------------------------------------------------------

class DailyMonthOnline : public ::google::protobuf::MessageLite {
 public:
  DailyMonthOnline();
  virtual ~DailyMonthOnline();

  DailyMonthOnline(const DailyMonthOnline& from);

  inline DailyMonthOnline& operator=(const DailyMonthOnline& from) {
    CopyFrom(from);
    return *this;
  }

  static const DailyMonthOnline& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DailyMonthOnline* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DailyMonthOnline* other);

  // implements Message ----------------------------------------------

  DailyMonthOnline* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DailyMonthOnline& from);
  void MergeFrom(const DailyMonthOnline& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 day_id = 1;
  inline bool has_day_id() const;
  inline void clear_day_id();
  static const int kDayIdFieldNumber = 1;
  inline ::google::protobuf::uint32 day_id() const;
  inline void set_day_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.DailyMonthOnline)
 private:
  inline void set_has_day_id();
  inline void clear_has_day_id();

  ::google::protobuf::uint32 day_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static DailyMonthOnline* default_instance_;
};
// -------------------------------------------------------------------

class ReqDailyMonthOnlineData : public ::google::protobuf::MessageLite {
 public:
  ReqDailyMonthOnlineData();
  virtual ~ReqDailyMonthOnlineData();

  ReqDailyMonthOnlineData(const ReqDailyMonthOnlineData& from);

  inline ReqDailyMonthOnlineData& operator=(const ReqDailyMonthOnlineData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqDailyMonthOnlineData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqDailyMonthOnlineData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqDailyMonthOnlineData* other);

  // implements Message ----------------------------------------------

  ReqDailyMonthOnlineData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqDailyMonthOnlineData& from);
  void MergeFrom(const ReqDailyMonthOnlineData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 data_id = 1;
  inline bool has_data_id() const;
  inline void clear_data_id();
  static const int kDataIdFieldNumber = 1;
  inline ::google::protobuf::uint32 data_id() const;
  inline void set_data_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqDailyMonthOnlineData)
 private:
  inline void set_has_data_id();
  inline void clear_has_data_id();

  ::google::protobuf::uint32 data_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqDailyMonthOnlineData* default_instance_;
};
// -------------------------------------------------------------------

class AckDailyMonthOnlineData : public ::google::protobuf::MessageLite {
 public:
  AckDailyMonthOnlineData();
  virtual ~AckDailyMonthOnlineData();

  AckDailyMonthOnlineData(const AckDailyMonthOnlineData& from);

  inline AckDailyMonthOnlineData& operator=(const AckDailyMonthOnlineData& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckDailyMonthOnlineData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckDailyMonthOnlineData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckDailyMonthOnlineData* other);

  // implements Message ----------------------------------------------

  AckDailyMonthOnlineData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckDailyMonthOnlineData& from);
  void MergeFrom(const AckDailyMonthOnlineData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes daily_data = 1;
  inline int daily_data_size() const;
  inline void clear_daily_data();
  static const int kDailyDataFieldNumber = 1;
  inline const ::std::string& daily_data(int index) const;
  inline ::std::string* mutable_daily_data(int index);
  inline void set_daily_data(int index, const ::std::string& value);
  inline void set_daily_data(int index, const char* value);
  inline void set_daily_data(int index, const void* value, size_t size);
  inline ::std::string* add_daily_data();
  inline void add_daily_data(const ::std::string& value);
  inline void add_daily_data(const char* value);
  inline void add_daily_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& daily_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_daily_data();

  // @@protoc_insertion_point(class_scope:message.AckDailyMonthOnlineData)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> daily_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckDailyMonthOnlineData* default_instance_;
};
// -------------------------------------------------------------------

class ReqSoulBag : public ::google::protobuf::MessageLite {
 public:
  ReqSoulBag();
  virtual ~ReqSoulBag();

  ReqSoulBag(const ReqSoulBag& from);

  inline ReqSoulBag& operator=(const ReqSoulBag& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqSoulBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqSoulBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqSoulBag* other);

  // implements Message ----------------------------------------------

  ReqSoulBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqSoulBag& from);
  void MergeFrom(const ReqSoulBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 bag_id = 1;
  inline bool has_bag_id() const;
  inline void clear_bag_id();
  static const int kBagIdFieldNumber = 1;
  inline ::google::protobuf::uint32 bag_id() const;
  inline void set_bag_id(::google::protobuf::uint32 value);

  // optional uint32 is_dest = 2;
  inline bool has_is_dest() const;
  inline void clear_is_dest();
  static const int kIsDestFieldNumber = 2;
  inline ::google::protobuf::uint32 is_dest() const;
  inline void set_is_dest(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqSoulBag)
 private:
  inline void set_has_bag_id();
  inline void clear_has_bag_id();
  inline void set_has_is_dest();
  inline void clear_has_is_dest();

  ::google::protobuf::uint32 bag_id_;
  ::google::protobuf::uint32 is_dest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqSoulBag* default_instance_;
};
// -------------------------------------------------------------------

class ReqQuickSoulBag : public ::google::protobuf::MessageLite {
 public:
  ReqQuickSoulBag();
  virtual ~ReqQuickSoulBag();

  ReqQuickSoulBag(const ReqQuickSoulBag& from);

  inline ReqQuickSoulBag& operator=(const ReqQuickSoulBag& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqQuickSoulBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqQuickSoulBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqQuickSoulBag* other);

  // implements Message ----------------------------------------------

  ReqQuickSoulBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqQuickSoulBag& from);
  void MergeFrom(const ReqQuickSoulBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 is_choose = 1;
  inline bool has_is_choose() const;
  inline void clear_is_choose();
  static const int kIsChooseFieldNumber = 1;
  inline ::google::protobuf::uint32 is_choose() const;
  inline void set_is_choose(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqQuickSoulBag)
 private:
  inline void set_has_is_choose();
  inline void clear_has_is_choose();

  ::google::protobuf::uint32 is_choose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqQuickSoulBag* default_instance_;
};
// -------------------------------------------------------------------

class ReqChangeType : public ::google::protobuf::MessageLite {
 public:
  ReqChangeType();
  virtual ~ReqChangeType();

  ReqChangeType(const ReqChangeType& from);

  inline ReqChangeType& operator=(const ReqChangeType& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqChangeType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqChangeType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqChangeType* other);

  // implements Message ----------------------------------------------

  ReqChangeType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqChangeType& from);
  void MergeFrom(const ReqChangeType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqChangeType)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqChangeType* default_instance_;
};
// -------------------------------------------------------------------

class AckSoulBag : public ::google::protobuf::MessageLite {
 public:
  AckSoulBag();
  virtual ~AckSoulBag();

  AckSoulBag(const AckSoulBag& from);

  inline AckSoulBag& operator=(const AckSoulBag& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckSoulBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckSoulBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckSoulBag* other);

  // implements Message ----------------------------------------------

  AckSoulBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckSoulBag& from);
  void MergeFrom(const AckSoulBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 item_id = 1;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::uint32 value);
  inline void add_item_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_id();

  // optional uint32 is_dest = 2;
  inline bool has_is_dest() const;
  inline void clear_is_dest();
  static const int kIsDestFieldNumber = 2;
  inline ::google::protobuf::uint32 is_dest() const;
  inline void set_is_dest(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckSoulBag)
 private:
  inline void set_has_is_dest();
  inline void clear_has_is_dest();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_id_;
  ::google::protobuf::uint32 is_dest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckSoulBag* default_instance_;
};
// -------------------------------------------------------------------

class ReqSoulBagAction : public ::google::protobuf::MessageLite {
 public:
  ReqSoulBagAction();
  virtual ~ReqSoulBagAction();

  ReqSoulBagAction(const ReqSoulBagAction& from);

  inline ReqSoulBagAction& operator=(const ReqSoulBagAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqSoulBagAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqSoulBagAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqSoulBagAction* other);

  // implements Message ----------------------------------------------

  ReqSoulBagAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqSoulBagAction& from);
  void MergeFrom(const ReqSoulBagAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 item_pos = 1;
  inline int item_pos_size() const;
  inline void clear_item_pos();
  static const int kItemPosFieldNumber = 1;
  inline ::google::protobuf::uint32 item_pos(int index) const;
  inline void set_item_pos(int index, ::google::protobuf::uint32 value);
  inline void add_item_pos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_pos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_pos();

  // repeated uint64 item_only_id = 2;
  inline int item_only_id_size() const;
  inline void clear_item_only_id();
  static const int kItemOnlyIdFieldNumber = 2;
  inline ::google::protobuf::uint64 item_only_id(int index) const;
  inline void set_item_only_id(int index, ::google::protobuf::uint64 value);
  inline void add_item_only_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      item_only_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_item_only_id();

  // repeated uint32 oper_id = 3;
  inline int oper_id_size() const;
  inline void clear_oper_id();
  static const int kOperIdFieldNumber = 3;
  inline ::google::protobuf::uint32 oper_id(int index) const;
  inline void set_oper_id(int index, ::google::protobuf::uint32 value);
  inline void add_oper_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      oper_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_oper_id();

  // optional uint32 merc_pos = 4;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 4;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // optional uint32 is_dest = 5;
  inline bool has_is_dest() const;
  inline void clear_is_dest();
  static const int kIsDestFieldNumber = 5;
  inline ::google::protobuf::uint32 is_dest() const;
  inline void set_is_dest(::google::protobuf::uint32 value);

  // optional uint32 item_num = 6;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 6;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqSoulBagAction)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_is_dest();
  inline void clear_has_is_dest();
  inline void set_has_item_num();
  inline void clear_has_item_num();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_pos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > item_only_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > oper_id_;
  ::google::protobuf::uint32 merc_pos_;
  ::google::protobuf::uint32 is_dest_;
  ::google::protobuf::uint32 item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqSoulBagAction* default_instance_;
};
// -------------------------------------------------------------------

class AckSoulBagAction : public ::google::protobuf::MessageLite {
 public:
  AckSoulBagAction();
  virtual ~AckSoulBagAction();

  AckSoulBagAction(const AckSoulBagAction& from);

  inline AckSoulBagAction& operator=(const AckSoulBagAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckSoulBagAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckSoulBagAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckSoulBagAction* other);

  // implements Message ----------------------------------------------

  AckSoulBagAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckSoulBagAction& from);
  void MergeFrom(const AckSoulBagAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 money = 1;
  inline int money_size() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 1;
  inline ::google::protobuf::uint32 money(int index) const;
  inline void set_money(int index, ::google::protobuf::uint32 value);
  inline void add_money(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      money() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_money();

  // repeated uint32 attr_point = 2;
  inline int attr_point_size() const;
  inline void clear_attr_point();
  static const int kAttrPointFieldNumber = 2;
  inline ::google::protobuf::uint32 attr_point(int index) const;
  inline void set_attr_point(int index, ::google::protobuf::uint32 value);
  inline void add_attr_point(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attr_point() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attr_point();

  // repeated uint32 dest_glod = 3;
  inline int dest_glod_size() const;
  inline void clear_dest_glod();
  static const int kDestGlodFieldNumber = 3;
  inline ::google::protobuf::uint32 dest_glod(int index) const;
  inline void set_dest_glod(int index, ::google::protobuf::uint32 value);
  inline void add_dest_glod(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dest_glod() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dest_glod();

  // @@protoc_insertion_point(class_scope:message.AckSoulBagAction)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > money_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attr_point_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dest_glod_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckSoulBagAction* default_instance_;
};
// -------------------------------------------------------------------

class ReqSoulCombine : public ::google::protobuf::MessageLite {
 public:
  ReqSoulCombine();
  virtual ~ReqSoulCombine();

  ReqSoulCombine(const ReqSoulCombine& from);

  inline ReqSoulCombine& operator=(const ReqSoulCombine& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqSoulCombine& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqSoulCombine* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqSoulCombine* other);

  // implements Message ----------------------------------------------

  ReqSoulCombine* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqSoulCombine& from);
  void MergeFrom(const ReqSoulCombine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 combine_id = 1;
  inline bool has_combine_id() const;
  inline void clear_combine_id();
  static const int kCombineIdFieldNumber = 1;
  inline ::google::protobuf::uint32 combine_id() const;
  inline void set_combine_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqSoulCombine)
 private:
  inline void set_has_combine_id();
  inline void clear_has_combine_id();

  ::google::protobuf::uint32 combine_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqSoulCombine* default_instance_;
};
// -------------------------------------------------------------------

class ReqPlatMoney : public ::google::protobuf::MessageLite {
 public:
  ReqPlatMoney();
  virtual ~ReqPlatMoney();

  ReqPlatMoney(const ReqPlatMoney& from);

  inline ReqPlatMoney& operator=(const ReqPlatMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqPlatMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqPlatMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqPlatMoney* other);

  // implements Message ----------------------------------------------

  ReqPlatMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqPlatMoney& from);
  void MergeFrom(const ReqPlatMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // required bytes order_id = 2;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 2;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const void* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // @@protoc_insertion_point(class_scope:message.ReqPlatMoney)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();

  ::std::string* order_id_;
  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqPlatMoney* default_instance_;
};
// -------------------------------------------------------------------

class ReqPlatOrderID : public ::google::protobuf::MessageLite {
 public:
  ReqPlatOrderID();
  virtual ~ReqPlatOrderID();

  ReqPlatOrderID(const ReqPlatOrderID& from);

  inline ReqPlatOrderID& operator=(const ReqPlatOrderID& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqPlatOrderID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqPlatOrderID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqPlatOrderID* other);

  // implements Message ----------------------------------------------

  ReqPlatOrderID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqPlatOrderID& from);
  void MergeFrom(const ReqPlatOrderID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqPlatOrderID)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::uint32 app_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqPlatOrderID* default_instance_;
};
// -------------------------------------------------------------------

class AckPlatOrderID : public ::google::protobuf::MessageLite {
 public:
  AckPlatOrderID();
  virtual ~AckPlatOrderID();

  AckPlatOrderID(const AckPlatOrderID& from);

  inline AckPlatOrderID& operator=(const AckPlatOrderID& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckPlatOrderID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckPlatOrderID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckPlatOrderID* other);

  // implements Message ----------------------------------------------

  AckPlatOrderID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckPlatOrderID& from);
  void MergeFrom(const AckPlatOrderID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 order_id = 1;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 1;
  inline ::google::protobuf::uint64 order_id() const;
  inline void set_order_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:message.AckPlatOrderID)
 private:
  inline void set_has_order_id();
  inline void clear_has_order_id();

  ::google::protobuf::uint64 order_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckPlatOrderID* default_instance_;
};
// -------------------------------------------------------------------

class ReqAddStamina : public ::google::protobuf::MessageLite {
 public:
  ReqAddStamina();
  virtual ~ReqAddStamina();

  ReqAddStamina(const ReqAddStamina& from);

  inline ReqAddStamina& operator=(const ReqAddStamina& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqAddStamina& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqAddStamina* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqAddStamina* other);

  // implements Message ----------------------------------------------

  ReqAddStamina* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqAddStamina& from);
  void MergeFrom(const ReqAddStamina& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 stamina = 1;
  inline bool has_stamina() const;
  inline void clear_stamina();
  static const int kStaminaFieldNumber = 1;
  inline ::google::protobuf::uint32 stamina() const;
  inline void set_stamina(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqAddStamina)
 private:
  inline void set_has_stamina();
  inline void clear_has_stamina();

  ::google::protobuf::uint32 stamina_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqAddStamina* default_instance_;
};
// -------------------------------------------------------------------

class OfflineTrainMercenary : public ::google::protobuf::MessageLite {
 public:
  OfflineTrainMercenary();
  virtual ~OfflineTrainMercenary();

  OfflineTrainMercenary(const OfflineTrainMercenary& from);

  inline OfflineTrainMercenary& operator=(const OfflineTrainMercenary& from) {
    CopyFrom(from);
    return *this;
  }

  static const OfflineTrainMercenary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OfflineTrainMercenary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OfflineTrainMercenary* other);

  // implements Message ----------------------------------------------

  OfflineTrainMercenary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OfflineTrainMercenary& from);
  void MergeFrom(const OfflineTrainMercenary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nmercpos = 1;
  inline bool has_nmercpos() const;
  inline void clear_nmercpos();
  static const int kNmercposFieldNumber = 1;
  inline ::google::protobuf::uint32 nmercpos() const;
  inline void set_nmercpos(::google::protobuf::uint32 value);

  // required uint32 ntraintype = 2;
  inline bool has_ntraintype() const;
  inline void clear_ntraintype();
  static const int kNtraintypeFieldNumber = 2;
  inline ::google::protobuf::uint32 ntraintype() const;
  inline void set_ntraintype(::google::protobuf::uint32 value);

  // required uint32 nfriendid = 3;
  inline bool has_nfriendid() const;
  inline void clear_nfriendid();
  static const int kNfriendidFieldNumber = 3;
  inline ::google::protobuf::uint32 nfriendid() const;
  inline void set_nfriendid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.OfflineTrainMercenary)
 private:
  inline void set_has_nmercpos();
  inline void clear_has_nmercpos();
  inline void set_has_ntraintype();
  inline void clear_has_ntraintype();
  inline void set_has_nfriendid();
  inline void clear_has_nfriendid();

  ::google::protobuf::uint32 nmercpos_;
  ::google::protobuf::uint32 ntraintype_;
  ::google::protobuf::uint32 nfriendid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OfflineTrainMercenary* default_instance_;
};
// -------------------------------------------------------------------

class OfflineOper : public ::google::protobuf::MessageLite {
 public:
  OfflineOper();
  virtual ~OfflineOper();

  OfflineOper(const OfflineOper& from);

  inline OfflineOper& operator=(const OfflineOper& from) {
    CopyFrom(from);
    return *this;
  }

  static const OfflineOper& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OfflineOper* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OfflineOper* other);

  // implements Message ----------------------------------------------

  OfflineOper* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OfflineOper& from);
  void MergeFrom(const OfflineOper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_char_id = 1;
  inline bool has_from_char_id() const;
  inline void clear_from_char_id();
  static const int kFromCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_char_id() const;
  inline void set_from_char_id(::google::protobuf::uint32 value);

  // required uint32 to_char_id = 2;
  inline bool has_to_char_id() const;
  inline void clear_to_char_id();
  static const int kToCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_char_id() const;
  inline void set_to_char_id(::google::protobuf::uint32 value);

  // required uint32 oper_id = 3;
  inline bool has_oper_id() const;
  inline void clear_oper_id();
  static const int kOperIdFieldNumber = 3;
  inline ::google::protobuf::uint32 oper_id() const;
  inline void set_oper_id(::google::protobuf::uint32 value);

  // required uint32 oper_value1 = 4;
  inline bool has_oper_value1() const;
  inline void clear_oper_value1();
  static const int kOperValue1FieldNumber = 4;
  inline ::google::protobuf::uint32 oper_value1() const;
  inline void set_oper_value1(::google::protobuf::uint32 value);

  // required uint32 oper_value2 = 5;
  inline bool has_oper_value2() const;
  inline void clear_oper_value2();
  static const int kOperValue2FieldNumber = 5;
  inline ::google::protobuf::uint32 oper_value2() const;
  inline void set_oper_value2(::google::protobuf::uint32 value);

  // required uint32 oper_pos = 6;
  inline bool has_oper_pos() const;
  inline void clear_oper_pos();
  static const int kOperPosFieldNumber = 6;
  inline ::google::protobuf::uint32 oper_pos() const;
  inline void set_oper_pos(::google::protobuf::uint32 value);

  // required uint64 oper_time = 7;
  inline bool has_oper_time() const;
  inline void clear_oper_time();
  static const int kOperTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 oper_time() const;
  inline void set_oper_time(::google::protobuf::uint64 value);

  // optional uint32 mode_id = 8;
  inline bool has_mode_id() const;
  inline void clear_mode_id();
  static const int kModeIdFieldNumber = 8;
  inline ::google::protobuf::uint32 mode_id() const;
  inline void set_mode_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.OfflineOper)
 private:
  inline void set_has_from_char_id();
  inline void clear_has_from_char_id();
  inline void set_has_to_char_id();
  inline void clear_has_to_char_id();
  inline void set_has_oper_id();
  inline void clear_has_oper_id();
  inline void set_has_oper_value1();
  inline void clear_has_oper_value1();
  inline void set_has_oper_value2();
  inline void clear_has_oper_value2();
  inline void set_has_oper_pos();
  inline void clear_has_oper_pos();
  inline void set_has_oper_time();
  inline void clear_has_oper_time();
  inline void set_has_mode_id();
  inline void clear_has_mode_id();

  ::google::protobuf::uint32 from_char_id_;
  ::google::protobuf::uint32 to_char_id_;
  ::google::protobuf::uint32 oper_id_;
  ::google::protobuf::uint32 oper_value1_;
  ::google::protobuf::uint32 oper_value2_;
  ::google::protobuf::uint32 oper_pos_;
  ::google::protobuf::uint64 oper_time_;
  ::google::protobuf::uint32 mode_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OfflineOper* default_instance_;
};
// -------------------------------------------------------------------

class ReqOfflineOperList : public ::google::protobuf::MessageLite {
 public:
  ReqOfflineOperList();
  virtual ~ReqOfflineOperList();

  ReqOfflineOperList(const ReqOfflineOperList& from);

  inline ReqOfflineOperList& operator=(const ReqOfflineOperList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqOfflineOperList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqOfflineOperList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqOfflineOperList* other);

  // implements Message ----------------------------------------------

  ReqOfflineOperList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqOfflineOperList& from);
  void MergeFrom(const ReqOfflineOperList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // repeated uint32 char_id = 2;
  inline int char_id_size() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id(int index) const;
  inline void set_char_id(int index, ::google::protobuf::uint32 value);
  inline void add_char_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      char_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_char_id();

  // optional uint32 is_delete = 3;
  inline bool has_is_delete() const;
  inline void clear_is_delete();
  static const int kIsDeleteFieldNumber = 3;
  inline ::google::protobuf::uint32 is_delete() const;
  inline void set_is_delete(::google::protobuf::uint32 value);

  // optional uint32 oper_id = 4;
  inline bool has_oper_id() const;
  inline void clear_oper_id();
  static const int kOperIdFieldNumber = 4;
  inline ::google::protobuf::uint32 oper_id() const;
  inline void set_oper_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqOfflineOperList)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_is_delete();
  inline void clear_has_is_delete();
  inline void set_has_oper_id();
  inline void clear_has_oper_id();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > char_id_;
  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 is_delete_;
  ::google::protobuf::uint32 oper_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqOfflineOperList* default_instance_;
};
// -------------------------------------------------------------------

class AckOfflineOperList : public ::google::protobuf::MessageLite {
 public:
  AckOfflineOperList();
  virtual ~AckOfflineOperList();

  AckOfflineOperList(const AckOfflineOperList& from);

  inline AckOfflineOperList& operator=(const AckOfflineOperList& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckOfflineOperList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckOfflineOperList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckOfflineOperList* other);

  // implements Message ----------------------------------------------

  AckOfflineOperList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckOfflineOperList& from);
  void MergeFrom(const AckOfflineOperList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 from_char_id = 1;
  inline int from_char_id_size() const;
  inline void clear_from_char_id();
  static const int kFromCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_char_id(int index) const;
  inline void set_from_char_id(int index, ::google::protobuf::uint32 value);
  inline void add_from_char_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      from_char_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_from_char_id();

  // repeated uint32 to_char_id = 2;
  inline int to_char_id_size() const;
  inline void clear_to_char_id();
  static const int kToCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_char_id(int index) const;
  inline void set_to_char_id(int index, ::google::protobuf::uint32 value);
  inline void add_to_char_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      to_char_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_to_char_id();

  // repeated uint32 oper_id = 3;
  inline int oper_id_size() const;
  inline void clear_oper_id();
  static const int kOperIdFieldNumber = 3;
  inline ::google::protobuf::uint32 oper_id(int index) const;
  inline void set_oper_id(int index, ::google::protobuf::uint32 value);
  inline void add_oper_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      oper_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_oper_id();

  // repeated uint32 oper_value1 = 4;
  inline int oper_value1_size() const;
  inline void clear_oper_value1();
  static const int kOperValue1FieldNumber = 4;
  inline ::google::protobuf::uint32 oper_value1(int index) const;
  inline void set_oper_value1(int index, ::google::protobuf::uint32 value);
  inline void add_oper_value1(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      oper_value1() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_oper_value1();

  // repeated uint32 oper_value2 = 5;
  inline int oper_value2_size() const;
  inline void clear_oper_value2();
  static const int kOperValue2FieldNumber = 5;
  inline ::google::protobuf::uint32 oper_value2(int index) const;
  inline void set_oper_value2(int index, ::google::protobuf::uint32 value);
  inline void add_oper_value2(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      oper_value2() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_oper_value2();

  // repeated uint32 oper_pos = 6;
  inline int oper_pos_size() const;
  inline void clear_oper_pos();
  static const int kOperPosFieldNumber = 6;
  inline ::google::protobuf::uint32 oper_pos(int index) const;
  inline void set_oper_pos(int index, ::google::protobuf::uint32 value);
  inline void add_oper_pos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      oper_pos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_oper_pos();

  // repeated uint64 oper_time = 7;
  inline int oper_time_size() const;
  inline void clear_oper_time();
  static const int kOperTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 oper_time(int index) const;
  inline void set_oper_time(int index, ::google::protobuf::uint64 value);
  inline void add_oper_time(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      oper_time() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_oper_time();

  // repeated uint32 mode_id = 8;
  inline int mode_id_size() const;
  inline void clear_mode_id();
  static const int kModeIdFieldNumber = 8;
  inline ::google::protobuf::uint32 mode_id(int index) const;
  inline void set_mode_id(int index, ::google::protobuf::uint32 value);
  inline void add_mode_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      mode_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_mode_id();

  // repeated bytes sys_msg = 9;
  inline int sys_msg_size() const;
  inline void clear_sys_msg();
  static const int kSysMsgFieldNumber = 9;
  inline const ::std::string& sys_msg(int index) const;
  inline ::std::string* mutable_sys_msg(int index);
  inline void set_sys_msg(int index, const ::std::string& value);
  inline void set_sys_msg(int index, const char* value);
  inline void set_sys_msg(int index, const void* value, size_t size);
  inline ::std::string* add_sys_msg();
  inline void add_sys_msg(const ::std::string& value);
  inline void add_sys_msg(const char* value);
  inline void add_sys_msg(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sys_msg() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sys_msg();

  // @@protoc_insertion_point(class_scope:message.AckOfflineOperList)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > from_char_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > to_char_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > oper_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > oper_value1_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > oper_value2_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > oper_pos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > oper_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > mode_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sys_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckOfflineOperList* default_instance_;
};
// -------------------------------------------------------------------

class ReqActiveCode : public ::google::protobuf::MessageLite {
 public:
  ReqActiveCode();
  virtual ~ReqActiveCode();

  ReqActiveCode(const ReqActiveCode& from);

  inline ReqActiveCode& operator=(const ReqActiveCode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqActiveCode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqActiveCode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqActiveCode* other);

  // implements Message ----------------------------------------------

  ReqActiveCode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqActiveCode& from);
  void MergeFrom(const ReqActiveCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes code = 1;
  inline int code_size() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code(int index) const;
  inline ::std::string* mutable_code(int index);
  inline void set_code(int index, const ::std::string& value);
  inline void set_code(int index, const char* value);
  inline void set_code(int index, const void* value, size_t size);
  inline ::std::string* add_code();
  inline void add_code(const ::std::string& value);
  inline void add_code(const char* value);
  inline void add_code(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& code() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_code();

  // optional int32 is_invite = 2;
  inline bool has_is_invite() const;
  inline void clear_is_invite();
  static const int kIsInviteFieldNumber = 2;
  inline ::google::protobuf::int32 is_invite() const;
  inline void set_is_invite(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.ReqActiveCode)
 private:
  inline void set_has_is_invite();
  inline void clear_has_is_invite();

  ::google::protobuf::RepeatedPtrField< ::std::string> code_;
  ::google::protobuf::int32 is_invite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqActiveCode* default_instance_;
};
// -------------------------------------------------------------------

class ReqServerActiveCode : public ::google::protobuf::MessageLite {
 public:
  ReqServerActiveCode();
  virtual ~ReqServerActiveCode();

  ReqServerActiveCode(const ReqServerActiveCode& from);

  inline ReqServerActiveCode& operator=(const ReqServerActiveCode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqServerActiveCode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqServerActiveCode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqServerActiveCode* other);

  // implements Message ----------------------------------------------

  ReqServerActiveCode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqServerActiveCode& from);
  void MergeFrom(const ReqServerActiveCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes code = 1;
  inline int code_size() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code(int index) const;
  inline ::std::string* mutable_code(int index);
  inline void set_code(int index, const ::std::string& value);
  inline void set_code(int index, const char* value);
  inline void set_code(int index, const void* value, size_t size);
  inline ::std::string* add_code();
  inline void add_code(const ::std::string& value);
  inline void add_code(const char* value);
  inline void add_code(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& code() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_code();

  // optional uint32 is_delete = 2;
  inline bool has_is_delete() const;
  inline void clear_is_delete();
  static const int kIsDeleteFieldNumber = 2;
  inline ::google::protobuf::uint32 is_delete() const;
  inline void set_is_delete(::google::protobuf::uint32 value);

  // optional uint32 item_id = 3;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 3;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // optional uint32 is_invite = 4;
  inline bool has_is_invite() const;
  inline void clear_is_invite();
  static const int kIsInviteFieldNumber = 4;
  inline ::google::protobuf::uint32 is_invite() const;
  inline void set_is_invite(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqServerActiveCode)
 private:
  inline void set_has_is_delete();
  inline void clear_has_is_delete();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_is_invite();
  inline void clear_has_is_invite();

  ::google::protobuf::RepeatedPtrField< ::std::string> code_;
  ::google::protobuf::uint32 is_delete_;
  ::google::protobuf::uint32 item_id_;
  ::google::protobuf::uint32 is_invite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqServerActiveCode* default_instance_;
};
// -------------------------------------------------------------------

class AckServerActiveCode : public ::google::protobuf::MessageLite {
 public:
  AckServerActiveCode();
  virtual ~AckServerActiveCode();

  AckServerActiveCode(const AckServerActiveCode& from);

  inline AckServerActiveCode& operator=(const AckServerActiveCode& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckServerActiveCode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckServerActiveCode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckServerActiveCode* other);

  // implements Message ----------------------------------------------

  AckServerActiveCode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckServerActiveCode& from);
  void MergeFrom(const AckServerActiveCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // optional uint32 is_invite = 2;
  inline bool has_is_invite() const;
  inline void clear_is_invite();
  static const int kIsInviteFieldNumber = 2;
  inline ::google::protobuf::uint32 is_invite() const;
  inline void set_is_invite(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckServerActiveCode)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_is_invite();
  inline void clear_has_is_invite();

  ::google::protobuf::uint32 item_id_;
  ::google::protobuf::uint32 is_invite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckServerActiveCode* default_instance_;
};
// -------------------------------------------------------------------

class ReqRefreshGate : public ::google::protobuf::MessageLite {
 public:
  ReqRefreshGate();
  virtual ~ReqRefreshGate();

  ReqRefreshGate(const ReqRefreshGate& from);

  inline ReqRefreshGate& operator=(const ReqRefreshGate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqRefreshGate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqRefreshGate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqRefreshGate* other);

  // implements Message ----------------------------------------------

  ReqRefreshGate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqRefreshGate& from);
  void MergeFrom(const ReqRefreshGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 refresh_gate = 1;
  inline bool has_refresh_gate() const;
  inline void clear_refresh_gate();
  static const int kRefreshGateFieldNumber = 1;
  inline ::google::protobuf::uint32 refresh_gate() const;
  inline void set_refresh_gate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqRefreshGate)
 private:
  inline void set_has_refresh_gate();
  inline void clear_has_refresh_gate();

  ::google::protobuf::uint32 refresh_gate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqRefreshGate* default_instance_;
};
// -------------------------------------------------------------------

class RefreshGateCost : public ::google::protobuf::MessageLite {
 public:
  RefreshGateCost();
  virtual ~RefreshGateCost();

  RefreshGateCost(const RefreshGateCost& from);

  inline RefreshGateCost& operator=(const RefreshGateCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const RefreshGateCost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RefreshGateCost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RefreshGateCost* other);

  // implements Message ----------------------------------------------

  RefreshGateCost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RefreshGateCost& from);
  void MergeFrom(const RefreshGateCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cost = 1;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 1;
  inline ::google::protobuf::uint32 cost() const;
  inline void set_cost(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.RefreshGateCost)
 private:
  inline void set_has_cost();
  inline void clear_has_cost();

  ::google::protobuf::uint32 cost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RefreshGateCost* default_instance_;
};
// -------------------------------------------------------------------

class RefreshGate : public ::google::protobuf::MessageLite {
 public:
  RefreshGate();
  virtual ~RefreshGate();

  RefreshGate(const RefreshGate& from);

  inline RefreshGate& operator=(const RefreshGate& from) {
    CopyFrom(from);
    return *this;
  }

  static const RefreshGate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RefreshGate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RefreshGate* other);

  // implements Message ----------------------------------------------

  RefreshGate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RefreshGate& from);
  void MergeFrom(const RefreshGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.RefreshGate)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RefreshGate* default_instance_;
};
// -------------------------------------------------------------------

class ReqGateLevelUp : public ::google::protobuf::MessageLite {
 public:
  ReqGateLevelUp();
  virtual ~ReqGateLevelUp();

  ReqGateLevelUp(const ReqGateLevelUp& from);

  inline ReqGateLevelUp& operator=(const ReqGateLevelUp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqGateLevelUp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqGateLevelUp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqGateLevelUp* other);

  // implements Message ----------------------------------------------

  ReqGateLevelUp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqGateLevelUp& from);
  void MergeFrom(const ReqGateLevelUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 gate_num = 2;
  inline bool has_gate_num() const;
  inline void clear_gate_num();
  static const int kGateNumFieldNumber = 2;
  inline ::google::protobuf::uint32 gate_num() const;
  inline void set_gate_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqGateLevelUp)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_gate_num();
  inline void clear_has_gate_num();

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 gate_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqGateLevelUp* default_instance_;
};
// -------------------------------------------------------------------

class ReqChooseBigGate : public ::google::protobuf::MessageLite {
 public:
  ReqChooseBigGate();
  virtual ~ReqChooseBigGate();

  ReqChooseBigGate(const ReqChooseBigGate& from);

  inline ReqChooseBigGate& operator=(const ReqChooseBigGate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqChooseBigGate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqChooseBigGate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqChooseBigGate* other);

  // implements Message ----------------------------------------------

  ReqChooseBigGate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqChooseBigGate& from);
  void MergeFrom(const ReqChooseBigGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 oper_type = 1;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 oper_type() const;
  inline void set_oper_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqChooseBigGate)
 private:
  inline void set_has_oper_type();
  inline void clear_has_oper_type();

  ::google::protobuf::uint32 oper_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqChooseBigGate* default_instance_;
};
// -------------------------------------------------------------------

class ReqMercenaryUpgrade : public ::google::protobuf::MessageLite {
 public:
  ReqMercenaryUpgrade();
  virtual ~ReqMercenaryUpgrade();

  ReqMercenaryUpgrade(const ReqMercenaryUpgrade& from);

  inline ReqMercenaryUpgrade& operator=(const ReqMercenaryUpgrade& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqMercenaryUpgrade& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqMercenaryUpgrade* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqMercenaryUpgrade* other);

  // implements Message ----------------------------------------------

  ReqMercenaryUpgrade* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqMercenaryUpgrade& from);
  void MergeFrom(const ReqMercenaryUpgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqMercenaryUpgrade)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqMercenaryUpgrade* default_instance_;
};
// -------------------------------------------------------------------

class ReqLadderReward : public ::google::protobuf::MessageLite {
 public:
  ReqLadderReward();
  virtual ~ReqLadderReward();

  ReqLadderReward(const ReqLadderReward& from);

  inline ReqLadderReward& operator=(const ReqLadderReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqLadderReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqLadderReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqLadderReward* other);

  // implements Message ----------------------------------------------

  ReqLadderReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqLadderReward& from);
  void MergeFrom(const ReqLadderReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqLadderReward)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqLadderReward* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetLevelReward : public ::google::protobuf::MessageLite {
 public:
  ReqGetLevelReward();
  virtual ~ReqGetLevelReward();

  ReqGetLevelReward(const ReqGetLevelReward& from);

  inline ReqGetLevelReward& operator=(const ReqGetLevelReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqGetLevelReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqGetLevelReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqGetLevelReward* other);

  // implements Message ----------------------------------------------

  ReqGetLevelReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqGetLevelReward& from);
  void MergeFrom(const ReqGetLevelReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqGetLevelReward)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqGetLevelReward* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetActiveReward : public ::google::protobuf::MessageLite {
 public:
  ReqGetActiveReward();
  virtual ~ReqGetActiveReward();

  ReqGetActiveReward(const ReqGetActiveReward& from);

  inline ReqGetActiveReward& operator=(const ReqGetActiveReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqGetActiveReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqGetActiveReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqGetActiveReward* other);

  // implements Message ----------------------------------------------

  ReqGetActiveReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqGetActiveReward& from);
  void MergeFrom(const ReqGetActiveReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqGetActiveReward)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqGetActiveReward* default_instance_;
};
// -------------------------------------------------------------------

class RechargeLogInfo : public ::google::protobuf::MessageLite {
 public:
  RechargeLogInfo();
  virtual ~RechargeLogInfo();

  RechargeLogInfo(const RechargeLogInfo& from);

  inline RechargeLogInfo& operator=(const RechargeLogInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RechargeLogInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RechargeLogInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RechargeLogInfo* other);

  // implements Message ----------------------------------------------

  RechargeLogInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RechargeLogInfo& from);
  void MergeFrom(const RechargeLogInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 recharge_platid = 3;
  inline bool has_recharge_platid() const;
  inline void clear_recharge_platid();
  static const int kRechargePlatidFieldNumber = 3;
  inline ::google::protobuf::uint32 recharge_platid() const;
  inline void set_recharge_platid(::google::protobuf::uint32 value);

  // optional uint32 recharge_amount = 4;
  inline bool has_recharge_amount() const;
  inline void clear_recharge_amount();
  static const int kRechargeAmountFieldNumber = 4;
  inline ::google::protobuf::uint32 recharge_amount() const;
  inline void set_recharge_amount(::google::protobuf::uint32 value);

  // optional bytes char_name = 5;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 5;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // optional bytes recharge_time = 6;
  inline bool has_recharge_time() const;
  inline void clear_recharge_time();
  static const int kRechargeTimeFieldNumber = 6;
  inline const ::std::string& recharge_time() const;
  inline void set_recharge_time(const ::std::string& value);
  inline void set_recharge_time(const char* value);
  inline void set_recharge_time(const void* value, size_t size);
  inline ::std::string* mutable_recharge_time();
  inline ::std::string* release_recharge_time();
  inline void set_allocated_recharge_time(::std::string* recharge_time);

  // @@protoc_insertion_point(class_scope:message.RechargeLogInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_recharge_platid();
  inline void clear_has_recharge_platid();
  inline void set_has_recharge_amount();
  inline void clear_has_recharge_amount();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_recharge_time();
  inline void clear_has_recharge_time();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 recharge_platid_;
  ::google::protobuf::uint32 recharge_amount_;
  ::std::string* char_name_;
  ::std::string* recharge_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RechargeLogInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResetByDay : public ::google::protobuf::MessageLite {
 public:
  ResetByDay();
  virtual ~ResetByDay();

  ResetByDay(const ResetByDay& from);

  inline ResetByDay& operator=(const ResetByDay& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResetByDay& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResetByDay* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResetByDay* other);

  // implements Message ----------------------------------------------

  ResetByDay* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResetByDay& from);
  void MergeFrom(const ResetByDay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool isDailyOnline = 1;
  inline bool has_isdailyonline() const;
  inline void clear_isdailyonline();
  static const int kIsDailyOnlineFieldNumber = 1;
  inline bool isdailyonline() const;
  inline void set_isdailyonline(bool value);

  // @@protoc_insertion_point(class_scope:message.ResetByDay)
 private:
  inline void set_has_isdailyonline();
  inline void clear_has_isdailyonline();

  bool isdailyonline_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ResetByDay* default_instance_;
};
// -------------------------------------------------------------------

class UserBehaviorLogInfo : public ::google::protobuf::MessageLite {
 public:
  UserBehaviorLogInfo();
  virtual ~UserBehaviorLogInfo();

  UserBehaviorLogInfo(const UserBehaviorLogInfo& from);

  inline UserBehaviorLogInfo& operator=(const UserBehaviorLogInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserBehaviorLogInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserBehaviorLogInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserBehaviorLogInfo* other);

  // implements Message ----------------------------------------------

  UserBehaviorLogInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserBehaviorLogInfo& from);
  void MergeFrom(const UserBehaviorLogInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 enum_intent = 3;
  inline bool has_enum_intent() const;
  inline void clear_enum_intent();
  static const int kEnumIntentFieldNumber = 3;
  inline ::google::protobuf::uint32 enum_intent() const;
  inline void set_enum_intent(::google::protobuf::uint32 value);

  // optional uint32 enum_oper = 4;
  inline bool has_enum_oper() const;
  inline void clear_enum_oper();
  static const int kEnumOperFieldNumber = 4;
  inline ::google::protobuf::uint32 enum_oper() const;
  inline void set_enum_oper(::google::protobuf::uint32 value);

  // optional uint32 enum_attr = 5;
  inline bool has_enum_attr() const;
  inline void clear_enum_attr();
  static const int kEnumAttrFieldNumber = 5;
  inline ::google::protobuf::uint32 enum_attr() const;
  inline void set_enum_attr(::google::protobuf::uint32 value);

  // optional uint32 attr_amount = 6;
  inline bool has_attr_amount() const;
  inline void clear_attr_amount();
  static const int kAttrAmountFieldNumber = 6;
  inline ::google::protobuf::uint32 attr_amount() const;
  inline void set_attr_amount(::google::protobuf::uint32 value);

  // optional uint32 item_amount = 7;
  inline bool has_item_amount() const;
  inline void clear_item_amount();
  static const int kItemAmountFieldNumber = 7;
  inline ::google::protobuf::uint32 item_amount() const;
  inline void set_item_amount(::google::protobuf::uint32 value);

  // optional uint32 item_id = 8;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 8;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // optional uint32 pre_amount = 9;
  inline bool has_pre_amount() const;
  inline void clear_pre_amount();
  static const int kPreAmountFieldNumber = 9;
  inline ::google::protobuf::uint32 pre_amount() const;
  inline void set_pre_amount(::google::protobuf::uint32 value);

  // optional uint32 after_amount = 10;
  inline bool has_after_amount() const;
  inline void clear_after_amount();
  static const int kAfterAmountFieldNumber = 10;
  inline ::google::protobuf::uint32 after_amount() const;
  inline void set_after_amount(::google::protobuf::uint32 value);

  // optional bytes char_name = 11;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 11;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // optional bytes behavior_time = 12;
  inline bool has_behavior_time() const;
  inline void clear_behavior_time();
  static const int kBehaviorTimeFieldNumber = 12;
  inline const ::std::string& behavior_time() const;
  inline void set_behavior_time(const ::std::string& value);
  inline void set_behavior_time(const char* value);
  inline void set_behavior_time(const void* value, size_t size);
  inline ::std::string* mutable_behavior_time();
  inline ::std::string* release_behavior_time();
  inline void set_allocated_behavior_time(::std::string* behavior_time);

  // @@protoc_insertion_point(class_scope:message.UserBehaviorLogInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_enum_intent();
  inline void clear_has_enum_intent();
  inline void set_has_enum_oper();
  inline void clear_has_enum_oper();
  inline void set_has_enum_attr();
  inline void clear_has_enum_attr();
  inline void set_has_attr_amount();
  inline void clear_has_attr_amount();
  inline void set_has_item_amount();
  inline void clear_has_item_amount();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_pre_amount();
  inline void clear_has_pre_amount();
  inline void set_has_after_amount();
  inline void clear_has_after_amount();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_behavior_time();
  inline void clear_has_behavior_time();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 enum_intent_;
  ::google::protobuf::uint32 enum_oper_;
  ::google::protobuf::uint32 enum_attr_;
  ::google::protobuf::uint32 attr_amount_;
  ::google::protobuf::uint32 item_amount_;
  ::google::protobuf::uint32 item_id_;
  ::google::protobuf::uint32 pre_amount_;
  ::google::protobuf::uint32 after_amount_;
  ::std::string* char_name_;
  ::std::string* behavior_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UserBehaviorLogInfo* default_instance_;
};
// -------------------------------------------------------------------

class OnlineNumberInfo : public ::google::protobuf::MessageLite {
 public:
  OnlineNumberInfo();
  virtual ~OnlineNumberInfo();

  OnlineNumberInfo(const OnlineNumberInfo& from);

  inline OnlineNumberInfo& operator=(const OnlineNumberInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const OnlineNumberInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OnlineNumberInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OnlineNumberInfo* other);

  // implements Message ----------------------------------------------

  OnlineNumberInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OnlineNumberInfo& from);
  void MergeFrom(const OnlineNumberInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 online_num = 2;
  inline bool has_online_num() const;
  inline void clear_online_num();
  static const int kOnlineNumFieldNumber = 2;
  inline ::google::protobuf::uint32 online_num() const;
  inline void set_online_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.OnlineNumberInfo)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_online_num();
  inline void clear_has_online_num();

  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 online_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OnlineNumberInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqVIPOperation : public ::google::protobuf::MessageLite {
 public:
  ReqVIPOperation();
  virtual ~ReqVIPOperation();

  ReqVIPOperation(const ReqVIPOperation& from);

  inline ReqVIPOperation& operator=(const ReqVIPOperation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqVIPOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqVIPOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqVIPOperation* other);

  // implements Message ----------------------------------------------

  ReqVIPOperation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqVIPOperation& from);
  void MergeFrom(const ReqVIPOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 oper_id = 1;
  inline bool has_oper_id() const;
  inline void clear_oper_id();
  static const int kOperIdFieldNumber = 1;
  inline ::google::protobuf::uint32 oper_id() const;
  inline void set_oper_id(::google::protobuf::uint32 value);

  // optional uint32 oper_value1 = 2;
  inline bool has_oper_value1() const;
  inline void clear_oper_value1();
  static const int kOperValue1FieldNumber = 2;
  inline ::google::protobuf::uint32 oper_value1() const;
  inline void set_oper_value1(::google::protobuf::uint32 value);

  // optional uint32 oper_value2 = 3;
  inline bool has_oper_value2() const;
  inline void clear_oper_value2();
  static const int kOperValue2FieldNumber = 3;
  inline ::google::protobuf::uint32 oper_value2() const;
  inline void set_oper_value2(::google::protobuf::uint32 value);

  // optional uint32 oper_value3 = 4;
  inline bool has_oper_value3() const;
  inline void clear_oper_value3();
  static const int kOperValue3FieldNumber = 4;
  inline ::google::protobuf::uint32 oper_value3() const;
  inline void set_oper_value3(::google::protobuf::uint32 value);

  // optional uint32 oper_value4 = 5;
  inline bool has_oper_value4() const;
  inline void clear_oper_value4();
  static const int kOperValue4FieldNumber = 5;
  inline ::google::protobuf::uint32 oper_value4() const;
  inline void set_oper_value4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqVIPOperation)
 private:
  inline void set_has_oper_id();
  inline void clear_has_oper_id();
  inline void set_has_oper_value1();
  inline void clear_has_oper_value1();
  inline void set_has_oper_value2();
  inline void clear_has_oper_value2();
  inline void set_has_oper_value3();
  inline void clear_has_oper_value3();
  inline void set_has_oper_value4();
  inline void clear_has_oper_value4();

  ::google::protobuf::uint32 oper_id_;
  ::google::protobuf::uint32 oper_value1_;
  ::google::protobuf::uint32 oper_value2_;
  ::google::protobuf::uint32 oper_value3_;
  ::google::protobuf::uint32 oper_value4_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqVIPOperation* default_instance_;
};
// -------------------------------------------------------------------

class UserFeedback_UserFeedbackInfo : public ::google::protobuf::MessageLite {
 public:
  UserFeedback_UserFeedbackInfo();
  virtual ~UserFeedback_UserFeedbackInfo();

  UserFeedback_UserFeedbackInfo(const UserFeedback_UserFeedbackInfo& from);

  inline UserFeedback_UserFeedbackInfo& operator=(const UserFeedback_UserFeedbackInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserFeedback_UserFeedbackInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserFeedback_UserFeedbackInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserFeedback_UserFeedbackInfo* other);

  // implements Message ----------------------------------------------

  UserFeedback_UserFeedbackInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserFeedback_UserFeedbackInfo& from);
  void MergeFrom(const UserFeedback_UserFeedbackInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // optional uint32 fb_id = 2;
  inline bool has_fb_id() const;
  inline void clear_fb_id();
  static const int kFbIdFieldNumber = 2;
  inline ::google::protobuf::uint32 fb_id() const;
  inline void set_fb_id(::google::protobuf::uint32 value);

  // optional uint32 fb_type = 3;
  inline bool has_fb_type() const;
  inline void clear_fb_type();
  static const int kFbTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 fb_type() const;
  inline void set_fb_type(::google::protobuf::uint32 value);

  // optional uint32 finish = 4;
  inline bool has_finish() const;
  inline void clear_finish();
  static const int kFinishFieldNumber = 4;
  inline ::google::protobuf::uint32 finish() const;
  inline void set_finish(::google::protobuf::uint32 value);

  // optional bytes fb_content = 5;
  inline bool has_fb_content() const;
  inline void clear_fb_content();
  static const int kFbContentFieldNumber = 5;
  inline const ::std::string& fb_content() const;
  inline void set_fb_content(const ::std::string& value);
  inline void set_fb_content(const char* value);
  inline void set_fb_content(const void* value, size_t size);
  inline ::std::string* mutable_fb_content();
  inline ::std::string* release_fb_content();
  inline void set_allocated_fb_content(::std::string* fb_content);

  // optional bytes fb_reply = 6;
  inline bool has_fb_reply() const;
  inline void clear_fb_reply();
  static const int kFbReplyFieldNumber = 6;
  inline const ::std::string& fb_reply() const;
  inline void set_fb_reply(const ::std::string& value);
  inline void set_fb_reply(const char* value);
  inline void set_fb_reply(const void* value, size_t size);
  inline ::std::string* mutable_fb_reply();
  inline ::std::string* release_fb_reply();
  inline void set_allocated_fb_reply(::std::string* fb_reply);

  // optional bytes commit_time = 7;
  inline bool has_commit_time() const;
  inline void clear_commit_time();
  static const int kCommitTimeFieldNumber = 7;
  inline const ::std::string& commit_time() const;
  inline void set_commit_time(const ::std::string& value);
  inline void set_commit_time(const char* value);
  inline void set_commit_time(const void* value, size_t size);
  inline ::std::string* mutable_commit_time();
  inline ::std::string* release_commit_time();
  inline void set_allocated_commit_time(::std::string* commit_time);

  // optional bytes reply_time = 8;
  inline bool has_reply_time() const;
  inline void clear_reply_time();
  static const int kReplyTimeFieldNumber = 8;
  inline const ::std::string& reply_time() const;
  inline void set_reply_time(const ::std::string& value);
  inline void set_reply_time(const char* value);
  inline void set_reply_time(const void* value, size_t size);
  inline ::std::string* mutable_reply_time();
  inline ::std::string* release_reply_time();
  inline void set_allocated_reply_time(::std::string* reply_time);

  // optional uint32 answer_id = 9;
  inline bool has_answer_id() const;
  inline void clear_answer_id();
  static const int kAnswerIdFieldNumber = 9;
  inline ::google::protobuf::uint32 answer_id() const;
  inline void set_answer_id(::google::protobuf::uint32 value);

  // optional bytes char_name = 10;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 10;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // optional uint32 log_id = 11;
  inline bool has_log_id() const;
  inline void clear_log_id();
  static const int kLogIdFieldNumber = 11;
  inline ::google::protobuf::uint32 log_id() const;
  inline void set_log_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 12;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 12;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UserFeedback.UserFeedbackInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_fb_id();
  inline void clear_has_fb_id();
  inline void set_has_fb_type();
  inline void clear_has_fb_type();
  inline void set_has_finish();
  inline void clear_has_finish();
  inline void set_has_fb_content();
  inline void clear_has_fb_content();
  inline void set_has_fb_reply();
  inline void clear_has_fb_reply();
  inline void set_has_commit_time();
  inline void clear_has_commit_time();
  inline void set_has_reply_time();
  inline void clear_has_reply_time();
  inline void set_has_answer_id();
  inline void clear_has_answer_id();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_log_id();
  inline void clear_has_log_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 fb_id_;
  ::google::protobuf::uint32 fb_type_;
  ::google::protobuf::uint32 finish_;
  ::std::string* fb_content_;
  ::std::string* fb_reply_;
  ::std::string* commit_time_;
  ::std::string* reply_time_;
  ::std::string* char_name_;
  ::google::protobuf::uint32 answer_id_;
  ::google::protobuf::uint32 log_id_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UserFeedback_UserFeedbackInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserFeedback : public ::google::protobuf::MessageLite {
 public:
  UserFeedback();
  virtual ~UserFeedback();

  UserFeedback(const UserFeedback& from);

  inline UserFeedback& operator=(const UserFeedback& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserFeedback& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserFeedback* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserFeedback* other);

  // implements Message ----------------------------------------------

  UserFeedback* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserFeedback& from);
  void MergeFrom(const UserFeedback& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UserFeedback_UserFeedbackInfo UserFeedbackInfo;

  // accessors -------------------------------------------------------

  // repeated .message.UserFeedback.UserFeedbackInfo user_feedback_info = 1;
  inline int user_feedback_info_size() const;
  inline void clear_user_feedback_info();
  static const int kUserFeedbackInfoFieldNumber = 1;
  inline const ::message::UserFeedback_UserFeedbackInfo& user_feedback_info(int index) const;
  inline ::message::UserFeedback_UserFeedbackInfo* mutable_user_feedback_info(int index);
  inline ::message::UserFeedback_UserFeedbackInfo* add_user_feedback_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::UserFeedback_UserFeedbackInfo >&
      user_feedback_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::UserFeedback_UserFeedbackInfo >*
      mutable_user_feedback_info();

  // optional bytes gm_comit_time = 2;
  inline bool has_gm_comit_time() const;
  inline void clear_gm_comit_time();
  static const int kGmComitTimeFieldNumber = 2;
  inline const ::std::string& gm_comit_time() const;
  inline void set_gm_comit_time(const ::std::string& value);
  inline void set_gm_comit_time(const char* value);
  inline void set_gm_comit_time(const void* value, size_t size);
  inline ::std::string* mutable_gm_comit_time();
  inline ::std::string* release_gm_comit_time();
  inline void set_allocated_gm_comit_time(::std::string* gm_comit_time);

  // optional bytes gm_reply_time = 3;
  inline bool has_gm_reply_time() const;
  inline void clear_gm_reply_time();
  static const int kGmReplyTimeFieldNumber = 3;
  inline const ::std::string& gm_reply_time() const;
  inline void set_gm_reply_time(const ::std::string& value);
  inline void set_gm_reply_time(const char* value);
  inline void set_gm_reply_time(const void* value, size_t size);
  inline ::std::string* mutable_gm_reply_time();
  inline ::std::string* release_gm_reply_time();
  inline void set_allocated_gm_reply_time(::std::string* gm_reply_time);

  // optional bytes gm_char_name = 4;
  inline bool has_gm_char_name() const;
  inline void clear_gm_char_name();
  static const int kGmCharNameFieldNumber = 4;
  inline const ::std::string& gm_char_name() const;
  inline void set_gm_char_name(const ::std::string& value);
  inline void set_gm_char_name(const char* value);
  inline void set_gm_char_name(const void* value, size_t size);
  inline ::std::string* mutable_gm_char_name();
  inline ::std::string* release_gm_char_name();
  inline void set_allocated_gm_char_name(::std::string* gm_char_name);

  // optional uint32 sendfb_type = 5;
  inline bool has_sendfb_type() const;
  inline void clear_sendfb_type();
  static const int kSendfbTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 sendfb_type() const;
  inline void set_sendfb_type(::google::protobuf::uint32 value);

  // optional bytes gm_talk = 6;
  inline bool has_gm_talk() const;
  inline void clear_gm_talk();
  static const int kGmTalkFieldNumber = 6;
  inline const ::std::string& gm_talk() const;
  inline void set_gm_talk(const ::std::string& value);
  inline void set_gm_talk(const char* value);
  inline void set_gm_talk(const void* value, size_t size);
  inline ::std::string* mutable_gm_talk();
  inline ::std::string* release_gm_talk();
  inline void set_allocated_gm_talk(::std::string* gm_talk);

  // optional uint32 fb_id_new = 7;
  inline bool has_fb_id_new() const;
  inline void clear_fb_id_new();
  static const int kFbIdNewFieldNumber = 7;
  inline ::google::protobuf::uint32 fb_id_new() const;
  inline void set_fb_id_new(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.UserFeedback)
 private:
  inline void set_has_gm_comit_time();
  inline void clear_has_gm_comit_time();
  inline void set_has_gm_reply_time();
  inline void clear_has_gm_reply_time();
  inline void set_has_gm_char_name();
  inline void clear_has_gm_char_name();
  inline void set_has_sendfb_type();
  inline void clear_has_sendfb_type();
  inline void set_has_gm_talk();
  inline void clear_has_gm_talk();
  inline void set_has_fb_id_new();
  inline void clear_has_fb_id_new();

  ::google::protobuf::RepeatedPtrField< ::message::UserFeedback_UserFeedbackInfo > user_feedback_info_;
  ::std::string* gm_comit_time_;
  ::std::string* gm_reply_time_;
  ::std::string* gm_char_name_;
  ::std::string* gm_talk_;
  ::google::protobuf::uint32 sendfb_type_;
  ::google::protobuf::uint32 fb_id_new_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UserFeedback* default_instance_;
};
// -------------------------------------------------------------------

class SystemReward : public ::google::protobuf::MessageLite {
 public:
  SystemReward();
  virtual ~SystemReward();

  SystemReward(const SystemReward& from);

  inline SystemReward& operator=(const SystemReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const SystemReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SystemReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SystemReward* other);

  // implements Message ----------------------------------------------

  SystemReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SystemReward& from);
  void MergeFrom(const SystemReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 oper_id = 1;
  inline int oper_id_size() const;
  inline void clear_oper_id();
  static const int kOperIdFieldNumber = 1;
  inline ::google::protobuf::uint32 oper_id(int index) const;
  inline void set_oper_id(int index, ::google::protobuf::uint32 value);
  inline void add_oper_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      oper_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_oper_id();

  // repeated uint32 reward_item = 2;
  inline int reward_item_size() const;
  inline void clear_reward_item();
  static const int kRewardItemFieldNumber = 2;
  inline ::google::protobuf::uint32 reward_item(int index) const;
  inline void set_reward_item(int index, ::google::protobuf::uint32 value);
  inline void add_reward_item(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reward_item() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reward_item();

  // repeated uint32 reward_item_num = 3;
  inline int reward_item_num_size() const;
  inline void clear_reward_item_num();
  static const int kRewardItemNumFieldNumber = 3;
  inline ::google::protobuf::uint32 reward_item_num(int index) const;
  inline void set_reward_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_reward_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reward_item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reward_item_num();

  // repeated uint32 oper_pos = 4;
  inline int oper_pos_size() const;
  inline void clear_oper_pos();
  static const int kOperPosFieldNumber = 4;
  inline ::google::protobuf::uint32 oper_pos(int index) const;
  inline void set_oper_pos(int index, ::google::protobuf::uint32 value);
  inline void add_oper_pos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      oper_pos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_oper_pos();

  // repeated bytes sys_msg = 5;
  inline int sys_msg_size() const;
  inline void clear_sys_msg();
  static const int kSysMsgFieldNumber = 5;
  inline const ::std::string& sys_msg(int index) const;
  inline ::std::string* mutable_sys_msg(int index);
  inline void set_sys_msg(int index, const ::std::string& value);
  inline void set_sys_msg(int index, const char* value);
  inline void set_sys_msg(int index, const void* value, size_t size);
  inline ::std::string* add_sys_msg();
  inline void add_sys_msg(const ::std::string& value);
  inline void add_sys_msg(const char* value);
  inline void add_sys_msg(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sys_msg() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sys_msg();

  // optional uint32 send_type = 6;
  inline bool has_send_type() const;
  inline void clear_send_type();
  static const int kSendTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 send_type() const;
  inline void set_send_type(::google::protobuf::uint32 value);

  // optional uint32 glass = 7;
  inline bool has_glass() const;
  inline void clear_glass();
  static const int kGlassFieldNumber = 7;
  inline ::google::protobuf::uint32 glass() const;
  inline void set_glass(::google::protobuf::uint32 value);

  // optional bytes name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes sdk = 9;
  inline bool has_sdk() const;
  inline void clear_sdk();
  static const int kSdkFieldNumber = 9;
  inline const ::std::string& sdk() const;
  inline void set_sdk(const ::std::string& value);
  inline void set_sdk(const char* value);
  inline void set_sdk(const void* value, size_t size);
  inline ::std::string* mutable_sdk();
  inline ::std::string* release_sdk();
  inline void set_allocated_sdk(::std::string* sdk);

  // optional uint32 server_id = 10;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 10;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 gm_accid = 11;
  inline bool has_gm_accid() const;
  inline void clear_gm_accid();
  static const int kGmAccidFieldNumber = 11;
  inline ::google::protobuf::uint32 gm_accid() const;
  inline void set_gm_accid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SystemReward)
 private:
  inline void set_has_send_type();
  inline void clear_has_send_type();
  inline void set_has_glass();
  inline void clear_has_glass();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sdk();
  inline void clear_has_sdk();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_gm_accid();
  inline void clear_has_gm_accid();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > oper_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reward_item_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reward_item_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > oper_pos_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sys_msg_;
  ::google::protobuf::uint32 send_type_;
  ::google::protobuf::uint32 glass_;
  ::std::string* name_;
  ::std::string* sdk_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 gm_accid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SystemReward* default_instance_;
};
// -------------------------------------------------------------------

class GMFreezeSystem_GMFreezeSystemInfo : public ::google::protobuf::MessageLite {
 public:
  GMFreezeSystem_GMFreezeSystemInfo();
  virtual ~GMFreezeSystem_GMFreezeSystemInfo();

  GMFreezeSystem_GMFreezeSystemInfo(const GMFreezeSystem_GMFreezeSystemInfo& from);

  inline GMFreezeSystem_GMFreezeSystemInfo& operator=(const GMFreezeSystem_GMFreezeSystemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GMFreezeSystem_GMFreezeSystemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GMFreezeSystem_GMFreezeSystemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GMFreezeSystem_GMFreezeSystemInfo* other);

  // implements Message ----------------------------------------------

  GMFreezeSystem_GMFreezeSystemInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GMFreezeSystem_GMFreezeSystemInfo& from);
  void MergeFrom(const GMFreezeSystem_GMFreezeSystemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 gm_type = 3;
  inline bool has_gm_type() const;
  inline void clear_gm_type();
  static const int kGmTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 gm_type() const;
  inline void set_gm_type(::google::protobuf::uint32 value);

  // optional uint32 hour = 4;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 4;
  inline ::google::protobuf::uint32 hour() const;
  inline void set_hour(::google::protobuf::uint32 value);

  // optional bytes reason = 5;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 5;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const void* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // optional bytes freeze_time = 6;
  inline bool has_freeze_time() const;
  inline void clear_freeze_time();
  static const int kFreezeTimeFieldNumber = 6;
  inline const ::std::string& freeze_time() const;
  inline void set_freeze_time(const ::std::string& value);
  inline void set_freeze_time(const char* value);
  inline void set_freeze_time(const void* value, size_t size);
  inline ::std::string* mutable_freeze_time();
  inline ::std::string* release_freeze_time();
  inline void set_allocated_freeze_time(::std::string* freeze_time);

  // optional bytes end_time = 7;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 7;
  inline const ::std::string& end_time() const;
  inline void set_end_time(const ::std::string& value);
  inline void set_end_time(const char* value);
  inline void set_end_time(const void* value, size_t size);
  inline ::std::string* mutable_end_time();
  inline ::std::string* release_end_time();
  inline void set_allocated_end_time(::std::string* end_time);

  // optional bytes gm_name = 8;
  inline bool has_gm_name() const;
  inline void clear_gm_name();
  static const int kGmNameFieldNumber = 8;
  inline const ::std::string& gm_name() const;
  inline void set_gm_name(const ::std::string& value);
  inline void set_gm_name(const char* value);
  inline void set_gm_name(const void* value, size_t size);
  inline ::std::string* mutable_gm_name();
  inline ::std::string* release_gm_name();
  inline void set_allocated_gm_name(::std::string* gm_name);

  // optional bytes char_name = 9;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 9;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // @@protoc_insertion_point(class_scope:message.GMFreezeSystem.GMFreezeSystemInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_gm_type();
  inline void clear_has_gm_type();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_freeze_time();
  inline void clear_has_freeze_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_gm_name();
  inline void clear_has_gm_name();
  inline void set_has_char_name();
  inline void clear_has_char_name();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 gm_type_;
  ::google::protobuf::uint32 hour_;
  ::std::string* reason_;
  ::std::string* freeze_time_;
  ::std::string* end_time_;
  ::std::string* gm_name_;
  ::std::string* char_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GMFreezeSystem_GMFreezeSystemInfo* default_instance_;
};
// -------------------------------------------------------------------

class GMFreezeSystem : public ::google::protobuf::MessageLite {
 public:
  GMFreezeSystem();
  virtual ~GMFreezeSystem();

  GMFreezeSystem(const GMFreezeSystem& from);

  inline GMFreezeSystem& operator=(const GMFreezeSystem& from) {
    CopyFrom(from);
    return *this;
  }

  static const GMFreezeSystem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GMFreezeSystem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GMFreezeSystem* other);

  // implements Message ----------------------------------------------

  GMFreezeSystem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GMFreezeSystem& from);
  void MergeFrom(const GMFreezeSystem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GMFreezeSystem_GMFreezeSystemInfo GMFreezeSystemInfo;

  // accessors -------------------------------------------------------

  // repeated .message.GMFreezeSystem.GMFreezeSystemInfo gm_freeze_info = 1;
  inline int gm_freeze_info_size() const;
  inline void clear_gm_freeze_info();
  static const int kGmFreezeInfoFieldNumber = 1;
  inline const ::message::GMFreezeSystem_GMFreezeSystemInfo& gm_freeze_info(int index) const;
  inline ::message::GMFreezeSystem_GMFreezeSystemInfo* mutable_gm_freeze_info(int index);
  inline ::message::GMFreezeSystem_GMFreezeSystemInfo* add_gm_freeze_info();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GMFreezeSystem_GMFreezeSystemInfo >&
      gm_freeze_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GMFreezeSystem_GMFreezeSystemInfo >*
      mutable_gm_freeze_info();

  // optional uint32 gm_acc_id = 2;
  inline bool has_gm_acc_id() const;
  inline void clear_gm_acc_id();
  static const int kGmAccIdFieldNumber = 2;
  inline ::google::protobuf::uint32 gm_acc_id() const;
  inline void set_gm_acc_id(::google::protobuf::uint32 value);

  // optional uint32 send_type = 3;
  inline bool has_send_type() const;
  inline void clear_send_type();
  static const int kSendTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 send_type() const;
  inline void set_send_type(::google::protobuf::uint32 value);

  // optional bytes gm_check_time = 4;
  inline bool has_gm_check_time() const;
  inline void clear_gm_check_time();
  static const int kGmCheckTimeFieldNumber = 4;
  inline const ::std::string& gm_check_time() const;
  inline void set_gm_check_time(const ::std::string& value);
  inline void set_gm_check_time(const char* value);
  inline void set_gm_check_time(const void* value, size_t size);
  inline ::std::string* mutable_gm_check_time();
  inline ::std::string* release_gm_check_time();
  inline void set_allocated_gm_check_time(::std::string* gm_check_time);

  // optional bytes gm_char_name = 5;
  inline bool has_gm_char_name() const;
  inline void clear_gm_char_name();
  static const int kGmCharNameFieldNumber = 5;
  inline const ::std::string& gm_char_name() const;
  inline void set_gm_char_name(const ::std::string& value);
  inline void set_gm_char_name(const char* value);
  inline void set_gm_char_name(const void* value, size_t size);
  inline ::std::string* mutable_gm_char_name();
  inline ::std::string* release_gm_char_name();
  inline void set_allocated_gm_char_name(::std::string* gm_char_name);

  // @@protoc_insertion_point(class_scope:message.GMFreezeSystem)
 private:
  inline void set_has_gm_acc_id();
  inline void clear_has_gm_acc_id();
  inline void set_has_send_type();
  inline void clear_has_send_type();
  inline void set_has_gm_check_time();
  inline void clear_has_gm_check_time();
  inline void set_has_gm_char_name();
  inline void clear_has_gm_char_name();

  ::google::protobuf::RepeatedPtrField< ::message::GMFreezeSystem_GMFreezeSystemInfo > gm_freeze_info_;
  ::google::protobuf::uint32 gm_acc_id_;
  ::google::protobuf::uint32 send_type_;
  ::std::string* gm_check_time_;
  ::std::string* gm_char_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GMFreezeSystem* default_instance_;
};
// -------------------------------------------------------------------

class LoginSystemNotice : public ::google::protobuf::MessageLite {
 public:
  LoginSystemNotice();
  virtual ~LoginSystemNotice();

  LoginSystemNotice(const LoginSystemNotice& from);

  inline LoginSystemNotice& operator=(const LoginSystemNotice& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginSystemNotice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginSystemNotice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginSystemNotice* other);

  // implements Message ----------------------------------------------

  LoginSystemNotice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginSystemNotice& from);
  void MergeFrom(const LoginSystemNotice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 notice_type = 1;
  inline bool has_notice_type() const;
  inline void clear_notice_type();
  static const int kNoticeTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 notice_type() const;
  inline void set_notice_type(::google::protobuf::uint32 value);

  // optional uint32 acc_id = 2;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 2;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // optional bytes notice = 3;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 3;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const void* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional bytes notice_time = 4;
  inline bool has_notice_time() const;
  inline void clear_notice_time();
  static const int kNoticeTimeFieldNumber = 4;
  inline const ::std::string& notice_time() const;
  inline void set_notice_time(const ::std::string& value);
  inline void set_notice_time(const char* value);
  inline void set_notice_time(const void* value, size_t size);
  inline ::std::string* mutable_notice_time();
  inline ::std::string* release_notice_time();
  inline void set_allocated_notice_time(::std::string* notice_time);

  // optional bytes sdk = 5;
  inline bool has_sdk() const;
  inline void clear_sdk();
  static const int kSdkFieldNumber = 5;
  inline const ::std::string& sdk() const;
  inline void set_sdk(const ::std::string& value);
  inline void set_sdk(const char* value);
  inline void set_sdk(const void* value, size_t size);
  inline ::std::string* mutable_sdk();
  inline ::std::string* release_sdk();
  inline void set_allocated_sdk(::std::string* sdk);

  // @@protoc_insertion_point(class_scope:message.LoginSystemNotice)
 private:
  inline void set_has_notice_type();
  inline void clear_has_notice_type();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_notice_time();
  inline void clear_has_notice_time();
  inline void set_has_sdk();
  inline void clear_has_sdk();

  ::google::protobuf::uint32 notice_type_;
  ::google::protobuf::uint32 acc_id_;
  ::std::string* notice_;
  ::std::string* notice_time_;
  ::std::string* sdk_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoginSystemNotice* default_instance_;
};
// -------------------------------------------------------------------

class GMOperationResult : public ::google::protobuf::MessageLite {
 public:
  GMOperationResult();
  virtual ~GMOperationResult();

  GMOperationResult(const GMOperationResult& from);

  inline GMOperationResult& operator=(const GMOperationResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const GMOperationResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GMOperationResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GMOperationResult* other);

  // implements Message ----------------------------------------------

  GMOperationResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GMOperationResult& from);
  void MergeFrom(const GMOperationResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gm_accid = 1;
  inline bool has_gm_accid() const;
  inline void clear_gm_accid();
  static const int kGmAccidFieldNumber = 1;
  inline ::google::protobuf::uint32 gm_accid() const;
  inline void set_gm_accid(::google::protobuf::uint32 value);

  // optional uint32 gm_optype = 2;
  inline bool has_gm_optype() const;
  inline void clear_gm_optype();
  static const int kGmOptypeFieldNumber = 2;
  inline ::google::protobuf::uint32 gm_optype() const;
  inline void set_gm_optype(::google::protobuf::uint32 value);

  // optional bytes rolename = 3;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRolenameFieldNumber = 3;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const void* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // optional bytes fail_reason = 4;
  inline bool has_fail_reason() const;
  inline void clear_fail_reason();
  static const int kFailReasonFieldNumber = 4;
  inline const ::std::string& fail_reason() const;
  inline void set_fail_reason(const ::std::string& value);
  inline void set_fail_reason(const char* value);
  inline void set_fail_reason(const void* value, size_t size);
  inline ::std::string* mutable_fail_reason();
  inline ::std::string* release_fail_reason();
  inline void set_allocated_fail_reason(::std::string* fail_reason);

  // @@protoc_insertion_point(class_scope:message.GMOperationResult)
 private:
  inline void set_has_gm_accid();
  inline void clear_has_gm_accid();
  inline void set_has_gm_optype();
  inline void clear_has_gm_optype();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_fail_reason();
  inline void clear_has_fail_reason();

  ::google::protobuf::uint32 gm_accid_;
  ::google::protobuf::uint32 gm_optype_;
  ::std::string* rolename_;
  ::std::string* fail_reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GMOperationResult* default_instance_;
};
// -------------------------------------------------------------------

class AckGetInviteCode : public ::google::protobuf::MessageLite {
 public:
  AckGetInviteCode();
  virtual ~AckGetInviteCode();

  AckGetInviteCode(const AckGetInviteCode& from);

  inline AckGetInviteCode& operator=(const AckGetInviteCode& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckGetInviteCode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckGetInviteCode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckGetInviteCode* other);

  // implements Message ----------------------------------------------

  AckGetInviteCode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckGetInviteCode& from);
  void MergeFrom(const AckGetInviteCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:message.AckGetInviteCode)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckGetInviteCode* default_instance_;
};
// -------------------------------------------------------------------

class ReqDrawLottery : public ::google::protobuf::MessageLite {
 public:
  ReqDrawLottery();
  virtual ~ReqDrawLottery();

  ReqDrawLottery(const ReqDrawLottery& from);

  inline ReqDrawLottery& operator=(const ReqDrawLottery& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqDrawLottery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqDrawLottery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqDrawLottery* other);

  // implements Message ----------------------------------------------

  ReqDrawLottery* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqDrawLottery& from);
  void MergeFrom(const ReqDrawLottery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqDrawLottery)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqDrawLottery* default_instance_;
};
// -------------------------------------------------------------------

class GetLotteryReward : public ::google::protobuf::MessageLite {
 public:
  GetLotteryReward();
  virtual ~GetLotteryReward();

  GetLotteryReward(const GetLotteryReward& from);

  inline GetLotteryReward& operator=(const GetLotteryReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetLotteryReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetLotteryReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetLotteryReward* other);

  // implements Message ----------------------------------------------

  GetLotteryReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetLotteryReward& from);
  void MergeFrom(const GetLotteryReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetLotteryReward)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetLotteryReward* default_instance_;
};
// -------------------------------------------------------------------

class GiveUpHighGradeDrawLottery : public ::google::protobuf::MessageLite {
 public:
  GiveUpHighGradeDrawLottery();
  virtual ~GiveUpHighGradeDrawLottery();

  GiveUpHighGradeDrawLottery(const GiveUpHighGradeDrawLottery& from);

  inline GiveUpHighGradeDrawLottery& operator=(const GiveUpHighGradeDrawLottery& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiveUpHighGradeDrawLottery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiveUpHighGradeDrawLottery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiveUpHighGradeDrawLottery* other);

  // implements Message ----------------------------------------------

  GiveUpHighGradeDrawLottery* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiveUpHighGradeDrawLottery& from);
  void MergeFrom(const GiveUpHighGradeDrawLottery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GiveUpHighGradeDrawLottery)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GiveUpHighGradeDrawLottery* default_instance_;
};
// -------------------------------------------------------------------

class LotteryReward : public ::google::protobuf::MessageLite {
 public:
  LotteryReward();
  virtual ~LotteryReward();

  LotteryReward(const LotteryReward& from);

  inline LotteryReward& operator=(const LotteryReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const LotteryReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LotteryReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LotteryReward* other);

  // implements Message ----------------------------------------------

  LotteryReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LotteryReward& from);
  void MergeFrom(const LotteryReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // required uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // required uint32 man_quality = 3;
  inline bool has_man_quality() const;
  inline void clear_man_quality();
  static const int kManQualityFieldNumber = 3;
  inline ::google::protobuf::uint32 man_quality() const;
  inline void set_man_quality(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LotteryReward)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_man_quality();
  inline void clear_has_man_quality();

  ::google::protobuf::uint32 item_id_;
  ::google::protobuf::uint32 item_num_;
  ::google::protobuf::uint32 man_quality_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LotteryReward* default_instance_;
};
// -------------------------------------------------------------------

class LotteryRewardData : public ::google::protobuf::MessageLite {
 public:
  LotteryRewardData();
  virtual ~LotteryRewardData();

  LotteryRewardData(const LotteryRewardData& from);

  inline LotteryRewardData& operator=(const LotteryRewardData& from) {
    CopyFrom(from);
    return *this;
  }

  static const LotteryRewardData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LotteryRewardData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LotteryRewardData* other);

  // implements Message ----------------------------------------------

  LotteryRewardData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LotteryRewardData& from);
  void MergeFrom(const LotteryRewardData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LotteryRewardData)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LotteryRewardData* default_instance_;
};
// -------------------------------------------------------------------

class ReqQuickDrawLottery : public ::google::protobuf::MessageLite {
 public:
  ReqQuickDrawLottery();
  virtual ~ReqQuickDrawLottery();

  ReqQuickDrawLottery(const ReqQuickDrawLottery& from);

  inline ReqQuickDrawLottery& operator=(const ReqQuickDrawLottery& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqQuickDrawLottery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqQuickDrawLottery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqQuickDrawLottery* other);

  // implements Message ----------------------------------------------

  ReqQuickDrawLottery* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqQuickDrawLottery& from);
  void MergeFrom(const ReqQuickDrawLottery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqQuickDrawLottery)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqQuickDrawLottery* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetInviteReward : public ::google::protobuf::MessageLite {
 public:
  ReqGetInviteReward();
  virtual ~ReqGetInviteReward();

  ReqGetInviteReward(const ReqGetInviteReward& from);

  inline ReqGetInviteReward& operator=(const ReqGetInviteReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqGetInviteReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqGetInviteReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqGetInviteReward* other);

  // implements Message ----------------------------------------------

  ReqGetInviteReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqGetInviteReward& from);
  void MergeFrom(const ReqGetInviteReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqGetInviteReward)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqGetInviteReward* default_instance_;
};
// -------------------------------------------------------------------

class AckGetInviteNum : public ::google::protobuf::MessageLite {
 public:
  AckGetInviteNum();
  virtual ~AckGetInviteNum();

  AckGetInviteNum(const AckGetInviteNum& from);

  inline AckGetInviteNum& operator=(const AckGetInviteNum& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckGetInviteNum& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckGetInviteNum* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckGetInviteNum* other);

  // implements Message ----------------------------------------------

  AckGetInviteNum* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckGetInviteNum& from);
  void MergeFrom(const AckGetInviteNum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional bytes code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const void* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:message.AckGetInviteNum)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_code();
  inline void clear_has_code();

  ::std::string* code_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckGetInviteNum* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetInviteNum : public ::google::protobuf::MessageLite {
 public:
  ReqGetInviteNum();
  virtual ~ReqGetInviteNum();

  ReqGetInviteNum(const ReqGetInviteNum& from);

  inline ReqGetInviteNum& operator=(const ReqGetInviteNum& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqGetInviteNum& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqGetInviteNum* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqGetInviteNum* other);

  // implements Message ----------------------------------------------

  ReqGetInviteNum* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqGetInviteNum& from);
  void MergeFrom(const ReqGetInviteNum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqGetInviteNum)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqGetInviteNum* default_instance_;
};
// -------------------------------------------------------------------

class ReqAddMoney : public ::google::protobuf::MessageLite {
 public:
  ReqAddMoney();
  virtual ~ReqAddMoney();

  ReqAddMoney(const ReqAddMoney& from);

  inline ReqAddMoney& operator=(const ReqAddMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqAddMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqAddMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqAddMoney* other);

  // implements Message ----------------------------------------------

  ReqAddMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqAddMoney& from);
  void MergeFrom(const ReqAddMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqAddMoney)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqAddMoney* default_instance_;
};
// -------------------------------------------------------------------

class AddMoneyCost : public ::google::protobuf::MessageLite {
 public:
  AddMoneyCost();
  virtual ~AddMoneyCost();

  AddMoneyCost(const AddMoneyCost& from);

  inline AddMoneyCost& operator=(const AddMoneyCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddMoneyCost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddMoneyCost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddMoneyCost* other);

  // implements Message ----------------------------------------------

  AddMoneyCost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddMoneyCost& from);
  void MergeFrom(const AddMoneyCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cost = 1;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 1;
  inline ::google::protobuf::uint32 cost() const;
  inline void set_cost(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AddMoneyCost)
 private:
  inline void set_has_cost();
  inline void clear_has_cost();

  ::google::protobuf::uint32 cost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddMoneyCost* default_instance_;
};
// -------------------------------------------------------------------

class ChooseAddMoney : public ::google::protobuf::MessageLite {
 public:
  ChooseAddMoney();
  virtual ~ChooseAddMoney();

  ChooseAddMoney(const ChooseAddMoney& from);

  inline ChooseAddMoney& operator=(const ChooseAddMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChooseAddMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChooseAddMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChooseAddMoney* other);

  // implements Message ----------------------------------------------

  ChooseAddMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChooseAddMoney& from);
  void MergeFrom(const ChooseAddMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ChooseAddMoney)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ChooseAddMoney* default_instance_;
};
// -------------------------------------------------------------------

class RightPosition : public ::google::protobuf::MessageLite {
 public:
  RightPosition();
  virtual ~RightPosition();

  RightPosition(const RightPosition& from);

  inline RightPosition& operator=(const RightPosition& from) {
    CopyFrom(from);
    return *this;
  }

  static const RightPosition& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RightPosition* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RightPosition* other);

  // implements Message ----------------------------------------------

  RightPosition* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RightPosition& from);
  void MergeFrom(const RightPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.RightPosition)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RightPosition* default_instance_;
};
// -------------------------------------------------------------------

class OpenBowl : public ::google::protobuf::MessageLite {
 public:
  OpenBowl();
  virtual ~OpenBowl();

  OpenBowl(const OpenBowl& from);

  inline OpenBowl& operator=(const OpenBowl& from) {
    CopyFrom(from);
    return *this;
  }

  static const OpenBowl& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenBowl* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenBowl* other);

  // implements Message ----------------------------------------------

  OpenBowl* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenBowl& from);
  void MergeFrom(const OpenBowl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.OpenBowl)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OpenBowl* default_instance_;
};
// -------------------------------------------------------------------

class AddMoneyReward : public ::google::protobuf::MessageLite {
 public:
  AddMoneyReward();
  virtual ~AddMoneyReward();

  AddMoneyReward(const AddMoneyReward& from);

  inline AddMoneyReward& operator=(const AddMoneyReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddMoneyReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddMoneyReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddMoneyReward* other);

  // implements Message ----------------------------------------------

  AddMoneyReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddMoneyReward& from);
  void MergeFrom(const AddMoneyReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // required uint32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AddMoneyReward)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddMoneyReward* default_instance_;
};
// -------------------------------------------------------------------

class GetFirstRechargeGift : public ::google::protobuf::MessageLite {
 public:
  GetFirstRechargeGift();
  virtual ~GetFirstRechargeGift();

  GetFirstRechargeGift(const GetFirstRechargeGift& from);

  inline GetFirstRechargeGift& operator=(const GetFirstRechargeGift& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetFirstRechargeGift& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetFirstRechargeGift* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetFirstRechargeGift* other);

  // implements Message ----------------------------------------------

  GetFirstRechargeGift* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetFirstRechargeGift& from);
  void MergeFrom(const GetFirstRechargeGift& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetFirstRechargeGift)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetFirstRechargeGift* default_instance_;
};
// -------------------------------------------------------------------

class ReqAccelerateAction : public ::google::protobuf::MessageLite {
 public:
  ReqAccelerateAction();
  virtual ~ReqAccelerateAction();

  ReqAccelerateAction(const ReqAccelerateAction& from);

  inline ReqAccelerateAction& operator=(const ReqAccelerateAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqAccelerateAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqAccelerateAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqAccelerateAction* other);

  // implements Message ----------------------------------------------

  ReqAccelerateAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqAccelerateAction& from);
  void MergeFrom(const ReqAccelerateAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  static const int kActionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 action_id() const;
  inline void set_action_id(::google::protobuf::uint32 value);

  // optional uint32 action_value = 2;
  inline bool has_action_value() const;
  inline void clear_action_value();
  static const int kActionValueFieldNumber = 2;
  inline ::google::protobuf::uint32 action_value() const;
  inline void set_action_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqAccelerateAction)
 private:
  inline void set_has_action_id();
  inline void clear_has_action_id();
  inline void set_has_action_value();
  inline void clear_has_action_value();

  ::google::protobuf::uint32 action_id_;
  ::google::protobuf::uint32 action_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqAccelerateAction* default_instance_;
};
// -------------------------------------------------------------------

class ReqBuyTimesAction : public ::google::protobuf::MessageLite {
 public:
  ReqBuyTimesAction();
  virtual ~ReqBuyTimesAction();

  ReqBuyTimesAction(const ReqBuyTimesAction& from);

  inline ReqBuyTimesAction& operator=(const ReqBuyTimesAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqBuyTimesAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqBuyTimesAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqBuyTimesAction* other);

  // implements Message ----------------------------------------------

  ReqBuyTimesAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqBuyTimesAction& from);
  void MergeFrom(const ReqBuyTimesAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  static const int kActionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 action_id() const;
  inline void set_action_id(::google::protobuf::uint32 value);

  // optional uint32 action_value = 2;
  inline bool has_action_value() const;
  inline void clear_action_value();
  static const int kActionValueFieldNumber = 2;
  inline ::google::protobuf::uint32 action_value() const;
  inline void set_action_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqBuyTimesAction)
 private:
  inline void set_has_action_id();
  inline void clear_has_action_id();
  inline void set_has_action_value();
  inline void clear_has_action_value();

  ::google::protobuf::uint32 action_id_;
  ::google::protobuf::uint32 action_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqBuyTimesAction* default_instance_;
};
// -------------------------------------------------------------------

class ReqIsMercTraining : public ::google::protobuf::MessageLite {
 public:
  ReqIsMercTraining();
  virtual ~ReqIsMercTraining();

  ReqIsMercTraining(const ReqIsMercTraining& from);

  inline ReqIsMercTraining& operator=(const ReqIsMercTraining& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqIsMercTraining& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqIsMercTraining* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqIsMercTraining* other);

  // implements Message ----------------------------------------------

  ReqIsMercTraining* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqIsMercTraining& from);
  void MergeFrom(const ReqIsMercTraining& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqIsMercTraining)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();

  ::google::protobuf::uint32 merc_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqIsMercTraining* default_instance_;
};
// -------------------------------------------------------------------

class AckOtherLevelUp : public ::google::protobuf::MessageLite {
 public:
  AckOtherLevelUp();
  virtual ~AckOtherLevelUp();

  AckOtherLevelUp(const AckOtherLevelUp& from);

  inline AckOtherLevelUp& operator=(const AckOtherLevelUp& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckOtherLevelUp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckOtherLevelUp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckOtherLevelUp* other);

  // implements Message ----------------------------------------------

  AckOtherLevelUp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckOtherLevelUp& from);
  void MergeFrom(const AckOtherLevelUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckOtherLevelUp)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();

  ::google::protobuf::uint32 char_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckOtherLevelUp* default_instance_;
};
// -------------------------------------------------------------------

class SendHeartBeatMsg : public ::google::protobuf::MessageLite {
 public:
  SendHeartBeatMsg();
  virtual ~SendHeartBeatMsg();

  SendHeartBeatMsg(const SendHeartBeatMsg& from);

  inline SendHeartBeatMsg& operator=(const SendHeartBeatMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const SendHeartBeatMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendHeartBeatMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendHeartBeatMsg* other);

  // implements Message ----------------------------------------------

  SendHeartBeatMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendHeartBeatMsg& from);
  void MergeFrom(const SendHeartBeatMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SendHeartBeatMsg)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SendHeartBeatMsg* default_instance_;
};
// -------------------------------------------------------------------

class SendStoneMsg : public ::google::protobuf::MessageLite {
 public:
  SendStoneMsg();
  virtual ~SendStoneMsg();

  SendStoneMsg(const SendStoneMsg& from);

  inline SendStoneMsg& operator=(const SendStoneMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const SendStoneMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendStoneMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendStoneMsg* other);

  // implements Message ----------------------------------------------

  SendStoneMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendStoneMsg& from);
  void MergeFrom(const SendStoneMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // optional uint64 oper_pos = 2;
  inline bool has_oper_pos() const;
  inline void clear_oper_pos();
  static const int kOperPosFieldNumber = 2;
  inline ::google::protobuf::uint64 oper_pos() const;
  inline void set_oper_pos(::google::protobuf::uint64 value);

  // optional uint64 item_pos = 3;
  inline bool has_item_pos() const;
  inline void clear_item_pos();
  static const int kItemPosFieldNumber = 3;
  inline ::google::protobuf::uint64 item_pos() const;
  inline void set_item_pos(::google::protobuf::uint64 value);

  // optional uint32 oper_id = 4;
  inline bool has_oper_id() const;
  inline void clear_oper_id();
  static const int kOperIdFieldNumber = 4;
  inline ::google::protobuf::uint32 oper_id() const;
  inline void set_oper_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SendStoneMsg)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();
  inline void set_has_oper_pos();
  inline void clear_has_oper_pos();
  inline void set_has_item_pos();
  inline void clear_has_item_pos();
  inline void set_has_oper_id();
  inline void clear_has_oper_id();

  ::google::protobuf::uint64 oper_pos_;
  ::google::protobuf::uint32 merc_pos_;
  ::google::protobuf::uint32 oper_id_;
  ::google::protobuf::uint64 item_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SendStoneMsg* default_instance_;
};
// -------------------------------------------------------------------

class ReqWorldBossInfo : public ::google::protobuf::MessageLite {
 public:
  ReqWorldBossInfo();
  virtual ~ReqWorldBossInfo();

  ReqWorldBossInfo(const ReqWorldBossInfo& from);

  inline ReqWorldBossInfo& operator=(const ReqWorldBossInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqWorldBossInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqWorldBossInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqWorldBossInfo* other);

  // implements Message ----------------------------------------------

  ReqWorldBossInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqWorldBossInfo& from);
  void MergeFrom(const ReqWorldBossInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqWorldBossInfo)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqWorldBossInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckWorldBossInfo : public ::google::protobuf::MessageLite {
 public:
  AckWorldBossInfo();
  virtual ~AckWorldBossInfo();

  AckWorldBossInfo(const AckWorldBossInfo& from);

  inline AckWorldBossInfo& operator=(const AckWorldBossInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AckWorldBossInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AckWorldBossInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AckWorldBossInfo* other);

  // implements Message ----------------------------------------------

  AckWorldBossInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AckWorldBossInfo& from);
  void MergeFrom(const AckWorldBossInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 boss_id = 1;
  inline bool has_boss_id() const;
  inline void clear_boss_id();
  static const int kBossIdFieldNumber = 1;
  inline ::google::protobuf::uint32 boss_id() const;
  inline void set_boss_id(::google::protobuf::uint32 value);

  // required uint32 boss_hp = 2;
  inline bool has_boss_hp() const;
  inline void clear_boss_hp();
  static const int kBossHpFieldNumber = 2;
  inline ::google::protobuf::uint32 boss_hp() const;
  inline void set_boss_hp(::google::protobuf::uint32 value);

  // required uint32 if_used = 3;
  inline bool has_if_used() const;
  inline void clear_if_used();
  static const int kIfUsedFieldNumber = 3;
  inline ::google::protobuf::uint32 if_used() const;
  inline void set_if_used(::google::protobuf::uint32 value);

  // required uint32 server_id = 4;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AckWorldBossInfo)
 private:
  inline void set_has_boss_id();
  inline void clear_has_boss_id();
  inline void set_has_boss_hp();
  inline void clear_has_boss_hp();
  inline void set_has_if_used();
  inline void clear_has_if_used();
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::uint32 boss_id_;
  ::google::protobuf::uint32 boss_hp_;
  ::google::protobuf::uint32 if_used_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AckWorldBossInfo* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteSQL : public ::google::protobuf::MessageLite {
 public:
  ExecuteSQL();
  virtual ~ExecuteSQL();

  ExecuteSQL(const ExecuteSQL& from);

  inline ExecuteSQL& operator=(const ExecuteSQL& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExecuteSQL& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExecuteSQL* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExecuteSQL* other);

  // implements Message ----------------------------------------------

  ExecuteSQL* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExecuteSQL& from);
  void MergeFrom(const ExecuteSQL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sql = 1;
  inline bool has_sql() const;
  inline void clear_sql();
  static const int kSqlFieldNumber = 1;
  inline const ::std::string& sql() const;
  inline void set_sql(const ::std::string& value);
  inline void set_sql(const char* value);
  inline void set_sql(const void* value, size_t size);
  inline ::std::string* mutable_sql();
  inline ::std::string* release_sql();
  inline void set_allocated_sql(::std::string* sql);

  // optional uint32 if_return = 2;
  inline bool has_if_return() const;
  inline void clear_if_return();
  static const int kIfReturnFieldNumber = 2;
  inline ::google::protobuf::uint32 if_return() const;
  inline void set_if_return(::google::protobuf::uint32 value);

  // optional uint32 acc_id = 3;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 3;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ExecuteSQL)
 private:
  inline void set_has_sql();
  inline void clear_has_sql();
  inline void set_has_if_return();
  inline void clear_has_if_return();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::std::string* sql_;
  ::google::protobuf::uint32 if_return_;
  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ExecuteSQL* default_instance_;
};
// -------------------------------------------------------------------

class LoadAllActivityDataReq : public ::google::protobuf::MessageLite {
 public:
  LoadAllActivityDataReq();
  virtual ~LoadAllActivityDataReq();

  LoadAllActivityDataReq(const LoadAllActivityDataReq& from);

  inline LoadAllActivityDataReq& operator=(const LoadAllActivityDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadAllActivityDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadAllActivityDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadAllActivityDataReq* other);

  // implements Message ----------------------------------------------

  LoadAllActivityDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadAllActivityDataReq& from);
  void MergeFrom(const LoadAllActivityDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoadAllActivityDataReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoadAllActivityDataReq* default_instance_;
};
// -------------------------------------------------------------------

class LoadAllActivityDataAck_ActivityData : public ::google::protobuf::MessageLite {
 public:
  LoadAllActivityDataAck_ActivityData();
  virtual ~LoadAllActivityDataAck_ActivityData();

  LoadAllActivityDataAck_ActivityData(const LoadAllActivityDataAck_ActivityData& from);

  inline LoadAllActivityDataAck_ActivityData& operator=(const LoadAllActivityDataAck_ActivityData& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadAllActivityDataAck_ActivityData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadAllActivityDataAck_ActivityData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadAllActivityDataAck_ActivityData* other);

  // implements Message ----------------------------------------------

  LoadAllActivityDataAck_ActivityData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadAllActivityDataAck_ActivityData& from);
  void MergeFrom(const LoadAllActivityDataAck_ActivityData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 begin_time = 2;
  inline bool has_begin_time() const;
  inline void clear_begin_time();
  static const int kBeginTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 begin_time() const;
  inline void set_begin_time(::google::protobuf::uint32 value);

  // required uint32 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // required uint32 open = 4;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 4;
  inline ::google::protobuf::uint32 open() const;
  inline void set_open(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoadAllActivityDataAck.ActivityData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_begin_time();
  inline void clear_has_begin_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_open();
  inline void clear_has_open();

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 begin_time_;
  ::google::protobuf::uint32 end_time_;
  ::google::protobuf::uint32 open_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoadAllActivityDataAck_ActivityData* default_instance_;
};
// -------------------------------------------------------------------

class LoadAllActivityDataAck : public ::google::protobuf::MessageLite {
 public:
  LoadAllActivityDataAck();
  virtual ~LoadAllActivityDataAck();

  LoadAllActivityDataAck(const LoadAllActivityDataAck& from);

  inline LoadAllActivityDataAck& operator=(const LoadAllActivityDataAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadAllActivityDataAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadAllActivityDataAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadAllActivityDataAck* other);

  // implements Message ----------------------------------------------

  LoadAllActivityDataAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadAllActivityDataAck& from);
  void MergeFrom(const LoadAllActivityDataAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoadAllActivityDataAck_ActivityData ActivityData;

  // accessors -------------------------------------------------------

  // repeated .message.LoadAllActivityDataAck.ActivityData data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::message::LoadAllActivityDataAck_ActivityData& data(int index) const;
  inline ::message::LoadAllActivityDataAck_ActivityData* mutable_data(int index);
  inline ::message::LoadAllActivityDataAck_ActivityData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::LoadAllActivityDataAck_ActivityData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::LoadAllActivityDataAck_ActivityData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:message.LoadAllActivityDataAck)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::LoadAllActivityDataAck_ActivityData > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoadAllActivityDataAck* default_instance_;
};
// -------------------------------------------------------------------

class CanGetFirstRechargeReward : public ::google::protobuf::MessageLite {
 public:
  CanGetFirstRechargeReward();
  virtual ~CanGetFirstRechargeReward();

  CanGetFirstRechargeReward(const CanGetFirstRechargeReward& from);

  inline CanGetFirstRechargeReward& operator=(const CanGetFirstRechargeReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const CanGetFirstRechargeReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CanGetFirstRechargeReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CanGetFirstRechargeReward* other);

  // implements Message ----------------------------------------------

  CanGetFirstRechargeReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CanGetFirstRechargeReward& from);
  void MergeFrom(const CanGetFirstRechargeReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.CanGetFirstRechargeReward)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static CanGetFirstRechargeReward* default_instance_;
};
// -------------------------------------------------------------------

class LoadAllSysBroadcastDataReq : public ::google::protobuf::MessageLite {
 public:
  LoadAllSysBroadcastDataReq();
  virtual ~LoadAllSysBroadcastDataReq();

  LoadAllSysBroadcastDataReq(const LoadAllSysBroadcastDataReq& from);

  inline LoadAllSysBroadcastDataReq& operator=(const LoadAllSysBroadcastDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadAllSysBroadcastDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadAllSysBroadcastDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadAllSysBroadcastDataReq* other);

  // implements Message ----------------------------------------------

  LoadAllSysBroadcastDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadAllSysBroadcastDataReq& from);
  void MergeFrom(const LoadAllSysBroadcastDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoadAllSysBroadcastDataReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoadAllSysBroadcastDataReq* default_instance_;
};
// -------------------------------------------------------------------

class LoadAllSysBroadcastDataAck_SysBroadcastData : public ::google::protobuf::MessageLite {
 public:
  LoadAllSysBroadcastDataAck_SysBroadcastData();
  virtual ~LoadAllSysBroadcastDataAck_SysBroadcastData();

  LoadAllSysBroadcastDataAck_SysBroadcastData(const LoadAllSysBroadcastDataAck_SysBroadcastData& from);

  inline LoadAllSysBroadcastDataAck_SysBroadcastData& operator=(const LoadAllSysBroadcastDataAck_SysBroadcastData& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadAllSysBroadcastDataAck_SysBroadcastData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadAllSysBroadcastDataAck_SysBroadcastData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadAllSysBroadcastDataAck_SysBroadcastData* other);

  // implements Message ----------------------------------------------

  LoadAllSysBroadcastDataAck_SysBroadcastData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadAllSysBroadcastDataAck_SysBroadcastData& from);
  void MergeFrom(const LoadAllSysBroadcastDataAck_SysBroadcastData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 begin_time = 2;
  inline bool has_begin_time() const;
  inline void clear_begin_time();
  static const int kBeginTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 begin_time() const;
  inline void set_begin_time(::google::protobuf::uint32 value);

  // required uint32 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // required uint32 next_time = 4;
  inline bool has_next_time() const;
  inline void clear_next_time();
  static const int kNextTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 next_time() const;
  inline void set_next_time(::google::protobuf::uint32 value);

  // required uint32 minutes = 5;
  inline bool has_minutes() const;
  inline void clear_minutes();
  static const int kMinutesFieldNumber = 5;
  inline ::google::protobuf::uint32 minutes() const;
  inline void set_minutes(::google::protobuf::uint32 value);

  // required bytes text = 6;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const void* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:message.LoadAllSysBroadcastDataAck.SysBroadcastData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_begin_time();
  inline void clear_has_begin_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_next_time();
  inline void clear_has_next_time();
  inline void set_has_minutes();
  inline void clear_has_minutes();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 begin_time_;
  ::google::protobuf::uint32 end_time_;
  ::google::protobuf::uint32 next_time_;
  ::std::string* text_;
  ::google::protobuf::uint32 minutes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoadAllSysBroadcastDataAck_SysBroadcastData* default_instance_;
};
// -------------------------------------------------------------------

class LoadAllSysBroadcastDataAck : public ::google::protobuf::MessageLite {
 public:
  LoadAllSysBroadcastDataAck();
  virtual ~LoadAllSysBroadcastDataAck();

  LoadAllSysBroadcastDataAck(const LoadAllSysBroadcastDataAck& from);

  inline LoadAllSysBroadcastDataAck& operator=(const LoadAllSysBroadcastDataAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadAllSysBroadcastDataAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadAllSysBroadcastDataAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadAllSysBroadcastDataAck* other);

  // implements Message ----------------------------------------------

  LoadAllSysBroadcastDataAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadAllSysBroadcastDataAck& from);
  void MergeFrom(const LoadAllSysBroadcastDataAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoadAllSysBroadcastDataAck_SysBroadcastData SysBroadcastData;

  // accessors -------------------------------------------------------

  // repeated .message.LoadAllSysBroadcastDataAck.SysBroadcastData data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::message::LoadAllSysBroadcastDataAck_SysBroadcastData& data(int index) const;
  inline ::message::LoadAllSysBroadcastDataAck_SysBroadcastData* mutable_data(int index);
  inline ::message::LoadAllSysBroadcastDataAck_SysBroadcastData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::LoadAllSysBroadcastDataAck_SysBroadcastData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::LoadAllSysBroadcastDataAck_SysBroadcastData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:message.LoadAllSysBroadcastDataAck)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::LoadAllSysBroadcastDataAck_SysBroadcastData > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoadAllSysBroadcastDataAck* default_instance_;
};
// -------------------------------------------------------------------

class QueryAccidByAccnameReq : public ::google::protobuf::MessageLite {
 public:
  QueryAccidByAccnameReq();
  virtual ~QueryAccidByAccnameReq();

  QueryAccidByAccnameReq(const QueryAccidByAccnameReq& from);

  inline QueryAccidByAccnameReq& operator=(const QueryAccidByAccnameReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryAccidByAccnameReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryAccidByAccnameReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryAccidByAccnameReq* other);

  // implements Message ----------------------------------------------

  QueryAccidByAccnameReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryAccidByAccnameReq& from);
  void MergeFrom(const QueryAccidByAccnameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes acc_name = 1;
  inline bool has_acc_name() const;
  inline void clear_acc_name();
  static const int kAccNameFieldNumber = 1;
  inline const ::std::string& acc_name() const;
  inline void set_acc_name(const ::std::string& value);
  inline void set_acc_name(const char* value);
  inline void set_acc_name(const void* value, size_t size);
  inline ::std::string* mutable_acc_name();
  inline ::std::string* release_acc_name();
  inline void set_allocated_acc_name(::std::string* acc_name);

  // required uint32 serial_id = 2;
  inline bool has_serial_id() const;
  inline void clear_serial_id();
  static const int kSerialIdFieldNumber = 2;
  inline ::google::protobuf::uint32 serial_id() const;
  inline void set_serial_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.QueryAccidByAccnameReq)
 private:
  inline void set_has_acc_name();
  inline void clear_has_acc_name();
  inline void set_has_serial_id();
  inline void clear_has_serial_id();

  ::std::string* acc_name_;
  ::google::protobuf::uint32 serial_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static QueryAccidByAccnameReq* default_instance_;
};
// -------------------------------------------------------------------

class QueryAccidByAccnameAck : public ::google::protobuf::MessageLite {
 public:
  QueryAccidByAccnameAck();
  virtual ~QueryAccidByAccnameAck();

  QueryAccidByAccnameAck(const QueryAccidByAccnameAck& from);

  inline QueryAccidByAccnameAck& operator=(const QueryAccidByAccnameAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryAccidByAccnameAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryAccidByAccnameAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryAccidByAccnameAck* other);

  // implements Message ----------------------------------------------

  QueryAccidByAccnameAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryAccidByAccnameAck& from);
  void MergeFrom(const QueryAccidByAccnameAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 serial_id = 2;
  inline bool has_serial_id() const;
  inline void clear_serial_id();
  static const int kSerialIdFieldNumber = 2;
  inline ::google::protobuf::uint32 serial_id() const;
  inline void set_serial_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.QueryAccidByAccnameAck)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_serial_id();
  inline void clear_has_serial_id();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 serial_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static QueryAccidByAccnameAck* default_instance_;
};
// -------------------------------------------------------------------

class PkBattle : public ::google::protobuf::MessageLite {
 public:
  PkBattle();
  virtual ~PkBattle();

  PkBattle(const PkBattle& from);

  inline PkBattle& operator=(const PkBattle& from) {
    CopyFrom(from);
    return *this;
  }

  static const PkBattle& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PkBattle* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PkBattle* other);

  // implements Message ----------------------------------------------

  PkBattle* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PkBattle& from);
  void MergeFrom(const PkBattle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 target_id = 1;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 1;
  inline ::google::protobuf::uint32 target_id() const;
  inline void set_target_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PkBattle)
 private:
  inline void set_has_target_id();
  inline void clear_has_target_id();

  ::google::protobuf::uint32 target_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PkBattle* default_instance_;
};
// -------------------------------------------------------------------

class HorseData_HorseAttr : public ::google::protobuf::MessageLite {
 public:
  HorseData_HorseAttr();
  virtual ~HorseData_HorseAttr();

  HorseData_HorseAttr(const HorseData_HorseAttr& from);

  inline HorseData_HorseAttr& operator=(const HorseData_HorseAttr& from) {
    CopyFrom(from);
    return *this;
  }

  static const HorseData_HorseAttr& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HorseData_HorseAttr* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HorseData_HorseAttr* other);

  // implements Message ----------------------------------------------

  HorseData_HorseAttr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HorseData_HorseAttr& from);
  void MergeFrom(const HorseData_HorseAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.HorseData.HorseAttr)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HorseData_HorseAttr* default_instance_;
};
// -------------------------------------------------------------------

class HorseData : public ::google::protobuf::MessageLite {
 public:
  HorseData();
  virtual ~HorseData();

  HorseData(const HorseData& from);

  inline HorseData& operator=(const HorseData& from) {
    CopyFrom(from);
    return *this;
  }

  static const HorseData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HorseData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HorseData* other);

  // implements Message ----------------------------------------------

  HorseData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HorseData& from);
  void MergeFrom(const HorseData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HorseData_HorseAttr HorseAttr;

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required bytes change_name = 3;
  inline bool has_change_name() const;
  inline void clear_change_name();
  static const int kChangeNameFieldNumber = 3;
  inline const ::std::string& change_name() const;
  inline void set_change_name(const ::std::string& value);
  inline void set_change_name(const char* value);
  inline void set_change_name(const void* value, size_t size);
  inline ::std::string* mutable_change_name();
  inline ::std::string* release_change_name();
  inline void set_allocated_change_name(::std::string* change_name);

  // required uint32 image = 4;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 4;
  inline ::google::protobuf::uint32 image() const;
  inline void set_image(::google::protobuf::uint32 value);

  // required uint32 high_level = 5;
  inline bool has_high_level() const;
  inline void clear_high_level();
  static const int kHighLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 high_level() const;
  inline void set_high_level(::google::protobuf::uint32 value);

  // required uint32 low_level = 6;
  inline bool has_low_level() const;
  inline void clear_low_level();
  static const int kLowLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 low_level() const;
  inline void set_low_level(::google::protobuf::uint32 value);

  // required uint32 exp = 7;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 7;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // required uint32 train = 8;
  inline bool has_train() const;
  inline void clear_train();
  static const int kTrainFieldNumber = 8;
  inline ::google::protobuf::uint32 train() const;
  inline void set_train(::google::protobuf::uint32 value);

  // required uint32 bless = 9;
  inline bool has_bless() const;
  inline void clear_bless();
  static const int kBlessFieldNumber = 9;
  inline ::google::protobuf::uint32 bless() const;
  inline void set_bless(::google::protobuf::uint32 value);

  // repeated .message.HorseData.HorseAttr attr = 10;
  inline int attr_size() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 10;
  inline const ::message::HorseData_HorseAttr& attr(int index) const;
  inline ::message::HorseData_HorseAttr* mutable_attr(int index);
  inline ::message::HorseData_HorseAttr* add_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::message::HorseData_HorseAttr >&
      attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::HorseData_HorseAttr >*
      mutable_attr();

  // repeated uint32 skill_id = 11;
  inline int skill_id_size() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 11;
  inline ::google::protobuf::uint32 skill_id(int index) const;
  inline void set_skill_id(int index, ::google::protobuf::uint32 value);
  inline void add_skill_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      skill_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_skill_id();

  // required uint32 is_show = 12;
  inline bool has_is_show() const;
  inline void clear_is_show();
  static const int kIsShowFieldNumber = 12;
  inline ::google::protobuf::uint32 is_show() const;
  inline void set_is_show(::google::protobuf::uint32 value);

  // required uint32 card_type = 13;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 13;
  inline ::google::protobuf::uint32 card_type() const;
  inline void set_card_type(::google::protobuf::uint32 value);

  // repeated uint32 card_id = 14;
  inline int card_id_size() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 14;
  inline ::google::protobuf::uint32 card_id(int index) const;
  inline void set_card_id(int index, ::google::protobuf::uint32 value);
  inline void add_card_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      card_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_card_id();

  // @@protoc_insertion_point(class_scope:message.HorseData)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_change_name();
  inline void clear_has_change_name();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_high_level();
  inline void clear_has_high_level();
  inline void set_has_low_level();
  inline void clear_has_low_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_train();
  inline void clear_has_train();
  inline void set_has_bless();
  inline void clear_has_bless();
  inline void set_has_is_show();
  inline void clear_has_is_show();
  inline void set_has_card_type();
  inline void clear_has_card_type();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 id_;
  ::std::string* change_name_;
  ::google::protobuf::uint32 image_;
  ::google::protobuf::uint32 high_level_;
  ::google::protobuf::uint32 low_level_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 train_;
  ::google::protobuf::uint32 bless_;
  ::google::protobuf::RepeatedPtrField< ::message::HorseData_HorseAttr > attr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > skill_id_;
  ::google::protobuf::uint32 is_show_;
  ::google::protobuf::uint32 card_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > card_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HorseData* default_instance_;
};
// -------------------------------------------------------------------

class GetHorseDataReq : public ::google::protobuf::MessageLite {
 public:
  GetHorseDataReq();
  virtual ~GetHorseDataReq();

  GetHorseDataReq(const GetHorseDataReq& from);

  inline GetHorseDataReq& operator=(const GetHorseDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetHorseDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetHorseDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetHorseDataReq* other);

  // implements Message ----------------------------------------------

  GetHorseDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetHorseDataReq& from);
  void MergeFrom(const GetHorseDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetHorseDataReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetHorseDataReq* default_instance_;
};
// -------------------------------------------------------------------

class GetHorseDataAck : public ::google::protobuf::MessageLite {
 public:
  GetHorseDataAck();
  virtual ~GetHorseDataAck();

  GetHorseDataAck(const GetHorseDataAck& from);

  inline GetHorseDataAck& operator=(const GetHorseDataAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetHorseDataAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetHorseDataAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetHorseDataAck* other);

  // implements Message ----------------------------------------------

  GetHorseDataAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetHorseDataAck& from);
  void MergeFrom(const GetHorseDataAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .message.HorseData horse_data = 1;
  inline int horse_data_size() const;
  inline void clear_horse_data();
  static const int kHorseDataFieldNumber = 1;
  inline const ::message::HorseData& horse_data(int index) const;
  inline ::message::HorseData* mutable_horse_data(int index);
  inline ::message::HorseData* add_horse_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::HorseData >&
      horse_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::HorseData >*
      mutable_horse_data();

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetHorseDataAck)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::RepeatedPtrField< ::message::HorseData > horse_data_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetHorseDataAck* default_instance_;
};
// -------------------------------------------------------------------

class HorseGroomReq : public ::google::protobuf::MessageLite {
 public:
  HorseGroomReq();
  virtual ~HorseGroomReq();

  HorseGroomReq(const HorseGroomReq& from);

  inline HorseGroomReq& operator=(const HorseGroomReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const HorseGroomReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HorseGroomReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HorseGroomReq* other);

  // implements Message ----------------------------------------------

  HorseGroomReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HorseGroomReq& from);
  void MergeFrom(const HorseGroomReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // repeated uint32 value = 3;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::uint32 value);
  inline void add_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:message.HorseGroomReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HorseGroomReq* default_instance_;
};
// -------------------------------------------------------------------

class HorseGroomAck : public ::google::protobuf::MessageLite {
 public:
  HorseGroomAck();
  virtual ~HorseGroomAck();

  HorseGroomAck(const HorseGroomAck& from);

  inline HorseGroomAck& operator=(const HorseGroomAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const HorseGroomAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HorseGroomAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HorseGroomAck* other);

  // implements Message ----------------------------------------------

  HorseGroomAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HorseGroomAck& from);
  void MergeFrom(const HorseGroomAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message.HorseData horse_data = 1;
  inline bool has_horse_data() const;
  inline void clear_horse_data();
  static const int kHorseDataFieldNumber = 1;
  inline const ::message::HorseData& horse_data() const;
  inline ::message::HorseData* mutable_horse_data();
  inline ::message::HorseData* release_horse_data();
  inline void set_allocated_horse_data(::message::HorseData* horse_data);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // repeated uint32 value = 4;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline ::google::protobuf::uint32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::uint32 value);
  inline void add_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:message.HorseGroomAck)
 private:
  inline void set_has_horse_data();
  inline void clear_has_horse_data();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_type();
  inline void clear_has_type();

  ::message::HorseData* horse_data_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HorseGroomAck* default_instance_;
};
// -------------------------------------------------------------------

class BuyHorseFeedCountReq : public ::google::protobuf::MessageLite {
 public:
  BuyHorseFeedCountReq();
  virtual ~BuyHorseFeedCountReq();

  BuyHorseFeedCountReq(const BuyHorseFeedCountReq& from);

  inline BuyHorseFeedCountReq& operator=(const BuyHorseFeedCountReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuyHorseFeedCountReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuyHorseFeedCountReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuyHorseFeedCountReq* other);

  // implements Message ----------------------------------------------

  BuyHorseFeedCountReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuyHorseFeedCountReq& from);
  void MergeFrom(const BuyHorseFeedCountReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BuyHorseFeedCountReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BuyHorseFeedCountReq* default_instance_;
};
// -------------------------------------------------------------------

class BuyHorseFeedCountAck : public ::google::protobuf::MessageLite {
 public:
  BuyHorseFeedCountAck();
  virtual ~BuyHorseFeedCountAck();

  BuyHorseFeedCountAck(const BuyHorseFeedCountAck& from);

  inline BuyHorseFeedCountAck& operator=(const BuyHorseFeedCountAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuyHorseFeedCountAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuyHorseFeedCountAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuyHorseFeedCountAck* other);

  // implements Message ----------------------------------------------

  BuyHorseFeedCountAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuyHorseFeedCountAck& from);
  void MergeFrom(const BuyHorseFeedCountAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BuyHorseFeedCountAck)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BuyHorseFeedCountAck* default_instance_;
};
// -------------------------------------------------------------------

class HorseShowChangeReq : public ::google::protobuf::MessageLite {
 public:
  HorseShowChangeReq();
  virtual ~HorseShowChangeReq();

  HorseShowChangeReq(const HorseShowChangeReq& from);

  inline HorseShowChangeReq& operator=(const HorseShowChangeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const HorseShowChangeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HorseShowChangeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HorseShowChangeReq* other);

  // implements Message ----------------------------------------------

  HorseShowChangeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HorseShowChangeReq& from);
  void MergeFrom(const HorseShowChangeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.HorseShowChangeReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HorseShowChangeReq* default_instance_;
};
// -------------------------------------------------------------------

class HorseShowChangeAck : public ::google::protobuf::MessageLite {
 public:
  HorseShowChangeAck();
  virtual ~HorseShowChangeAck();

  HorseShowChangeAck(const HorseShowChangeAck& from);

  inline HorseShowChangeAck& operator=(const HorseShowChangeAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const HorseShowChangeAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HorseShowChangeAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HorseShowChangeAck* other);

  // implements Message ----------------------------------------------

  HorseShowChangeAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HorseShowChangeAck& from);
  void MergeFrom(const HorseShowChangeAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.HorseShowChangeAck)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HorseShowChangeAck* default_instance_;
};
// -------------------------------------------------------------------

class HorseChangeSys : public ::google::protobuf::MessageLite {
 public:
  HorseChangeSys();
  virtual ~HorseChangeSys();

  HorseChangeSys(const HorseChangeSys& from);

  inline HorseChangeSys& operator=(const HorseChangeSys& from) {
    CopyFrom(from);
    return *this;
  }

  static const HorseChangeSys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HorseChangeSys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HorseChangeSys* other);

  // implements Message ----------------------------------------------

  HorseChangeSys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HorseChangeSys& from);
  void MergeFrom(const HorseChangeSys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 horse_id = 2;
  inline bool has_horse_id() const;
  inline void clear_horse_id();
  static const int kHorseIdFieldNumber = 2;
  inline ::google::protobuf::uint32 horse_id() const;
  inline void set_horse_id(::google::protobuf::uint32 value);

  // optional uint32 horse_image = 3;
  inline bool has_horse_image() const;
  inline void clear_horse_image();
  static const int kHorseImageFieldNumber = 3;
  inline ::google::protobuf::uint32 horse_image() const;
  inline void set_horse_image(::google::protobuf::uint32 value);

  // optional bytes horse_name = 4;
  inline bool has_horse_name() const;
  inline void clear_horse_name();
  static const int kHorseNameFieldNumber = 4;
  inline const ::std::string& horse_name() const;
  inline void set_horse_name(const ::std::string& value);
  inline void set_horse_name(const char* value);
  inline void set_horse_name(const void* value, size_t size);
  inline ::std::string* mutable_horse_name();
  inline ::std::string* release_horse_name();
  inline void set_allocated_horse_name(::std::string* horse_name);

  // @@protoc_insertion_point(class_scope:message.HorseChangeSys)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_horse_id();
  inline void clear_has_horse_id();
  inline void set_has_horse_image();
  inline void clear_has_horse_image();
  inline void set_has_horse_name();
  inline void clear_has_horse_name();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 horse_id_;
  ::std::string* horse_name_;
  ::google::protobuf::uint32 horse_image_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HorseChangeSys* default_instance_;
};
// -------------------------------------------------------------------

class LoadAllHorseDataReq : public ::google::protobuf::MessageLite {
 public:
  LoadAllHorseDataReq();
  virtual ~LoadAllHorseDataReq();

  LoadAllHorseDataReq(const LoadAllHorseDataReq& from);

  inline LoadAllHorseDataReq& operator=(const LoadAllHorseDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadAllHorseDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadAllHorseDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadAllHorseDataReq* other);

  // implements Message ----------------------------------------------

  LoadAllHorseDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadAllHorseDataReq& from);
  void MergeFrom(const LoadAllHorseDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.LoadAllHorseDataReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoadAllHorseDataReq* default_instance_;
};
// -------------------------------------------------------------------

class LoadAllHorseDataAck : public ::google::protobuf::MessageLite {
 public:
  LoadAllHorseDataAck();
  virtual ~LoadAllHorseDataAck();

  LoadAllHorseDataAck(const LoadAllHorseDataAck& from);

  inline LoadAllHorseDataAck& operator=(const LoadAllHorseDataAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadAllHorseDataAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadAllHorseDataAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadAllHorseDataAck* other);

  // implements Message ----------------------------------------------

  LoadAllHorseDataAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadAllHorseDataAck& from);
  void MergeFrom(const LoadAllHorseDataAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .message.HorseData data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::message::HorseData& data(int index) const;
  inline ::message::HorseData* mutable_data(int index);
  inline ::message::HorseData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::HorseData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::HorseData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:message.LoadAllHorseDataAck)
 private:

  ::google::protobuf::RepeatedPtrField< ::message::HorseData > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static LoadAllHorseDataAck* default_instance_;
};
// -------------------------------------------------------------------

class ReqStopQuickDestiny : public ::google::protobuf::MessageLite {
 public:
  ReqStopQuickDestiny();
  virtual ~ReqStopQuickDestiny();

  ReqStopQuickDestiny(const ReqStopQuickDestiny& from);

  inline ReqStopQuickDestiny& operator=(const ReqStopQuickDestiny& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqStopQuickDestiny& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqStopQuickDestiny* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqStopQuickDestiny* other);

  // implements Message ----------------------------------------------

  ReqStopQuickDestiny* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqStopQuickDestiny& from);
  void MergeFrom(const ReqStopQuickDestiny& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqStopQuickDestiny)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqStopQuickDestiny* default_instance_;
};
// -------------------------------------------------------------------

class PlatScrollReq : public ::google::protobuf::MessageLite {
 public:
  PlatScrollReq();
  virtual ~PlatScrollReq();

  PlatScrollReq(const PlatScrollReq& from);

  inline PlatScrollReq& operator=(const PlatScrollReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlatScrollReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlatScrollReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlatScrollReq* other);

  // implements Message ----------------------------------------------

  PlatScrollReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlatScrollReq& from);
  void MergeFrom(const PlatScrollReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PlatScrollReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PlatScrollReq* default_instance_;
};
// -------------------------------------------------------------------

class PlatScrollAck : public ::google::protobuf::MessageLite {
 public:
  PlatScrollAck();
  virtual ~PlatScrollAck();

  PlatScrollAck(const PlatScrollAck& from);

  inline PlatScrollAck& operator=(const PlatScrollAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlatScrollAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlatScrollAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlatScrollAck* other);

  // implements Message ----------------------------------------------

  PlatScrollAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlatScrollAck& from);
  void MergeFrom(const PlatScrollAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes order_id = 1;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 1;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const void* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // required bytes server_url = 2;
  inline bool has_server_url() const;
  inline void clear_server_url();
  static const int kServerUrlFieldNumber = 2;
  inline const ::std::string& server_url() const;
  inline void set_server_url(const ::std::string& value);
  inline void set_server_url(const char* value);
  inline void set_server_url(const void* value, size_t size);
  inline ::std::string* mutable_server_url();
  inline ::std::string* release_server_url();
  inline void set_allocated_server_url(::std::string* server_url);

  // @@protoc_insertion_point(class_scope:message.PlatScrollAck)
 private:
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_server_url();
  inline void clear_has_server_url();

  ::std::string* order_id_;
  ::std::string* server_url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PlatScrollAck* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetVipLevelReward : public ::google::protobuf::MessageLite {
 public:
  ReqGetVipLevelReward();
  virtual ~ReqGetVipLevelReward();

  ReqGetVipLevelReward(const ReqGetVipLevelReward& from);

  inline ReqGetVipLevelReward& operator=(const ReqGetVipLevelReward& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqGetVipLevelReward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqGetVipLevelReward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqGetVipLevelReward* other);

  // implements Message ----------------------------------------------

  ReqGetVipLevelReward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqGetVipLevelReward& from);
  void MergeFrom(const ReqGetVipLevelReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 vip_lv = 1;
  inline bool has_vip_lv() const;
  inline void clear_vip_lv();
  static const int kVipLvFieldNumber = 1;
  inline ::google::protobuf::uint32 vip_lv() const;
  inline void set_vip_lv(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqGetVipLevelReward)
 private:
  inline void set_has_vip_lv();
  inline void clear_has_vip_lv();

  ::google::protobuf::uint32 vip_lv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqGetVipLevelReward* default_instance_;
};
// -------------------------------------------------------------------

class SaveBattleInfo : public ::google::protobuf::MessageLite {
 public:
  SaveBattleInfo();
  virtual ~SaveBattleInfo();

  SaveBattleInfo(const SaveBattleInfo& from);

  inline SaveBattleInfo& operator=(const SaveBattleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SaveBattleInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SaveBattleInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SaveBattleInfo* other);

  // implements Message ----------------------------------------------

  SaveBattleInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SaveBattleInfo& from);
  void MergeFrom(const SaveBattleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // repeated bytes battle_data = 2;
  inline int battle_data_size() const;
  inline void clear_battle_data();
  static const int kBattleDataFieldNumber = 2;
  inline const ::std::string& battle_data(int index) const;
  inline ::std::string* mutable_battle_data(int index);
  inline void set_battle_data(int index, const ::std::string& value);
  inline void set_battle_data(int index, const char* value);
  inline void set_battle_data(int index, const void* value, size_t size);
  inline ::std::string* add_battle_data();
  inline void add_battle_data(const ::std::string& value);
  inline void add_battle_data(const char* value);
  inline void add_battle_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& battle_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_battle_data();

  // optional uint32 sequence_id = 3;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 3;
  inline ::google::protobuf::uint32 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SaveBattleInfo)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();

  ::google::protobuf::RepeatedPtrField< ::std::string> battle_data_;
  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 sequence_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SaveBattleInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqViewBattleHistory : public ::google::protobuf::MessageLite {
 public:
  ReqViewBattleHistory();
  virtual ~ReqViewBattleHistory();

  ReqViewBattleHistory(const ReqViewBattleHistory& from);

  inline ReqViewBattleHistory& operator=(const ReqViewBattleHistory& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqViewBattleHistory& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqViewBattleHistory* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqViewBattleHistory* other);

  // implements Message ----------------------------------------------

  ReqViewBattleHistory* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqViewBattleHistory& from);
  void MergeFrom(const ReqViewBattleHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqViewBattleHistory)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqViewBattleHistory* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetBattleHistoryData : public ::google::protobuf::MessageLite {
 public:
  ReqGetBattleHistoryData();
  virtual ~ReqGetBattleHistoryData();

  ReqGetBattleHistoryData(const ReqGetBattleHistoryData& from);

  inline ReqGetBattleHistoryData& operator=(const ReqGetBattleHistoryData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqGetBattleHistoryData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqGetBattleHistoryData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqGetBattleHistoryData* other);

  // implements Message ----------------------------------------------

  ReqGetBattleHistoryData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqGetBattleHistoryData& from);
  void MergeFrom(const ReqGetBattleHistoryData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 acc_id = 1;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // required uint32 server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqGetBattleHistoryData)
 private:
  inline void set_has_acc_id();
  inline void clear_has_acc_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::uint32 acc_id_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqGetBattleHistoryData* default_instance_;
};
// -------------------------------------------------------------------

class BattleHistoryInfo : public ::google::protobuf::MessageLite {
 public:
  BattleHistoryInfo();
  virtual ~BattleHistoryInfo();

  BattleHistoryInfo(const BattleHistoryInfo& from);

  inline BattleHistoryInfo& operator=(const BattleHistoryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleHistoryInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleHistoryInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleHistoryInfo* other);

  // implements Message ----------------------------------------------

  BattleHistoryInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleHistoryInfo& from);
  void MergeFrom(const BattleHistoryInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes battle_data = 1;
  inline int battle_data_size() const;
  inline void clear_battle_data();
  static const int kBattleDataFieldNumber = 1;
  inline const ::std::string& battle_data(int index) const;
  inline ::std::string* mutable_battle_data(int index);
  inline void set_battle_data(int index, const ::std::string& value);
  inline void set_battle_data(int index, const char* value);
  inline void set_battle_data(int index, const void* value, size_t size);
  inline ::std::string* add_battle_data();
  inline void add_battle_data(const ::std::string& value);
  inline void add_battle_data(const char* value);
  inline void add_battle_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& battle_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_battle_data();

  // optional uint32 no_battle_history = 2;
  inline bool has_no_battle_history() const;
  inline void clear_no_battle_history();
  static const int kNoBattleHistoryFieldNumber = 2;
  inline ::google::protobuf::uint32 no_battle_history() const;
  inline void set_no_battle_history(::google::protobuf::uint32 value);

  // optional uint32 is_last_one = 3;
  inline bool has_is_last_one() const;
  inline void clear_is_last_one();
  static const int kIsLastOneFieldNumber = 3;
  inline ::google::protobuf::uint32 is_last_one() const;
  inline void set_is_last_one(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.BattleHistoryInfo)
 private:
  inline void set_has_no_battle_history();
  inline void clear_has_no_battle_history();
  inline void set_has_is_last_one();
  inline void clear_has_is_last_one();

  ::google::protobuf::RepeatedPtrField< ::std::string> battle_data_;
  ::google::protobuf::uint32 no_battle_history_;
  ::google::protobuf::uint32 is_last_one_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static BattleHistoryInfo* default_instance_;
};
// -------------------------------------------------------------------

class EnterActiveReq : public ::google::protobuf::MessageLite {
 public:
  EnterActiveReq();
  virtual ~EnterActiveReq();

  EnterActiveReq(const EnterActiveReq& from);

  inline EnterActiveReq& operator=(const EnterActiveReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterActiveReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterActiveReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterActiveReq* other);

  // implements Message ----------------------------------------------

  EnterActiveReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterActiveReq& from);
  void MergeFrom(const EnterActiveReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 active_id = 1;
  inline bool has_active_id() const;
  inline void clear_active_id();
  static const int kActiveIdFieldNumber = 1;
  inline ::google::protobuf::uint32 active_id() const;
  inline void set_active_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.EnterActiveReq)
 private:
  inline void set_has_active_id();
  inline void clear_has_active_id();

  ::google::protobuf::uint32 active_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EnterActiveReq* default_instance_;
};
// -------------------------------------------------------------------

class EnterActiveAck : public ::google::protobuf::MessageLite {
 public:
  EnterActiveAck();
  virtual ~EnterActiveAck();

  EnterActiveAck(const EnterActiveAck& from);

  inline EnterActiveAck& operator=(const EnterActiveAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterActiveAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterActiveAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterActiveAck* other);

  // implements Message ----------------------------------------------

  EnterActiveAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterActiveAck& from);
  void MergeFrom(const EnterActiveAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 active_id = 1;
  inline bool has_active_id() const;
  inline void clear_active_id();
  static const int kActiveIdFieldNumber = 1;
  inline ::google::protobuf::uint32 active_id() const;
  inline void set_active_id(::google::protobuf::uint32 value);

  // optional uint32 error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional uint32 remain_time = 3;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 remain_time() const;
  inline void set_remain_time(::google::protobuf::uint32 value);

  // optional uint32 remain_battle_times = 4;
  inline bool has_remain_battle_times() const;
  inline void clear_remain_battle_times();
  static const int kRemainBattleTimesFieldNumber = 4;
  inline ::google::protobuf::uint32 remain_battle_times() const;
  inline void set_remain_battle_times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.EnterActiveAck)
 private:
  inline void set_has_active_id();
  inline void clear_has_active_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_remain_time();
  inline void clear_has_remain_time();
  inline void set_has_remain_battle_times();
  inline void clear_has_remain_battle_times();

  ::google::protobuf::uint32 active_id_;
  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::uint32 remain_time_;
  ::google::protobuf::uint32 remain_battle_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EnterActiveAck* default_instance_;
};
// -------------------------------------------------------------------

class OpenTreasureUIReq : public ::google::protobuf::MessageLite {
 public:
  OpenTreasureUIReq();
  virtual ~OpenTreasureUIReq();

  OpenTreasureUIReq(const OpenTreasureUIReq& from);

  inline OpenTreasureUIReq& operator=(const OpenTreasureUIReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const OpenTreasureUIReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenTreasureUIReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenTreasureUIReq* other);

  // implements Message ----------------------------------------------

  OpenTreasureUIReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenTreasureUIReq& from);
  void MergeFrom(const OpenTreasureUIReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.OpenTreasureUIReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OpenTreasureUIReq* default_instance_;
};
// -------------------------------------------------------------------

class OpenTreasureUIAck : public ::google::protobuf::MessageLite {
 public:
  OpenTreasureUIAck();
  virtual ~OpenTreasureUIAck();

  OpenTreasureUIAck(const OpenTreasureUIAck& from);

  inline OpenTreasureUIAck& operator=(const OpenTreasureUIAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const OpenTreasureUIAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenTreasureUIAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenTreasureUIAck* other);

  // implements Message ----------------------------------------------

  OpenTreasureUIAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenTreasureUIAck& from);
  void MergeFrom(const OpenTreasureUIAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 free_times = 1;
  inline bool has_free_times() const;
  inline void clear_free_times();
  static const int kFreeTimesFieldNumber = 1;
  inline ::google::protobuf::uint32 free_times() const;
  inline void set_free_times(::google::protobuf::uint32 value);

  // optional uint32 coin_next_free_time = 2;
  inline bool has_coin_next_free_time() const;
  inline void clear_coin_next_free_time();
  static const int kCoinNextFreeTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 coin_next_free_time() const;
  inline void set_coin_next_free_time(::google::protobuf::uint32 value);

  // optional uint32 scroll_next_free_time = 3;
  inline bool has_scroll_next_free_time() const;
  inline void clear_scroll_next_free_time();
  static const int kScrollNextFreeTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 scroll_next_free_time() const;
  inline void set_scroll_next_free_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.OpenTreasureUIAck)
 private:
  inline void set_has_free_times();
  inline void clear_has_free_times();
  inline void set_has_coin_next_free_time();
  inline void clear_has_coin_next_free_time();
  inline void set_has_scroll_next_free_time();
  inline void clear_has_scroll_next_free_time();

  ::google::protobuf::uint32 free_times_;
  ::google::protobuf::uint32 coin_next_free_time_;
  ::google::protobuf::uint32 scroll_next_free_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static OpenTreasureUIAck* default_instance_;
};
// -------------------------------------------------------------------

class GetTreasureReq : public ::google::protobuf::MessageLite {
 public:
  GetTreasureReq();
  virtual ~GetTreasureReq();

  GetTreasureReq(const GetTreasureReq& from);

  inline GetTreasureReq& operator=(const GetTreasureReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetTreasureReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTreasureReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTreasureReq* other);

  // implements Message ----------------------------------------------

  GetTreasureReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTreasureReq& from);
  void MergeFrom(const GetTreasureReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trea_mode = 1;
  inline bool has_trea_mode() const;
  inline void clear_trea_mode();
  static const int kTreaModeFieldNumber = 1;
  inline ::google::protobuf::uint32 trea_mode() const;
  inline void set_trea_mode(::google::protobuf::uint32 value);

  // optional uint32 cost_type = 2;
  inline bool has_cost_type() const;
  inline void clear_cost_type();
  static const int kCostTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 cost_type() const;
  inline void set_cost_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetTreasureReq)
 private:
  inline void set_has_trea_mode();
  inline void clear_has_trea_mode();
  inline void set_has_cost_type();
  inline void clear_has_cost_type();

  ::google::protobuf::uint32 trea_mode_;
  ::google::protobuf::uint32 cost_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetTreasureReq* default_instance_;
};
// -------------------------------------------------------------------

class GetTreasureAck : public ::google::protobuf::MessageLite {
 public:
  GetTreasureAck();
  virtual ~GetTreasureAck();

  GetTreasureAck(const GetTreasureAck& from);

  inline GetTreasureAck& operator=(const GetTreasureAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetTreasureAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTreasureAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTreasureAck* other);

  // implements Message ----------------------------------------------

  GetTreasureAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTreasureAck& from);
  void MergeFrom(const GetTreasureAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // repeated uint32 item_id = 2;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::uint32 value);
  inline void add_item_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_id();

  // repeated uint32 item_num = 3;
  inline int item_num_size() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 3;
  inline ::google::protobuf::uint32 item_num(int index) const;
  inline void set_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_num();

  // repeated uint32 item_type = 4;
  inline int item_type_size() const;
  inline void clear_item_type();
  static const int kItemTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 item_type(int index) const;
  inline void set_item_type(int index, ::google::protobuf::uint32 value);
  inline void add_item_type(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_type();

  // @@protoc_insertion_point(class_scope:message.GetTreasureAck)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_type_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetTreasureAck* default_instance_;
};
// -------------------------------------------------------------------

class ResetAck : public ::google::protobuf::MessageLite {
 public:
  ResetAck();
  virtual ~ResetAck();

  ResetAck(const ResetAck& from);

  inline ResetAck& operator=(const ResetAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResetAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResetAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResetAck* other);

  // implements Message ----------------------------------------------

  ResetAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResetAck& from);
  void MergeFrom(const ResetAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional uint32 active_id = 2;
  inline bool has_active_id() const;
  inline void clear_active_id();
  static const int kActiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 active_id() const;
  inline void set_active_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ResetAck)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_active_id();
  inline void clear_has_active_id();

  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 active_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ResetAck* default_instance_;
};
// -------------------------------------------------------------------

class AddEquipStarReq : public ::google::protobuf::MessageLite {
 public:
  AddEquipStarReq();
  virtual ~AddEquipStarReq();

  AddEquipStarReq(const AddEquipStarReq& from);

  inline AddEquipStarReq& operator=(const AddEquipStarReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddEquipStarReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddEquipStarReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddEquipStarReq* other);

  // implements Message ----------------------------------------------

  AddEquipStarReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddEquipStarReq& from);
  void MergeFrom(const AddEquipStarReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 only_id = 1;
  inline bool has_only_id() const;
  inline void clear_only_id();
  static const int kOnlyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 only_id() const;
  inline void set_only_id(::google::protobuf::uint32 value);

  // optional bool if_equip = 2;
  inline bool has_if_equip() const;
  inline void clear_if_equip();
  static const int kIfEquipFieldNumber = 2;
  inline bool if_equip() const;
  inline void set_if_equip(bool value);

  // @@protoc_insertion_point(class_scope:message.AddEquipStarReq)
 private:
  inline void set_has_only_id();
  inline void clear_has_only_id();
  inline void set_has_if_equip();
  inline void clear_has_if_equip();

  ::google::protobuf::uint32 only_id_;
  bool if_equip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddEquipStarReq* default_instance_;
};
// -------------------------------------------------------------------

class AddEquipStarAck : public ::google::protobuf::MessageLite {
 public:
  AddEquipStarAck();
  virtual ~AddEquipStarAck();

  AddEquipStarAck(const AddEquipStarAck& from);

  inline AddEquipStarAck& operator=(const AddEquipStarAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddEquipStarAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddEquipStarAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddEquipStarAck* other);

  // implements Message ----------------------------------------------

  AddEquipStarAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddEquipStarAck& from);
  void MergeFrom(const AddEquipStarAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 only_id = 1;
  inline bool has_only_id() const;
  inline void clear_only_id();
  static const int kOnlyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 only_id() const;
  inline void set_only_id(::google::protobuf::uint32 value);

  // optional uint32 error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.AddEquipStarAck)
 private:
  inline void set_has_only_id();
  inline void clear_has_only_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::uint32 only_id_;
  ::google::protobuf::uint32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AddEquipStarAck* default_instance_;
};
// -------------------------------------------------------------------

class GetRoleMailInfoReq : public ::google::protobuf::MessageLite {
 public:
  GetRoleMailInfoReq();
  virtual ~GetRoleMailInfoReq();

  GetRoleMailInfoReq(const GetRoleMailInfoReq& from);

  inline GetRoleMailInfoReq& operator=(const GetRoleMailInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetRoleMailInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetRoleMailInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetRoleMailInfoReq* other);

  // implements Message ----------------------------------------------

  GetRoleMailInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetRoleMailInfoReq& from);
  void MergeFrom(const GetRoleMailInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetRoleMailInfoReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetRoleMailInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class SelectMailInfoReq : public ::google::protobuf::MessageLite {
 public:
  SelectMailInfoReq();
  virtual ~SelectMailInfoReq();

  SelectMailInfoReq(const SelectMailInfoReq& from);

  inline SelectMailInfoReq& operator=(const SelectMailInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const SelectMailInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SelectMailInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SelectMailInfoReq* other);

  // implements Message ----------------------------------------------

  SelectMailInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SelectMailInfoReq& from);
  void MergeFrom(const SelectMailInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 acc_id = 2;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 2;
  inline ::google::protobuf::uint32 acc_id() const;
  inline void set_acc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SelectMailInfoReq)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 acc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SelectMailInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class RoleMailInfo : public ::google::protobuf::MessageLite {
 public:
  RoleMailInfo();
  virtual ~RoleMailInfo();

  RoleMailInfo(const RoleMailInfo& from);

  inline RoleMailInfo& operator=(const RoleMailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoleMailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoleMailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoleMailInfo* other);

  // implements Message ----------------------------------------------

  RoleMailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoleMailInfo& from);
  void MergeFrom(const RoleMailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mail_id = 1;
  inline bool has_mail_id() const;
  inline void clear_mail_id();
  static const int kMailIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mail_id() const;
  inline void set_mail_id(::google::protobuf::uint32 value);

  // optional uint32 mail_type = 2;
  inline bool has_mail_type() const;
  inline void clear_mail_type();
  static const int kMailTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 mail_type() const;
  inline void set_mail_type(::google::protobuf::uint32 value);

  // optional uint32 has_read = 3;
  inline bool has_has_read() const;
  inline void clear_has_read();
  static const int kHasReadFieldNumber = 3;
  inline ::google::protobuf::uint32 has_read() const;
  inline void set_has_read(::google::protobuf::uint32 value);

  // repeated uint32 item_id = 4;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 4;
  inline ::google::protobuf::uint32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::uint32 value);
  inline void add_item_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_id();

  // repeated uint32 item_num = 5;
  inline int item_num_size() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 5;
  inline ::google::protobuf::uint32 item_num(int index) const;
  inline void set_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_num();

  // optional bytes mail_title = 6;
  inline bool has_mail_title() const;
  inline void clear_mail_title();
  static const int kMailTitleFieldNumber = 6;
  inline const ::std::string& mail_title() const;
  inline void set_mail_title(const ::std::string& value);
  inline void set_mail_title(const char* value);
  inline void set_mail_title(const void* value, size_t size);
  inline ::std::string* mutable_mail_title();
  inline ::std::string* release_mail_title();
  inline void set_allocated_mail_title(::std::string* mail_title);

  // optional bytes mail_content = 7;
  inline bool has_mail_content() const;
  inline void clear_mail_content();
  static const int kMailContentFieldNumber = 7;
  inline const ::std::string& mail_content() const;
  inline void set_mail_content(const ::std::string& value);
  inline void set_mail_content(const char* value);
  inline void set_mail_content(const void* value, size_t size);
  inline ::std::string* mutable_mail_content();
  inline ::std::string* release_mail_content();
  inline void set_allocated_mail_content(::std::string* mail_content);

  // optional uint32 mail_time = 9;
  inline bool has_mail_time() const;
  inline void clear_mail_time();
  static const int kMailTimeFieldNumber = 9;
  inline ::google::protobuf::uint32 mail_time() const;
  inline void set_mail_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 10;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // optional uint32 is_last_one = 11;
  inline bool has_is_last_one() const;
  inline void clear_is_last_one();
  static const int kIsLastOneFieldNumber = 11;
  inline ::google::protobuf::uint32 is_last_one() const;
  inline void set_is_last_one(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.RoleMailInfo)
 private:
  inline void set_has_mail_id();
  inline void clear_has_mail_id();
  inline void set_has_mail_type();
  inline void clear_has_mail_type();
  inline void set_has_has_read();
  inline void clear_has_has_read();
  inline void set_has_mail_title();
  inline void clear_has_mail_title();
  inline void set_has_mail_content();
  inline void clear_has_mail_content();
  inline void set_has_mail_time();
  inline void clear_has_mail_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_is_last_one();
  inline void clear_has_is_last_one();

  ::google::protobuf::uint32 mail_id_;
  ::google::protobuf::uint32 mail_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_num_;
  ::google::protobuf::uint32 has_read_;
  ::google::protobuf::uint32 mail_time_;
  ::std::string* mail_title_;
  ::std::string* mail_content_;
  ::google::protobuf::uint32 end_time_;
  ::google::protobuf::uint32 is_last_one_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RoleMailInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReadMailReq : public ::google::protobuf::MessageLite {
 public:
  ReadMailReq();
  virtual ~ReadMailReq();

  ReadMailReq(const ReadMailReq& from);

  inline ReadMailReq& operator=(const ReadMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReadMailReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadMailReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadMailReq* other);

  // implements Message ----------------------------------------------

  ReadMailReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadMailReq& from);
  void MergeFrom(const ReadMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mail_id = 1;
  inline bool has_mail_id() const;
  inline void clear_mail_id();
  static const int kMailIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mail_id() const;
  inline void set_mail_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReadMailReq)
 private:
  inline void set_has_mail_id();
  inline void clear_has_mail_id();

  ::google::protobuf::uint32 mail_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReadMailReq* default_instance_;
};
// -------------------------------------------------------------------

class ReadMailAck : public ::google::protobuf::MessageLite {
 public:
  ReadMailAck();
  virtual ~ReadMailAck();

  ReadMailAck(const ReadMailAck& from);

  inline ReadMailAck& operator=(const ReadMailAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReadMailAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadMailAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadMailAck* other);

  // implements Message ----------------------------------------------

  ReadMailAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadMailAck& from);
  void MergeFrom(const ReadMailAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mail_id = 1;
  inline bool has_mail_id() const;
  inline void clear_mail_id();
  static const int kMailIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mail_id() const;
  inline void set_mail_id(::google::protobuf::uint32 value);

  // optional uint32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReadMailAck)
 private:
  inline void set_has_mail_id();
  inline void clear_has_mail_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::uint32 mail_id_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReadMailAck* default_instance_;
};
// -------------------------------------------------------------------

class GetMailRewardReq : public ::google::protobuf::MessageLite {
 public:
  GetMailRewardReq();
  virtual ~GetMailRewardReq();

  GetMailRewardReq(const GetMailRewardReq& from);

  inline GetMailRewardReq& operator=(const GetMailRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetMailRewardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMailRewardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetMailRewardReq* other);

  // implements Message ----------------------------------------------

  GetMailRewardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMailRewardReq& from);
  void MergeFrom(const GetMailRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mail_id = 1;
  inline bool has_mail_id() const;
  inline void clear_mail_id();
  static const int kMailIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mail_id() const;
  inline void set_mail_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetMailRewardReq)
 private:
  inline void set_has_mail_id();
  inline void clear_has_mail_id();

  ::google::protobuf::uint32 mail_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetMailRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class GetMailRewardAck : public ::google::protobuf::MessageLite {
 public:
  GetMailRewardAck();
  virtual ~GetMailRewardAck();

  GetMailRewardAck(const GetMailRewardAck& from);

  inline GetMailRewardAck& operator=(const GetMailRewardAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetMailRewardAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMailRewardAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetMailRewardAck* other);

  // implements Message ----------------------------------------------

  GetMailRewardAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMailRewardAck& from);
  void MergeFrom(const GetMailRewardAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mail_id = 1;
  inline bool has_mail_id() const;
  inline void clear_mail_id();
  static const int kMailIdFieldNumber = 1;
  inline ::google::protobuf::uint32 mail_id() const;
  inline void set_mail_id(::google::protobuf::uint32 value);

  // optional uint32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetMailRewardAck)
 private:
  inline void set_has_mail_id();
  inline void clear_has_mail_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::uint32 mail_id_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetMailRewardAck* default_instance_;
};
// -------------------------------------------------------------------

class SendGMMailReq : public ::google::protobuf::MessageLite {
 public:
  SendGMMailReq();
  virtual ~SendGMMailReq();

  SendGMMailReq(const SendGMMailReq& from);

  inline SendGMMailReq& operator=(const SendGMMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const SendGMMailReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendGMMailReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendGMMailReq* other);

  // implements Message ----------------------------------------------

  SendGMMailReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendGMMailReq& from);
  void MergeFrom(const SendGMMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 to_acc_id = 1;
  inline bool has_to_acc_id() const;
  inline void clear_to_acc_id();
  static const int kToAccIdFieldNumber = 1;
  inline ::google::protobuf::uint32 to_acc_id() const;
  inline void set_to_acc_id(::google::protobuf::uint32 value);

  // optional uint32 to_char_id = 2;
  inline bool has_to_char_id() const;
  inline void clear_to_char_id();
  static const int kToCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_char_id() const;
  inline void set_to_char_id(::google::protobuf::uint32 value);

  // optional uint32 to_lv_low = 3;
  inline bool has_to_lv_low() const;
  inline void clear_to_lv_low();
  static const int kToLvLowFieldNumber = 3;
  inline ::google::protobuf::uint32 to_lv_low() const;
  inline void set_to_lv_low(::google::protobuf::uint32 value);

  // optional uint32 to_lv_high = 4;
  inline bool has_to_lv_high() const;
  inline void clear_to_lv_high();
  static const int kToLvHighFieldNumber = 4;
  inline ::google::protobuf::uint32 to_lv_high() const;
  inline void set_to_lv_high(::google::protobuf::uint32 value);

  // repeated uint32 item_id = 5;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 5;
  inline ::google::protobuf::uint32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::uint32 value);
  inline void add_item_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_id();

  // repeated uint32 item_num = 6;
  inline int item_num_size() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 6;
  inline ::google::protobuf::uint32 item_num(int index) const;
  inline void set_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_num();

  // optional uint32 end_time = 7;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // optional bytes to_char_name = 8;
  inline bool has_to_char_name() const;
  inline void clear_to_char_name();
  static const int kToCharNameFieldNumber = 8;
  inline const ::std::string& to_char_name() const;
  inline void set_to_char_name(const ::std::string& value);
  inline void set_to_char_name(const char* value);
  inline void set_to_char_name(const void* value, size_t size);
  inline ::std::string* mutable_to_char_name();
  inline ::std::string* release_to_char_name();
  inline void set_allocated_to_char_name(::std::string* to_char_name);

  // optional bytes mail_title = 9;
  inline bool has_mail_title() const;
  inline void clear_mail_title();
  static const int kMailTitleFieldNumber = 9;
  inline const ::std::string& mail_title() const;
  inline void set_mail_title(const ::std::string& value);
  inline void set_mail_title(const char* value);
  inline void set_mail_title(const void* value, size_t size);
  inline ::std::string* mutable_mail_title();
  inline ::std::string* release_mail_title();
  inline void set_allocated_mail_title(::std::string* mail_title);

  // optional bytes mail_content = 10;
  inline bool has_mail_content() const;
  inline void clear_mail_content();
  static const int kMailContentFieldNumber = 10;
  inline const ::std::string& mail_content() const;
  inline void set_mail_content(const ::std::string& value);
  inline void set_mail_content(const char* value);
  inline void set_mail_content(const void* value, size_t size);
  inline ::std::string* mutable_mail_content();
  inline ::std::string* release_mail_content();
  inline void set_allocated_mail_content(::std::string* mail_content);

  // @@protoc_insertion_point(class_scope:message.SendGMMailReq)
 private:
  inline void set_has_to_acc_id();
  inline void clear_has_to_acc_id();
  inline void set_has_to_char_id();
  inline void clear_has_to_char_id();
  inline void set_has_to_lv_low();
  inline void clear_has_to_lv_low();
  inline void set_has_to_lv_high();
  inline void clear_has_to_lv_high();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_to_char_name();
  inline void clear_has_to_char_name();
  inline void set_has_mail_title();
  inline void clear_has_mail_title();
  inline void set_has_mail_content();
  inline void clear_has_mail_content();

  ::google::protobuf::uint32 to_acc_id_;
  ::google::protobuf::uint32 to_char_id_;
  ::google::protobuf::uint32 to_lv_low_;
  ::google::protobuf::uint32 to_lv_high_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_num_;
  ::std::string* to_char_name_;
  ::std::string* mail_title_;
  ::std::string* mail_content_;
  ::google::protobuf::uint32 end_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SendGMMailReq* default_instance_;
};
// -------------------------------------------------------------------

class SendGMMailAck : public ::google::protobuf::MessageLite {
 public:
  SendGMMailAck();
  virtual ~SendGMMailAck();

  SendGMMailAck(const SendGMMailAck& from);

  inline SendGMMailAck& operator=(const SendGMMailAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const SendGMMailAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendGMMailAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendGMMailAck* other);

  // implements Message ----------------------------------------------

  SendGMMailAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendGMMailAck& from);
  void MergeFrom(const SendGMMailAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SendGMMailAck)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SendGMMailAck* default_instance_;
};
// -------------------------------------------------------------------

class NewMailNotice : public ::google::protobuf::MessageLite {
 public:
  NewMailNotice();
  virtual ~NewMailNotice();

  NewMailNotice(const NewMailNotice& from);

  inline NewMailNotice& operator=(const NewMailNotice& from) {
    CopyFrom(from);
    return *this;
  }

  static const NewMailNotice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewMailNotice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewMailNotice* other);

  // implements Message ----------------------------------------------

  NewMailNotice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewMailNotice& from);
  void MergeFrom(const NewMailNotice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 new_mail = 1;
  inline bool has_new_mail() const;
  inline void clear_new_mail();
  static const int kNewMailFieldNumber = 1;
  inline ::google::protobuf::uint32 new_mail() const;
  inline void set_new_mail(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.NewMailNotice)
 private:
  inline void set_has_new_mail();
  inline void clear_has_new_mail();

  ::google::protobuf::uint32 new_mail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static NewMailNotice* default_instance_;
};
// -------------------------------------------------------------------

class SelectMailInfoAck : public ::google::protobuf::MessageLite {
 public:
  SelectMailInfoAck();
  virtual ~SelectMailInfoAck();

  SelectMailInfoAck(const SelectMailInfoAck& from);

  inline SelectMailInfoAck& operator=(const SelectMailInfoAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const SelectMailInfoAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SelectMailInfoAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SelectMailInfoAck* other);

  // implements Message ----------------------------------------------

  SelectMailInfoAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SelectMailInfoAck& from);
  void MergeFrom(const SelectMailInfoAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes mail_data = 1;
  inline int mail_data_size() const;
  inline void clear_mail_data();
  static const int kMailDataFieldNumber = 1;
  inline const ::std::string& mail_data(int index) const;
  inline ::std::string* mutable_mail_data(int index);
  inline void set_mail_data(int index, const ::std::string& value);
  inline void set_mail_data(int index, const char* value);
  inline void set_mail_data(int index, const void* value, size_t size);
  inline ::std::string* add_mail_data();
  inline void add_mail_data(const ::std::string& value);
  inline void add_mail_data(const char* value);
  inline void add_mail_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mail_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mail_data();

  // optional uint32 is_last_one = 2;
  inline bool has_is_last_one() const;
  inline void clear_is_last_one();
  static const int kIsLastOneFieldNumber = 2;
  inline ::google::protobuf::uint32 is_last_one() const;
  inline void set_is_last_one(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SelectMailInfoAck)
 private:
  inline void set_has_is_last_one();
  inline void clear_has_is_last_one();

  ::google::protobuf::RepeatedPtrField< ::std::string> mail_data_;
  ::google::protobuf::uint32 is_last_one_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SelectMailInfoAck* default_instance_;
};
// -------------------------------------------------------------------

class GetSkillInfoReq : public ::google::protobuf::MessageLite {
 public:
  GetSkillInfoReq();
  virtual ~GetSkillInfoReq();

  GetSkillInfoReq(const GetSkillInfoReq& from);

  inline GetSkillInfoReq& operator=(const GetSkillInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetSkillInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetSkillInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetSkillInfoReq* other);

  // implements Message ----------------------------------------------

  GetSkillInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetSkillInfoReq& from);
  void MergeFrom(const GetSkillInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 nvalue = 1;
  inline bool has_nvalue() const;
  inline void clear_nvalue();
  static const int kNvalueFieldNumber = 1;
  inline ::google::protobuf::uint32 nvalue() const;
  inline void set_nvalue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetSkillInfoReq)
 private:
  inline void set_has_nvalue();
  inline void clear_has_nvalue();

  ::google::protobuf::uint32 nvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetSkillInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class GetSkillInfoAck : public ::google::protobuf::MessageLite {
 public:
  GetSkillInfoAck();
  virtual ~GetSkillInfoAck();

  GetSkillInfoAck(const GetSkillInfoAck& from);

  inline GetSkillInfoAck& operator=(const GetSkillInfoAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetSkillInfoAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetSkillInfoAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetSkillInfoAck* other);

  // implements Message ----------------------------------------------

  GetSkillInfoAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetSkillInfoAck& from);
  void MergeFrom(const GetSkillInfoAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 skill_point = 1;
  inline bool has_skill_point() const;
  inline void clear_skill_point();
  static const int kSkillPointFieldNumber = 1;
  inline ::google::protobuf::uint32 skill_point() const;
  inline void set_skill_point(::google::protobuf::uint32 value);

  // optional uint32 next_add_time = 2;
  inline bool has_next_add_time() const;
  inline void clear_next_add_time();
  static const int kNextAddTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 next_add_time() const;
  inline void set_next_add_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetSkillInfoAck)
 private:
  inline void set_has_skill_point();
  inline void clear_has_skill_point();
  inline void set_has_next_add_time();
  inline void clear_has_next_add_time();

  ::google::protobuf::uint32 skill_point_;
  ::google::protobuf::uint32 next_add_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetSkillInfoAck* default_instance_;
};
// -------------------------------------------------------------------

class EquipUpgradeItemReq : public ::google::protobuf::MessageLite {
 public:
  EquipUpgradeItemReq();
  virtual ~EquipUpgradeItemReq();

  EquipUpgradeItemReq(const EquipUpgradeItemReq& from);

  inline EquipUpgradeItemReq& operator=(const EquipUpgradeItemReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const EquipUpgradeItemReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EquipUpgradeItemReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EquipUpgradeItemReq* other);

  // implements Message ----------------------------------------------

  EquipUpgradeItemReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EquipUpgradeItemReq& from);
  void MergeFrom(const EquipUpgradeItemReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 merc_id = 1;
  inline bool has_merc_id() const;
  inline void clear_merc_id();
  static const int kMercIdFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_id() const;
  inline void set_merc_id(::google::protobuf::uint32 value);

  // optional uint32 equip_pos = 2;
  inline bool has_equip_pos() const;
  inline void clear_equip_pos();
  static const int kEquipPosFieldNumber = 2;
  inline ::google::protobuf::uint32 equip_pos() const;
  inline void set_equip_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.EquipUpgradeItemReq)
 private:
  inline void set_has_merc_id();
  inline void clear_has_merc_id();
  inline void set_has_equip_pos();
  inline void clear_has_equip_pos();

  ::google::protobuf::uint32 merc_id_;
  ::google::protobuf::uint32 equip_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static EquipUpgradeItemReq* default_instance_;
};
// -------------------------------------------------------------------

class UnlockedSkill : public ::google::protobuf::MessageLite {
 public:
  UnlockedSkill();
  virtual ~UnlockedSkill();

  UnlockedSkill(const UnlockedSkill& from);

  inline UnlockedSkill& operator=(const UnlockedSkill& from) {
    CopyFrom(from);
    return *this;
  }

  static const UnlockedSkill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnlockedSkill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnlockedSkill* other);

  // implements Message ----------------------------------------------

  UnlockedSkill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnlockedSkill& from);
  void MergeFrom(const UnlockedSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 merc_pos = 1;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // repeated uint32 skill_pos = 2;
  inline int skill_pos_size() const;
  inline void clear_skill_pos();
  static const int kSkillPosFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_pos(int index) const;
  inline void set_skill_pos(int index, ::google::protobuf::uint32 value);
  inline void add_skill_pos(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      skill_pos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_skill_pos();

  // @@protoc_insertion_point(class_scope:message.UnlockedSkill)
 private:
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > skill_pos_;
  ::google::protobuf::uint32 merc_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static UnlockedSkill* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetLastPvpRewardTime : public ::google::protobuf::MessageLite {
 public:
  ReqGetLastPvpRewardTime();
  virtual ~ReqGetLastPvpRewardTime();

  ReqGetLastPvpRewardTime(const ReqGetLastPvpRewardTime& from);

  inline ReqGetLastPvpRewardTime& operator=(const ReqGetLastPvpRewardTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReqGetLastPvpRewardTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReqGetLastPvpRewardTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReqGetLastPvpRewardTime* other);

  // implements Message ----------------------------------------------

  ReqGetLastPvpRewardTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReqGetLastPvpRewardTime& from);
  void MergeFrom(const ReqGetLastPvpRewardTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReqGetLastPvpRewardTime)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReqGetLastPvpRewardTime* default_instance_;
};
// -------------------------------------------------------------------

class PvpRewardTimeAck : public ::google::protobuf::MessageLite {
 public:
  PvpRewardTimeAck();
  virtual ~PvpRewardTimeAck();

  PvpRewardTimeAck(const PvpRewardTimeAck& from);

  inline PvpRewardTimeAck& operator=(const PvpRewardTimeAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const PvpRewardTimeAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PvpRewardTimeAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PvpRewardTimeAck* other);

  // implements Message ----------------------------------------------

  PvpRewardTimeAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PvpRewardTimeAck& from);
  void MergeFrom(const PvpRewardTimeAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 last_time = 1;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 last_time() const;
  inline void set_last_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.PvpRewardTimeAck)
 private:
  inline void set_has_last_time();
  inline void clear_has_last_time();

  ::google::protobuf::uint32 last_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static PvpRewardTimeAck* default_instance_;
};
// -------------------------------------------------------------------

class GetClimbTowerEnemyReq : public ::google::protobuf::MessageLite {
 public:
  GetClimbTowerEnemyReq();
  virtual ~GetClimbTowerEnemyReq();

  GetClimbTowerEnemyReq(const GetClimbTowerEnemyReq& from);

  inline GetClimbTowerEnemyReq& operator=(const GetClimbTowerEnemyReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetClimbTowerEnemyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetClimbTowerEnemyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetClimbTowerEnemyReq* other);

  // implements Message ----------------------------------------------

  GetClimbTowerEnemyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetClimbTowerEnemyReq& from);
  void MergeFrom(const GetClimbTowerEnemyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetClimbTowerEnemyReq)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();

  ::google::protobuf::uint32 map_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetClimbTowerEnemyReq* default_instance_;
};
// -------------------------------------------------------------------

class SelectClimbTowerEnemy : public ::google::protobuf::MessageLite {
 public:
  SelectClimbTowerEnemy();
  virtual ~SelectClimbTowerEnemy();

  SelectClimbTowerEnemy(const SelectClimbTowerEnemy& from);

  inline SelectClimbTowerEnemy& operator=(const SelectClimbTowerEnemy& from) {
    CopyFrom(from);
    return *this;
  }

  static const SelectClimbTowerEnemy& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SelectClimbTowerEnemy* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SelectClimbTowerEnemy* other);

  // implements Message ----------------------------------------------

  SelectClimbTowerEnemy* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SelectClimbTowerEnemy& from);
  void MergeFrom(const SelectClimbTowerEnemy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 3;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 battle_score_low = 4;
  inline bool has_battle_score_low() const;
  inline void clear_battle_score_low();
  static const int kBattleScoreLowFieldNumber = 4;
  inline ::google::protobuf::uint32 battle_score_low() const;
  inline void set_battle_score_low(::google::protobuf::uint32 value);

  // optional uint32 battle_score_high = 5;
  inline bool has_battle_score_high() const;
  inline void clear_battle_score_high();
  static const int kBattleScoreHighFieldNumber = 5;
  inline ::google::protobuf::uint32 battle_score_high() const;
  inline void set_battle_score_high(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SelectClimbTowerEnemy)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_battle_score_low();
  inline void clear_has_battle_score_low();
  inline void set_has_battle_score_high();
  inline void clear_has_battle_score_high();

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 battle_score_low_;
  ::google::protobuf::uint32 battle_score_high_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SelectClimbTowerEnemy* default_instance_;
};
// -------------------------------------------------------------------

class ClimbTowerEnemyData : public ::google::protobuf::MessageLite {
 public:
  ClimbTowerEnemyData();
  virtual ~ClimbTowerEnemyData();

  ClimbTowerEnemyData(const ClimbTowerEnemyData& from);

  inline ClimbTowerEnemyData& operator=(const ClimbTowerEnemyData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClimbTowerEnemyData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClimbTowerEnemyData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClimbTowerEnemyData* other);

  // implements Message ----------------------------------------------

  ClimbTowerEnemyData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClimbTowerEnemyData& from);
  void MergeFrom(const ClimbTowerEnemyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 query_type = 1;
  inline bool has_query_type() const;
  inline void clear_query_type();
  static const int kQueryTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 query_type() const;
  inline void set_query_type(::google::protobuf::uint32 value);

  // optional uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // optional uint32 char_sex = 3;
  inline bool has_char_sex() const;
  inline void clear_char_sex();
  static const int kCharSexFieldNumber = 3;
  inline ::google::protobuf::uint32 char_sex() const;
  inline void set_char_sex(::google::protobuf::uint32 value);

  // optional uint32 char_job = 4;
  inline bool has_char_job() const;
  inline void clear_char_job();
  static const int kCharJobFieldNumber = 4;
  inline ::google::protobuf::uint32 char_job() const;
  inline void set_char_job(::google::protobuf::uint32 value);

  // optional uint32 char_level = 5;
  inline bool has_char_level() const;
  inline void clear_char_level();
  static const int kCharLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 char_level() const;
  inline void set_char_level(::google::protobuf::uint32 value);

  // optional bytes char_name = 6;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 6;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // optional bytes merc_data = 7;
  inline bool has_merc_data() const;
  inline void clear_merc_data();
  static const int kMercDataFieldNumber = 7;
  inline const ::std::string& merc_data() const;
  inline void set_merc_data(const ::std::string& value);
  inline void set_merc_data(const char* value);
  inline void set_merc_data(const void* value, size_t size);
  inline ::std::string* mutable_merc_data();
  inline ::std::string* release_merc_data();
  inline void set_allocated_merc_data(::std::string* merc_data);

  // optional bytes equip_data = 8;
  inline bool has_equip_data() const;
  inline void clear_equip_data();
  static const int kEquipDataFieldNumber = 8;
  inline const ::std::string& equip_data() const;
  inline void set_equip_data(const ::std::string& value);
  inline void set_equip_data(const char* value);
  inline void set_equip_data(const void* value, size_t size);
  inline ::std::string* mutable_equip_data();
  inline ::std::string* release_equip_data();
  inline void set_allocated_equip_data(::std::string* equip_data);

  // @@protoc_insertion_point(class_scope:message.ClimbTowerEnemyData)
 private:
  inline void set_has_query_type();
  inline void clear_has_query_type();
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_char_sex();
  inline void clear_has_char_sex();
  inline void set_has_char_job();
  inline void clear_has_char_job();
  inline void set_has_char_level();
  inline void clear_has_char_level();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_merc_data();
  inline void clear_has_merc_data();
  inline void set_has_equip_data();
  inline void clear_has_equip_data();

  ::google::protobuf::uint32 query_type_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 char_sex_;
  ::google::protobuf::uint32 char_job_;
  ::std::string* char_name_;
  ::std::string* merc_data_;
  ::std::string* equip_data_;
  ::google::protobuf::uint32 char_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ClimbTowerEnemyData* default_instance_;
};
// -------------------------------------------------------------------

class GetClimbTowerEnemyAck_MercInfo : public ::google::protobuf::MessageLite {
 public:
  GetClimbTowerEnemyAck_MercInfo();
  virtual ~GetClimbTowerEnemyAck_MercInfo();

  GetClimbTowerEnemyAck_MercInfo(const GetClimbTowerEnemyAck_MercInfo& from);

  inline GetClimbTowerEnemyAck_MercInfo& operator=(const GetClimbTowerEnemyAck_MercInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetClimbTowerEnemyAck_MercInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetClimbTowerEnemyAck_MercInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetClimbTowerEnemyAck_MercInfo* other);

  // implements Message ----------------------------------------------

  GetClimbTowerEnemyAck_MercInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetClimbTowerEnemyAck_MercInfo& from);
  void MergeFrom(const GetClimbTowerEnemyAck_MercInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 merc_id = 1;
  inline bool has_merc_id() const;
  inline void clear_merc_id();
  static const int kMercIdFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_id() const;
  inline void set_merc_id(::google::protobuf::uint32 value);

  // optional uint32 merc_level = 2;
  inline bool has_merc_level() const;
  inline void clear_merc_level();
  static const int kMercLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 merc_level() const;
  inline void set_merc_level(::google::protobuf::uint32 value);

  // optional uint32 merc_color = 3;
  inline bool has_merc_color() const;
  inline void clear_merc_color();
  static const int kMercColorFieldNumber = 3;
  inline ::google::protobuf::uint32 merc_color() const;
  inline void set_merc_color(::google::protobuf::uint32 value);

  // optional uint32 merc_star = 4;
  inline bool has_merc_star() const;
  inline void clear_merc_star();
  static const int kMercStarFieldNumber = 4;
  inline ::google::protobuf::uint32 merc_star() const;
  inline void set_merc_star(::google::protobuf::uint32 value);

  // optional uint32 merc_blood = 5;
  inline bool has_merc_blood() const;
  inline void clear_merc_blood();
  static const int kMercBloodFieldNumber = 5;
  inline ::google::protobuf::uint32 merc_blood() const;
  inline void set_merc_blood(::google::protobuf::uint32 value);

  // optional uint32 merc_skill_energy = 6;
  inline bool has_merc_skill_energy() const;
  inline void clear_merc_skill_energy();
  static const int kMercSkillEnergyFieldNumber = 6;
  inline ::google::protobuf::uint32 merc_skill_energy() const;
  inline void set_merc_skill_energy(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetClimbTowerEnemyAck.MercInfo)
 private:
  inline void set_has_merc_id();
  inline void clear_has_merc_id();
  inline void set_has_merc_level();
  inline void clear_has_merc_level();
  inline void set_has_merc_color();
  inline void clear_has_merc_color();
  inline void set_has_merc_star();
  inline void clear_has_merc_star();
  inline void set_has_merc_blood();
  inline void clear_has_merc_blood();
  inline void set_has_merc_skill_energy();
  inline void clear_has_merc_skill_energy();

  ::google::protobuf::uint32 merc_id_;
  ::google::protobuf::uint32 merc_level_;
  ::google::protobuf::uint32 merc_color_;
  ::google::protobuf::uint32 merc_star_;
  ::google::protobuf::uint32 merc_blood_;
  ::google::protobuf::uint32 merc_skill_energy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetClimbTowerEnemyAck_MercInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetClimbTowerEnemyAck : public ::google::protobuf::MessageLite {
 public:
  GetClimbTowerEnemyAck();
  virtual ~GetClimbTowerEnemyAck();

  GetClimbTowerEnemyAck(const GetClimbTowerEnemyAck& from);

  inline GetClimbTowerEnemyAck& operator=(const GetClimbTowerEnemyAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetClimbTowerEnemyAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetClimbTowerEnemyAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetClimbTowerEnemyAck* other);

  // implements Message ----------------------------------------------

  GetClimbTowerEnemyAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetClimbTowerEnemyAck& from);
  void MergeFrom(const GetClimbTowerEnemyAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GetClimbTowerEnemyAck_MercInfo MercInfo;

  // accessors -------------------------------------------------------

  // optional uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // optional bytes char_name = 3;
  inline bool has_char_name() const;
  inline void clear_char_name();
  static const int kCharNameFieldNumber = 3;
  inline const ::std::string& char_name() const;
  inline void set_char_name(const ::std::string& value);
  inline void set_char_name(const char* value);
  inline void set_char_name(const void* value, size_t size);
  inline ::std::string* mutable_char_name();
  inline ::std::string* release_char_name();
  inline void set_allocated_char_name(::std::string* char_name);

  // optional uint32 char_sex = 4;
  inline bool has_char_sex() const;
  inline void clear_char_sex();
  static const int kCharSexFieldNumber = 4;
  inline ::google::protobuf::uint32 char_sex() const;
  inline void set_char_sex(::google::protobuf::uint32 value);

  // optional uint32 char_job = 5;
  inline bool has_char_job() const;
  inline void clear_char_job();
  static const int kCharJobFieldNumber = 5;
  inline ::google::protobuf::uint32 char_job() const;
  inline void set_char_job(::google::protobuf::uint32 value);

  // optional uint32 char_level = 6;
  inline bool has_char_level() const;
  inline void clear_char_level();
  static const int kCharLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 char_level() const;
  inline void set_char_level(::google::protobuf::uint32 value);

  // repeated .message.GetClimbTowerEnemyAck.MercInfo merc_data = 7;
  inline int merc_data_size() const;
  inline void clear_merc_data();
  static const int kMercDataFieldNumber = 7;
  inline const ::message::GetClimbTowerEnemyAck_MercInfo& merc_data(int index) const;
  inline ::message::GetClimbTowerEnemyAck_MercInfo* mutable_merc_data(int index);
  inline ::message::GetClimbTowerEnemyAck_MercInfo* add_merc_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::GetClimbTowerEnemyAck_MercInfo >&
      merc_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::GetClimbTowerEnemyAck_MercInfo >*
      mutable_merc_data();

  // @@protoc_insertion_point(class_scope:message.GetClimbTowerEnemyAck)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_char_name();
  inline void clear_has_char_name();
  inline void set_has_char_sex();
  inline void clear_has_char_sex();
  inline void set_has_char_job();
  inline void clear_has_char_job();
  inline void set_has_char_level();
  inline void clear_has_char_level();

  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::uint32 char_id_;
  ::std::string* char_name_;
  ::google::protobuf::uint32 char_sex_;
  ::google::protobuf::uint32 char_job_;
  ::google::protobuf::RepeatedPtrField< ::message::GetClimbTowerEnemyAck_MercInfo > merc_data_;
  ::google::protobuf::uint32 char_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetClimbTowerEnemyAck* default_instance_;
};
// -------------------------------------------------------------------

class GetClimbTowerRewardReq : public ::google::protobuf::MessageLite {
 public:
  GetClimbTowerRewardReq();
  virtual ~GetClimbTowerRewardReq();

  GetClimbTowerRewardReq(const GetClimbTowerRewardReq& from);

  inline GetClimbTowerRewardReq& operator=(const GetClimbTowerRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetClimbTowerRewardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetClimbTowerRewardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetClimbTowerRewardReq* other);

  // implements Message ----------------------------------------------

  GetClimbTowerRewardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetClimbTowerRewardReq& from);
  void MergeFrom(const GetClimbTowerRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.GetClimbTowerRewardReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetClimbTowerRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class GetClimbTowerRewardAck : public ::google::protobuf::MessageLite {
 public:
  GetClimbTowerRewardAck();
  virtual ~GetClimbTowerRewardAck();

  GetClimbTowerRewardAck(const GetClimbTowerRewardAck& from);

  inline GetClimbTowerRewardAck& operator=(const GetClimbTowerRewardAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetClimbTowerRewardAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetClimbTowerRewardAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetClimbTowerRewardAck* other);

  // implements Message ----------------------------------------------

  GetClimbTowerRewardAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetClimbTowerRewardAck& from);
  void MergeFrom(const GetClimbTowerRewardAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional uint32 money_num = 2;
  inline bool has_money_num() const;
  inline void clear_money_num();
  static const int kMoneyNumFieldNumber = 2;
  inline ::google::protobuf::uint32 money_num() const;
  inline void set_money_num(::google::protobuf::uint32 value);

  // optional uint32 ct_money = 3;
  inline bool has_ct_money() const;
  inline void clear_ct_money();
  static const int kCtMoneyFieldNumber = 3;
  inline ::google::protobuf::uint32 ct_money() const;
  inline void set_ct_money(::google::protobuf::uint32 value);

  // repeated uint32 item_id = 4;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 4;
  inline ::google::protobuf::uint32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::uint32 value);
  inline void add_item_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_id();

  // repeated uint32 item_num = 5;
  inline int item_num_size() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 5;
  inline ::google::protobuf::uint32 item_num(int index) const;
  inline void set_item_num(int index, ::google::protobuf::uint32 value);
  inline void add_item_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      item_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_item_num();

  // @@protoc_insertion_point(class_scope:message.GetClimbTowerRewardAck)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_money_num();
  inline void clear_has_money_num();
  inline void set_has_ct_money();
  inline void clear_has_ct_money();

  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::uint32 money_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > item_num_;
  ::google::protobuf::uint32 ct_money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static GetClimbTowerRewardAck* default_instance_;
};
// -------------------------------------------------------------------

class ReliveMercReq : public ::google::protobuf::MessageLite {
 public:
  ReliveMercReq();
  virtual ~ReliveMercReq();

  ReliveMercReq(const ReliveMercReq& from);

  inline ReliveMercReq& operator=(const ReliveMercReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReliveMercReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReliveMercReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReliveMercReq* other);

  // implements Message ----------------------------------------------

  ReliveMercReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReliveMercReq& from);
  void MergeFrom(const ReliveMercReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 merc_id = 1;
  inline bool has_merc_id() const;
  inline void clear_merc_id();
  static const int kMercIdFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_id() const;
  inline void set_merc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReliveMercReq)
 private:
  inline void set_has_merc_id();
  inline void clear_has_merc_id();

  ::google::protobuf::uint32 merc_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReliveMercReq* default_instance_;
};
// -------------------------------------------------------------------

class ReliveMercAck : public ::google::protobuf::MessageLite {
 public:
  ReliveMercAck();
  virtual ~ReliveMercAck();

  ReliveMercAck(const ReliveMercAck& from);

  inline ReliveMercAck& operator=(const ReliveMercAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReliveMercAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReliveMercAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReliveMercAck* other);

  // implements Message ----------------------------------------------

  ReliveMercAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReliveMercAck& from);
  void MergeFrom(const ReliveMercAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);

  // optional uint32 merc_pos = 2;
  inline bool has_merc_pos() const;
  inline void clear_merc_pos();
  static const int kMercPosFieldNumber = 2;
  inline ::google::protobuf::uint32 merc_pos() const;
  inline void set_merc_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ReliveMercAck)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_merc_pos();
  inline void clear_has_merc_pos();

  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::uint32 merc_pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ReliveMercAck* default_instance_;
};
// -------------------------------------------------------------------

class ResetClimbTowerReq : public ::google::protobuf::MessageLite {
 public:
  ResetClimbTowerReq();
  virtual ~ResetClimbTowerReq();

  ResetClimbTowerReq(const ResetClimbTowerReq& from);

  inline ResetClimbTowerReq& operator=(const ResetClimbTowerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResetClimbTowerReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResetClimbTowerReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResetClimbTowerReq* other);

  // implements Message ----------------------------------------------

  ResetClimbTowerReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResetClimbTowerReq& from);
  void MergeFrom(const ResetClimbTowerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ResetClimbTowerReq)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ResetClimbTowerReq* default_instance_;
};
// -------------------------------------------------------------------

class ClimbTowerBattleResult_SaveData : public ::google::protobuf::MessageLite {
 public:
  ClimbTowerBattleResult_SaveData();
  virtual ~ClimbTowerBattleResult_SaveData();

  ClimbTowerBattleResult_SaveData(const ClimbTowerBattleResult_SaveData& from);

  inline ClimbTowerBattleResult_SaveData& operator=(const ClimbTowerBattleResult_SaveData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClimbTowerBattleResult_SaveData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClimbTowerBattleResult_SaveData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClimbTowerBattleResult_SaveData* other);

  // implements Message ----------------------------------------------

  ClimbTowerBattleResult_SaveData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClimbTowerBattleResult_SaveData& from);
  void MergeFrom(const ClimbTowerBattleResult_SaveData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 merc_id = 1;
  inline bool has_merc_id() const;
  inline void clear_merc_id();
  static const int kMercIdFieldNumber = 1;
  inline ::google::protobuf::uint32 merc_id() const;
  inline void set_merc_id(::google::protobuf::uint32 value);

  // optional uint32 blood_num = 2;
  inline bool has_blood_num() const;
  inline void clear_blood_num();
  static const int kBloodNumFieldNumber = 2;
  inline ::google::protobuf::uint32 blood_num() const;
  inline void set_blood_num(::google::protobuf::uint32 value);

  // optional uint32 skill_energy = 3;
  inline bool has_skill_energy() const;
  inline void clear_skill_energy();
  static const int kSkillEnergyFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_energy() const;
  inline void set_skill_energy(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ClimbTowerBattleResult.SaveData)
 private:
  inline void set_has_merc_id();
  inline void clear_has_merc_id();
  inline void set_has_blood_num();
  inline void clear_has_blood_num();
  inline void set_has_skill_energy();
  inline void clear_has_skill_energy();

  ::google::protobuf::uint32 merc_id_;
  ::google::protobuf::uint32 blood_num_;
  ::google::protobuf::uint32 skill_energy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ClimbTowerBattleResult_SaveData* default_instance_;
};
// -------------------------------------------------------------------

class ClimbTowerBattleResult : public ::google::protobuf::MessageLite {
 public:
  ClimbTowerBattleResult();
  virtual ~ClimbTowerBattleResult();

  ClimbTowerBattleResult(const ClimbTowerBattleResult& from);

  inline ClimbTowerBattleResult& operator=(const ClimbTowerBattleResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClimbTowerBattleResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClimbTowerBattleResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClimbTowerBattleResult* other);

  // implements Message ----------------------------------------------

  ClimbTowerBattleResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClimbTowerBattleResult& from);
  void MergeFrom(const ClimbTowerBattleResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClimbTowerBattleResult_SaveData SaveData;

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 battle_result = 2;
  inline bool has_battle_result() const;
  inline void clear_battle_result();
  static const int kBattleResultFieldNumber = 2;
  inline ::google::protobuf::uint32 battle_result() const;
  inline void set_battle_result(::google::protobuf::uint32 value);

  // repeated .message.ClimbTowerBattleResult.SaveData source_data = 3;
  inline int source_data_size() const;
  inline void clear_source_data();
  static const int kSourceDataFieldNumber = 3;
  inline const ::message::ClimbTowerBattleResult_SaveData& source_data(int index) const;
  inline ::message::ClimbTowerBattleResult_SaveData* mutable_source_data(int index);
  inline ::message::ClimbTowerBattleResult_SaveData* add_source_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData >&
      source_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData >*
      mutable_source_data();

  // repeated .message.ClimbTowerBattleResult.SaveData target_data = 4;
  inline int target_data_size() const;
  inline void clear_target_data();
  static const int kTargetDataFieldNumber = 4;
  inline const ::message::ClimbTowerBattleResult_SaveData& target_data(int index) const;
  inline ::message::ClimbTowerBattleResult_SaveData* mutable_target_data(int index);
  inline ::message::ClimbTowerBattleResult_SaveData* add_target_data();
  inline const ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData >&
      target_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData >*
      mutable_target_data();

  // @@protoc_insertion_point(class_scope:message.ClimbTowerBattleResult)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_battle_result();
  inline void clear_has_battle_result();

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 battle_result_;
  ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData > source_data_;
  ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData > target_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ClimbTowerBattleResult* default_instance_;
};
// -------------------------------------------------------------------

class SaveCTEnemyInfo : public ::google::protobuf::MessageLite {
 public:
  SaveCTEnemyInfo();
  virtual ~SaveCTEnemyInfo();

  SaveCTEnemyInfo(const SaveCTEnemyInfo& from);

  inline SaveCTEnemyInfo& operator=(const SaveCTEnemyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SaveCTEnemyInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SaveCTEnemyInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SaveCTEnemyInfo* other);

  // implements Message ----------------------------------------------

  SaveCTEnemyInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SaveCTEnemyInfo& from);
  void MergeFrom(const SaveCTEnemyInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // optional uint32 server_id = 3;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional bytes enemy_info = 4;
  inline bool has_enemy_info() const;
  inline void clear_enemy_info();
  static const int kEnemyInfoFieldNumber = 4;
  inline const ::std::string& enemy_info() const;
  inline void set_enemy_info(const ::std::string& value);
  inline void set_enemy_info(const char* value);
  inline void set_enemy_info(const void* value, size_t size);
  inline ::std::string* mutable_enemy_info();
  inline ::std::string* release_enemy_info();
  inline void set_allocated_enemy_info(::std::string* enemy_info);

  // @@protoc_insertion_point(class_scope:message.SaveCTEnemyInfo)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_enemy_info();
  inline void clear_has_enemy_info();

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 char_id_;
  ::std::string* enemy_info_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SaveCTEnemyInfo* default_instance_;
};
// -------------------------------------------------------------------

class SendPvpRankRiseAwards : public ::google::protobuf::MessageLite {
 public:
  SendPvpRankRiseAwards();
  virtual ~SendPvpRankRiseAwards();

  SendPvpRankRiseAwards(const SendPvpRankRiseAwards& from);

  inline SendPvpRankRiseAwards& operator=(const SendPvpRankRiseAwards& from) {
    CopyFrom(from);
    return *this;
  }

  static const SendPvpRankRiseAwards& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendPvpRankRiseAwards* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendPvpRankRiseAwards* other);

  // implements Message ----------------------------------------------

  SendPvpRankRiseAwards* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendPvpRankRiseAwards& from);
  void MergeFrom(const SendPvpRankRiseAwards& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 history_rank = 1;
  inline bool has_history_rank() const;
  inline void clear_history_rank();
  static const int kHistoryRankFieldNumber = 1;
  inline ::google::protobuf::uint32 history_rank() const;
  inline void set_history_rank(::google::protobuf::uint32 value);

  // optional uint32 now_rank = 2;
  inline bool has_now_rank() const;
  inline void clear_now_rank();
  static const int kNowRankFieldNumber = 2;
  inline ::google::protobuf::uint32 now_rank() const;
  inline void set_now_rank(::google::protobuf::uint32 value);

  // optional uint32 scroll_point = 3;
  inline bool has_scroll_point() const;
  inline void clear_scroll_point();
  static const int kScrollPointFieldNumber = 3;
  inline ::google::protobuf::uint32 scroll_point() const;
  inline void set_scroll_point(::google::protobuf::uint32 value);

  // optional uint32 rank_rise = 4;
  inline bool has_rank_rise() const;
  inline void clear_rank_rise();
  static const int kRankRiseFieldNumber = 4;
  inline ::google::protobuf::uint32 rank_rise() const;
  inline void set_rank_rise(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.SendPvpRankRiseAwards)
 private:
  inline void set_has_history_rank();
  inline void clear_has_history_rank();
  inline void set_has_now_rank();
  inline void clear_has_now_rank();
  inline void set_has_scroll_point();
  inline void clear_has_scroll_point();
  inline void set_has_rank_rise();
  inline void clear_has_rank_rise();

  ::google::protobuf::uint32 history_rank_;
  ::google::protobuf::uint32 now_rank_;
  ::google::protobuf::uint32 scroll_point_;
  ::google::protobuf::uint32 rank_rise_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static SendPvpRankRiseAwards* default_instance_;
};
// -------------------------------------------------------------------

class VipOperResult : public ::google::protobuf::MessageLite {
 public:
  VipOperResult();
  virtual ~VipOperResult();

  VipOperResult(const VipOperResult& from);

  inline VipOperResult& operator=(const VipOperResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const VipOperResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VipOperResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VipOperResult* other);

  // implements Message ----------------------------------------------

  VipOperResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VipOperResult& from);
  void MergeFrom(const VipOperResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 oper_type = 1;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 oper_type() const;
  inline void set_oper_type(::google::protobuf::uint32 value);

  // optional uint32 oper_result = 2;
  inline bool has_oper_result() const;
  inline void clear_oper_result();
  static const int kOperResultFieldNumber = 2;
  inline ::google::protobuf::uint32 oper_result() const;
  inline void set_oper_result(::google::protobuf::uint32 value);

  // optional uint32 oper_other = 3;
  inline bool has_oper_other() const;
  inline void clear_oper_other();
  static const int kOperOtherFieldNumber = 3;
  inline ::google::protobuf::uint32 oper_other() const;
  inline void set_oper_other(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.VipOperResult)
 private:
  inline void set_has_oper_type();
  inline void clear_has_oper_type();
  inline void set_has_oper_result();
  inline void clear_has_oper_result();
  inline void set_has_oper_other();
  inline void clear_has_oper_other();

  ::google::protobuf::uint32 oper_type_;
  ::google::protobuf::uint32 oper_result_;
  ::google::protobuf::uint32 oper_other_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static VipOperResult* default_instance_;
};
// -------------------------------------------------------------------

class ItemCombineReq : public ::google::protobuf::MessageLite {
 public:
  ItemCombineReq();
  virtual ~ItemCombineReq();

  ItemCombineReq(const ItemCombineReq& from);

  inline ItemCombineReq& operator=(const ItemCombineReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemCombineReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemCombineReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemCombineReq* other);

  // implements Message ----------------------------------------------

  ItemCombineReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemCombineReq& from);
  void MergeFrom(const ItemCombineReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.ItemCombineReq)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();

  ::google::protobuf::uint32 item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static ItemCombineReq* default_instance_;
};
// ===================================================================


// ===================================================================

// GateIpPortInfo

// required uint32 gate_id = 1;
inline bool GateIpPortInfo::has_gate_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateIpPortInfo::set_has_gate_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateIpPortInfo::clear_has_gate_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateIpPortInfo::clear_gate_id() {
  gate_id_ = 0u;
  clear_has_gate_id();
}
inline ::google::protobuf::uint32 GateIpPortInfo::gate_id() const {
  return gate_id_;
}
inline void GateIpPortInfo::set_gate_id(::google::protobuf::uint32 value) {
  set_has_gate_id();
  gate_id_ = value;
}

// required string gate_ip = 2;
inline bool GateIpPortInfo::has_gate_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GateIpPortInfo::set_has_gate_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GateIpPortInfo::clear_has_gate_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GateIpPortInfo::clear_gate_ip() {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    gate_ip_->clear();
  }
  clear_has_gate_ip();
}
inline const ::std::string& GateIpPortInfo::gate_ip() const {
  return *gate_ip_;
}
inline void GateIpPortInfo::set_gate_ip(const ::std::string& value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void GateIpPortInfo::set_gate_ip(const char* value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void GateIpPortInfo::set_gate_ip(const char* value, size_t size) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GateIpPortInfo::mutable_gate_ip() {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  return gate_ip_;
}
inline ::std::string* GateIpPortInfo::release_gate_ip() {
  clear_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gate_ip_;
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GateIpPortInfo::set_allocated_gate_ip(::std::string* gate_ip) {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete gate_ip_;
  }
  if (gate_ip) {
    set_has_gate_ip();
    gate_ip_ = gate_ip;
  } else {
    clear_has_gate_ip();
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 gate_port = 3;
inline bool GateIpPortInfo::has_gate_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GateIpPortInfo::set_has_gate_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GateIpPortInfo::clear_has_gate_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GateIpPortInfo::clear_gate_port() {
  gate_port_ = 0u;
  clear_has_gate_port();
}
inline ::google::protobuf::uint32 GateIpPortInfo::gate_port() const {
  return gate_port_;
}
inline void GateIpPortInfo::set_gate_port(::google::protobuf::uint32 value) {
  set_has_gate_port();
  gate_port_ = value;
}

// -------------------------------------------------------------------

// VersionInfoRequest

// required uint32 ver_release = 1;
inline bool VersionInfoRequest::has_ver_release() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionInfoRequest::set_has_ver_release() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionInfoRequest::clear_has_ver_release() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionInfoRequest::clear_ver_release() {
  ver_release_ = 0u;
  clear_has_ver_release();
}
inline ::google::protobuf::uint32 VersionInfoRequest::ver_release() const {
  return ver_release_;
}
inline void VersionInfoRequest::set_ver_release(::google::protobuf::uint32 value) {
  set_has_ver_release();
  ver_release_ = value;
}

// required uint32 ver_freeze = 2;
inline bool VersionInfoRequest::has_ver_freeze() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionInfoRequest::set_has_ver_freeze() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionInfoRequest::clear_has_ver_freeze() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionInfoRequest::clear_ver_freeze() {
  ver_freeze_ = 0u;
  clear_has_ver_freeze();
}
inline ::google::protobuf::uint32 VersionInfoRequest::ver_freeze() const {
  return ver_freeze_;
}
inline void VersionInfoRequest::set_ver_freeze(::google::protobuf::uint32 value) {
  set_has_ver_freeze();
  ver_freeze_ = value;
}

// required uint32 ver_development = 3;
inline bool VersionInfoRequest::has_ver_development() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VersionInfoRequest::set_has_ver_development() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VersionInfoRequest::clear_has_ver_development() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VersionInfoRequest::clear_ver_development() {
  ver_development_ = 0u;
  clear_has_ver_development();
}
inline ::google::protobuf::uint32 VersionInfoRequest::ver_development() const {
  return ver_development_;
}
inline void VersionInfoRequest::set_ver_development(::google::protobuf::uint32 value) {
  set_has_ver_development();
  ver_development_ = value;
}

// required uint32 ver_patch = 4;
inline bool VersionInfoRequest::has_ver_patch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VersionInfoRequest::set_has_ver_patch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VersionInfoRequest::clear_has_ver_patch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VersionInfoRequest::clear_ver_patch() {
  ver_patch_ = 0u;
  clear_has_ver_patch();
}
inline ::google::protobuf::uint32 VersionInfoRequest::ver_patch() const {
  return ver_patch_;
}
inline void VersionInfoRequest::set_ver_patch(::google::protobuf::uint32 value) {
  set_has_ver_patch();
  ver_patch_ = value;
}

// optional uint32 ver_type = 5;
inline bool VersionInfoRequest::has_ver_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VersionInfoRequest::set_has_ver_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VersionInfoRequest::clear_has_ver_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VersionInfoRequest::clear_ver_type() {
  ver_type_ = 0u;
  clear_has_ver_type();
}
inline ::google::protobuf::uint32 VersionInfoRequest::ver_type() const {
  return ver_type_;
}
inline void VersionInfoRequest::set_ver_type(::google::protobuf::uint32 value) {
  set_has_ver_type();
  ver_type_ = value;
}

// optional uint32 ver_no = 6;
inline bool VersionInfoRequest::has_ver_no() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VersionInfoRequest::set_has_ver_no() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VersionInfoRequest::clear_has_ver_no() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VersionInfoRequest::clear_ver_no() {
  ver_no_ = 0u;
  clear_has_ver_no();
}
inline ::google::protobuf::uint32 VersionInfoRequest::ver_no() const {
  return ver_no_;
}
inline void VersionInfoRequest::set_ver_no(::google::protobuf::uint32 value) {
  set_has_ver_no();
  ver_no_ = value;
}

// -------------------------------------------------------------------

// VersionInfoResponse

// -------------------------------------------------------------------

// LoginAuthSys

// required int32 acc_id = 1;
inline bool LoginAuthSys::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAuthSys::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAuthSys::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAuthSys::clear_acc_id() {
  acc_id_ = 0;
  clear_has_acc_id();
}
inline ::google::protobuf::int32 LoginAuthSys::acc_id() const {
  return acc_id_;
}
inline void LoginAuthSys::set_acc_id(::google::protobuf::int32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required string session_str = 2;
inline bool LoginAuthSys::has_session_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginAuthSys::set_has_session_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginAuthSys::clear_has_session_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginAuthSys::clear_session_str() {
  if (session_str_ != &::google::protobuf::internal::kEmptyString) {
    session_str_->clear();
  }
  clear_has_session_str();
}
inline const ::std::string& LoginAuthSys::session_str() const {
  return *session_str_;
}
inline void LoginAuthSys::set_session_str(const ::std::string& value) {
  set_has_session_str();
  if (session_str_ == &::google::protobuf::internal::kEmptyString) {
    session_str_ = new ::std::string;
  }
  session_str_->assign(value);
}
inline void LoginAuthSys::set_session_str(const char* value) {
  set_has_session_str();
  if (session_str_ == &::google::protobuf::internal::kEmptyString) {
    session_str_ = new ::std::string;
  }
  session_str_->assign(value);
}
inline void LoginAuthSys::set_session_str(const char* value, size_t size) {
  set_has_session_str();
  if (session_str_ == &::google::protobuf::internal::kEmptyString) {
    session_str_ = new ::std::string;
  }
  session_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginAuthSys::mutable_session_str() {
  set_has_session_str();
  if (session_str_ == &::google::protobuf::internal::kEmptyString) {
    session_str_ = new ::std::string;
  }
  return session_str_;
}
inline ::std::string* LoginAuthSys::release_session_str() {
  clear_has_session_str();
  if (session_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_str_;
    session_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginAuthSys::set_allocated_session_str(::std::string* session_str) {
  if (session_str_ != &::google::protobuf::internal::kEmptyString) {
    delete session_str_;
  }
  if (session_str) {
    set_has_session_str();
    session_str_ = session_str;
  } else {
    clear_has_session_str();
    session_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes user_name = 3;
inline bool LoginAuthSys::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginAuthSys::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginAuthSys::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginAuthSys::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginAuthSys::user_name() const {
  return *user_name_;
}
inline void LoginAuthSys::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginAuthSys::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginAuthSys::set_user_name(const void* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginAuthSys::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* LoginAuthSys::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginAuthSys::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes user_pass = 4;
inline bool LoginAuthSys::has_user_pass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginAuthSys::set_has_user_pass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginAuthSys::clear_has_user_pass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginAuthSys::clear_user_pass() {
  if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
    user_pass_->clear();
  }
  clear_has_user_pass();
}
inline const ::std::string& LoginAuthSys::user_pass() const {
  return *user_pass_;
}
inline void LoginAuthSys::set_user_pass(const ::std::string& value) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(value);
}
inline void LoginAuthSys::set_user_pass(const char* value) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(value);
}
inline void LoginAuthSys::set_user_pass(const void* value, size_t size) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginAuthSys::mutable_user_pass() {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  return user_pass_;
}
inline ::std::string* LoginAuthSys::release_user_pass() {
  clear_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_pass_;
    user_pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginAuthSys::set_allocated_user_pass(::std::string* user_pass) {
  if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
    delete user_pass_;
  }
  if (user_pass) {
    set_has_user_pass();
    user_pass_ = user_pass;
  } else {
    clear_has_user_pass();
    user_pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gm_check = 5;
inline bool LoginAuthSys::has_gm_check() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginAuthSys::set_has_gm_check() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginAuthSys::clear_has_gm_check() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginAuthSys::clear_gm_check() {
  gm_check_ = 0u;
  clear_has_gm_check();
}
inline ::google::protobuf::uint32 LoginAuthSys::gm_check() const {
  return gm_check_;
}
inline void LoginAuthSys::set_gm_check(::google::protobuf::uint32 value) {
  set_has_gm_check();
  gm_check_ = value;
}

// -------------------------------------------------------------------

// LoginCenterAuthReq

// optional bytes user_name = 1;
inline bool LoginCenterAuthReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginCenterAuthReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginCenterAuthReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginCenterAuthReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginCenterAuthReq::user_name() const {
  return *user_name_;
}
inline void LoginCenterAuthReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginCenterAuthReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginCenterAuthReq::set_user_name(const void* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCenterAuthReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* LoginCenterAuthReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginCenterAuthReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes user_pass = 2;
inline bool LoginCenterAuthReq::has_user_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginCenterAuthReq::set_has_user_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginCenterAuthReq::clear_has_user_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginCenterAuthReq::clear_user_pass() {
  if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
    user_pass_->clear();
  }
  clear_has_user_pass();
}
inline const ::std::string& LoginCenterAuthReq::user_pass() const {
  return *user_pass_;
}
inline void LoginCenterAuthReq::set_user_pass(const ::std::string& value) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(value);
}
inline void LoginCenterAuthReq::set_user_pass(const char* value) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(value);
}
inline void LoginCenterAuthReq::set_user_pass(const void* value, size_t size) {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  user_pass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCenterAuthReq::mutable_user_pass() {
  set_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    user_pass_ = new ::std::string;
  }
  return user_pass_;
}
inline ::std::string* LoginCenterAuthReq::release_user_pass() {
  clear_has_user_pass();
  if (user_pass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_pass_;
    user_pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginCenterAuthReq::set_allocated_user_pass(::std::string* user_pass) {
  if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
    delete user_pass_;
  }
  if (user_pass) {
    set_has_user_pass();
    user_pass_ = user_pass;
  } else {
    clear_has_user_pass();
    user_pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes user_ip = 3;
inline bool LoginCenterAuthReq::has_user_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginCenterAuthReq::set_has_user_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginCenterAuthReq::clear_has_user_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginCenterAuthReq::clear_user_ip() {
  if (user_ip_ != &::google::protobuf::internal::kEmptyString) {
    user_ip_->clear();
  }
  clear_has_user_ip();
}
inline const ::std::string& LoginCenterAuthReq::user_ip() const {
  return *user_ip_;
}
inline void LoginCenterAuthReq::set_user_ip(const ::std::string& value) {
  set_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void LoginCenterAuthReq::set_user_ip(const char* value) {
  set_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void LoginCenterAuthReq::set_user_ip(const void* value, size_t size) {
  set_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCenterAuthReq::mutable_user_ip() {
  set_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    user_ip_ = new ::std::string;
  }
  return user_ip_;
}
inline ::std::string* LoginCenterAuthReq::release_user_ip() {
  clear_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_ip_;
    user_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginCenterAuthReq::set_allocated_user_ip(::std::string* user_ip) {
  if (user_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete user_ip_;
  }
  if (user_ip) {
    set_has_user_ip();
    user_ip_ = user_ip;
  } else {
    clear_has_user_ip();
    user_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gm_check = 4;
inline bool LoginCenterAuthReq::has_gm_check() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginCenterAuthReq::set_has_gm_check() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginCenterAuthReq::clear_has_gm_check() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginCenterAuthReq::clear_gm_check() {
  gm_check_ = 0u;
  clear_has_gm_check();
}
inline ::google::protobuf::uint32 LoginCenterAuthReq::gm_check() const {
  return gm_check_;
}
inline void LoginCenterAuthReq::set_gm_check(::google::protobuf::uint32 value) {
  set_has_gm_check();
  gm_check_ = value;
}

// -------------------------------------------------------------------

// CenterGateState_CenterGateStateInfo

// required uint32 server_id = 1;
inline bool CenterGateState_CenterGateStateInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterGateState_CenterGateStateInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterGateState_CenterGateStateInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterGateState_CenterGateStateInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 CenterGateState_CenterGateStateInfo::server_id() const {
  return server_id_;
}
inline void CenterGateState_CenterGateStateInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// required uint32 server_state = 2;
inline bool CenterGateState_CenterGateStateInfo::has_server_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CenterGateState_CenterGateStateInfo::set_has_server_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CenterGateState_CenterGateStateInfo::clear_has_server_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CenterGateState_CenterGateStateInfo::clear_server_state() {
  server_state_ = 0u;
  clear_has_server_state();
}
inline ::google::protobuf::uint32 CenterGateState_CenterGateStateInfo::server_state() const {
  return server_state_;
}
inline void CenterGateState_CenterGateStateInfo::set_server_state(::google::protobuf::uint32 value) {
  set_has_server_state();
  server_state_ = value;
}

// -------------------------------------------------------------------

// CenterGateState

// repeated .message.CenterGateState.CenterGateStateInfo server_state_info = 1;
inline int CenterGateState::server_state_info_size() const {
  return server_state_info_.size();
}
inline void CenterGateState::clear_server_state_info() {
  server_state_info_.Clear();
}
inline const ::message::CenterGateState_CenterGateStateInfo& CenterGateState::server_state_info(int index) const {
  return server_state_info_.Get(index);
}
inline ::message::CenterGateState_CenterGateStateInfo* CenterGateState::mutable_server_state_info(int index) {
  return server_state_info_.Mutable(index);
}
inline ::message::CenterGateState_CenterGateStateInfo* CenterGateState::add_server_state_info() {
  return server_state_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::CenterGateState_CenterGateStateInfo >&
CenterGateState::server_state_info() const {
  return server_state_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::CenterGateState_CenterGateStateInfo >*
CenterGateState::mutable_server_state_info() {
  return &server_state_info_;
}

// -------------------------------------------------------------------

// LoginCenterAuthAck

// required int32 acc_id = 1;
inline bool LoginCenterAuthAck::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginCenterAuthAck::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginCenterAuthAck::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginCenterAuthAck::clear_acc_id() {
  acc_id_ = 0;
  clear_has_acc_id();
}
inline ::google::protobuf::int32 LoginCenterAuthAck::acc_id() const {
  return acc_id_;
}
inline void LoginCenterAuthAck::set_acc_id(::google::protobuf::int32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// optional bytes user_name = 2;
inline bool LoginCenterAuthAck::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginCenterAuthAck::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginCenterAuthAck::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginCenterAuthAck::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginCenterAuthAck::user_name() const {
  return *user_name_;
}
inline void LoginCenterAuthAck::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginCenterAuthAck::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginCenterAuthAck::set_user_name(const void* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCenterAuthAck::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* LoginCenterAuthAck::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginCenterAuthAck::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 3;
inline bool LoginCenterAuthAck::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginCenterAuthAck::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginCenterAuthAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginCenterAuthAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginCenterAuthAck::result() const {
  return result_;
}
inline void LoginCenterAuthAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 last_server = 4;
inline bool LoginCenterAuthAck::has_last_server() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginCenterAuthAck::set_has_last_server() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginCenterAuthAck::clear_has_last_server() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginCenterAuthAck::clear_last_server() {
  last_server_ = 0;
  clear_has_last_server();
}
inline ::google::protobuf::int32 LoginCenterAuthAck::last_server() const {
  return last_server_;
}
inline void LoginCenterAuthAck::set_last_server(::google::protobuf::int32 value) {
  set_has_last_server();
  last_server_ = value;
}

// -------------------------------------------------------------------

// LoginCenterCharInfo_LoginServerCharInfo

// required uint32 server_id = 1;
inline bool LoginCenterCharInfo_LoginServerCharInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 LoginCenterCharInfo_LoginServerCharInfo::server_id() const {
  return server_id_;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// required uint32 char_job = 2;
inline bool LoginCenterCharInfo_LoginServerCharInfo::has_char_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_has_char_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_has_char_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_char_job() {
  char_job_ = 0u;
  clear_has_char_job();
}
inline ::google::protobuf::uint32 LoginCenterCharInfo_LoginServerCharInfo::char_job() const {
  return char_job_;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_char_job(::google::protobuf::uint32 value) {
  set_has_char_job();
  char_job_ = value;
}

// required uint32 char_level = 3;
inline bool LoginCenterCharInfo_LoginServerCharInfo::has_char_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_has_char_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_has_char_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_char_level() {
  char_level_ = 0u;
  clear_has_char_level();
}
inline ::google::protobuf::uint32 LoginCenterCharInfo_LoginServerCharInfo::char_level() const {
  return char_level_;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_char_level(::google::protobuf::uint32 value) {
  set_has_char_level();
  char_level_ = value;
}

// required uint32 char_sex = 4;
inline bool LoginCenterCharInfo_LoginServerCharInfo::has_char_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_has_char_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_has_char_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_char_sex() {
  char_sex_ = 0u;
  clear_has_char_sex();
}
inline ::google::protobuf::uint32 LoginCenterCharInfo_LoginServerCharInfo::char_sex() const {
  return char_sex_;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_char_sex(::google::protobuf::uint32 value) {
  set_has_char_sex();
  char_sex_ = value;
}

// required uint32 gm_type = 5;
inline bool LoginCenterCharInfo_LoginServerCharInfo::has_gm_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_has_gm_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_has_gm_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::clear_gm_type() {
  gm_type_ = 0u;
  clear_has_gm_type();
}
inline ::google::protobuf::uint32 LoginCenterCharInfo_LoginServerCharInfo::gm_type() const {
  return gm_type_;
}
inline void LoginCenterCharInfo_LoginServerCharInfo::set_gm_type(::google::protobuf::uint32 value) {
  set_has_gm_type();
  gm_type_ = value;
}

// -------------------------------------------------------------------

// LoginCenterCharInfo

// required uint32 acc_id = 1;
inline bool LoginCenterCharInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginCenterCharInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginCenterCharInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginCenterCharInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 LoginCenterCharInfo::acc_id() const {
  return acc_id_;
}
inline void LoginCenterCharInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// optional bytes acc_name = 2;
inline bool LoginCenterCharInfo::has_acc_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginCenterCharInfo::set_has_acc_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginCenterCharInfo::clear_has_acc_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginCenterCharInfo::clear_acc_name() {
  if (acc_name_ != &::google::protobuf::internal::kEmptyString) {
    acc_name_->clear();
  }
  clear_has_acc_name();
}
inline const ::std::string& LoginCenterCharInfo::acc_name() const {
  return *acc_name_;
}
inline void LoginCenterCharInfo::set_acc_name(const ::std::string& value) {
  set_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    acc_name_ = new ::std::string;
  }
  acc_name_->assign(value);
}
inline void LoginCenterCharInfo::set_acc_name(const char* value) {
  set_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    acc_name_ = new ::std::string;
  }
  acc_name_->assign(value);
}
inline void LoginCenterCharInfo::set_acc_name(const void* value, size_t size) {
  set_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    acc_name_ = new ::std::string;
  }
  acc_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCenterCharInfo::mutable_acc_name() {
  set_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    acc_name_ = new ::std::string;
  }
  return acc_name_;
}
inline ::std::string* LoginCenterCharInfo::release_acc_name() {
  clear_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_name_;
    acc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginCenterCharInfo::set_allocated_acc_name(::std::string* acc_name) {
  if (acc_name_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_name_;
  }
  if (acc_name) {
    set_has_acc_name();
    acc_name_ = acc_name;
  } else {
    clear_has_acc_name();
    acc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .message.LoginCenterCharInfo.LoginServerCharInfo server_char_info = 3;
inline int LoginCenterCharInfo::server_char_info_size() const {
  return server_char_info_.size();
}
inline void LoginCenterCharInfo::clear_server_char_info() {
  server_char_info_.Clear();
}
inline const ::message::LoginCenterCharInfo_LoginServerCharInfo& LoginCenterCharInfo::server_char_info(int index) const {
  return server_char_info_.Get(index);
}
inline ::message::LoginCenterCharInfo_LoginServerCharInfo* LoginCenterCharInfo::mutable_server_char_info(int index) {
  return server_char_info_.Mutable(index);
}
inline ::message::LoginCenterCharInfo_LoginServerCharInfo* LoginCenterCharInfo::add_server_char_info() {
  return server_char_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::LoginCenterCharInfo_LoginServerCharInfo >&
LoginCenterCharInfo::server_char_info() const {
  return server_char_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::LoginCenterCharInfo_LoginServerCharInfo >*
LoginCenterCharInfo::mutable_server_char_info() {
  return &server_char_info_;
}

// -------------------------------------------------------------------

// LoginAuthAck

// required uint32 acc_id = 1;
inline bool LoginAuthAck::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAuthAck::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAuthAck::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAuthAck::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 LoginAuthAck::acc_id() const {
  return acc_id_;
}
inline void LoginAuthAck::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// LoginAuthNack

// required uint32 error_code = 1;
inline bool LoginAuthNack::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAuthNack::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAuthNack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAuthNack::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 LoginAuthNack::error_code() const {
  return error_code_;
}
inline void LoginAuthNack::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// LoginServerList_LoginServerInfo

// optional uint32 server_id = 1;
inline bool LoginServerList_LoginServerInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginServerList_LoginServerInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginServerList_LoginServerInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 LoginServerList_LoginServerInfo::server_id() const {
  return server_id_;
}
inline void LoginServerList_LoginServerInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional bytes server_name = 2;
inline bool LoginServerList_LoginServerInfo::has_server_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_server_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginServerList_LoginServerInfo::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginServerList_LoginServerInfo::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& LoginServerList_LoginServerInfo::server_name() const {
  return *server_name_;
}
inline void LoginServerList_LoginServerInfo::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void LoginServerList_LoginServerInfo::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void LoginServerList_LoginServerInfo::set_server_name(const void* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginServerList_LoginServerInfo::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* LoginServerList_LoginServerInfo::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginServerList_LoginServerInfo::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_state = 3;
inline bool LoginServerList_LoginServerInfo::has_server_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_server_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginServerList_LoginServerInfo::clear_has_server_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginServerList_LoginServerInfo::clear_server_state() {
  server_state_ = 0u;
  clear_has_server_state();
}
inline ::google::protobuf::uint32 LoginServerList_LoginServerInfo::server_state() const {
  return server_state_;
}
inline void LoginServerList_LoginServerInfo::set_server_state(::google::protobuf::uint32 value) {
  set_has_server_state();
  server_state_ = value;
}

// optional uint32 server_new = 4;
inline bool LoginServerList_LoginServerInfo::has_server_new() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_server_new() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginServerList_LoginServerInfo::clear_has_server_new() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginServerList_LoginServerInfo::clear_server_new() {
  server_new_ = 0u;
  clear_has_server_new();
}
inline ::google::protobuf::uint32 LoginServerList_LoginServerInfo::server_new() const {
  return server_new_;
}
inline void LoginServerList_LoginServerInfo::set_server_new(::google::protobuf::uint32 value) {
  set_has_server_new();
  server_new_ = value;
}

// optional uint32 char_job = 5;
inline bool LoginServerList_LoginServerInfo::has_char_job() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_char_job() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginServerList_LoginServerInfo::clear_has_char_job() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginServerList_LoginServerInfo::clear_char_job() {
  char_job_ = 0u;
  clear_has_char_job();
}
inline ::google::protobuf::uint32 LoginServerList_LoginServerInfo::char_job() const {
  return char_job_;
}
inline void LoginServerList_LoginServerInfo::set_char_job(::google::protobuf::uint32 value) {
  set_has_char_job();
  char_job_ = value;
}

// optional uint32 char_level = 6;
inline bool LoginServerList_LoginServerInfo::has_char_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_char_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginServerList_LoginServerInfo::clear_has_char_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginServerList_LoginServerInfo::clear_char_level() {
  char_level_ = 0u;
  clear_has_char_level();
}
inline ::google::protobuf::uint32 LoginServerList_LoginServerInfo::char_level() const {
  return char_level_;
}
inline void LoginServerList_LoginServerInfo::set_char_level(::google::protobuf::uint32 value) {
  set_has_char_level();
  char_level_ = value;
}

// optional uint32 server_player_count = 7;
inline bool LoginServerList_LoginServerInfo::has_server_player_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_server_player_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginServerList_LoginServerInfo::clear_has_server_player_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginServerList_LoginServerInfo::clear_server_player_count() {
  server_player_count_ = 0u;
  clear_has_server_player_count();
}
inline ::google::protobuf::uint32 LoginServerList_LoginServerInfo::server_player_count() const {
  return server_player_count_;
}
inline void LoginServerList_LoginServerInfo::set_server_player_count(::google::protobuf::uint32 value) {
  set_has_server_player_count();
  server_player_count_ = value;
}

// optional uint32 char_sex = 8;
inline bool LoginServerList_LoginServerInfo::has_char_sex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_char_sex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginServerList_LoginServerInfo::clear_has_char_sex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginServerList_LoginServerInfo::clear_char_sex() {
  char_sex_ = 0u;
  clear_has_char_sex();
}
inline ::google::protobuf::uint32 LoginServerList_LoginServerInfo::char_sex() const {
  return char_sex_;
}
inline void LoginServerList_LoginServerInfo::set_char_sex(::google::protobuf::uint32 value) {
  set_has_char_sex();
  char_sex_ = value;
}

// optional uint32 gm_type = 9;
inline bool LoginServerList_LoginServerInfo::has_gm_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginServerList_LoginServerInfo::set_has_gm_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginServerList_LoginServerInfo::clear_has_gm_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginServerList_LoginServerInfo::clear_gm_type() {
  gm_type_ = 0u;
  clear_has_gm_type();
}
inline ::google::protobuf::uint32 LoginServerList_LoginServerInfo::gm_type() const {
  return gm_type_;
}
inline void LoginServerList_LoginServerInfo::set_gm_type(::google::protobuf::uint32 value) {
  set_has_gm_type();
  gm_type_ = value;
}

// -------------------------------------------------------------------

// LoginServerList

// repeated .message.LoginServerList.LoginServerInfo server_info = 1;
inline int LoginServerList::server_info_size() const {
  return server_info_.size();
}
inline void LoginServerList::clear_server_info() {
  server_info_.Clear();
}
inline const ::message::LoginServerList_LoginServerInfo& LoginServerList::server_info(int index) const {
  return server_info_.Get(index);
}
inline ::message::LoginServerList_LoginServerInfo* LoginServerList::mutable_server_info(int index) {
  return server_info_.Mutable(index);
}
inline ::message::LoginServerList_LoginServerInfo* LoginServerList::add_server_info() {
  return server_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::LoginServerList_LoginServerInfo >&
LoginServerList::server_info() const {
  return server_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::LoginServerList_LoginServerInfo >*
LoginServerList::mutable_server_info() {
  return &server_info_;
}

// optional uint32 last_server = 2;
inline bool LoginServerList::has_last_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginServerList::set_has_last_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginServerList::clear_has_last_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginServerList::clear_last_server() {
  last_server_ = 0u;
  clear_has_last_server();
}
inline ::google::protobuf::uint32 LoginServerList::last_server() const {
  return last_server_;
}
inline void LoginServerList::set_last_server(::google::protobuf::uint32 value) {
  set_has_last_server();
  last_server_ = value;
}

// -------------------------------------------------------------------

// LoginServerChoose

// required uint32 server_id = 1;
inline bool LoginServerChoose::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginServerChoose::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginServerChoose::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginServerChoose::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 LoginServerChoose::server_id() const {
  return server_id_;
}
inline void LoginServerChoose::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 char_id = 2;
inline bool LoginServerChoose::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginServerChoose::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginServerChoose::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginServerChoose::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 LoginServerChoose::char_id() const {
  return char_id_;
}
inline void LoginServerChoose::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// CenterServerChoose

// required uint32 server_id = 1;
inline bool CenterServerChoose::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterServerChoose::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterServerChoose::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterServerChoose::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 CenterServerChoose::server_id() const {
  return server_id_;
}
inline void CenterServerChoose::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 char_id = 2;
inline bool CenterServerChoose::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CenterServerChoose::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CenterServerChoose::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CenterServerChoose::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 CenterServerChoose::char_id() const {
  return char_id_;
}
inline void CenterServerChoose::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// GateInfoSys

// required uint32 acc_id = 1;
inline bool GateInfoSys::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateInfoSys::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateInfoSys::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateInfoSys::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 GateInfoSys::acc_id() const {
  return acc_id_;
}
inline void GateInfoSys::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 session_id = 2;
inline bool GateInfoSys::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GateInfoSys::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GateInfoSys::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GateInfoSys::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 GateInfoSys::session_id() const {
  return session_id_;
}
inline void GateInfoSys::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional uint32 sever_id = 3;
inline bool GateInfoSys::has_sever_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GateInfoSys::set_has_sever_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GateInfoSys::clear_has_sever_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GateInfoSys::clear_sever_id() {
  sever_id_ = 0u;
  clear_has_sever_id();
}
inline ::google::protobuf::uint32 GateInfoSys::sever_id() const {
  return sever_id_;
}
inline void GateInfoSys::set_sever_id(::google::protobuf::uint32 value) {
  set_has_sever_id();
  sever_id_ = value;
}

// -------------------------------------------------------------------

// GateInfoNack

// required uint32 session_id = 1;
inline bool GateInfoNack::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateInfoNack::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateInfoNack::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateInfoNack::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 GateInfoNack::session_id() const {
  return session_id_;
}
inline void GateInfoNack::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required uint32 error_code = 2;
inline bool GateInfoNack::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GateInfoNack::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GateInfoNack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GateInfoNack::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 GateInfoNack::error_code() const {
  return error_code_;
}
inline void GateInfoNack::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// GateInfoAck

// required uint32 session_id = 1;
inline bool GateInfoAck::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateInfoAck::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateInfoAck::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateInfoAck::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 GateInfoAck::session_id() const {
  return session_id_;
}
inline void GateInfoAck::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required uint32 acc_id = 2;
inline bool GateInfoAck::has_acc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GateInfoAck::set_has_acc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GateInfoAck::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GateInfoAck::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 GateInfoAck::acc_id() const {
  return acc_id_;
}
inline void GateInfoAck::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 nPort = 3;
inline bool GateInfoAck::has_nport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GateInfoAck::set_has_nport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GateInfoAck::clear_has_nport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GateInfoAck::clear_nport() {
  nport_ = 0u;
  clear_has_nport();
}
inline ::google::protobuf::uint32 GateInfoAck::nport() const {
  return nport_;
}
inline void GateInfoAck::set_nport(::google::protobuf::uint32 value) {
  set_has_nport();
  nport_ = value;
}

// required string sGateIp = 4;
inline bool GateInfoAck::has_sgateip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GateInfoAck::set_has_sgateip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GateInfoAck::clear_has_sgateip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GateInfoAck::clear_sgateip() {
  if (sgateip_ != &::google::protobuf::internal::kEmptyString) {
    sgateip_->clear();
  }
  clear_has_sgateip();
}
inline const ::std::string& GateInfoAck::sgateip() const {
  return *sgateip_;
}
inline void GateInfoAck::set_sgateip(const ::std::string& value) {
  set_has_sgateip();
  if (sgateip_ == &::google::protobuf::internal::kEmptyString) {
    sgateip_ = new ::std::string;
  }
  sgateip_->assign(value);
}
inline void GateInfoAck::set_sgateip(const char* value) {
  set_has_sgateip();
  if (sgateip_ == &::google::protobuf::internal::kEmptyString) {
    sgateip_ = new ::std::string;
  }
  sgateip_->assign(value);
}
inline void GateInfoAck::set_sgateip(const char* value, size_t size) {
  set_has_sgateip();
  if (sgateip_ == &::google::protobuf::internal::kEmptyString) {
    sgateip_ = new ::std::string;
  }
  sgateip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GateInfoAck::mutable_sgateip() {
  set_has_sgateip();
  if (sgateip_ == &::google::protobuf::internal::kEmptyString) {
    sgateip_ = new ::std::string;
  }
  return sgateip_;
}
inline ::std::string* GateInfoAck::release_sgateip() {
  clear_has_sgateip();
  if (sgateip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sgateip_;
    sgateip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GateInfoAck::set_allocated_sgateip(::std::string* sgateip) {
  if (sgateip_ != &::google::protobuf::internal::kEmptyString) {
    delete sgateip_;
  }
  if (sgateip) {
    set_has_sgateip();
    sgateip_ = sgateip;
  } else {
    clear_has_sgateip();
    sgateip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserDisconnect

// required uint32 acc_id = 1;
inline bool UserDisconnect::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDisconnect::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDisconnect::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDisconnect::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 UserDisconnect::acc_id() const {
  return acc_id_;
}
inline void UserDisconnect::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// GateGetNonceSys

// -------------------------------------------------------------------

// GateAuchNonce

// required uint32 nonce = 1;
inline bool GateAuchNonce::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateAuchNonce::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateAuchNonce::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateAuchNonce::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 GateAuchNonce::nonce() const {
  return nonce_;
}
inline void GateAuchNonce::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
}

// -------------------------------------------------------------------

// GateAuthSys

// required uint32 acc_id = 1;
inline bool GateAuthSys::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateAuthSys::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateAuthSys::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateAuthSys::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 GateAuthSys::acc_id() const {
  return acc_id_;
}
inline void GateAuthSys::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 client_nonce = 2;
inline bool GateAuthSys::has_client_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GateAuthSys::set_has_client_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GateAuthSys::clear_has_client_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GateAuthSys::clear_client_nonce() {
  client_nonce_ = 0u;
  clear_has_client_nonce();
}
inline ::google::protobuf::uint32 GateAuthSys::client_nonce() const {
  return client_nonce_;
}
inline void GateAuthSys::set_client_nonce(::google::protobuf::uint32 value) {
  set_has_client_nonce();
  client_nonce_ = value;
}

// required bytes digest = 3;
inline bool GateAuthSys::has_digest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GateAuthSys::set_has_digest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GateAuthSys::clear_has_digest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GateAuthSys::clear_digest() {
  if (digest_ != &::google::protobuf::internal::kEmptyString) {
    digest_->clear();
  }
  clear_has_digest();
}
inline const ::std::string& GateAuthSys::digest() const {
  return *digest_;
}
inline void GateAuthSys::set_digest(const ::std::string& value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
}
inline void GateAuthSys::set_digest(const char* value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
}
inline void GateAuthSys::set_digest(const void* value, size_t size) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GateAuthSys::mutable_digest() {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  return digest_;
}
inline ::std::string* GateAuthSys::release_digest() {
  clear_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = digest_;
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GateAuthSys::set_allocated_digest(::std::string* digest) {
  if (digest_ != &::google::protobuf::internal::kEmptyString) {
    delete digest_;
  }
  if (digest) {
    set_has_digest();
    digest_ = digest;
  } else {
    clear_has_digest();
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CenterAuthSys

// required uint32 acc_id = 1;
inline bool CenterAuthSys::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterAuthSys::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterAuthSys::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterAuthSys::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 CenterAuthSys::acc_id() const {
  return acc_id_;
}
inline void CenterAuthSys::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 client_nonce = 2;
inline bool CenterAuthSys::has_client_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CenterAuthSys::set_has_client_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CenterAuthSys::clear_has_client_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CenterAuthSys::clear_client_nonce() {
  client_nonce_ = 0u;
  clear_has_client_nonce();
}
inline ::google::protobuf::uint32 CenterAuthSys::client_nonce() const {
  return client_nonce_;
}
inline void CenterAuthSys::set_client_nonce(::google::protobuf::uint32 value) {
  set_has_client_nonce();
  client_nonce_ = value;
}

// required uint32 server_nonce = 3;
inline bool CenterAuthSys::has_server_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CenterAuthSys::set_has_server_nonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CenterAuthSys::clear_has_server_nonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CenterAuthSys::clear_server_nonce() {
  server_nonce_ = 0u;
  clear_has_server_nonce();
}
inline ::google::protobuf::uint32 CenterAuthSys::server_nonce() const {
  return server_nonce_;
}
inline void CenterAuthSys::set_server_nonce(::google::protobuf::uint32 value) {
  set_has_server_nonce();
  server_nonce_ = value;
}

// required bytes digest = 4;
inline bool CenterAuthSys::has_digest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CenterAuthSys::set_has_digest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CenterAuthSys::clear_has_digest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CenterAuthSys::clear_digest() {
  if (digest_ != &::google::protobuf::internal::kEmptyString) {
    digest_->clear();
  }
  clear_has_digest();
}
inline const ::std::string& CenterAuthSys::digest() const {
  return *digest_;
}
inline void CenterAuthSys::set_digest(const ::std::string& value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
}
inline void CenterAuthSys::set_digest(const char* value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
}
inline void CenterAuthSys::set_digest(const void* value, size_t size) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CenterAuthSys::mutable_digest() {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  return digest_;
}
inline ::std::string* CenterAuthSys::release_digest() {
  clear_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = digest_;
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CenterAuthSys::set_allocated_digest(::std::string* digest) {
  if (digest_ != &::google::protobuf::internal::kEmptyString) {
    delete digest_;
  }
  if (digest) {
    set_has_digest();
    digest_ = digest;
  } else {
    clear_has_digest();
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 temp_user_key = 5;
inline bool CenterAuthSys::has_temp_user_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CenterAuthSys::set_has_temp_user_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CenterAuthSys::clear_has_temp_user_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CenterAuthSys::clear_temp_user_key() {
  temp_user_key_ = 0u;
  clear_has_temp_user_key();
}
inline ::google::protobuf::uint32 CenterAuthSys::temp_user_key() const {
  return temp_user_key_;
}
inline void CenterAuthSys::set_temp_user_key(::google::protobuf::uint32 value) {
  set_has_temp_user_key();
  temp_user_key_ = value;
}

// -------------------------------------------------------------------

// CenterAuthAck

// required uint32 acc_id = 1;
inline bool CenterAuthAck::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterAuthAck::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterAuthAck::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterAuthAck::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 CenterAuthAck::acc_id() const {
  return acc_id_;
}
inline void CenterAuthAck::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 temp_user_key = 2;
inline bool CenterAuthAck::has_temp_user_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CenterAuthAck::set_has_temp_user_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CenterAuthAck::clear_has_temp_user_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CenterAuthAck::clear_temp_user_key() {
  temp_user_key_ = 0u;
  clear_has_temp_user_key();
}
inline ::google::protobuf::uint32 CenterAuthAck::temp_user_key() const {
  return temp_user_key_;
}
inline void CenterAuthAck::set_temp_user_key(::google::protobuf::uint32 value) {
  set_has_temp_user_key();
  temp_user_key_ = value;
}

// -------------------------------------------------------------------

// CenterAuthNack

// required uint32 error_code = 1;
inline bool CenterAuthNack::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterAuthNack::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterAuthNack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterAuthNack::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 CenterAuthNack::error_code() const {
  return error_code_;
}
inline void CenterAuthNack::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional uint32 temp_user_key = 2;
inline bool CenterAuthNack::has_temp_user_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CenterAuthNack::set_has_temp_user_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CenterAuthNack::clear_has_temp_user_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CenterAuthNack::clear_temp_user_key() {
  temp_user_key_ = 0u;
  clear_has_temp_user_key();
}
inline ::google::protobuf::uint32 CenterAuthNack::temp_user_key() const {
  return temp_user_key_;
}
inline void CenterAuthNack::set_temp_user_key(::google::protobuf::uint32 value) {
  set_has_temp_user_key();
  temp_user_key_ = value;
}

// -------------------------------------------------------------------

// CenterAuthLogout

// required uint32 acc_id = 1;
inline bool CenterAuthLogout::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CenterAuthLogout::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CenterAuthLogout::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CenterAuthLogout::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 CenterAuthLogout::acc_id() const {
  return acc_id_;
}
inline void CenterAuthLogout::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// GetPlayerRoleList

// required uint32 acc_id = 1;
inline bool GetPlayerRoleList::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPlayerRoleList::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPlayerRoleList::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPlayerRoleList::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 GetPlayerRoleList::acc_id() const {
  return acc_id_;
}
inline void GetPlayerRoleList::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// PlayerRoleListData

// repeated bytes role_data = 1;
inline int PlayerRoleListData::role_data_size() const {
  return role_data_.size();
}
inline void PlayerRoleListData::clear_role_data() {
  role_data_.Clear();
}
inline const ::std::string& PlayerRoleListData::role_data(int index) const {
  return role_data_.Get(index);
}
inline ::std::string* PlayerRoleListData::mutable_role_data(int index) {
  return role_data_.Mutable(index);
}
inline void PlayerRoleListData::set_role_data(int index, const ::std::string& value) {
  role_data_.Mutable(index)->assign(value);
}
inline void PlayerRoleListData::set_role_data(int index, const char* value) {
  role_data_.Mutable(index)->assign(value);
}
inline void PlayerRoleListData::set_role_data(int index, const void* value, size_t size) {
  role_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerRoleListData::add_role_data() {
  return role_data_.Add();
}
inline void PlayerRoleListData::add_role_data(const ::std::string& value) {
  role_data_.Add()->assign(value);
}
inline void PlayerRoleListData::add_role_data(const char* value) {
  role_data_.Add()->assign(value);
}
inline void PlayerRoleListData::add_role_data(const void* value, size_t size) {
  role_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PlayerRoleListData::role_data() const {
  return role_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PlayerRoleListData::mutable_role_data() {
  return &role_data_;
}

// optional uint32 acc_id = 2;
inline bool PlayerRoleListData::has_acc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerRoleListData::set_has_acc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerRoleListData::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerRoleListData::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 PlayerRoleListData::acc_id() const {
  return acc_id_;
}
inline void PlayerRoleListData::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// EnterSceneSys

// required int32 avater_index = 1;
inline bool EnterSceneSys::has_avater_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterSceneSys::set_has_avater_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterSceneSys::clear_has_avater_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterSceneSys::clear_avater_index() {
  avater_index_ = 0;
  clear_has_avater_index();
}
inline ::google::protobuf::int32 EnterSceneSys::avater_index() const {
  return avater_index_;
}
inline void EnterSceneSys::set_avater_index(::google::protobuf::int32 value) {
  set_has_avater_index();
  avater_index_ = value;
}

// -------------------------------------------------------------------

// EnterSceneNack

// required uint32 acc_id = 1;
inline bool EnterSceneNack::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterSceneNack::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterSceneNack::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterSceneNack::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 EnterSceneNack::acc_id() const {
  return acc_id_;
}
inline void EnterSceneNack::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 error_code = 2;
inline bool EnterSceneNack::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterSceneNack::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterSceneNack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterSceneNack::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 EnterSceneNack::error_code() const {
  return error_code_;
}
inline void EnterSceneNack::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// ChooseSceneCmd

// required uint32 acc_id = 1;
inline bool ChooseSceneCmd::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChooseSceneCmd::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChooseSceneCmd::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChooseSceneCmd::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 ChooseSceneCmd::acc_id() const {
  return acc_id_;
}
inline void ChooseSceneCmd::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 char_id = 2;
inline bool ChooseSceneCmd::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChooseSceneCmd::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChooseSceneCmd::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChooseSceneCmd::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 ChooseSceneCmd::char_id() const {
  return char_id_;
}
inline void ChooseSceneCmd::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required uint32 map_id = 3;
inline bool ChooseSceneCmd::has_map_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChooseSceneCmd::set_has_map_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChooseSceneCmd::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChooseSceneCmd::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 ChooseSceneCmd::map_id() const {
  return map_id_;
}
inline void ChooseSceneCmd::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// required uint32 slot_index = 4;
inline bool ChooseSceneCmd::has_slot_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChooseSceneCmd::set_has_slot_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChooseSceneCmd::clear_has_slot_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChooseSceneCmd::clear_slot_index() {
  slot_index_ = 0u;
  clear_has_slot_index();
}
inline ::google::protobuf::uint32 ChooseSceneCmd::slot_index() const {
  return slot_index_;
}
inline void ChooseSceneCmd::set_slot_index(::google::protobuf::uint32 value) {
  set_has_slot_index();
  slot_index_ = value;
}

// required float pos_x = 5;
inline bool ChooseSceneCmd::has_pos_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChooseSceneCmd::set_has_pos_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChooseSceneCmd::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChooseSceneCmd::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline float ChooseSceneCmd::pos_x() const {
  return pos_x_;
}
inline void ChooseSceneCmd::set_pos_x(float value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required float pos_y = 6;
inline bool ChooseSceneCmd::has_pos_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChooseSceneCmd::set_has_pos_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChooseSceneCmd::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChooseSceneCmd::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline float ChooseSceneCmd::pos_y() const {
  return pos_y_;
}
inline void ChooseSceneCmd::set_pos_y(float value) {
  set_has_pos_y();
  pos_y_ = value;
}

// -------------------------------------------------------------------

// ServerInfoConnected

// -------------------------------------------------------------------

// MapServerInfo

// required uint32 server_id = 1;
inline bool MapServerInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapServerInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapServerInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapServerInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 MapServerInfo::server_id() const {
  return server_id_;
}
inline void MapServerInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// repeated bytes mapinfo_data = 2;
inline int MapServerInfo::mapinfo_data_size() const {
  return mapinfo_data_.size();
}
inline void MapServerInfo::clear_mapinfo_data() {
  mapinfo_data_.Clear();
}
inline const ::std::string& MapServerInfo::mapinfo_data(int index) const {
  return mapinfo_data_.Get(index);
}
inline ::std::string* MapServerInfo::mutable_mapinfo_data(int index) {
  return mapinfo_data_.Mutable(index);
}
inline void MapServerInfo::set_mapinfo_data(int index, const ::std::string& value) {
  mapinfo_data_.Mutable(index)->assign(value);
}
inline void MapServerInfo::set_mapinfo_data(int index, const char* value) {
  mapinfo_data_.Mutable(index)->assign(value);
}
inline void MapServerInfo::set_mapinfo_data(int index, const void* value, size_t size) {
  mapinfo_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapServerInfo::add_mapinfo_data() {
  return mapinfo_data_.Add();
}
inline void MapServerInfo::add_mapinfo_data(const ::std::string& value) {
  mapinfo_data_.Add()->assign(value);
}
inline void MapServerInfo::add_mapinfo_data(const char* value) {
  mapinfo_data_.Add()->assign(value);
}
inline void MapServerInfo::add_mapinfo_data(const void* value, size_t size) {
  mapinfo_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapServerInfo::mapinfo_data() const {
  return mapinfo_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapServerInfo::mutable_mapinfo_data() {
  return &mapinfo_data_;
}

// -------------------------------------------------------------------

// CreateUserInfo

// optional uint32 char_id = 1;
inline bool CreateUserInfo::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateUserInfo::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateUserInfo::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateUserInfo::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 CreateUserInfo::char_id() const {
  return char_id_;
}
inline void CreateUserInfo::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// repeated bytes user_data = 2;
inline int CreateUserInfo::user_data_size() const {
  return user_data_.size();
}
inline void CreateUserInfo::clear_user_data() {
  user_data_.Clear();
}
inline const ::std::string& CreateUserInfo::user_data(int index) const {
  return user_data_.Get(index);
}
inline ::std::string* CreateUserInfo::mutable_user_data(int index) {
  return user_data_.Mutable(index);
}
inline void CreateUserInfo::set_user_data(int index, const ::std::string& value) {
  user_data_.Mutable(index)->assign(value);
}
inline void CreateUserInfo::set_user_data(int index, const char* value) {
  user_data_.Mutable(index)->assign(value);
}
inline void CreateUserInfo::set_user_data(int index, const void* value, size_t size) {
  user_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateUserInfo::add_user_data() {
  return user_data_.Add();
}
inline void CreateUserInfo::add_user_data(const ::std::string& value) {
  user_data_.Add()->assign(value);
}
inline void CreateUserInfo::add_user_data(const char* value) {
  user_data_.Add()->assign(value);
}
inline void CreateUserInfo::add_user_data(const void* value, size_t size) {
  user_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreateUserInfo::user_data() const {
  return user_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreateUserInfo::mutable_user_data() {
  return &user_data_;
}

// optional uint32 server_id = 3;
inline bool CreateUserInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateUserInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateUserInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateUserInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 CreateUserInfo::server_id() const {
  return server_id_;
}
inline void CreateUserInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 is_robot = 4;
inline bool CreateUserInfo::has_is_robot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateUserInfo::set_has_is_robot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateUserInfo::clear_has_is_robot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateUserInfo::clear_is_robot() {
  is_robot_ = 0u;
  clear_has_is_robot();
}
inline ::google::protobuf::uint32 CreateUserInfo::is_robot() const {
  return is_robot_;
}
inline void CreateUserInfo::set_is_robot(::google::protobuf::uint32 value) {
  set_has_is_robot();
  is_robot_ = value;
}

// -------------------------------------------------------------------

// CreateUserResult

// required uint32 char_id = 1;
inline bool CreateUserResult::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateUserResult::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateUserResult::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateUserResult::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 CreateUserResult::char_id() const {
  return char_id_;
}
inline void CreateUserResult::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required uint32 result = 2;
inline bool CreateUserResult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateUserResult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateUserResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateUserResult::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CreateUserResult::result() const {
  return result_;
}
inline void CreateUserResult::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SaveUserInfo

// required uint32 acc_id = 1;
inline bool SaveUserInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveUserInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveUserInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveUserInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 SaveUserInfo::acc_id() const {
  return acc_id_;
}
inline void SaveUserInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// repeated bytes user_data = 2;
inline int SaveUserInfo::user_data_size() const {
  return user_data_.size();
}
inline void SaveUserInfo::clear_user_data() {
  user_data_.Clear();
}
inline const ::std::string& SaveUserInfo::user_data(int index) const {
  return user_data_.Get(index);
}
inline ::std::string* SaveUserInfo::mutable_user_data(int index) {
  return user_data_.Mutable(index);
}
inline void SaveUserInfo::set_user_data(int index, const ::std::string& value) {
  user_data_.Mutable(index)->assign(value);
}
inline void SaveUserInfo::set_user_data(int index, const char* value) {
  user_data_.Mutable(index)->assign(value);
}
inline void SaveUserInfo::set_user_data(int index, const void* value, size_t size) {
  user_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveUserInfo::add_user_data() {
  return user_data_.Add();
}
inline void SaveUserInfo::add_user_data(const ::std::string& value) {
  user_data_.Add()->assign(value);
}
inline void SaveUserInfo::add_user_data(const char* value) {
  user_data_.Add()->assign(value);
}
inline void SaveUserInfo::add_user_data(const void* value, size_t size) {
  user_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SaveUserInfo::user_data() const {
  return user_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SaveUserInfo::mutable_user_data() {
  return &user_data_;
}

// optional uint32 sequence_id = 3;
inline bool SaveUserInfo::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SaveUserInfo::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SaveUserInfo::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SaveUserInfo::clear_sequence_id() {
  sequence_id_ = 0u;
  clear_has_sequence_id();
}
inline ::google::protobuf::uint32 SaveUserInfo::sequence_id() const {
  return sequence_id_;
}
inline void SaveUserInfo::set_sequence_id(::google::protobuf::uint32 value) {
  set_has_sequence_id();
  sequence_id_ = value;
}

// -------------------------------------------------------------------

// GetUserDetailInfo

// required uint32 acc_id = 1;
inline bool GetUserDetailInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserDetailInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserDetailInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserDetailInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 GetUserDetailInfo::acc_id() const {
  return acc_id_;
}
inline void GetUserDetailInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 char_id = 2;
inline bool GetUserDetailInfo::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserDetailInfo::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserDetailInfo::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserDetailInfo::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 GetUserDetailInfo::char_id() const {
  return char_id_;
}
inline void GetUserDetailInfo::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// UserDetailInfo

// required uint32 acc_id = 1;
inline bool UserDetailInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDetailInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDetailInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDetailInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 UserDetailInfo::acc_id() const {
  return acc_id_;
}
inline void UserDetailInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 sequence_id = 2;
inline bool UserDetailInfo::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDetailInfo::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDetailInfo::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDetailInfo::clear_sequence_id() {
  sequence_id_ = 0u;
  clear_has_sequence_id();
}
inline ::google::protobuf::uint32 UserDetailInfo::sequence_id() const {
  return sequence_id_;
}
inline void UserDetailInfo::set_sequence_id(::google::protobuf::uint32 value) {
  set_has_sequence_id();
  sequence_id_ = value;
}

// repeated bytes user_data = 3;
inline int UserDetailInfo::user_data_size() const {
  return user_data_.size();
}
inline void UserDetailInfo::clear_user_data() {
  user_data_.Clear();
}
inline const ::std::string& UserDetailInfo::user_data(int index) const {
  return user_data_.Get(index);
}
inline ::std::string* UserDetailInfo::mutable_user_data(int index) {
  return user_data_.Mutable(index);
}
inline void UserDetailInfo::set_user_data(int index, const ::std::string& value) {
  user_data_.Mutable(index)->assign(value);
}
inline void UserDetailInfo::set_user_data(int index, const char* value) {
  user_data_.Mutable(index)->assign(value);
}
inline void UserDetailInfo::set_user_data(int index, const void* value, size_t size) {
  user_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserDetailInfo::add_user_data() {
  return user_data_.Add();
}
inline void UserDetailInfo::add_user_data(const ::std::string& value) {
  user_data_.Add()->assign(value);
}
inline void UserDetailInfo::add_user_data(const char* value) {
  user_data_.Add()->assign(value);
}
inline void UserDetailInfo::add_user_data(const void* value, size_t size) {
  user_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserDetailInfo::user_data() const {
  return user_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserDetailInfo::mutable_user_data() {
  return &user_data_;
}

// -------------------------------------------------------------------

// EnterSceneMapSys

// required uint32 gate_id = 1;
inline bool EnterSceneMapSys::has_gate_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterSceneMapSys::set_has_gate_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterSceneMapSys::clear_has_gate_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterSceneMapSys::clear_gate_id() {
  gate_id_ = 0u;
  clear_has_gate_id();
}
inline ::google::protobuf::uint32 EnterSceneMapSys::gate_id() const {
  return gate_id_;
}
inline void EnterSceneMapSys::set_gate_id(::google::protobuf::uint32 value) {
  set_has_gate_id();
  gate_id_ = value;
}

// required uint32 char_id = 2;
inline bool EnterSceneMapSys::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterSceneMapSys::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterSceneMapSys::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterSceneMapSys::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 EnterSceneMapSys::char_id() const {
  return char_id_;
}
inline void EnterSceneMapSys::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required uint32 acc_id = 3;
inline bool EnterSceneMapSys::has_acc_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterSceneMapSys::set_has_acc_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterSceneMapSys::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterSceneMapSys::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 EnterSceneMapSys::acc_id() const {
  return acc_id_;
}
inline void EnterSceneMapSys::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 map_id = 4;
inline bool EnterSceneMapSys::has_map_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterSceneMapSys::set_has_map_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterSceneMapSys::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterSceneMapSys::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 EnterSceneMapSys::map_id() const {
  return map_id_;
}
inline void EnterSceneMapSys::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// required uint32 slot_index = 5;
inline bool EnterSceneMapSys::has_slot_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnterSceneMapSys::set_has_slot_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnterSceneMapSys::clear_has_slot_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnterSceneMapSys::clear_slot_index() {
  slot_index_ = 0u;
  clear_has_slot_index();
}
inline ::google::protobuf::uint32 EnterSceneMapSys::slot_index() const {
  return slot_index_;
}
inline void EnterSceneMapSys::set_slot_index(::google::protobuf::uint32 value) {
  set_has_slot_index();
  slot_index_ = value;
}

// required uint32 instance_id = 6;
inline bool EnterSceneMapSys::has_instance_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnterSceneMapSys::set_has_instance_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnterSceneMapSys::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnterSceneMapSys::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 EnterSceneMapSys::instance_id() const {
  return instance_id_;
}
inline void EnterSceneMapSys::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// required float pos_x = 7;
inline bool EnterSceneMapSys::has_pos_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EnterSceneMapSys::set_has_pos_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EnterSceneMapSys::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EnterSceneMapSys::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline float EnterSceneMapSys::pos_x() const {
  return pos_x_;
}
inline void EnterSceneMapSys::set_pos_x(float value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required float pos_y = 8;
inline bool EnterSceneMapSys::has_pos_y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EnterSceneMapSys::set_has_pos_y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EnterSceneMapSys::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EnterSceneMapSys::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline float EnterSceneMapSys::pos_y() const {
  return pos_y_;
}
inline void EnterSceneMapSys::set_pos_y(float value) {
  set_has_pos_y();
  pos_y_ = value;
}

// required uint32 bchange_scene = 9;
inline bool EnterSceneMapSys::has_bchange_scene() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EnterSceneMapSys::set_has_bchange_scene() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EnterSceneMapSys::clear_has_bchange_scene() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EnterSceneMapSys::clear_bchange_scene() {
  bchange_scene_ = 0u;
  clear_has_bchange_scene();
}
inline ::google::protobuf::uint32 EnterSceneMapSys::bchange_scene() const {
  return bchange_scene_;
}
inline void EnterSceneMapSys::set_bchange_scene(::google::protobuf::uint32 value) {
  set_has_bchange_scene();
  bchange_scene_ = value;
}

// -------------------------------------------------------------------

// EnterSceneMapNack

// required uint32 acc_id = 1;
inline bool EnterSceneMapNack::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterSceneMapNack::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterSceneMapNack::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterSceneMapNack::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 EnterSceneMapNack::acc_id() const {
  return acc_id_;
}
inline void EnterSceneMapNack::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// EnterSceneMapAck

// required uint32 acc_id = 1;
inline bool EnterSceneMapAck::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterSceneMapAck::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterSceneMapAck::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterSceneMapAck::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 EnterSceneMapAck::acc_id() const {
  return acc_id_;
}
inline void EnterSceneMapAck::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// ClientCreateSenceCmd

// required uint32 map_id = 1;
inline bool ClientCreateSenceCmd::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCreateSenceCmd::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientCreateSenceCmd::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientCreateSenceCmd::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 ClientCreateSenceCmd::map_id() const {
  return map_id_;
}
inline void ClientCreateSenceCmd::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// required float pos_x = 2;
inline bool ClientCreateSenceCmd::has_pos_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientCreateSenceCmd::set_has_pos_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientCreateSenceCmd::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientCreateSenceCmd::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline float ClientCreateSenceCmd::pos_x() const {
  return pos_x_;
}
inline void ClientCreateSenceCmd::set_pos_x(float value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required float pos_y = 3;
inline bool ClientCreateSenceCmd::has_pos_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientCreateSenceCmd::set_has_pos_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientCreateSenceCmd::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientCreateSenceCmd::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline float ClientCreateSenceCmd::pos_y() const {
  return pos_y_;
}
inline void ClientCreateSenceCmd::set_pos_y(float value) {
  set_has_pos_y();
  pos_y_ = value;
}

// -------------------------------------------------------------------

// ClientEnterSenceSys

// -------------------------------------------------------------------

// AddPlayerSys

// required uint32 char_id = 1;
inline bool AddPlayerSys::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddPlayerSys::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddPlayerSys::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddPlayerSys::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 AddPlayerSys::char_id() const {
  return char_id_;
}
inline void AddPlayerSys::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required uint32 pos_x = 2;
inline bool AddPlayerSys::has_pos_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddPlayerSys::set_has_pos_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddPlayerSys::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddPlayerSys::clear_pos_x() {
  pos_x_ = 0u;
  clear_has_pos_x();
}
inline ::google::protobuf::uint32 AddPlayerSys::pos_x() const {
  return pos_x_;
}
inline void AddPlayerSys::set_pos_x(::google::protobuf::uint32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required uint32 pos_y = 3;
inline bool AddPlayerSys::has_pos_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddPlayerSys::set_has_pos_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddPlayerSys::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddPlayerSys::clear_pos_y() {
  pos_y_ = 0u;
  clear_has_pos_y();
}
inline ::google::protobuf::uint32 AddPlayerSys::pos_y() const {
  return pos_y_;
}
inline void AddPlayerSys::set_pos_y(::google::protobuf::uint32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// required uint32 pos_o = 4;
inline bool AddPlayerSys::has_pos_o() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddPlayerSys::set_has_pos_o() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddPlayerSys::clear_has_pos_o() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddPlayerSys::clear_pos_o() {
  pos_o_ = 0u;
  clear_has_pos_o();
}
inline ::google::protobuf::uint32 AddPlayerSys::pos_o() const {
  return pos_o_;
}
inline void AddPlayerSys::set_pos_o(::google::protobuf::uint32 value) {
  set_has_pos_o();
  pos_o_ = value;
}

// required uint32 char_job = 5;
inline bool AddPlayerSys::has_char_job() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddPlayerSys::set_has_char_job() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddPlayerSys::clear_has_char_job() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddPlayerSys::clear_char_job() {
  char_job_ = 0u;
  clear_has_char_job();
}
inline ::google::protobuf::uint32 AddPlayerSys::char_job() const {
  return char_job_;
}
inline void AddPlayerSys::set_char_job(::google::protobuf::uint32 value) {
  set_has_char_job();
  char_job_ = value;
}

// required uint32 char_sex = 6;
inline bool AddPlayerSys::has_char_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddPlayerSys::set_has_char_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddPlayerSys::clear_has_char_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddPlayerSys::clear_char_sex() {
  char_sex_ = 0u;
  clear_has_char_sex();
}
inline ::google::protobuf::uint32 AddPlayerSys::char_sex() const {
  return char_sex_;
}
inline void AddPlayerSys::set_char_sex(::google::protobuf::uint32 value) {
  set_has_char_sex();
  char_sex_ = value;
}

// required bytes char_name = 7;
inline bool AddPlayerSys::has_char_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddPlayerSys::set_has_char_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddPlayerSys::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddPlayerSys::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& AddPlayerSys::char_name() const {
  return *char_name_;
}
inline void AddPlayerSys::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void AddPlayerSys::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void AddPlayerSys::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddPlayerSys::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* AddPlayerSys::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddPlayerSys::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 char_weapon = 8;
inline bool AddPlayerSys::has_char_weapon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AddPlayerSys::set_has_char_weapon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AddPlayerSys::clear_has_char_weapon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AddPlayerSys::clear_char_weapon() {
  char_weapon_ = 0u;
  clear_has_char_weapon();
}
inline ::google::protobuf::uint32 AddPlayerSys::char_weapon() const {
  return char_weapon_;
}
inline void AddPlayerSys::set_char_weapon(::google::protobuf::uint32 value) {
  set_has_char_weapon();
  char_weapon_ = value;
}

// required uint32 char_level = 9;
inline bool AddPlayerSys::has_char_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AddPlayerSys::set_has_char_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AddPlayerSys::clear_has_char_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AddPlayerSys::clear_char_level() {
  char_level_ = 0u;
  clear_has_char_level();
}
inline ::google::protobuf::uint32 AddPlayerSys::char_level() const {
  return char_level_;
}
inline void AddPlayerSys::set_char_level(::google::protobuf::uint32 value) {
  set_has_char_level();
  char_level_ = value;
}

// optional uint32 horse_id = 10;
inline bool AddPlayerSys::has_horse_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AddPlayerSys::set_has_horse_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AddPlayerSys::clear_has_horse_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AddPlayerSys::clear_horse_id() {
  horse_id_ = 0u;
  clear_has_horse_id();
}
inline ::google::protobuf::uint32 AddPlayerSys::horse_id() const {
  return horse_id_;
}
inline void AddPlayerSys::set_horse_id(::google::protobuf::uint32 value) {
  set_has_horse_id();
  horse_id_ = value;
}

// optional uint32 horse_image = 11;
inline bool AddPlayerSys::has_horse_image() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AddPlayerSys::set_has_horse_image() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AddPlayerSys::clear_has_horse_image() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AddPlayerSys::clear_horse_image() {
  horse_image_ = 0u;
  clear_has_horse_image();
}
inline ::google::protobuf::uint32 AddPlayerSys::horse_image() const {
  return horse_image_;
}
inline void AddPlayerSys::set_horse_image(::google::protobuf::uint32 value) {
  set_has_horse_image();
  horse_image_ = value;
}

// optional bytes horse_name = 12;
inline bool AddPlayerSys::has_horse_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AddPlayerSys::set_has_horse_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AddPlayerSys::clear_has_horse_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AddPlayerSys::clear_horse_name() {
  if (horse_name_ != &::google::protobuf::internal::kEmptyString) {
    horse_name_->clear();
  }
  clear_has_horse_name();
}
inline const ::std::string& AddPlayerSys::horse_name() const {
  return *horse_name_;
}
inline void AddPlayerSys::set_horse_name(const ::std::string& value) {
  set_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    horse_name_ = new ::std::string;
  }
  horse_name_->assign(value);
}
inline void AddPlayerSys::set_horse_name(const char* value) {
  set_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    horse_name_ = new ::std::string;
  }
  horse_name_->assign(value);
}
inline void AddPlayerSys::set_horse_name(const void* value, size_t size) {
  set_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    horse_name_ = new ::std::string;
  }
  horse_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddPlayerSys::mutable_horse_name() {
  set_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    horse_name_ = new ::std::string;
  }
  return horse_name_;
}
inline ::std::string* AddPlayerSys::release_horse_name() {
  clear_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = horse_name_;
    horse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddPlayerSys::set_allocated_horse_name(::std::string* horse_name) {
  if (horse_name_ != &::google::protobuf::internal::kEmptyString) {
    delete horse_name_;
  }
  if (horse_name) {
    set_has_horse_name();
    horse_name_ = horse_name;
  } else {
    clear_has_horse_name();
    horse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AddNpcSys

// required uint32 npc_id = 1;
inline bool AddNpcSys::has_npc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddNpcSys::set_has_npc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddNpcSys::clear_has_npc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddNpcSys::clear_npc_id() {
  npc_id_ = 0u;
  clear_has_npc_id();
}
inline ::google::protobuf::uint32 AddNpcSys::npc_id() const {
  return npc_id_;
}
inline void AddNpcSys::set_npc_id(::google::protobuf::uint32 value) {
  set_has_npc_id();
  npc_id_ = value;
}

// required uint32 npc_only_id = 2;
inline bool AddNpcSys::has_npc_only_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddNpcSys::set_has_npc_only_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddNpcSys::clear_has_npc_only_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddNpcSys::clear_npc_only_id() {
  npc_only_id_ = 0u;
  clear_has_npc_only_id();
}
inline ::google::protobuf::uint32 AddNpcSys::npc_only_id() const {
  return npc_only_id_;
}
inline void AddNpcSys::set_npc_only_id(::google::protobuf::uint32 value) {
  set_has_npc_only_id();
  npc_only_id_ = value;
}

// required uint32 npc_mode_id = 3;
inline bool AddNpcSys::has_npc_mode_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddNpcSys::set_has_npc_mode_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddNpcSys::clear_has_npc_mode_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddNpcSys::clear_npc_mode_id() {
  npc_mode_id_ = 0u;
  clear_has_npc_mode_id();
}
inline ::google::protobuf::uint32 AddNpcSys::npc_mode_id() const {
  return npc_mode_id_;
}
inline void AddNpcSys::set_npc_mode_id(::google::protobuf::uint32 value) {
  set_has_npc_mode_id();
  npc_mode_id_ = value;
}

// required uint32 npc_type_id = 4;
inline bool AddNpcSys::has_npc_type_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddNpcSys::set_has_npc_type_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddNpcSys::clear_has_npc_type_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddNpcSys::clear_npc_type_id() {
  npc_type_id_ = 0u;
  clear_has_npc_type_id();
}
inline ::google::protobuf::uint32 AddNpcSys::npc_type_id() const {
  return npc_type_id_;
}
inline void AddNpcSys::set_npc_type_id(::google::protobuf::uint32 value) {
  set_has_npc_type_id();
  npc_type_id_ = value;
}

// required uint32 pos_x = 5;
inline bool AddNpcSys::has_pos_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddNpcSys::set_has_pos_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddNpcSys::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddNpcSys::clear_pos_x() {
  pos_x_ = 0u;
  clear_has_pos_x();
}
inline ::google::protobuf::uint32 AddNpcSys::pos_x() const {
  return pos_x_;
}
inline void AddNpcSys::set_pos_x(::google::protobuf::uint32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required uint32 pos_y = 6;
inline bool AddNpcSys::has_pos_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddNpcSys::set_has_pos_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddNpcSys::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddNpcSys::clear_pos_y() {
  pos_y_ = 0u;
  clear_has_pos_y();
}
inline ::google::protobuf::uint32 AddNpcSys::pos_y() const {
  return pos_y_;
}
inline void AddNpcSys::set_pos_y(::google::protobuf::uint32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// required uint32 pos_o = 7;
inline bool AddNpcSys::has_pos_o() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddNpcSys::set_has_pos_o() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddNpcSys::clear_has_pos_o() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddNpcSys::clear_pos_o() {
  pos_o_ = 0u;
  clear_has_pos_o();
}
inline ::google::protobuf::uint32 AddNpcSys::pos_o() const {
  return pos_o_;
}
inline void AddNpcSys::set_pos_o(::google::protobuf::uint32 value) {
  set_has_pos_o();
  pos_o_ = value;
}

// -------------------------------------------------------------------

// DelPlayerSys

// required uint32 char_id = 1;
inline bool DelPlayerSys::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelPlayerSys::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelPlayerSys::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelPlayerSys::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 DelPlayerSys::char_id() const {
  return char_id_;
}
inline void DelPlayerSys::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// DelNpcSys

// required uint32 npc_id = 1;
inline bool DelNpcSys::has_npc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelNpcSys::set_has_npc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelNpcSys::clear_has_npc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelNpcSys::clear_npc_id() {
  npc_id_ = 0u;
  clear_has_npc_id();
}
inline ::google::protobuf::uint32 DelNpcSys::npc_id() const {
  return npc_id_;
}
inline void DelNpcSys::set_npc_id(::google::protobuf::uint32 value) {
  set_has_npc_id();
  npc_id_ = value;
}

// -------------------------------------------------------------------

// GateInfoID

// required uint32 gate_id = 1;
inline bool GateInfoID::has_gate_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateInfoID::set_has_gate_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateInfoID::clear_has_gate_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateInfoID::clear_gate_id() {
  gate_id_ = 0u;
  clear_has_gate_id();
}
inline ::google::protobuf::uint32 GateInfoID::gate_id() const {
  return gate_id_;
}
inline void GateInfoID::set_gate_id(::google::protobuf::uint32 value) {
  set_has_gate_id();
  gate_id_ = value;
}

// -------------------------------------------------------------------

// GateLogoutCmd

// required int32 acc_id = 1;
inline bool GateLogoutCmd::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateLogoutCmd::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateLogoutCmd::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateLogoutCmd::clear_acc_id() {
  acc_id_ = 0;
  clear_has_acc_id();
}
inline ::google::protobuf::int32 GateLogoutCmd::acc_id() const {
  return acc_id_;
}
inline void GateLogoutCmd::set_acc_id(::google::protobuf::int32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// Move

// required uint32 char_id = 1;
inline bool Move::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Move::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Move::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Move::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 Move::char_id() const {
  return char_id_;
}
inline void Move::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required uint32 orient = 2;
inline bool Move::has_orient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Move::set_has_orient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Move::clear_has_orient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Move::clear_orient() {
  orient_ = 0u;
  clear_has_orient();
}
inline ::google::protobuf::uint32 Move::orient() const {
  return orient_;
}
inline void Move::set_orient(::google::protobuf::uint32 value) {
  set_has_orient();
  orient_ = value;
}

// required float x = 3;
inline bool Move::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Move::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Move::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Move::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Move::x() const {
  return x_;
}
inline void Move::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 4;
inline bool Move::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Move::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Move::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Move::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Move::y() const {
  return y_;
}
inline void Move::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// PlayerJumpMap

// required uint32 player_id = 1;
inline bool PlayerJumpMap::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerJumpMap::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerJumpMap::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerJumpMap::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerJumpMap::player_id() const {
  return player_id_;
}
inline void PlayerJumpMap::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// required uint32 jump_id = 2;
inline bool PlayerJumpMap::has_jump_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerJumpMap::set_has_jump_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerJumpMap::clear_has_jump_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerJumpMap::clear_jump_id() {
  jump_id_ = 0u;
  clear_has_jump_id();
}
inline ::google::protobuf::uint32 PlayerJumpMap::jump_id() const {
  return jump_id_;
}
inline void PlayerJumpMap::set_jump_id(::google::protobuf::uint32 value) {
  set_has_jump_id();
  jump_id_ = value;
}

// -------------------------------------------------------------------

// NPCTeleport

// required uint32 npc_id = 1;
inline bool NPCTeleport::has_npc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NPCTeleport::set_has_npc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NPCTeleport::clear_has_npc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NPCTeleport::clear_npc_id() {
  npc_id_ = 0u;
  clear_has_npc_id();
}
inline ::google::protobuf::uint32 NPCTeleport::npc_id() const {
  return npc_id_;
}
inline void NPCTeleport::set_npc_id(::google::protobuf::uint32 value) {
  set_has_npc_id();
  npc_id_ = value;
}

// required uint32 big_stage_id = 2;
inline bool NPCTeleport::has_big_stage_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPCTeleport::set_has_big_stage_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NPCTeleport::clear_has_big_stage_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NPCTeleport::clear_big_stage_id() {
  big_stage_id_ = 0u;
  clear_has_big_stage_id();
}
inline ::google::protobuf::uint32 NPCTeleport::big_stage_id() const {
  return big_stage_id_;
}
inline void NPCTeleport::set_big_stage_id(::google::protobuf::uint32 value) {
  set_has_big_stage_id();
  big_stage_id_ = value;
}

// required uint32 small_stage_id = 3;
inline bool NPCTeleport::has_small_stage_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NPCTeleport::set_has_small_stage_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NPCTeleport::clear_has_small_stage_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NPCTeleport::clear_small_stage_id() {
  small_stage_id_ = 0u;
  clear_has_small_stage_id();
}
inline ::google::protobuf::uint32 NPCTeleport::small_stage_id() const {
  return small_stage_id_;
}
inline void NPCTeleport::set_small_stage_id(::google::protobuf::uint32 value) {
  set_has_small_stage_id();
  small_stage_id_ = value;
}

// -------------------------------------------------------------------

// PlayerAttack

// required uint32 player_id = 1;
inline bool PlayerAttack::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAttack::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAttack::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAttack::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerAttack::player_id() const {
  return player_id_;
}
inline void PlayerAttack::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// required uint32 attack_id = 2;
inline bool PlayerAttack::has_attack_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAttack::set_has_attack_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAttack::clear_has_attack_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAttack::clear_attack_id() {
  attack_id_ = 0u;
  clear_has_attack_id();
}
inline ::google::protobuf::uint32 PlayerAttack::attack_id() const {
  return attack_id_;
}
inline void PlayerAttack::set_attack_id(::google::protobuf::uint32 value) {
  set_has_attack_id();
  attack_id_ = value;
}

// optional uint32 battle_type = 3;
inline bool PlayerAttack::has_battle_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerAttack::set_has_battle_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerAttack::clear_has_battle_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerAttack::clear_battle_type() {
  battle_type_ = 0u;
  clear_has_battle_type();
}
inline ::google::protobuf::uint32 PlayerAttack::battle_type() const {
  return battle_type_;
}
inline void PlayerAttack::set_battle_type(::google::protobuf::uint32 value) {
  set_has_battle_type();
  battle_type_ = value;
}

// -------------------------------------------------------------------

// QTEResult

// required uint32 player_id = 1;
inline bool QTEResult::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QTEResult::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QTEResult::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QTEResult::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 QTEResult::player_id() const {
  return player_id_;
}
inline void QTEResult::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// required uint32 QTE_id = 2;
inline bool QTEResult::has_qte_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QTEResult::set_has_qte_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QTEResult::clear_has_qte_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QTEResult::clear_qte_id() {
  qte_id_ = 0u;
  clear_has_qte_id();
}
inline ::google::protobuf::uint32 QTEResult::qte_id() const {
  return qte_id_;
}
inline void QTEResult::set_qte_id(::google::protobuf::uint32 value) {
  set_has_qte_id();
  qte_id_ = value;
}

// required uint32 QTE_result = 3;
inline bool QTEResult::has_qte_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QTEResult::set_has_qte_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QTEResult::clear_has_qte_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QTEResult::clear_qte_result() {
  qte_result_ = 0u;
  clear_has_qte_result();
}
inline ::google::protobuf::uint32 QTEResult::qte_result() const {
  return qte_result_;
}
inline void QTEResult::set_qte_result(::google::protobuf::uint32 value) {
  set_has_qte_result();
  qte_result_ = value;
}

// -------------------------------------------------------------------

// ClearSkill

// required uint32 player_id = 1;
inline bool ClearSkill::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClearSkill::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClearSkill::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClearSkill::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ClearSkill::player_id() const {
  return player_id_;
}
inline void ClearSkill::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// -------------------------------------------------------------------

// AddSkill

// required uint32 player_id = 1;
inline bool AddSkill::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddSkill::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddSkill::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddSkill::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 AddSkill::player_id() const {
  return player_id_;
}
inline void AddSkill::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// required uint32 skill_id = 2;
inline bool AddSkill::has_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddSkill::set_has_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddSkill::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddSkill::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 AddSkill::skill_id() const {
  return skill_id_;
}
inline void AddSkill::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// -------------------------------------------------------------------

// SkillSequence

// required uint32 player_id = 1;
inline bool SkillSequence::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillSequence::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillSequence::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillSequence::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 SkillSequence::player_id() const {
  return player_id_;
}
inline void SkillSequence::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// required uint32 skill_id1 = 2;
inline bool SkillSequence::has_skill_id1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillSequence::set_has_skill_id1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillSequence::clear_has_skill_id1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillSequence::clear_skill_id1() {
  skill_id1_ = 0u;
  clear_has_skill_id1();
}
inline ::google::protobuf::uint32 SkillSequence::skill_id1() const {
  return skill_id1_;
}
inline void SkillSequence::set_skill_id1(::google::protobuf::uint32 value) {
  set_has_skill_id1();
  skill_id1_ = value;
}

// required uint32 skill_id2 = 3;
inline bool SkillSequence::has_skill_id2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillSequence::set_has_skill_id2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillSequence::clear_has_skill_id2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillSequence::clear_skill_id2() {
  skill_id2_ = 0u;
  clear_has_skill_id2();
}
inline ::google::protobuf::uint32 SkillSequence::skill_id2() const {
  return skill_id2_;
}
inline void SkillSequence::set_skill_id2(::google::protobuf::uint32 value) {
  set_has_skill_id2();
  skill_id2_ = value;
}

// required uint32 skill_id3 = 4;
inline bool SkillSequence::has_skill_id3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillSequence::set_has_skill_id3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillSequence::clear_has_skill_id3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillSequence::clear_skill_id3() {
  skill_id3_ = 0u;
  clear_has_skill_id3();
}
inline ::google::protobuf::uint32 SkillSequence::skill_id3() const {
  return skill_id3_;
}
inline void SkillSequence::set_skill_id3(::google::protobuf::uint32 value) {
  set_has_skill_id3();
  skill_id3_ = value;
}

// -------------------------------------------------------------------

// BattleCharInfo_CharInfo

// required int32 char_id = 1;
inline bool BattleCharInfo_CharInfo::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleCharInfo_CharInfo::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleCharInfo_CharInfo::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::char_id() const {
  return char_id_;
}
inline void BattleCharInfo_CharInfo::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 mode_id = 2;
inline bool BattleCharInfo_CharInfo::has_mode_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_mode_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleCharInfo_CharInfo::clear_has_mode_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleCharInfo_CharInfo::clear_mode_id() {
  mode_id_ = 0;
  clear_has_mode_id();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::mode_id() const {
  return mode_id_;
}
inline void BattleCharInfo_CharInfo::set_mode_id(::google::protobuf::int32 value) {
  set_has_mode_id();
  mode_id_ = value;
}

// required int32 pos_x = 3;
inline bool BattleCharInfo_CharInfo::has_pos_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_pos_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleCharInfo_CharInfo::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleCharInfo_CharInfo::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::pos_x() const {
  return pos_x_;
}
inline void BattleCharInfo_CharInfo::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required int32 hp = 4;
inline bool BattleCharInfo_CharInfo::has_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleCharInfo_CharInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleCharInfo_CharInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::hp() const {
  return hp_;
}
inline void BattleCharInfo_CharInfo::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// required int32 move_speed = 5;
inline bool BattleCharInfo_CharInfo::has_move_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_move_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleCharInfo_CharInfo::clear_has_move_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleCharInfo_CharInfo::clear_move_speed() {
  move_speed_ = 0;
  clear_has_move_speed();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::move_speed() const {
  return move_speed_;
}
inline void BattleCharInfo_CharInfo::set_move_speed(::google::protobuf::int32 value) {
  set_has_move_speed();
  move_speed_ = value;
}

// optional int32 sex = 6;
inline bool BattleCharInfo_CharInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleCharInfo_CharInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleCharInfo_CharInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::sex() const {
  return sex_;
}
inline void BattleCharInfo_CharInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 weapon = 7;
inline bool BattleCharInfo_CharInfo::has_weapon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_weapon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleCharInfo_CharInfo::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleCharInfo_CharInfo::clear_weapon() {
  weapon_ = 0;
  clear_has_weapon();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::weapon() const {
  return weapon_;
}
inline void BattleCharInfo_CharInfo::set_weapon(::google::protobuf::int32 value) {
  set_has_weapon();
  weapon_ = value;
}

// optional int32 mp = 8;
inline bool BattleCharInfo_CharInfo::has_mp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_mp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleCharInfo_CharInfo::clear_has_mp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleCharInfo_CharInfo::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::mp() const {
  return mp_;
}
inline void BattleCharInfo_CharInfo::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
}

// optional int32 is_boss = 9;
inline bool BattleCharInfo_CharInfo::has_is_boss() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_is_boss() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleCharInfo_CharInfo::clear_has_is_boss() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleCharInfo_CharInfo::clear_is_boss() {
  is_boss_ = 0;
  clear_has_is_boss();
}
inline ::google::protobuf::int32 BattleCharInfo_CharInfo::is_boss() const {
  return is_boss_;
}
inline void BattleCharInfo_CharInfo::set_is_boss(::google::protobuf::int32 value) {
  set_has_is_boss();
  is_boss_ = value;
}

// optional bytes boss_name = 10;
inline bool BattleCharInfo_CharInfo::has_boss_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleCharInfo_CharInfo::set_has_boss_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleCharInfo_CharInfo::clear_has_boss_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleCharInfo_CharInfo::clear_boss_name() {
  if (boss_name_ != &::google::protobuf::internal::kEmptyString) {
    boss_name_->clear();
  }
  clear_has_boss_name();
}
inline const ::std::string& BattleCharInfo_CharInfo::boss_name() const {
  return *boss_name_;
}
inline void BattleCharInfo_CharInfo::set_boss_name(const ::std::string& value) {
  set_has_boss_name();
  if (boss_name_ == &::google::protobuf::internal::kEmptyString) {
    boss_name_ = new ::std::string;
  }
  boss_name_->assign(value);
}
inline void BattleCharInfo_CharInfo::set_boss_name(const char* value) {
  set_has_boss_name();
  if (boss_name_ == &::google::protobuf::internal::kEmptyString) {
    boss_name_ = new ::std::string;
  }
  boss_name_->assign(value);
}
inline void BattleCharInfo_CharInfo::set_boss_name(const void* value, size_t size) {
  set_has_boss_name();
  if (boss_name_ == &::google::protobuf::internal::kEmptyString) {
    boss_name_ = new ::std::string;
  }
  boss_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleCharInfo_CharInfo::mutable_boss_name() {
  set_has_boss_name();
  if (boss_name_ == &::google::protobuf::internal::kEmptyString) {
    boss_name_ = new ::std::string;
  }
  return boss_name_;
}
inline ::std::string* BattleCharInfo_CharInfo::release_boss_name() {
  clear_has_boss_name();
  if (boss_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = boss_name_;
    boss_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleCharInfo_CharInfo::set_allocated_boss_name(::std::string* boss_name) {
  if (boss_name_ != &::google::protobuf::internal::kEmptyString) {
    delete boss_name_;
  }
  if (boss_name) {
    set_has_boss_name();
    boss_name_ = boss_name;
  } else {
    clear_has_boss_name();
    boss_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BattleCharInfo

// repeated .message.BattleCharInfo.CharInfo charinfo = 1;
inline int BattleCharInfo::charinfo_size() const {
  return charinfo_.size();
}
inline void BattleCharInfo::clear_charinfo() {
  charinfo_.Clear();
}
inline const ::message::BattleCharInfo_CharInfo& BattleCharInfo::charinfo(int index) const {
  return charinfo_.Get(index);
}
inline ::message::BattleCharInfo_CharInfo* BattleCharInfo::mutable_charinfo(int index) {
  return charinfo_.Mutable(index);
}
inline ::message::BattleCharInfo_CharInfo* BattleCharInfo::add_charinfo() {
  return charinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::BattleCharInfo_CharInfo >&
BattleCharInfo::charinfo() const {
  return charinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::BattleCharInfo_CharInfo >*
BattleCharInfo::mutable_charinfo() {
  return &charinfo_;
}

// -------------------------------------------------------------------

// BattleActionInfo_StartStopEvent

// required int32 char_id = 1;
inline bool BattleActionInfo_StartStopEvent::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleActionInfo_StartStopEvent::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleActionInfo_StartStopEvent::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleActionInfo_StartStopEvent::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleActionInfo_StartStopEvent::char_id() const {
  return char_id_;
}
inline void BattleActionInfo_StartStopEvent::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 event_type_id = 2;
inline bool BattleActionInfo_StartStopEvent::has_event_type_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleActionInfo_StartStopEvent::set_has_event_type_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleActionInfo_StartStopEvent::clear_has_event_type_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleActionInfo_StartStopEvent::clear_event_type_id() {
  event_type_id_ = 0;
  clear_has_event_type_id();
}
inline ::google::protobuf::int32 BattleActionInfo_StartStopEvent::event_type_id() const {
  return event_type_id_;
}
inline void BattleActionInfo_StartStopEvent::set_event_type_id(::google::protobuf::int32 value) {
  set_has_event_type_id();
  event_type_id_ = value;
}

// required int32 event_start_end = 3;
inline bool BattleActionInfo_StartStopEvent::has_event_start_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleActionInfo_StartStopEvent::set_has_event_start_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleActionInfo_StartStopEvent::clear_has_event_start_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleActionInfo_StartStopEvent::clear_event_start_end() {
  event_start_end_ = 0;
  clear_has_event_start_end();
}
inline ::google::protobuf::int32 BattleActionInfo_StartStopEvent::event_start_end() const {
  return event_start_end_;
}
inline void BattleActionInfo_StartStopEvent::set_event_start_end(::google::protobuf::int32 value) {
  set_has_event_start_end();
  event_start_end_ = value;
}

// optional int32 event_value = 4;
inline bool BattleActionInfo_StartStopEvent::has_event_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleActionInfo_StartStopEvent::set_has_event_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleActionInfo_StartStopEvent::clear_has_event_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleActionInfo_StartStopEvent::clear_event_value() {
  event_value_ = 0;
  clear_has_event_value();
}
inline ::google::protobuf::int32 BattleActionInfo_StartStopEvent::event_value() const {
  return event_value_;
}
inline void BattleActionInfo_StartStopEvent::set_event_value(::google::protobuf::int32 value) {
  set_has_event_value();
  event_value_ = value;
}

// optional int32 move_to_x = 5;
inline bool BattleActionInfo_StartStopEvent::has_move_to_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleActionInfo_StartStopEvent::set_has_move_to_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleActionInfo_StartStopEvent::clear_has_move_to_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleActionInfo_StartStopEvent::clear_move_to_x() {
  move_to_x_ = 0;
  clear_has_move_to_x();
}
inline ::google::protobuf::int32 BattleActionInfo_StartStopEvent::move_to_x() const {
  return move_to_x_;
}
inline void BattleActionInfo_StartStopEvent::set_move_to_x(::google::protobuf::int32 value) {
  set_has_move_to_x();
  move_to_x_ = value;
}

// optional int32 target_id = 6;
inline bool BattleActionInfo_StartStopEvent::has_target_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleActionInfo_StartStopEvent::set_has_target_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleActionInfo_StartStopEvent::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleActionInfo_StartStopEvent::clear_target_id() {
  target_id_ = 0;
  clear_has_target_id();
}
inline ::google::protobuf::int32 BattleActionInfo_StartStopEvent::target_id() const {
  return target_id_;
}
inline void BattleActionInfo_StartStopEvent::set_target_id(::google::protobuf::int32 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional int32 next_x = 7;
inline bool BattleActionInfo_StartStopEvent::has_next_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleActionInfo_StartStopEvent::set_has_next_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleActionInfo_StartStopEvent::clear_has_next_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleActionInfo_StartStopEvent::clear_next_x() {
  next_x_ = 0;
  clear_has_next_x();
}
inline ::google::protobuf::int32 BattleActionInfo_StartStopEvent::next_x() const {
  return next_x_;
}
inline void BattleActionInfo_StartStopEvent::set_next_x(::google::protobuf::int32 value) {
  set_has_next_x();
  next_x_ = value;
}

// -------------------------------------------------------------------

// BattleActionInfo_TargetEvent

// required int32 target_char_id = 1;
inline bool BattleActionInfo_TargetEvent::has_target_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleActionInfo_TargetEvent::set_has_target_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleActionInfo_TargetEvent::clear_has_target_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleActionInfo_TargetEvent::clear_target_char_id() {
  target_char_id_ = 0;
  clear_has_target_char_id();
}
inline ::google::protobuf::int32 BattleActionInfo_TargetEvent::target_char_id() const {
  return target_char_id_;
}
inline void BattleActionInfo_TargetEvent::set_target_char_id(::google::protobuf::int32 value) {
  set_has_target_char_id();
  target_char_id_ = value;
}

// required int32 damage = 2;
inline bool BattleActionInfo_TargetEvent::has_damage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleActionInfo_TargetEvent::set_has_damage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleActionInfo_TargetEvent::clear_has_damage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleActionInfo_TargetEvent::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 BattleActionInfo_TargetEvent::damage() const {
  return damage_;
}
inline void BattleActionInfo_TargetEvent::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// BattleActionInfo_AttackEvent

// required int32 char_id = 1;
inline bool BattleActionInfo_AttackEvent::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleActionInfo_AttackEvent::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleActionInfo_AttackEvent::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleActionInfo_AttackEvent::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleActionInfo_AttackEvent::char_id() const {
  return char_id_;
}
inline void BattleActionInfo_AttackEvent::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 skill_id = 2;
inline bool BattleActionInfo_AttackEvent::has_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleActionInfo_AttackEvent::set_has_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleActionInfo_AttackEvent::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleActionInfo_AttackEvent::clear_skill_id() {
  skill_id_ = 0;
  clear_has_skill_id();
}
inline ::google::protobuf::int32 BattleActionInfo_AttackEvent::skill_id() const {
  return skill_id_;
}
inline void BattleActionInfo_AttackEvent::set_skill_id(::google::protobuf::int32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// repeated int32 target_char_id = 3;
inline int BattleActionInfo_AttackEvent::target_char_id_size() const {
  return target_char_id_.size();
}
inline void BattleActionInfo_AttackEvent::clear_target_char_id() {
  target_char_id_.Clear();
}
inline ::google::protobuf::int32 BattleActionInfo_AttackEvent::target_char_id(int index) const {
  return target_char_id_.Get(index);
}
inline void BattleActionInfo_AttackEvent::set_target_char_id(int index, ::google::protobuf::int32 value) {
  target_char_id_.Set(index, value);
}
inline void BattleActionInfo_AttackEvent::add_target_char_id(::google::protobuf::int32 value) {
  target_char_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BattleActionInfo_AttackEvent::target_char_id() const {
  return target_char_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BattleActionInfo_AttackEvent::mutable_target_char_id() {
  return &target_char_id_;
}

// optional int32 change_value = 4;
inline bool BattleActionInfo_AttackEvent::has_change_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleActionInfo_AttackEvent::set_has_change_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleActionInfo_AttackEvent::clear_has_change_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleActionInfo_AttackEvent::clear_change_value() {
  change_value_ = 0;
  clear_has_change_value();
}
inline ::google::protobuf::int32 BattleActionInfo_AttackEvent::change_value() const {
  return change_value_;
}
inline void BattleActionInfo_AttackEvent::set_change_value(::google::protobuf::int32 value) {
  set_has_change_value();
  change_value_ = value;
}

// optional int32 is_critical = 5;
inline bool BattleActionInfo_AttackEvent::has_is_critical() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleActionInfo_AttackEvent::set_has_is_critical() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleActionInfo_AttackEvent::clear_has_is_critical() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleActionInfo_AttackEvent::clear_is_critical() {
  is_critical_ = 0;
  clear_has_is_critical();
}
inline ::google::protobuf::int32 BattleActionInfo_AttackEvent::is_critical() const {
  return is_critical_;
}
inline void BattleActionInfo_AttackEvent::set_is_critical(::google::protobuf::int32 value) {
  set_has_is_critical();
  is_critical_ = value;
}

// optional int32 time_info = 6;
inline bool BattleActionInfo_AttackEvent::has_time_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleActionInfo_AttackEvent::set_has_time_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleActionInfo_AttackEvent::clear_has_time_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleActionInfo_AttackEvent::clear_time_info() {
  time_info_ = 0;
  clear_has_time_info();
}
inline ::google::protobuf::int32 BattleActionInfo_AttackEvent::time_info() const {
  return time_info_;
}
inline void BattleActionInfo_AttackEvent::set_time_info(::google::protobuf::int32 value) {
  set_has_time_info();
  time_info_ = value;
}

// -------------------------------------------------------------------

// BattleActionInfo_AttrChangeEvent

// required int32 char_id = 1;
inline bool BattleActionInfo_AttrChangeEvent::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleActionInfo_AttrChangeEvent::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleActionInfo_AttrChangeEvent::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleActionInfo_AttrChangeEvent::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleActionInfo_AttrChangeEvent::char_id() const {
  return char_id_;
}
inline void BattleActionInfo_AttrChangeEvent::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 change_type = 2;
inline bool BattleActionInfo_AttrChangeEvent::has_change_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleActionInfo_AttrChangeEvent::set_has_change_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleActionInfo_AttrChangeEvent::clear_has_change_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleActionInfo_AttrChangeEvent::clear_change_type() {
  change_type_ = 0;
  clear_has_change_type();
}
inline ::google::protobuf::int32 BattleActionInfo_AttrChangeEvent::change_type() const {
  return change_type_;
}
inline void BattleActionInfo_AttrChangeEvent::set_change_type(::google::protobuf::int32 value) {
  set_has_change_type();
  change_type_ = value;
}

// required int32 change_value = 3;
inline bool BattleActionInfo_AttrChangeEvent::has_change_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleActionInfo_AttrChangeEvent::set_has_change_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleActionInfo_AttrChangeEvent::clear_has_change_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleActionInfo_AttrChangeEvent::clear_change_value() {
  change_value_ = 0;
  clear_has_change_value();
}
inline ::google::protobuf::int32 BattleActionInfo_AttrChangeEvent::change_value() const {
  return change_value_;
}
inline void BattleActionInfo_AttrChangeEvent::set_change_value(::google::protobuf::int32 value) {
  set_has_change_value();
  change_value_ = value;
}

// optional int32 skill_damage = 4;
inline bool BattleActionInfo_AttrChangeEvent::has_skill_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleActionInfo_AttrChangeEvent::set_has_skill_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleActionInfo_AttrChangeEvent::clear_has_skill_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleActionInfo_AttrChangeEvent::clear_skill_damage() {
  skill_damage_ = 0;
  clear_has_skill_damage();
}
inline ::google::protobuf::int32 BattleActionInfo_AttrChangeEvent::skill_damage() const {
  return skill_damage_;
}
inline void BattleActionInfo_AttrChangeEvent::set_skill_damage(::google::protobuf::int32 value) {
  set_has_skill_damage();
  skill_damage_ = value;
}

// -------------------------------------------------------------------

// BattleActionInfo_SummonEvent

// required int32 char_id = 1;
inline bool BattleActionInfo_SummonEvent::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleActionInfo_SummonEvent::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleActionInfo_SummonEvent::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleActionInfo_SummonEvent::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleActionInfo_SummonEvent::char_id() const {
  return char_id_;
}
inline void BattleActionInfo_SummonEvent::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 mode_id = 2;
inline bool BattleActionInfo_SummonEvent::has_mode_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleActionInfo_SummonEvent::set_has_mode_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleActionInfo_SummonEvent::clear_has_mode_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleActionInfo_SummonEvent::clear_mode_id() {
  mode_id_ = 0;
  clear_has_mode_id();
}
inline ::google::protobuf::int32 BattleActionInfo_SummonEvent::mode_id() const {
  return mode_id_;
}
inline void BattleActionInfo_SummonEvent::set_mode_id(::google::protobuf::int32 value) {
  set_has_mode_id();
  mode_id_ = value;
}

// required int32 pos_x = 3;
inline bool BattleActionInfo_SummonEvent::has_pos_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleActionInfo_SummonEvent::set_has_pos_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleActionInfo_SummonEvent::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleActionInfo_SummonEvent::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 BattleActionInfo_SummonEvent::pos_x() const {
  return pos_x_;
}
inline void BattleActionInfo_SummonEvent::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required int32 hp = 4;
inline bool BattleActionInfo_SummonEvent::has_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleActionInfo_SummonEvent::set_has_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleActionInfo_SummonEvent::clear_has_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleActionInfo_SummonEvent::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 BattleActionInfo_SummonEvent::hp() const {
  return hp_;
}
inline void BattleActionInfo_SummonEvent::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// BattleActionInfo_SufferEvent

// required int32 char_id = 1;
inline bool BattleActionInfo_SufferEvent::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleActionInfo_SufferEvent::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleActionInfo_SufferEvent::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleActionInfo_SufferEvent::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleActionInfo_SufferEvent::char_id() const {
  return char_id_;
}
inline void BattleActionInfo_SufferEvent::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 skill_id = 2;
inline bool BattleActionInfo_SufferEvent::has_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleActionInfo_SufferEvent::set_has_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleActionInfo_SufferEvent::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleActionInfo_SufferEvent::clear_skill_id() {
  skill_id_ = 0;
  clear_has_skill_id();
}
inline ::google::protobuf::int32 BattleActionInfo_SufferEvent::skill_id() const {
  return skill_id_;
}
inline void BattleActionInfo_SufferEvent::set_skill_id(::google::protobuf::int32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// repeated int32 target_char_id = 3;
inline int BattleActionInfo_SufferEvent::target_char_id_size() const {
  return target_char_id_.size();
}
inline void BattleActionInfo_SufferEvent::clear_target_char_id() {
  target_char_id_.Clear();
}
inline ::google::protobuf::int32 BattleActionInfo_SufferEvent::target_char_id(int index) const {
  return target_char_id_.Get(index);
}
inline void BattleActionInfo_SufferEvent::set_target_char_id(int index, ::google::protobuf::int32 value) {
  target_char_id_.Set(index, value);
}
inline void BattleActionInfo_SufferEvent::add_target_char_id(::google::protobuf::int32 value) {
  target_char_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BattleActionInfo_SufferEvent::target_char_id() const {
  return target_char_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BattleActionInfo_SufferEvent::mutable_target_char_id() {
  return &target_char_id_;
}

// -------------------------------------------------------------------

// BattleActionInfo_CastAreaEvent

// required int32 event_start_end = 1;
inline bool BattleActionInfo_CastAreaEvent::has_event_start_end() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleActionInfo_CastAreaEvent::set_has_event_start_end() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleActionInfo_CastAreaEvent::clear_has_event_start_end() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleActionInfo_CastAreaEvent::clear_event_start_end() {
  event_start_end_ = 0;
  clear_has_event_start_end();
}
inline ::google::protobuf::int32 BattleActionInfo_CastAreaEvent::event_start_end() const {
  return event_start_end_;
}
inline void BattleActionInfo_CastAreaEvent::set_event_start_end(::google::protobuf::int32 value) {
  set_has_event_start_end();
  event_start_end_ = value;
}

// required int32 pos_x = 2;
inline bool BattleActionInfo_CastAreaEvent::has_pos_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleActionInfo_CastAreaEvent::set_has_pos_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleActionInfo_CastAreaEvent::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleActionInfo_CastAreaEvent::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 BattleActionInfo_CastAreaEvent::pos_x() const {
  return pos_x_;
}
inline void BattleActionInfo_CastAreaEvent::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required int32 area = 3;
inline bool BattleActionInfo_CastAreaEvent::has_area() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleActionInfo_CastAreaEvent::set_has_area() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleActionInfo_CastAreaEvent::clear_has_area() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleActionInfo_CastAreaEvent::clear_area() {
  area_ = 0;
  clear_has_area();
}
inline ::google::protobuf::int32 BattleActionInfo_CastAreaEvent::area() const {
  return area_;
}
inline void BattleActionInfo_CastAreaEvent::set_area(::google::protobuf::int32 value) {
  set_has_area();
  area_ = value;
}

// -------------------------------------------------------------------

// BattleActionInfo_ActionInfo

// optional .message.BattleActionInfo.StartStopEvent start_stop_event = 1;
inline bool BattleActionInfo_ActionInfo::has_start_stop_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleActionInfo_ActionInfo::set_has_start_stop_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleActionInfo_ActionInfo::clear_has_start_stop_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleActionInfo_ActionInfo::clear_start_stop_event() {
  if (start_stop_event_ != NULL) start_stop_event_->::message::BattleActionInfo_StartStopEvent::Clear();
  clear_has_start_stop_event();
}
inline const ::message::BattleActionInfo_StartStopEvent& BattleActionInfo_ActionInfo::start_stop_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return start_stop_event_ != NULL ? *start_stop_event_ : *default_instance().start_stop_event_;
#else
  return start_stop_event_ != NULL ? *start_stop_event_ : *default_instance_->start_stop_event_;
#endif
}
inline ::message::BattleActionInfo_StartStopEvent* BattleActionInfo_ActionInfo::mutable_start_stop_event() {
  set_has_start_stop_event();
  if (start_stop_event_ == NULL) start_stop_event_ = new ::message::BattleActionInfo_StartStopEvent;
  return start_stop_event_;
}
inline ::message::BattleActionInfo_StartStopEvent* BattleActionInfo_ActionInfo::release_start_stop_event() {
  clear_has_start_stop_event();
  ::message::BattleActionInfo_StartStopEvent* temp = start_stop_event_;
  start_stop_event_ = NULL;
  return temp;
}
inline void BattleActionInfo_ActionInfo::set_allocated_start_stop_event(::message::BattleActionInfo_StartStopEvent* start_stop_event) {
  delete start_stop_event_;
  start_stop_event_ = start_stop_event;
  if (start_stop_event) {
    set_has_start_stop_event();
  } else {
    clear_has_start_stop_event();
  }
}

// optional .message.BattleActionInfo.AttackEvent attack_event = 2;
inline bool BattleActionInfo_ActionInfo::has_attack_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleActionInfo_ActionInfo::set_has_attack_event() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleActionInfo_ActionInfo::clear_has_attack_event() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleActionInfo_ActionInfo::clear_attack_event() {
  if (attack_event_ != NULL) attack_event_->::message::BattleActionInfo_AttackEvent::Clear();
  clear_has_attack_event();
}
inline const ::message::BattleActionInfo_AttackEvent& BattleActionInfo_ActionInfo::attack_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attack_event_ != NULL ? *attack_event_ : *default_instance().attack_event_;
#else
  return attack_event_ != NULL ? *attack_event_ : *default_instance_->attack_event_;
#endif
}
inline ::message::BattleActionInfo_AttackEvent* BattleActionInfo_ActionInfo::mutable_attack_event() {
  set_has_attack_event();
  if (attack_event_ == NULL) attack_event_ = new ::message::BattleActionInfo_AttackEvent;
  return attack_event_;
}
inline ::message::BattleActionInfo_AttackEvent* BattleActionInfo_ActionInfo::release_attack_event() {
  clear_has_attack_event();
  ::message::BattleActionInfo_AttackEvent* temp = attack_event_;
  attack_event_ = NULL;
  return temp;
}
inline void BattleActionInfo_ActionInfo::set_allocated_attack_event(::message::BattleActionInfo_AttackEvent* attack_event) {
  delete attack_event_;
  attack_event_ = attack_event;
  if (attack_event) {
    set_has_attack_event();
  } else {
    clear_has_attack_event();
  }
}

// optional .message.BattleActionInfo.AttrChangeEvent attr_change_event = 3;
inline bool BattleActionInfo_ActionInfo::has_attr_change_event() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleActionInfo_ActionInfo::set_has_attr_change_event() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleActionInfo_ActionInfo::clear_has_attr_change_event() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleActionInfo_ActionInfo::clear_attr_change_event() {
  if (attr_change_event_ != NULL) attr_change_event_->::message::BattleActionInfo_AttrChangeEvent::Clear();
  clear_has_attr_change_event();
}
inline const ::message::BattleActionInfo_AttrChangeEvent& BattleActionInfo_ActionInfo::attr_change_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_change_event_ != NULL ? *attr_change_event_ : *default_instance().attr_change_event_;
#else
  return attr_change_event_ != NULL ? *attr_change_event_ : *default_instance_->attr_change_event_;
#endif
}
inline ::message::BattleActionInfo_AttrChangeEvent* BattleActionInfo_ActionInfo::mutable_attr_change_event() {
  set_has_attr_change_event();
  if (attr_change_event_ == NULL) attr_change_event_ = new ::message::BattleActionInfo_AttrChangeEvent;
  return attr_change_event_;
}
inline ::message::BattleActionInfo_AttrChangeEvent* BattleActionInfo_ActionInfo::release_attr_change_event() {
  clear_has_attr_change_event();
  ::message::BattleActionInfo_AttrChangeEvent* temp = attr_change_event_;
  attr_change_event_ = NULL;
  return temp;
}
inline void BattleActionInfo_ActionInfo::set_allocated_attr_change_event(::message::BattleActionInfo_AttrChangeEvent* attr_change_event) {
  delete attr_change_event_;
  attr_change_event_ = attr_change_event;
  if (attr_change_event) {
    set_has_attr_change_event();
  } else {
    clear_has_attr_change_event();
  }
}

// optional .message.BattleActionInfo.SummonEvent summon_event = 4;
inline bool BattleActionInfo_ActionInfo::has_summon_event() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleActionInfo_ActionInfo::set_has_summon_event() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleActionInfo_ActionInfo::clear_has_summon_event() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleActionInfo_ActionInfo::clear_summon_event() {
  if (summon_event_ != NULL) summon_event_->::message::BattleActionInfo_SummonEvent::Clear();
  clear_has_summon_event();
}
inline const ::message::BattleActionInfo_SummonEvent& BattleActionInfo_ActionInfo::summon_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return summon_event_ != NULL ? *summon_event_ : *default_instance().summon_event_;
#else
  return summon_event_ != NULL ? *summon_event_ : *default_instance_->summon_event_;
#endif
}
inline ::message::BattleActionInfo_SummonEvent* BattleActionInfo_ActionInfo::mutable_summon_event() {
  set_has_summon_event();
  if (summon_event_ == NULL) summon_event_ = new ::message::BattleActionInfo_SummonEvent;
  return summon_event_;
}
inline ::message::BattleActionInfo_SummonEvent* BattleActionInfo_ActionInfo::release_summon_event() {
  clear_has_summon_event();
  ::message::BattleActionInfo_SummonEvent* temp = summon_event_;
  summon_event_ = NULL;
  return temp;
}
inline void BattleActionInfo_ActionInfo::set_allocated_summon_event(::message::BattleActionInfo_SummonEvent* summon_event) {
  delete summon_event_;
  summon_event_ = summon_event;
  if (summon_event) {
    set_has_summon_event();
  } else {
    clear_has_summon_event();
  }
}

// optional .message.BattleActionInfo.SufferEvent suffer_event = 5;
inline bool BattleActionInfo_ActionInfo::has_suffer_event() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleActionInfo_ActionInfo::set_has_suffer_event() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleActionInfo_ActionInfo::clear_has_suffer_event() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleActionInfo_ActionInfo::clear_suffer_event() {
  if (suffer_event_ != NULL) suffer_event_->::message::BattleActionInfo_SufferEvent::Clear();
  clear_has_suffer_event();
}
inline const ::message::BattleActionInfo_SufferEvent& BattleActionInfo_ActionInfo::suffer_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return suffer_event_ != NULL ? *suffer_event_ : *default_instance().suffer_event_;
#else
  return suffer_event_ != NULL ? *suffer_event_ : *default_instance_->suffer_event_;
#endif
}
inline ::message::BattleActionInfo_SufferEvent* BattleActionInfo_ActionInfo::mutable_suffer_event() {
  set_has_suffer_event();
  if (suffer_event_ == NULL) suffer_event_ = new ::message::BattleActionInfo_SufferEvent;
  return suffer_event_;
}
inline ::message::BattleActionInfo_SufferEvent* BattleActionInfo_ActionInfo::release_suffer_event() {
  clear_has_suffer_event();
  ::message::BattleActionInfo_SufferEvent* temp = suffer_event_;
  suffer_event_ = NULL;
  return temp;
}
inline void BattleActionInfo_ActionInfo::set_allocated_suffer_event(::message::BattleActionInfo_SufferEvent* suffer_event) {
  delete suffer_event_;
  suffer_event_ = suffer_event;
  if (suffer_event) {
    set_has_suffer_event();
  } else {
    clear_has_suffer_event();
  }
}

// optional .message.BattleActionInfo.CastAreaEvent cast_area_event = 6;
inline bool BattleActionInfo_ActionInfo::has_cast_area_event() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleActionInfo_ActionInfo::set_has_cast_area_event() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleActionInfo_ActionInfo::clear_has_cast_area_event() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleActionInfo_ActionInfo::clear_cast_area_event() {
  if (cast_area_event_ != NULL) cast_area_event_->::message::BattleActionInfo_CastAreaEvent::Clear();
  clear_has_cast_area_event();
}
inline const ::message::BattleActionInfo_CastAreaEvent& BattleActionInfo_ActionInfo::cast_area_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cast_area_event_ != NULL ? *cast_area_event_ : *default_instance().cast_area_event_;
#else
  return cast_area_event_ != NULL ? *cast_area_event_ : *default_instance_->cast_area_event_;
#endif
}
inline ::message::BattleActionInfo_CastAreaEvent* BattleActionInfo_ActionInfo::mutable_cast_area_event() {
  set_has_cast_area_event();
  if (cast_area_event_ == NULL) cast_area_event_ = new ::message::BattleActionInfo_CastAreaEvent;
  return cast_area_event_;
}
inline ::message::BattleActionInfo_CastAreaEvent* BattleActionInfo_ActionInfo::release_cast_area_event() {
  clear_has_cast_area_event();
  ::message::BattleActionInfo_CastAreaEvent* temp = cast_area_event_;
  cast_area_event_ = NULL;
  return temp;
}
inline void BattleActionInfo_ActionInfo::set_allocated_cast_area_event(::message::BattleActionInfo_CastAreaEvent* cast_area_event) {
  delete cast_area_event_;
  cast_area_event_ = cast_area_event;
  if (cast_area_event) {
    set_has_cast_area_event();
  } else {
    clear_has_cast_area_event();
  }
}

// -------------------------------------------------------------------

// BattleActionInfo

// repeated .message.BattleActionInfo.ActionInfo action_info = 1;
inline int BattleActionInfo::action_info_size() const {
  return action_info_.size();
}
inline void BattleActionInfo::clear_action_info() {
  action_info_.Clear();
}
inline const ::message::BattleActionInfo_ActionInfo& BattleActionInfo::action_info(int index) const {
  return action_info_.Get(index);
}
inline ::message::BattleActionInfo_ActionInfo* BattleActionInfo::mutable_action_info(int index) {
  return action_info_.Mutable(index);
}
inline ::message::BattleActionInfo_ActionInfo* BattleActionInfo::add_action_info() {
  return action_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::BattleActionInfo_ActionInfo >&
BattleActionInfo::action_info() const {
  return action_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::BattleActionInfo_ActionInfo >*
BattleActionInfo::mutable_action_info() {
  return &action_info_;
}

// -------------------------------------------------------------------

// BattleProcess_AttackEvent

// required int32 char_id = 1;
inline bool BattleProcess_AttackEvent::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleProcess_AttackEvent::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleProcess_AttackEvent::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleProcess_AttackEvent::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleProcess_AttackEvent::char_id() const {
  return char_id_;
}
inline void BattleProcess_AttackEvent::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 skill_id = 2;
inline bool BattleProcess_AttackEvent::has_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleProcess_AttackEvent::set_has_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleProcess_AttackEvent::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleProcess_AttackEvent::clear_skill_id() {
  skill_id_ = 0;
  clear_has_skill_id();
}
inline ::google::protobuf::int32 BattleProcess_AttackEvent::skill_id() const {
  return skill_id_;
}
inline void BattleProcess_AttackEvent::set_skill_id(::google::protobuf::int32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// repeated int32 target_char_id = 3;
inline int BattleProcess_AttackEvent::target_char_id_size() const {
  return target_char_id_.size();
}
inline void BattleProcess_AttackEvent::clear_target_char_id() {
  target_char_id_.Clear();
}
inline ::google::protobuf::int32 BattleProcess_AttackEvent::target_char_id(int index) const {
  return target_char_id_.Get(index);
}
inline void BattleProcess_AttackEvent::set_target_char_id(int index, ::google::protobuf::int32 value) {
  target_char_id_.Set(index, value);
}
inline void BattleProcess_AttackEvent::add_target_char_id(::google::protobuf::int32 value) {
  target_char_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BattleProcess_AttackEvent::target_char_id() const {
  return target_char_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BattleProcess_AttackEvent::mutable_target_char_id() {
  return &target_char_id_;
}

// optional int32 change_value = 4;
inline bool BattleProcess_AttackEvent::has_change_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleProcess_AttackEvent::set_has_change_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleProcess_AttackEvent::clear_has_change_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleProcess_AttackEvent::clear_change_value() {
  change_value_ = 0;
  clear_has_change_value();
}
inline ::google::protobuf::int32 BattleProcess_AttackEvent::change_value() const {
  return change_value_;
}
inline void BattleProcess_AttackEvent::set_change_value(::google::protobuf::int32 value) {
  set_has_change_value();
  change_value_ = value;
}

// optional int32 is_critical = 5;
inline bool BattleProcess_AttackEvent::has_is_critical() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleProcess_AttackEvent::set_has_is_critical() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleProcess_AttackEvent::clear_has_is_critical() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleProcess_AttackEvent::clear_is_critical() {
  is_critical_ = 0;
  clear_has_is_critical();
}
inline ::google::protobuf::int32 BattleProcess_AttackEvent::is_critical() const {
  return is_critical_;
}
inline void BattleProcess_AttackEvent::set_is_critical(::google::protobuf::int32 value) {
  set_has_is_critical();
  is_critical_ = value;
}

// -------------------------------------------------------------------

// BattleProcess_AttrChangeEvent

// required int32 char_id = 1;
inline bool BattleProcess_AttrChangeEvent::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleProcess_AttrChangeEvent::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleProcess_AttrChangeEvent::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleProcess_AttrChangeEvent::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleProcess_AttrChangeEvent::char_id() const {
  return char_id_;
}
inline void BattleProcess_AttrChangeEvent::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 change_type = 2;
inline bool BattleProcess_AttrChangeEvent::has_change_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleProcess_AttrChangeEvent::set_has_change_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleProcess_AttrChangeEvent::clear_has_change_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleProcess_AttrChangeEvent::clear_change_type() {
  change_type_ = 0;
  clear_has_change_type();
}
inline ::google::protobuf::int32 BattleProcess_AttrChangeEvent::change_type() const {
  return change_type_;
}
inline void BattleProcess_AttrChangeEvent::set_change_type(::google::protobuf::int32 value) {
  set_has_change_type();
  change_type_ = value;
}

// required int32 change_value = 3;
inline bool BattleProcess_AttrChangeEvent::has_change_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleProcess_AttrChangeEvent::set_has_change_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleProcess_AttrChangeEvent::clear_has_change_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleProcess_AttrChangeEvent::clear_change_value() {
  change_value_ = 0;
  clear_has_change_value();
}
inline ::google::protobuf::int32 BattleProcess_AttrChangeEvent::change_value() const {
  return change_value_;
}
inline void BattleProcess_AttrChangeEvent::set_change_value(::google::protobuf::int32 value) {
  set_has_change_value();
  change_value_ = value;
}

// optional int32 skill_damage = 4;
inline bool BattleProcess_AttrChangeEvent::has_skill_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleProcess_AttrChangeEvent::set_has_skill_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleProcess_AttrChangeEvent::clear_has_skill_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleProcess_AttrChangeEvent::clear_skill_damage() {
  skill_damage_ = 0;
  clear_has_skill_damage();
}
inline ::google::protobuf::int32 BattleProcess_AttrChangeEvent::skill_damage() const {
  return skill_damage_;
}
inline void BattleProcess_AttrChangeEvent::set_skill_damage(::google::protobuf::int32 value) {
  set_has_skill_damage();
  skill_damage_ = value;
}

// -------------------------------------------------------------------

// BattleProcess_ActionInfo

// optional .message.BattleProcess.AttackEvent attack_event = 1;
inline bool BattleProcess_ActionInfo::has_attack_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleProcess_ActionInfo::set_has_attack_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleProcess_ActionInfo::clear_has_attack_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleProcess_ActionInfo::clear_attack_event() {
  if (attack_event_ != NULL) attack_event_->::message::BattleProcess_AttackEvent::Clear();
  clear_has_attack_event();
}
inline const ::message::BattleProcess_AttackEvent& BattleProcess_ActionInfo::attack_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attack_event_ != NULL ? *attack_event_ : *default_instance().attack_event_;
#else
  return attack_event_ != NULL ? *attack_event_ : *default_instance_->attack_event_;
#endif
}
inline ::message::BattleProcess_AttackEvent* BattleProcess_ActionInfo::mutable_attack_event() {
  set_has_attack_event();
  if (attack_event_ == NULL) attack_event_ = new ::message::BattleProcess_AttackEvent;
  return attack_event_;
}
inline ::message::BattleProcess_AttackEvent* BattleProcess_ActionInfo::release_attack_event() {
  clear_has_attack_event();
  ::message::BattleProcess_AttackEvent* temp = attack_event_;
  attack_event_ = NULL;
  return temp;
}
inline void BattleProcess_ActionInfo::set_allocated_attack_event(::message::BattleProcess_AttackEvent* attack_event) {
  delete attack_event_;
  attack_event_ = attack_event;
  if (attack_event) {
    set_has_attack_event();
  } else {
    clear_has_attack_event();
  }
}

// optional .message.BattleProcess.AttrChangeEvent attr_change_event = 2;
inline bool BattleProcess_ActionInfo::has_attr_change_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleProcess_ActionInfo::set_has_attr_change_event() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleProcess_ActionInfo::clear_has_attr_change_event() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleProcess_ActionInfo::clear_attr_change_event() {
  if (attr_change_event_ != NULL) attr_change_event_->::message::BattleProcess_AttrChangeEvent::Clear();
  clear_has_attr_change_event();
}
inline const ::message::BattleProcess_AttrChangeEvent& BattleProcess_ActionInfo::attr_change_event() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_change_event_ != NULL ? *attr_change_event_ : *default_instance().attr_change_event_;
#else
  return attr_change_event_ != NULL ? *attr_change_event_ : *default_instance_->attr_change_event_;
#endif
}
inline ::message::BattleProcess_AttrChangeEvent* BattleProcess_ActionInfo::mutable_attr_change_event() {
  set_has_attr_change_event();
  if (attr_change_event_ == NULL) attr_change_event_ = new ::message::BattleProcess_AttrChangeEvent;
  return attr_change_event_;
}
inline ::message::BattleProcess_AttrChangeEvent* BattleProcess_ActionInfo::release_attr_change_event() {
  clear_has_attr_change_event();
  ::message::BattleProcess_AttrChangeEvent* temp = attr_change_event_;
  attr_change_event_ = NULL;
  return temp;
}
inline void BattleProcess_ActionInfo::set_allocated_attr_change_event(::message::BattleProcess_AttrChangeEvent* attr_change_event) {
  delete attr_change_event_;
  attr_change_event_ = attr_change_event;
  if (attr_change_event) {
    set_has_attr_change_event();
  } else {
    clear_has_attr_change_event();
  }
}

// -------------------------------------------------------------------

// BattleProcess

// repeated .message.BattleProcess.ActionInfo action_info = 1;
inline int BattleProcess::action_info_size() const {
  return action_info_.size();
}
inline void BattleProcess::clear_action_info() {
  action_info_.Clear();
}
inline const ::message::BattleProcess_ActionInfo& BattleProcess::action_info(int index) const {
  return action_info_.Get(index);
}
inline ::message::BattleProcess_ActionInfo* BattleProcess::mutable_action_info(int index) {
  return action_info_.Mutable(index);
}
inline ::message::BattleProcess_ActionInfo* BattleProcess::add_action_info() {
  return action_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::BattleProcess_ActionInfo >&
BattleProcess::action_info() const {
  return action_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::BattleProcess_ActionInfo >*
BattleProcess::mutable_action_info() {
  return &action_info_;
}

// -------------------------------------------------------------------

// BattleManualSkill

// required int32 char_id = 1;
inline bool BattleManualSkill::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleManualSkill::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleManualSkill::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleManualSkill::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleManualSkill::char_id() const {
  return char_id_;
}
inline void BattleManualSkill::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 manual_skill = 2;
inline bool BattleManualSkill::has_manual_skill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleManualSkill::set_has_manual_skill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleManualSkill::clear_has_manual_skill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleManualSkill::clear_manual_skill() {
  manual_skill_ = 0;
  clear_has_manual_skill();
}
inline ::google::protobuf::int32 BattleManualSkill::manual_skill() const {
  return manual_skill_;
}
inline void BattleManualSkill::set_manual_skill(::google::protobuf::int32 value) {
  set_has_manual_skill();
  manual_skill_ = value;
}

// -------------------------------------------------------------------

// BattleOperation

// required int32 char_id = 1;
inline bool BattleOperation::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleOperation::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleOperation::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleOperation::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleOperation::char_id() const {
  return char_id_;
}
inline void BattleOperation::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 operation_id = 2;
inline bool BattleOperation::has_operation_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleOperation::set_has_operation_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleOperation::clear_has_operation_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleOperation::clear_operation_id() {
  operation_id_ = 0;
  clear_has_operation_id();
}
inline ::google::protobuf::int32 BattleOperation::operation_id() const {
  return operation_id_;
}
inline void BattleOperation::set_operation_id(::google::protobuf::int32 value) {
  set_has_operation_id();
  operation_id_ = value;
}

// optional int32 pos_x = 3;
inline bool BattleOperation::has_pos_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleOperation::set_has_pos_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleOperation::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleOperation::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 BattleOperation::pos_x() const {
  return pos_x_;
}
inline void BattleOperation::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// -------------------------------------------------------------------

// BattleOperationResult

// required int32 char_id = 1;
inline bool BattleOperationResult::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleOperationResult::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleOperationResult::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleOperationResult::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 BattleOperationResult::char_id() const {
  return char_id_;
}
inline void BattleOperationResult::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required int32 operation_id = 2;
inline bool BattleOperationResult::has_operation_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleOperationResult::set_has_operation_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleOperationResult::clear_has_operation_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleOperationResult::clear_operation_id() {
  operation_id_ = 0;
  clear_has_operation_id();
}
inline ::google::protobuf::int32 BattleOperationResult::operation_id() const {
  return operation_id_;
}
inline void BattleOperationResult::set_operation_id(::google::protobuf::int32 value) {
  set_has_operation_id();
  operation_id_ = value;
}

// required int32 operation_result = 3;
inline bool BattleOperationResult::has_operation_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleOperationResult::set_has_operation_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleOperationResult::clear_has_operation_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleOperationResult::clear_operation_result() {
  operation_result_ = 0;
  clear_has_operation_result();
}
inline ::google::protobuf::int32 BattleOperationResult::operation_result() const {
  return operation_result_;
}
inline void BattleOperationResult::set_operation_result(::google::protobuf::int32 value) {
  set_has_operation_result();
  operation_result_ = value;
}

// -------------------------------------------------------------------

// BattleResultInfo

// required uint32 battle_result = 1;
inline bool BattleResultInfo::has_battle_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleResultInfo::set_has_battle_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleResultInfo::clear_has_battle_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleResultInfo::clear_battle_result() {
  battle_result_ = 0u;
  clear_has_battle_result();
}
inline ::google::protobuf::uint32 BattleResultInfo::battle_result() const {
  return battle_result_;
}
inline void BattleResultInfo::set_battle_result(::google::protobuf::uint32 value) {
  set_has_battle_result();
  battle_result_ = value;
}

// optional uint32 battle_star = 2;
inline bool BattleResultInfo::has_battle_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleResultInfo::set_has_battle_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleResultInfo::clear_has_battle_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleResultInfo::clear_battle_star() {
  battle_star_ = 0u;
  clear_has_battle_star();
}
inline ::google::protobuf::uint32 BattleResultInfo::battle_star() const {
  return battle_star_;
}
inline void BattleResultInfo::set_battle_star(::google::protobuf::uint32 value) {
  set_has_battle_star();
  battle_star_ = value;
}

// optional uint32 pvp_char_id = 3;
inline bool BattleResultInfo::has_pvp_char_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleResultInfo::set_has_pvp_char_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleResultInfo::clear_has_pvp_char_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleResultInfo::clear_pvp_char_id() {
  pvp_char_id_ = 0u;
  clear_has_pvp_char_id();
}
inline ::google::protobuf::uint32 BattleResultInfo::pvp_char_id() const {
  return pvp_char_id_;
}
inline void BattleResultInfo::set_pvp_char_id(::google::protobuf::uint32 value) {
  set_has_pvp_char_id();
  pvp_char_id_ = value;
}

// optional uint32 skill_exp = 4;
inline bool BattleResultInfo::has_skill_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleResultInfo::set_has_skill_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleResultInfo::clear_has_skill_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleResultInfo::clear_skill_exp() {
  skill_exp_ = 0u;
  clear_has_skill_exp();
}
inline ::google::protobuf::uint32 BattleResultInfo::skill_exp() const {
  return skill_exp_;
}
inline void BattleResultInfo::set_skill_exp(::google::protobuf::uint32 value) {
  set_has_skill_exp();
  skill_exp_ = value;
}

// optional uint32 map_id = 5;
inline bool BattleResultInfo::has_map_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleResultInfo::set_has_map_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleResultInfo::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleResultInfo::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 BattleResultInfo::map_id() const {
  return map_id_;
}
inline void BattleResultInfo::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 type = 6;
inline bool BattleResultInfo::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleResultInfo::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleResultInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleResultInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 BattleResultInfo::type() const {
  return type_;
}
inline void BattleResultInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 is_pk = 7;
inline bool BattleResultInfo::has_is_pk() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleResultInfo::set_has_is_pk() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleResultInfo::clear_has_is_pk() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleResultInfo::clear_is_pk() {
  is_pk_ = 0u;
  clear_has_is_pk();
}
inline ::google::protobuf::uint32 BattleResultInfo::is_pk() const {
  return is_pk_;
}
inline void BattleResultInfo::set_is_pk(::google::protobuf::uint32 value) {
  set_has_is_pk();
  is_pk_ = value;
}

// -------------------------------------------------------------------

// BattleRepeat

// required uint32 map_id = 1;
inline bool BattleRepeat::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleRepeat::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleRepeat::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleRepeat::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 BattleRepeat::map_id() const {
  return map_id_;
}
inline void BattleRepeat::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// required uint32 battle_times = 2;
inline bool BattleRepeat::has_battle_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleRepeat::set_has_battle_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleRepeat::clear_has_battle_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleRepeat::clear_battle_times() {
  battle_times_ = 0u;
  clear_has_battle_times();
}
inline ::google::protobuf::uint32 BattleRepeat::battle_times() const {
  return battle_times_;
}
inline void BattleRepeat::set_battle_times(::google::protobuf::uint32 value) {
  set_has_battle_times();
  battle_times_ = value;
}

// optional uint32 type = 3;
inline bool BattleRepeat::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleRepeat::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleRepeat::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleRepeat::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 BattleRepeat::type() const {
  return type_;
}
inline void BattleRepeat::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 auto_sell_material = 4;
inline bool BattleRepeat::has_auto_sell_material() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleRepeat::set_has_auto_sell_material() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleRepeat::clear_has_auto_sell_material() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleRepeat::clear_auto_sell_material() {
  auto_sell_material_ = 0u;
  clear_has_auto_sell_material();
}
inline ::google::protobuf::uint32 BattleRepeat::auto_sell_material() const {
  return auto_sell_material_;
}
inline void BattleRepeat::set_auto_sell_material(::google::protobuf::uint32 value) {
  set_has_auto_sell_material();
  auto_sell_material_ = value;
}

// optional uint32 auto_sell_equip = 5;
inline bool BattleRepeat::has_auto_sell_equip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleRepeat::set_has_auto_sell_equip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleRepeat::clear_has_auto_sell_equip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleRepeat::clear_auto_sell_equip() {
  auto_sell_equip_ = 0u;
  clear_has_auto_sell_equip();
}
inline ::google::protobuf::uint32 BattleRepeat::auto_sell_equip() const {
  return auto_sell_equip_;
}
inline void BattleRepeat::set_auto_sell_equip(::google::protobuf::uint32 value) {
  set_has_auto_sell_equip();
  auto_sell_equip_ = value;
}

// -------------------------------------------------------------------

// BattleQTEInfo

// required int32 QTE_id = 1;
inline bool BattleQTEInfo::has_qte_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleQTEInfo::set_has_qte_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleQTEInfo::clear_has_qte_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleQTEInfo::clear_qte_id() {
  qte_id_ = 0;
  clear_has_qte_id();
}
inline ::google::protobuf::int32 BattleQTEInfo::qte_id() const {
  return qte_id_;
}
inline void BattleQTEInfo::set_qte_id(::google::protobuf::int32 value) {
  set_has_qte_id();
  qte_id_ = value;
}

// -------------------------------------------------------------------

// BattleReward

// required uint32 battle_map = 1;
inline bool BattleReward::has_battle_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleReward::set_has_battle_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleReward::clear_has_battle_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleReward::clear_battle_map() {
  battle_map_ = 0u;
  clear_has_battle_map();
}
inline ::google::protobuf::uint32 BattleReward::battle_map() const {
  return battle_map_;
}
inline void BattleReward::set_battle_map(::google::protobuf::uint32 value) {
  set_has_battle_map();
  battle_map_ = value;
}

// optional uint32 exp = 2;
inline bool BattleReward::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleReward::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleReward::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleReward::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 BattleReward::exp() const {
  return exp_;
}
inline void BattleReward::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// optional uint32 exp_additional = 3;
inline bool BattleReward::has_exp_additional() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleReward::set_has_exp_additional() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleReward::clear_has_exp_additional() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleReward::clear_exp_additional() {
  exp_additional_ = 0u;
  clear_has_exp_additional();
}
inline ::google::protobuf::uint32 BattleReward::exp_additional() const {
  return exp_additional_;
}
inline void BattleReward::set_exp_additional(::google::protobuf::uint32 value) {
  set_has_exp_additional();
  exp_additional_ = value;
}

// optional uint32 team_exp = 4;
inline bool BattleReward::has_team_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleReward::set_has_team_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleReward::clear_has_team_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleReward::clear_team_exp() {
  team_exp_ = 0u;
  clear_has_team_exp();
}
inline ::google::protobuf::uint32 BattleReward::team_exp() const {
  return team_exp_;
}
inline void BattleReward::set_team_exp(::google::protobuf::uint32 value) {
  set_has_team_exp();
  team_exp_ = value;
}

// optional uint32 team_exp_additional = 5;
inline bool BattleReward::has_team_exp_additional() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleReward::set_has_team_exp_additional() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleReward::clear_has_team_exp_additional() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleReward::clear_team_exp_additional() {
  team_exp_additional_ = 0u;
  clear_has_team_exp_additional();
}
inline ::google::protobuf::uint32 BattleReward::team_exp_additional() const {
  return team_exp_additional_;
}
inline void BattleReward::set_team_exp_additional(::google::protobuf::uint32 value) {
  set_has_team_exp_additional();
  team_exp_additional_ = value;
}

// optional uint32 money = 6;
inline bool BattleReward::has_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleReward::set_has_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleReward::clear_has_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleReward::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 BattleReward::money() const {
  return money_;
}
inline void BattleReward::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// optional uint32 money_additional = 7;
inline bool BattleReward::has_money_additional() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleReward::set_has_money_additional() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleReward::clear_has_money_additional() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleReward::clear_money_additional() {
  money_additional_ = 0u;
  clear_has_money_additional();
}
inline ::google::protobuf::uint32 BattleReward::money_additional() const {
  return money_additional_;
}
inline void BattleReward::set_money_additional(::google::protobuf::uint32 value) {
  set_has_money_additional();
  money_additional_ = value;
}

// repeated uint32 reward_item = 8;
inline int BattleReward::reward_item_size() const {
  return reward_item_.size();
}
inline void BattleReward::clear_reward_item() {
  reward_item_.Clear();
}
inline ::google::protobuf::uint32 BattleReward::reward_item(int index) const {
  return reward_item_.Get(index);
}
inline void BattleReward::set_reward_item(int index, ::google::protobuf::uint32 value) {
  reward_item_.Set(index, value);
}
inline void BattleReward::add_reward_item(::google::protobuf::uint32 value) {
  reward_item_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BattleReward::reward_item() const {
  return reward_item_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BattleReward::mutable_reward_item() {
  return &reward_item_;
}

// repeated uint32 reward_item_num = 9;
inline int BattleReward::reward_item_num_size() const {
  return reward_item_num_.size();
}
inline void BattleReward::clear_reward_item_num() {
  reward_item_num_.Clear();
}
inline ::google::protobuf::uint32 BattleReward::reward_item_num(int index) const {
  return reward_item_num_.Get(index);
}
inline void BattleReward::set_reward_item_num(int index, ::google::protobuf::uint32 value) {
  reward_item_num_.Set(index, value);
}
inline void BattleReward::add_reward_item_num(::google::protobuf::uint32 value) {
  reward_item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BattleReward::reward_item_num() const {
  return reward_item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BattleReward::mutable_reward_item_num() {
  return &reward_item_num_;
}

// optional uint32 is_repeat = 10;
inline bool BattleReward::has_is_repeat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleReward::set_has_is_repeat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleReward::clear_has_is_repeat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleReward::clear_is_repeat() {
  is_repeat_ = 0u;
  clear_has_is_repeat();
}
inline ::google::protobuf::uint32 BattleReward::is_repeat() const {
  return is_repeat_;
}
inline void BattleReward::set_is_repeat(::google::protobuf::uint32 value) {
  set_has_is_repeat();
  is_repeat_ = value;
}

// -------------------------------------------------------------------

// BattleRepeatReward_RewardInfo

// optional uint32 exp = 1;
inline bool BattleRepeatReward_RewardInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleRepeatReward_RewardInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleRepeatReward_RewardInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleRepeatReward_RewardInfo::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 BattleRepeatReward_RewardInfo::exp() const {
  return exp_;
}
inline void BattleRepeatReward_RewardInfo::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// optional uint32 team_exp = 2;
inline bool BattleRepeatReward_RewardInfo::has_team_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleRepeatReward_RewardInfo::set_has_team_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleRepeatReward_RewardInfo::clear_has_team_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleRepeatReward_RewardInfo::clear_team_exp() {
  team_exp_ = 0u;
  clear_has_team_exp();
}
inline ::google::protobuf::uint32 BattleRepeatReward_RewardInfo::team_exp() const {
  return team_exp_;
}
inline void BattleRepeatReward_RewardInfo::set_team_exp(::google::protobuf::uint32 value) {
  set_has_team_exp();
  team_exp_ = value;
}

// optional uint32 money = 3;
inline bool BattleRepeatReward_RewardInfo::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleRepeatReward_RewardInfo::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleRepeatReward_RewardInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleRepeatReward_RewardInfo::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 BattleRepeatReward_RewardInfo::money() const {
  return money_;
}
inline void BattleRepeatReward_RewardInfo::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// repeated uint32 item_id = 4;
inline int BattleRepeatReward_RewardInfo::item_id_size() const {
  return item_id_.size();
}
inline void BattleRepeatReward_RewardInfo::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::uint32 BattleRepeatReward_RewardInfo::item_id(int index) const {
  return item_id_.Get(index);
}
inline void BattleRepeatReward_RewardInfo::set_item_id(int index, ::google::protobuf::uint32 value) {
  item_id_.Set(index, value);
}
inline void BattleRepeatReward_RewardInfo::add_item_id(::google::protobuf::uint32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BattleRepeatReward_RewardInfo::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BattleRepeatReward_RewardInfo::mutable_item_id() {
  return &item_id_;
}

// repeated uint32 item_num = 5;
inline int BattleRepeatReward_RewardInfo::item_num_size() const {
  return item_num_.size();
}
inline void BattleRepeatReward_RewardInfo::clear_item_num() {
  item_num_.Clear();
}
inline ::google::protobuf::uint32 BattleRepeatReward_RewardInfo::item_num(int index) const {
  return item_num_.Get(index);
}
inline void BattleRepeatReward_RewardInfo::set_item_num(int index, ::google::protobuf::uint32 value) {
  item_num_.Set(index, value);
}
inline void BattleRepeatReward_RewardInfo::add_item_num(::google::protobuf::uint32 value) {
  item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BattleRepeatReward_RewardInfo::item_num() const {
  return item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BattleRepeatReward_RewardInfo::mutable_item_num() {
  return &item_num_;
}

// -------------------------------------------------------------------

// BattleRepeatReward

// required uint32 battle_map = 1;
inline bool BattleRepeatReward::has_battle_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleRepeatReward::set_has_battle_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleRepeatReward::clear_has_battle_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleRepeatReward::clear_battle_map() {
  battle_map_ = 0u;
  clear_has_battle_map();
}
inline ::google::protobuf::uint32 BattleRepeatReward::battle_map() const {
  return battle_map_;
}
inline void BattleRepeatReward::set_battle_map(::google::protobuf::uint32 value) {
  set_has_battle_map();
  battle_map_ = value;
}

// repeated .message.BattleRepeatReward.RewardInfo reward_data = 2;
inline int BattleRepeatReward::reward_data_size() const {
  return reward_data_.size();
}
inline void BattleRepeatReward::clear_reward_data() {
  reward_data_.Clear();
}
inline const ::message::BattleRepeatReward_RewardInfo& BattleRepeatReward::reward_data(int index) const {
  return reward_data_.Get(index);
}
inline ::message::BattleRepeatReward_RewardInfo* BattleRepeatReward::mutable_reward_data(int index) {
  return reward_data_.Mutable(index);
}
inline ::message::BattleRepeatReward_RewardInfo* BattleRepeatReward::add_reward_data() {
  return reward_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::BattleRepeatReward_RewardInfo >&
BattleRepeatReward::reward_data() const {
  return reward_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::BattleRepeatReward_RewardInfo >*
BattleRepeatReward::mutable_reward_data() {
  return &reward_data_;
}

// optional uint32 exp_additional = 3;
inline bool BattleRepeatReward::has_exp_additional() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleRepeatReward::set_has_exp_additional() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleRepeatReward::clear_has_exp_additional() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleRepeatReward::clear_exp_additional() {
  exp_additional_ = 0u;
  clear_has_exp_additional();
}
inline ::google::protobuf::uint32 BattleRepeatReward::exp_additional() const {
  return exp_additional_;
}
inline void BattleRepeatReward::set_exp_additional(::google::protobuf::uint32 value) {
  set_has_exp_additional();
  exp_additional_ = value;
}

// optional uint32 team_exp_additional = 4;
inline bool BattleRepeatReward::has_team_exp_additional() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleRepeatReward::set_has_team_exp_additional() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleRepeatReward::clear_has_team_exp_additional() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleRepeatReward::clear_team_exp_additional() {
  team_exp_additional_ = 0u;
  clear_has_team_exp_additional();
}
inline ::google::protobuf::uint32 BattleRepeatReward::team_exp_additional() const {
  return team_exp_additional_;
}
inline void BattleRepeatReward::set_team_exp_additional(::google::protobuf::uint32 value) {
  set_has_team_exp_additional();
  team_exp_additional_ = value;
}

// optional uint32 money_additional = 5;
inline bool BattleRepeatReward::has_money_additional() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleRepeatReward::set_has_money_additional() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleRepeatReward::clear_has_money_additional() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleRepeatReward::clear_money_additional() {
  money_additional_ = 0u;
  clear_has_money_additional();
}
inline ::google::protobuf::uint32 BattleRepeatReward::money_additional() const {
  return money_additional_;
}
inline void BattleRepeatReward::set_money_additional(::google::protobuf::uint32 value) {
  set_has_money_additional();
  money_additional_ = value;
}

// repeated uint32 item_id_additional = 6;
inline int BattleRepeatReward::item_id_additional_size() const {
  return item_id_additional_.size();
}
inline void BattleRepeatReward::clear_item_id_additional() {
  item_id_additional_.Clear();
}
inline ::google::protobuf::uint32 BattleRepeatReward::item_id_additional(int index) const {
  return item_id_additional_.Get(index);
}
inline void BattleRepeatReward::set_item_id_additional(int index, ::google::protobuf::uint32 value) {
  item_id_additional_.Set(index, value);
}
inline void BattleRepeatReward::add_item_id_additional(::google::protobuf::uint32 value) {
  item_id_additional_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BattleRepeatReward::item_id_additional() const {
  return item_id_additional_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BattleRepeatReward::mutable_item_id_additional() {
  return &item_id_additional_;
}

// repeated uint32 item_num_additional = 7;
inline int BattleRepeatReward::item_num_additional_size() const {
  return item_num_additional_.size();
}
inline void BattleRepeatReward::clear_item_num_additional() {
  item_num_additional_.Clear();
}
inline ::google::protobuf::uint32 BattleRepeatReward::item_num_additional(int index) const {
  return item_num_additional_.Get(index);
}
inline void BattleRepeatReward::set_item_num_additional(int index, ::google::protobuf::uint32 value) {
  item_num_additional_.Set(index, value);
}
inline void BattleRepeatReward::add_item_num_additional(::google::protobuf::uint32 value) {
  item_num_additional_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BattleRepeatReward::item_num_additional() const {
  return item_num_additional_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BattleRepeatReward::mutable_item_num_additional() {
  return &item_num_additional_;
}

// optional uint32 ticket_num = 8;
inline bool BattleRepeatReward::has_ticket_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleRepeatReward::set_has_ticket_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleRepeatReward::clear_has_ticket_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleRepeatReward::clear_ticket_num() {
  ticket_num_ = 0u;
  clear_has_ticket_num();
}
inline ::google::protobuf::uint32 BattleRepeatReward::ticket_num() const {
  return ticket_num_;
}
inline void BattleRepeatReward::set_ticket_num(::google::protobuf::uint32 value) {
  set_has_ticket_num();
  ticket_num_ = value;
}

// -------------------------------------------------------------------

// ExitBattle

// required uint32 player_id = 1;
inline bool ExitBattle::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitBattle::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitBattle::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitBattle::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ExitBattle::player_id() const {
  return player_id_;
}
inline void ExitBattle::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// -------------------------------------------------------------------

// NPCTalk

// required uint32 npc_id = 1;
inline bool NPCTalk::has_npc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NPCTalk::set_has_npc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NPCTalk::clear_has_npc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NPCTalk::clear_npc_id() {
  npc_id_ = 0u;
  clear_has_npc_id();
}
inline ::google::protobuf::uint32 NPCTalk::npc_id() const {
  return npc_id_;
}
inline void NPCTalk::set_npc_id(::google::protobuf::uint32 value) {
  set_has_npc_id();
  npc_id_ = value;
}

// -------------------------------------------------------------------

// NPCTalkResult

// repeated uint32 func_type = 1;
inline int NPCTalkResult::func_type_size() const {
  return func_type_.size();
}
inline void NPCTalkResult::clear_func_type() {
  func_type_.Clear();
}
inline ::google::protobuf::uint32 NPCTalkResult::func_type(int index) const {
  return func_type_.Get(index);
}
inline void NPCTalkResult::set_func_type(int index, ::google::protobuf::uint32 value) {
  func_type_.Set(index, value);
}
inline void NPCTalkResult::add_func_type(::google::protobuf::uint32 value) {
  func_type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NPCTalkResult::func_type() const {
  return func_type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NPCTalkResult::mutable_func_type() {
  return &func_type_;
}

// repeated uint32 func_value = 2;
inline int NPCTalkResult::func_value_size() const {
  return func_value_.size();
}
inline void NPCTalkResult::clear_func_value() {
  func_value_.Clear();
}
inline ::google::protobuf::uint32 NPCTalkResult::func_value(int index) const {
  return func_value_.Get(index);
}
inline void NPCTalkResult::set_func_value(int index, ::google::protobuf::uint32 value) {
  func_value_.Set(index, value);
}
inline void NPCTalkResult::add_func_value(::google::protobuf::uint32 value) {
  func_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NPCTalkResult::func_value() const {
  return func_value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NPCTalkResult::mutable_func_value() {
  return &func_value_;
}

// -------------------------------------------------------------------

// NPCFunction

// required uint32 func_type = 1;
inline bool NPCFunction::has_func_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NPCFunction::set_has_func_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NPCFunction::clear_has_func_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NPCFunction::clear_func_type() {
  func_type_ = 0u;
  clear_has_func_type();
}
inline ::google::protobuf::uint32 NPCFunction::func_type() const {
  return func_type_;
}
inline void NPCFunction::set_func_type(::google::protobuf::uint32 value) {
  set_has_func_type();
  func_type_ = value;
}

// required uint32 func_value = 2;
inline bool NPCFunction::has_func_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPCFunction::set_has_func_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NPCFunction::clear_has_func_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NPCFunction::clear_func_value() {
  func_value_ = 0u;
  clear_has_func_value();
}
inline ::google::protobuf::uint32 NPCFunction::func_value() const {
  return func_value_;
}
inline void NPCFunction::set_func_value(::google::protobuf::uint32 value) {
  set_has_func_value();
  func_value_ = value;
}

// -------------------------------------------------------------------

// AddItem

// required uint64 item_only_id = 1;
inline bool AddItem::has_item_only_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddItem::set_has_item_only_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddItem::clear_has_item_only_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddItem::clear_item_only_id() {
  item_only_id_ = GOOGLE_ULONGLONG(0);
  clear_has_item_only_id();
}
inline ::google::protobuf::uint64 AddItem::item_only_id() const {
  return item_only_id_;
}
inline void AddItem::set_item_only_id(::google::protobuf::uint64 value) {
  set_has_item_only_id();
  item_only_id_ = value;
}

// required uint32 item_type = 2;
inline bool AddItem::has_item_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddItem::set_has_item_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddItem::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddItem::clear_item_type() {
  item_type_ = 0u;
  clear_has_item_type();
}
inline ::google::protobuf::uint32 AddItem::item_type() const {
  return item_type_;
}
inline void AddItem::set_item_type(::google::protobuf::uint32 value) {
  set_has_item_type();
  item_type_ = value;
}

// required uint32 item_num = 3;
inline bool AddItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddItem::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 AddItem::item_num() const {
  return item_num_;
}
inline void AddItem::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional uint32 item_upgrade = 4;
inline bool AddItem::has_item_upgrade() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddItem::set_has_item_upgrade() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddItem::clear_has_item_upgrade() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddItem::clear_item_upgrade() {
  item_upgrade_ = 0u;
  clear_has_item_upgrade();
}
inline ::google::protobuf::uint32 AddItem::item_upgrade() const {
  return item_upgrade_;
}
inline void AddItem::set_item_upgrade(::google::protobuf::uint32 value) {
  set_has_item_upgrade();
  item_upgrade_ = value;
}

// repeated uint32 item_hole = 5;
inline int AddItem::item_hole_size() const {
  return item_hole_.size();
}
inline void AddItem::clear_item_hole() {
  item_hole_.Clear();
}
inline ::google::protobuf::uint32 AddItem::item_hole(int index) const {
  return item_hole_.Get(index);
}
inline void AddItem::set_item_hole(int index, ::google::protobuf::uint32 value) {
  item_hole_.Set(index, value);
}
inline void AddItem::add_item_hole(::google::protobuf::uint32 value) {
  item_hole_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AddItem::item_hole() const {
  return item_hole_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AddItem::mutable_item_hole() {
  return &item_hole_;
}

// optional uint32 is_battle = 6;
inline bool AddItem::has_is_battle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddItem::set_has_is_battle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddItem::clear_has_is_battle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddItem::clear_is_battle() {
  is_battle_ = 0u;
  clear_has_is_battle();
}
inline ::google::protobuf::uint32 AddItem::is_battle() const {
  return is_battle_;
}
inline void AddItem::set_is_battle(::google::protobuf::uint32 value) {
  set_has_is_battle();
  is_battle_ = value;
}

// optional uint32 is_equip = 7;
inline bool AddItem::has_is_equip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddItem::set_has_is_equip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddItem::clear_has_is_equip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddItem::clear_is_equip() {
  is_equip_ = 0u;
  clear_has_is_equip();
}
inline ::google::protobuf::uint32 AddItem::is_equip() const {
  return is_equip_;
}
inline void AddItem::set_is_equip(::google::protobuf::uint32 value) {
  set_has_is_equip();
  is_equip_ = value;
}

// -------------------------------------------------------------------

// DeleteItem

// required uint64 item_only_id = 1;
inline bool DeleteItem::has_item_only_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteItem::set_has_item_only_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteItem::clear_has_item_only_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteItem::clear_item_only_id() {
  item_only_id_ = GOOGLE_ULONGLONG(0);
  clear_has_item_only_id();
}
inline ::google::protobuf::uint64 DeleteItem::item_only_id() const {
  return item_only_id_;
}
inline void DeleteItem::set_item_only_id(::google::protobuf::uint64 value) {
  set_has_item_only_id();
  item_only_id_ = value;
}

// required uint32 item_num = 2;
inline bool DeleteItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteItem::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 DeleteItem::item_num() const {
  return item_num_;
}
inline void DeleteItem::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional uint32 is_equip = 3;
inline bool DeleteItem::has_is_equip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteItem::set_has_is_equip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteItem::clear_has_is_equip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteItem::clear_is_equip() {
  is_equip_ = 0u;
  clear_has_is_equip();
}
inline ::google::protobuf::uint32 DeleteItem::is_equip() const {
  return is_equip_;
}
inline void DeleteItem::set_is_equip(::google::protobuf::uint32 value) {
  set_has_is_equip();
  is_equip_ = value;
}

// -------------------------------------------------------------------

// UpdateItem

// required uint64 item_only_id = 1;
inline bool UpdateItem::has_item_only_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateItem::set_has_item_only_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateItem::clear_has_item_only_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateItem::clear_item_only_id() {
  item_only_id_ = GOOGLE_ULONGLONG(0);
  clear_has_item_only_id();
}
inline ::google::protobuf::uint64 UpdateItem::item_only_id() const {
  return item_only_id_;
}
inline void UpdateItem::set_item_only_id(::google::protobuf::uint64 value) {
  set_has_item_only_id();
  item_only_id_ = value;
}

// optional uint32 item_type = 2;
inline bool UpdateItem::has_item_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateItem::set_has_item_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateItem::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateItem::clear_item_type() {
  item_type_ = 0u;
  clear_has_item_type();
}
inline ::google::protobuf::uint32 UpdateItem::item_type() const {
  return item_type_;
}
inline void UpdateItem::set_item_type(::google::protobuf::uint32 value) {
  set_has_item_type();
  item_type_ = value;
}

// optional uint32 item_num = 3;
inline bool UpdateItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateItem::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 UpdateItem::item_num() const {
  return item_num_;
}
inline void UpdateItem::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional uint32 item_upgrade = 4;
inline bool UpdateItem::has_item_upgrade() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateItem::set_has_item_upgrade() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateItem::clear_has_item_upgrade() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateItem::clear_item_upgrade() {
  item_upgrade_ = 0u;
  clear_has_item_upgrade();
}
inline ::google::protobuf::uint32 UpdateItem::item_upgrade() const {
  return item_upgrade_;
}
inline void UpdateItem::set_item_upgrade(::google::protobuf::uint32 value) {
  set_has_item_upgrade();
  item_upgrade_ = value;
}

// repeated uint32 item_hole = 5;
inline int UpdateItem::item_hole_size() const {
  return item_hole_.size();
}
inline void UpdateItem::clear_item_hole() {
  item_hole_.Clear();
}
inline ::google::protobuf::uint32 UpdateItem::item_hole(int index) const {
  return item_hole_.Get(index);
}
inline void UpdateItem::set_item_hole(int index, ::google::protobuf::uint32 value) {
  item_hole_.Set(index, value);
}
inline void UpdateItem::add_item_hole(::google::protobuf::uint32 value) {
  item_hole_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UpdateItem::item_hole() const {
  return item_hole_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UpdateItem::mutable_item_hole() {
  return &item_hole_;
}

// optional uint32 is_equip = 6;
inline bool UpdateItem::has_is_equip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateItem::set_has_is_equip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateItem::clear_has_is_equip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateItem::clear_is_equip() {
  is_equip_ = 0u;
  clear_has_is_equip();
}
inline ::google::protobuf::uint32 UpdateItem::is_equip() const {
  return is_equip_;
}
inline void UpdateItem::set_is_equip(::google::protobuf::uint32 value) {
  set_has_is_equip();
  is_equip_ = value;
}

// -------------------------------------------------------------------

// EquipItem

// required uint64 item_only_id = 1;
inline bool EquipItem::has_item_only_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipItem::set_has_item_only_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipItem::clear_has_item_only_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipItem::clear_item_only_id() {
  item_only_id_ = GOOGLE_ULONGLONG(0);
  clear_has_item_only_id();
}
inline ::google::protobuf::uint64 EquipItem::item_only_id() const {
  return item_only_id_;
}
inline void EquipItem::set_item_only_id(::google::protobuf::uint64 value) {
  set_has_item_only_id();
  item_only_id_ = value;
}

// optional uint32 merc_pos = 2;
inline bool EquipItem::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipItem::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipItem::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipItem::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 EquipItem::merc_pos() const {
  return merc_pos_;
}
inline void EquipItem::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// optional bool is_unequip = 3;
inline bool EquipItem::has_is_unequip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EquipItem::set_has_is_unequip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EquipItem::clear_has_is_unequip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EquipItem::clear_is_unequip() {
  is_unequip_ = false;
  clear_has_is_unequip();
}
inline bool EquipItem::is_unequip() const {
  return is_unequip_;
}
inline void EquipItem::set_is_unequip(bool value) {
  set_has_is_unequip();
  is_unequip_ = value;
}

// optional bool is_dest = 4;
inline bool EquipItem::has_is_dest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EquipItem::set_has_is_dest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EquipItem::clear_has_is_dest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EquipItem::clear_is_dest() {
  is_dest_ = false;
  clear_has_is_dest();
}
inline bool EquipItem::is_dest() const {
  return is_dest_;
}
inline void EquipItem::set_is_dest(bool value) {
  set_has_is_dest();
  is_dest_ = value;
}

// optional uint32 pos = 5;
inline bool EquipItem::has_pos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EquipItem::set_has_pos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EquipItem::clear_has_pos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EquipItem::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 EquipItem::pos() const {
  return pos_;
}
inline void EquipItem::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// UseItem

// required uint64 item_only_id = 1;
inline bool UseItem::has_item_only_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UseItem::set_has_item_only_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UseItem::clear_has_item_only_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UseItem::clear_item_only_id() {
  item_only_id_ = GOOGLE_ULONGLONG(0);
  clear_has_item_only_id();
}
inline ::google::protobuf::uint64 UseItem::item_only_id() const {
  return item_only_id_;
}
inline void UseItem::set_item_only_id(::google::protobuf::uint64 value) {
  set_has_item_only_id();
  item_only_id_ = value;
}

// optional uint32 merc_pos = 2;
inline bool UseItem::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UseItem::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UseItem::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UseItem::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 UseItem::merc_pos() const {
  return merc_pos_;
}
inline void UseItem::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// optional uint32 item_num = 3;
inline bool UseItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UseItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UseItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UseItem::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 UseItem::item_num() const {
  return item_num_;
}
inline void UseItem::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// -------------------------------------------------------------------

// OtherEquipItem

// required uint32 player_id = 1;
inline bool OtherEquipItem::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtherEquipItem::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtherEquipItem::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtherEquipItem::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 OtherEquipItem::player_id() const {
  return player_id_;
}
inline void OtherEquipItem::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// required uint32 item_type = 2;
inline bool OtherEquipItem::has_item_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtherEquipItem::set_has_item_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtherEquipItem::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtherEquipItem::clear_item_type() {
  item_type_ = 0u;
  clear_has_item_type();
}
inline ::google::protobuf::uint32 OtherEquipItem::item_type() const {
  return item_type_;
}
inline void OtherEquipItem::set_item_type(::google::protobuf::uint32 value) {
  set_has_item_type();
  item_type_ = value;
}

// optional bool is_unequip = 3;
inline bool OtherEquipItem::has_is_unequip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OtherEquipItem::set_has_is_unequip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OtherEquipItem::clear_has_is_unequip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OtherEquipItem::clear_is_unequip() {
  is_unequip_ = false;
  clear_has_is_unequip();
}
inline bool OtherEquipItem::is_unequip() const {
  return is_unequip_;
}
inline void OtherEquipItem::set_is_unequip(bool value) {
  set_has_is_unequip();
  is_unequip_ = value;
}

// -------------------------------------------------------------------

// ChangeAttr

// repeated uint32 attr_type = 1;
inline int ChangeAttr::attr_type_size() const {
  return attr_type_.size();
}
inline void ChangeAttr::clear_attr_type() {
  attr_type_.Clear();
}
inline ::google::protobuf::uint32 ChangeAttr::attr_type(int index) const {
  return attr_type_.Get(index);
}
inline void ChangeAttr::set_attr_type(int index, ::google::protobuf::uint32 value) {
  attr_type_.Set(index, value);
}
inline void ChangeAttr::add_attr_type(::google::protobuf::uint32 value) {
  attr_type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChangeAttr::attr_type() const {
  return attr_type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChangeAttr::mutable_attr_type() {
  return &attr_type_;
}

// repeated uint32 attr_value = 2;
inline int ChangeAttr::attr_value_size() const {
  return attr_value_.size();
}
inline void ChangeAttr::clear_attr_value() {
  attr_value_.Clear();
}
inline ::google::protobuf::uint32 ChangeAttr::attr_value(int index) const {
  return attr_value_.Get(index);
}
inline void ChangeAttr::set_attr_value(int index, ::google::protobuf::uint32 value) {
  attr_value_.Set(index, value);
}
inline void ChangeAttr::add_attr_value(::google::protobuf::uint32 value) {
  attr_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChangeAttr::attr_value() const {
  return attr_value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChangeAttr::mutable_attr_value() {
  return &attr_value_;
}

// optional uint32 attr_value_type = 3;
inline bool ChangeAttr::has_attr_value_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeAttr::set_has_attr_value_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeAttr::clear_has_attr_value_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeAttr::clear_attr_value_type() {
  attr_value_type_ = 0u;
  clear_has_attr_value_type();
}
inline ::google::protobuf::uint32 ChangeAttr::attr_value_type() const {
  return attr_value_type_;
}
inline void ChangeAttr::set_attr_value_type(::google::protobuf::uint32 value) {
  set_has_attr_value_type();
  attr_value_type_ = value;
}

// optional uint32 merc_pos = 4;
inline bool ChangeAttr::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeAttr::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeAttr::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeAttr::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 ChangeAttr::merc_pos() const {
  return merc_pos_;
}
inline void ChangeAttr::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// optional uint32 is_battle = 5;
inline bool ChangeAttr::has_is_battle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeAttr::set_has_is_battle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeAttr::clear_has_is_battle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeAttr::clear_is_battle() {
  is_battle_ = 0u;
  clear_has_is_battle();
}
inline ::google::protobuf::uint32 ChangeAttr::is_battle() const {
  return is_battle_;
}
inline void ChangeAttr::set_is_battle(::google::protobuf::uint32 value) {
  set_has_is_battle();
  is_battle_ = value;
}

// repeated uint32 cost_channel = 6;
inline int ChangeAttr::cost_channel_size() const {
  return cost_channel_.size();
}
inline void ChangeAttr::clear_cost_channel() {
  cost_channel_.Clear();
}
inline ::google::protobuf::uint32 ChangeAttr::cost_channel(int index) const {
  return cost_channel_.Get(index);
}
inline void ChangeAttr::set_cost_channel(int index, ::google::protobuf::uint32 value) {
  cost_channel_.Set(index, value);
}
inline void ChangeAttr::add_cost_channel(::google::protobuf::uint32 value) {
  cost_channel_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChangeAttr::cost_channel() const {
  return cost_channel_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChangeAttr::mutable_cost_channel() {
  return &cost_channel_;
}

// -------------------------------------------------------------------

// ChangeTask

// repeated uint32 task_var = 1;
inline int ChangeTask::task_var_size() const {
  return task_var_.size();
}
inline void ChangeTask::clear_task_var() {
  task_var_.Clear();
}
inline ::google::protobuf::uint32 ChangeTask::task_var(int index) const {
  return task_var_.Get(index);
}
inline void ChangeTask::set_task_var(int index, ::google::protobuf::uint32 value) {
  task_var_.Set(index, value);
}
inline void ChangeTask::add_task_var(::google::protobuf::uint32 value) {
  task_var_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChangeTask::task_var() const {
  return task_var_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChangeTask::mutable_task_var() {
  return &task_var_;
}

// repeated uint32 task_value = 2;
inline int ChangeTask::task_value_size() const {
  return task_value_.size();
}
inline void ChangeTask::clear_task_value() {
  task_value_.Clear();
}
inline ::google::protobuf::uint32 ChangeTask::task_value(int index) const {
  return task_value_.Get(index);
}
inline void ChangeTask::set_task_value(int index, ::google::protobuf::uint32 value) {
  task_value_.Set(index, value);
}
inline void ChangeTask::add_task_value(::google::protobuf::uint32 value) {
  task_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChangeTask::task_value() const {
  return task_value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChangeTask::mutable_task_value() {
  return &task_value_;
}

// -------------------------------------------------------------------

// CheckTime

// required uint32 month = 1;
inline bool CheckTime::has_month() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckTime::set_has_month() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckTime::clear_has_month() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckTime::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 CheckTime::month() const {
  return month_;
}
inline void CheckTime::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
}

// required uint32 day = 2;
inline bool CheckTime::has_day() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckTime::set_has_day() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckTime::clear_has_day() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckTime::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 CheckTime::day() const {
  return day_;
}
inline void CheckTime::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// required uint32 hour = 3;
inline bool CheckTime::has_hour() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckTime::set_has_hour() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckTime::clear_has_hour() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckTime::clear_hour() {
  hour_ = 0u;
  clear_has_hour();
}
inline ::google::protobuf::uint32 CheckTime::hour() const {
  return hour_;
}
inline void CheckTime::set_hour(::google::protobuf::uint32 value) {
  set_has_hour();
  hour_ = value;
}

// required uint32 minute = 4;
inline bool CheckTime::has_minute() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckTime::set_has_minute() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckTime::clear_has_minute() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckTime::clear_minute() {
  minute_ = 0u;
  clear_has_minute();
}
inline ::google::protobuf::uint32 CheckTime::minute() const {
  return minute_;
}
inline void CheckTime::set_minute(::google::protobuf::uint32 value) {
  set_has_minute();
  minute_ = value;
}

// required uint32 second = 5;
inline bool CheckTime::has_second() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckTime::set_has_second() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckTime::clear_has_second() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckTime::clear_second() {
  second_ = 0u;
  clear_has_second();
}
inline ::google::protobuf::uint32 CheckTime::second() const {
  return second_;
}
inline void CheckTime::set_second(::google::protobuf::uint32 value) {
  set_has_second();
  second_ = value;
}

// -------------------------------------------------------------------

// MercenaryGet

// required uint32 merc_card = 1;
inline bool MercenaryGet::has_merc_card() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MercenaryGet::set_has_merc_card() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MercenaryGet::clear_has_merc_card() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MercenaryGet::clear_merc_card() {
  merc_card_ = 0u;
  clear_has_merc_card();
}
inline ::google::protobuf::uint32 MercenaryGet::merc_card() const {
  return merc_card_;
}
inline void MercenaryGet::set_merc_card(::google::protobuf::uint32 value) {
  set_has_merc_card();
  merc_card_ = value;
}

// -------------------------------------------------------------------

// MercenaryCardGet

// required uint32 merc_card = 1;
inline bool MercenaryCardGet::has_merc_card() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MercenaryCardGet::set_has_merc_card() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MercenaryCardGet::clear_has_merc_card() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MercenaryCardGet::clear_merc_card() {
  merc_card_ = 0u;
  clear_has_merc_card();
}
inline ::google::protobuf::uint32 MercenaryCardGet::merc_card() const {
  return merc_card_;
}
inline void MercenaryCardGet::set_merc_card(::google::protobuf::uint32 value) {
  set_has_merc_card();
  merc_card_ = value;
}

// -------------------------------------------------------------------

// MercenaryCardGetResult

// required uint32 oper_result = 1;
inline bool MercenaryCardGetResult::has_oper_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MercenaryCardGetResult::set_has_oper_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MercenaryCardGetResult::clear_has_oper_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MercenaryCardGetResult::clear_oper_result() {
  oper_result_ = 0u;
  clear_has_oper_result();
}
inline ::google::protobuf::uint32 MercenaryCardGetResult::oper_result() const {
  return oper_result_;
}
inline void MercenaryCardGetResult::set_oper_result(::google::protobuf::uint32 value) {
  set_has_oper_result();
  oper_result_ = value;
}

// required uint32 merc_card = 2;
inline bool MercenaryCardGetResult::has_merc_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MercenaryCardGetResult::set_has_merc_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MercenaryCardGetResult::clear_has_merc_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MercenaryCardGetResult::clear_merc_card() {
  merc_card_ = 0u;
  clear_has_merc_card();
}
inline ::google::protobuf::uint32 MercenaryCardGetResult::merc_card() const {
  return merc_card_;
}
inline void MercenaryCardGetResult::set_merc_card(::google::protobuf::uint32 value) {
  set_has_merc_card();
  merc_card_ = value;
}

// required uint32 merc_id = 3;
inline bool MercenaryCardGetResult::has_merc_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MercenaryCardGetResult::set_has_merc_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MercenaryCardGetResult::clear_has_merc_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MercenaryCardGetResult::clear_merc_id() {
  merc_id_ = 0u;
  clear_has_merc_id();
}
inline ::google::protobuf::uint32 MercenaryCardGetResult::merc_id() const {
  return merc_id_;
}
inline void MercenaryCardGetResult::set_merc_id(::google::protobuf::uint32 value) {
  set_has_merc_id();
  merc_id_ = value;
}

// required uint32 merc_chip_now = 4;
inline bool MercenaryCardGetResult::has_merc_chip_now() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MercenaryCardGetResult::set_has_merc_chip_now() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MercenaryCardGetResult::clear_has_merc_chip_now() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MercenaryCardGetResult::clear_merc_chip_now() {
  merc_chip_now_ = 0u;
  clear_has_merc_chip_now();
}
inline ::google::protobuf::uint32 MercenaryCardGetResult::merc_chip_now() const {
  return merc_chip_now_;
}
inline void MercenaryCardGetResult::set_merc_chip_now(::google::protobuf::uint32 value) {
  set_has_merc_chip_now();
  merc_chip_now_ = value;
}

// required uint32 merc_chip_max = 5;
inline bool MercenaryCardGetResult::has_merc_chip_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MercenaryCardGetResult::set_has_merc_chip_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MercenaryCardGetResult::clear_has_merc_chip_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MercenaryCardGetResult::clear_merc_chip_max() {
  merc_chip_max_ = 0u;
  clear_has_merc_chip_max();
}
inline ::google::protobuf::uint32 MercenaryCardGetResult::merc_chip_max() const {
  return merc_chip_max_;
}
inline void MercenaryCardGetResult::set_merc_chip_max(::google::protobuf::uint32 value) {
  set_has_merc_chip_max();
  merc_chip_max_ = value;
}

// required uint32 free_merc = 6;
inline bool MercenaryCardGetResult::has_free_merc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MercenaryCardGetResult::set_has_free_merc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MercenaryCardGetResult::clear_has_free_merc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MercenaryCardGetResult::clear_free_merc() {
  free_merc_ = 0u;
  clear_has_free_merc();
}
inline ::google::protobuf::uint32 MercenaryCardGetResult::free_merc() const {
  return free_merc_;
}
inline void MercenaryCardGetResult::set_free_merc(::google::protobuf::uint32 value) {
  set_has_free_merc();
  free_merc_ = value;
}

// required uint32 free_chip = 7;
inline bool MercenaryCardGetResult::has_free_chip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MercenaryCardGetResult::set_has_free_chip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MercenaryCardGetResult::clear_has_free_chip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MercenaryCardGetResult::clear_free_chip() {
  free_chip_ = 0u;
  clear_has_free_chip();
}
inline ::google::protobuf::uint32 MercenaryCardGetResult::free_chip() const {
  return free_chip_;
}
inline void MercenaryCardGetResult::set_free_chip(::google::protobuf::uint32 value) {
  set_has_free_chip();
  free_chip_ = value;
}

// -------------------------------------------------------------------

// MercenaryAttrAdd

// required uint32 merc_pos = 1;
inline bool MercenaryAttrAdd::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MercenaryAttrAdd::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MercenaryAttrAdd::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MercenaryAttrAdd::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 MercenaryAttrAdd::merc_pos() const {
  return merc_pos_;
}
inline void MercenaryAttrAdd::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// required uint32 attr_type = 2;
inline bool MercenaryAttrAdd::has_attr_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MercenaryAttrAdd::set_has_attr_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MercenaryAttrAdd::clear_has_attr_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MercenaryAttrAdd::clear_attr_type() {
  attr_type_ = 0u;
  clear_has_attr_type();
}
inline ::google::protobuf::uint32 MercenaryAttrAdd::attr_type() const {
  return attr_type_;
}
inline void MercenaryAttrAdd::set_attr_type(::google::protobuf::uint32 value) {
  set_has_attr_type();
  attr_type_ = value;
}

// required uint32 attr_value = 3;
inline bool MercenaryAttrAdd::has_attr_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MercenaryAttrAdd::set_has_attr_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MercenaryAttrAdd::clear_has_attr_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MercenaryAttrAdd::clear_attr_value() {
  attr_value_ = 0u;
  clear_has_attr_value();
}
inline ::google::protobuf::uint32 MercenaryAttrAdd::attr_value() const {
  return attr_value_;
}
inline void MercenaryAttrAdd::set_attr_value(::google::protobuf::uint32 value) {
  set_has_attr_value();
  attr_value_ = value;
}

// -------------------------------------------------------------------

// MercenaryToExp

// required uint32 merc_from_pos = 1;
inline bool MercenaryToExp::has_merc_from_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MercenaryToExp::set_has_merc_from_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MercenaryToExp::clear_has_merc_from_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MercenaryToExp::clear_merc_from_pos() {
  merc_from_pos_ = 0u;
  clear_has_merc_from_pos();
}
inline ::google::protobuf::uint32 MercenaryToExp::merc_from_pos() const {
  return merc_from_pos_;
}
inline void MercenaryToExp::set_merc_from_pos(::google::protobuf::uint32 value) {
  set_has_merc_from_pos();
  merc_from_pos_ = value;
}

// required uint32 merc_to_pos = 2;
inline bool MercenaryToExp::has_merc_to_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MercenaryToExp::set_has_merc_to_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MercenaryToExp::clear_has_merc_to_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MercenaryToExp::clear_merc_to_pos() {
  merc_to_pos_ = 0u;
  clear_has_merc_to_pos();
}
inline ::google::protobuf::uint32 MercenaryToExp::merc_to_pos() const {
  return merc_to_pos_;
}
inline void MercenaryToExp::set_merc_to_pos(::google::protobuf::uint32 value) {
  set_has_merc_to_pos();
  merc_to_pos_ = value;
}

// optional uint32 is_cost_money = 3;
inline bool MercenaryToExp::has_is_cost_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MercenaryToExp::set_has_is_cost_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MercenaryToExp::clear_has_is_cost_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MercenaryToExp::clear_is_cost_money() {
  is_cost_money_ = 0u;
  clear_has_is_cost_money();
}
inline ::google::protobuf::uint32 MercenaryToExp::is_cost_money() const {
  return is_cost_money_;
}
inline void MercenaryToExp::set_is_cost_money(::google::protobuf::uint32 value) {
  set_has_is_cost_money();
  is_cost_money_ = value;
}

// -------------------------------------------------------------------

// AddMercenary

// required uint32 merc_pos = 1;
inline bool AddMercenary::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddMercenary::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddMercenary::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddMercenary::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 AddMercenary::merc_pos() const {
  return merc_pos_;
}
inline void AddMercenary::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// repeated bytes merc_data = 2;
inline int AddMercenary::merc_data_size() const {
  return merc_data_.size();
}
inline void AddMercenary::clear_merc_data() {
  merc_data_.Clear();
}
inline const ::std::string& AddMercenary::merc_data(int index) const {
  return merc_data_.Get(index);
}
inline ::std::string* AddMercenary::mutable_merc_data(int index) {
  return merc_data_.Mutable(index);
}
inline void AddMercenary::set_merc_data(int index, const ::std::string& value) {
  merc_data_.Mutable(index)->assign(value);
}
inline void AddMercenary::set_merc_data(int index, const char* value) {
  merc_data_.Mutable(index)->assign(value);
}
inline void AddMercenary::set_merc_data(int index, const void* value, size_t size) {
  merc_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddMercenary::add_merc_data() {
  return merc_data_.Add();
}
inline void AddMercenary::add_merc_data(const ::std::string& value) {
  merc_data_.Add()->assign(value);
}
inline void AddMercenary::add_merc_data(const char* value) {
  merc_data_.Add()->assign(value);
}
inline void AddMercenary::add_merc_data(const void* value, size_t size) {
  merc_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AddMercenary::merc_data() const {
  return merc_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AddMercenary::mutable_merc_data() {
  return &merc_data_;
}

// -------------------------------------------------------------------

// UpdateMercenary

// required uint32 merc_pos = 1;
inline bool UpdateMercenary::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateMercenary::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateMercenary::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateMercenary::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 UpdateMercenary::merc_pos() const {
  return merc_pos_;
}
inline void UpdateMercenary::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// repeated bytes merc_data = 2;
inline int UpdateMercenary::merc_data_size() const {
  return merc_data_.size();
}
inline void UpdateMercenary::clear_merc_data() {
  merc_data_.Clear();
}
inline const ::std::string& UpdateMercenary::merc_data(int index) const {
  return merc_data_.Get(index);
}
inline ::std::string* UpdateMercenary::mutable_merc_data(int index) {
  return merc_data_.Mutable(index);
}
inline void UpdateMercenary::set_merc_data(int index, const ::std::string& value) {
  merc_data_.Mutable(index)->assign(value);
}
inline void UpdateMercenary::set_merc_data(int index, const char* value) {
  merc_data_.Mutable(index)->assign(value);
}
inline void UpdateMercenary::set_merc_data(int index, const void* value, size_t size) {
  merc_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateMercenary::add_merc_data() {
  return merc_data_.Add();
}
inline void UpdateMercenary::add_merc_data(const ::std::string& value) {
  merc_data_.Add()->assign(value);
}
inline void UpdateMercenary::add_merc_data(const char* value) {
  merc_data_.Add()->assign(value);
}
inline void UpdateMercenary::add_merc_data(const void* value, size_t size) {
  merc_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UpdateMercenary::merc_data() const {
  return merc_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UpdateMercenary::mutable_merc_data() {
  return &merc_data_;
}

// -------------------------------------------------------------------

// MercenaryDel

// required uint32 merc_pos = 1;
inline bool MercenaryDel::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MercenaryDel::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MercenaryDel::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MercenaryDel::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 MercenaryDel::merc_pos() const {
  return merc_pos_;
}
inline void MercenaryDel::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// -------------------------------------------------------------------

// AddCharBuff

// required uint32 buff_id = 1;
inline bool AddCharBuff::has_buff_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddCharBuff::set_has_buff_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddCharBuff::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddCharBuff::clear_buff_id() {
  buff_id_ = 0u;
  clear_has_buff_id();
}
inline ::google::protobuf::uint32 AddCharBuff::buff_id() const {
  return buff_id_;
}
inline void AddCharBuff::set_buff_id(::google::protobuf::uint32 value) {
  set_has_buff_id();
  buff_id_ = value;
}

// optional uint32 buff_value = 2;
inline bool AddCharBuff::has_buff_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddCharBuff::set_has_buff_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddCharBuff::clear_has_buff_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddCharBuff::clear_buff_value() {
  buff_value_ = 0u;
  clear_has_buff_value();
}
inline ::google::protobuf::uint32 AddCharBuff::buff_value() const {
  return buff_value_;
}
inline void AddCharBuff::set_buff_value(::google::protobuf::uint32 value) {
  set_has_buff_value();
  buff_value_ = value;
}

// -------------------------------------------------------------------

// DelCharBuff

// required uint32 buff_id = 1;
inline bool DelCharBuff::has_buff_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelCharBuff::set_has_buff_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelCharBuff::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelCharBuff::clear_buff_id() {
  buff_id_ = 0u;
  clear_has_buff_id();
}
inline ::google::protobuf::uint32 DelCharBuff::buff_id() const {
  return buff_id_;
}
inline void DelCharBuff::set_buff_id(::google::protobuf::uint32 value) {
  set_has_buff_id();
  buff_id_ = value;
}

// -------------------------------------------------------------------

// Chat

// required uint32 chat_type = 1;
inline bool Chat::has_chat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Chat::set_has_chat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Chat::clear_has_chat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Chat::clear_chat_type() {
  chat_type_ = 0u;
  clear_has_chat_type();
}
inline ::google::protobuf::uint32 Chat::chat_type() const {
  return chat_type_;
}
inline void Chat::set_chat_type(::google::protobuf::uint32 value) {
  set_has_chat_type();
  chat_type_ = value;
}

// repeated bytes chat_data = 2;
inline int Chat::chat_data_size() const {
  return chat_data_.size();
}
inline void Chat::clear_chat_data() {
  chat_data_.Clear();
}
inline const ::std::string& Chat::chat_data(int index) const {
  return chat_data_.Get(index);
}
inline ::std::string* Chat::mutable_chat_data(int index) {
  return chat_data_.Mutable(index);
}
inline void Chat::set_chat_data(int index, const ::std::string& value) {
  chat_data_.Mutable(index)->assign(value);
}
inline void Chat::set_chat_data(int index, const char* value) {
  chat_data_.Mutable(index)->assign(value);
}
inline void Chat::set_chat_data(int index, const void* value, size_t size) {
  chat_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::add_chat_data() {
  return chat_data_.Add();
}
inline void Chat::add_chat_data(const ::std::string& value) {
  chat_data_.Add()->assign(value);
}
inline void Chat::add_chat_data(const char* value) {
  chat_data_.Add()->assign(value);
}
inline void Chat::add_chat_data(const void* value, size_t size) {
  chat_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chat::chat_data() const {
  return chat_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chat::mutable_chat_data() {
  return &chat_data_;
}

// repeated bytes from_name = 3;
inline int Chat::from_name_size() const {
  return from_name_.size();
}
inline void Chat::clear_from_name() {
  from_name_.Clear();
}
inline const ::std::string& Chat::from_name(int index) const {
  return from_name_.Get(index);
}
inline ::std::string* Chat::mutable_from_name(int index) {
  return from_name_.Mutable(index);
}
inline void Chat::set_from_name(int index, const ::std::string& value) {
  from_name_.Mutable(index)->assign(value);
}
inline void Chat::set_from_name(int index, const char* value) {
  from_name_.Mutable(index)->assign(value);
}
inline void Chat::set_from_name(int index, const void* value, size_t size) {
  from_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::add_from_name() {
  return from_name_.Add();
}
inline void Chat::add_from_name(const ::std::string& value) {
  from_name_.Add()->assign(value);
}
inline void Chat::add_from_name(const char* value) {
  from_name_.Add()->assign(value);
}
inline void Chat::add_from_name(const void* value, size_t size) {
  from_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chat::from_name() const {
  return from_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chat::mutable_from_name() {
  return &from_name_;
}

// repeated bytes to_name = 4;
inline int Chat::to_name_size() const {
  return to_name_.size();
}
inline void Chat::clear_to_name() {
  to_name_.Clear();
}
inline const ::std::string& Chat::to_name(int index) const {
  return to_name_.Get(index);
}
inline ::std::string* Chat::mutable_to_name(int index) {
  return to_name_.Mutable(index);
}
inline void Chat::set_to_name(int index, const ::std::string& value) {
  to_name_.Mutable(index)->assign(value);
}
inline void Chat::set_to_name(int index, const char* value) {
  to_name_.Mutable(index)->assign(value);
}
inline void Chat::set_to_name(int index, const void* value, size_t size) {
  to_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::add_to_name() {
  return to_name_.Add();
}
inline void Chat::add_to_name(const ::std::string& value) {
  to_name_.Add()->assign(value);
}
inline void Chat::add_to_name(const char* value) {
  to_name_.Add()->assign(value);
}
inline void Chat::add_to_name(const void* value, size_t size) {
  to_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chat::to_name() const {
  return to_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chat::mutable_to_name() {
  return &to_name_;
}

// repeated bytes item_info = 5;
inline int Chat::item_info_size() const {
  return item_info_.size();
}
inline void Chat::clear_item_info() {
  item_info_.Clear();
}
inline const ::std::string& Chat::item_info(int index) const {
  return item_info_.Get(index);
}
inline ::std::string* Chat::mutable_item_info(int index) {
  return item_info_.Mutable(index);
}
inline void Chat::set_item_info(int index, const ::std::string& value) {
  item_info_.Mutable(index)->assign(value);
}
inline void Chat::set_item_info(int index, const char* value) {
  item_info_.Mutable(index)->assign(value);
}
inline void Chat::set_item_info(int index, const void* value, size_t size) {
  item_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::add_item_info() {
  return item_info_.Add();
}
inline void Chat::add_item_info(const ::std::string& value) {
  item_info_.Add()->assign(value);
}
inline void Chat::add_item_info(const char* value) {
  item_info_.Add()->assign(value);
}
inline void Chat::add_item_info(const void* value, size_t size) {
  item_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chat::item_info() const {
  return item_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chat::mutable_item_info() {
  return &item_info_;
}

// repeated bytes equip_info = 6;
inline int Chat::equip_info_size() const {
  return equip_info_.size();
}
inline void Chat::clear_equip_info() {
  equip_info_.Clear();
}
inline const ::std::string& Chat::equip_info(int index) const {
  return equip_info_.Get(index);
}
inline ::std::string* Chat::mutable_equip_info(int index) {
  return equip_info_.Mutable(index);
}
inline void Chat::set_equip_info(int index, const ::std::string& value) {
  equip_info_.Mutable(index)->assign(value);
}
inline void Chat::set_equip_info(int index, const char* value) {
  equip_info_.Mutable(index)->assign(value);
}
inline void Chat::set_equip_info(int index, const void* value, size_t size) {
  equip_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::add_equip_info() {
  return equip_info_.Add();
}
inline void Chat::add_equip_info(const ::std::string& value) {
  equip_info_.Add()->assign(value);
}
inline void Chat::add_equip_info(const char* value) {
  equip_info_.Add()->assign(value);
}
inline void Chat::add_equip_info(const void* value, size_t size) {
  equip_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chat::equip_info() const {
  return equip_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chat::mutable_equip_info() {
  return &equip_info_;
}

// repeated bytes role_info = 7;
inline int Chat::role_info_size() const {
  return role_info_.size();
}
inline void Chat::clear_role_info() {
  role_info_.Clear();
}
inline const ::std::string& Chat::role_info(int index) const {
  return role_info_.Get(index);
}
inline ::std::string* Chat::mutable_role_info(int index) {
  return role_info_.Mutable(index);
}
inline void Chat::set_role_info(int index, const ::std::string& value) {
  role_info_.Mutable(index)->assign(value);
}
inline void Chat::set_role_info(int index, const char* value) {
  role_info_.Mutable(index)->assign(value);
}
inline void Chat::set_role_info(int index, const void* value, size_t size) {
  role_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::add_role_info() {
  return role_info_.Add();
}
inline void Chat::add_role_info(const ::std::string& value) {
  role_info_.Add()->assign(value);
}
inline void Chat::add_role_info(const char* value) {
  role_info_.Add()->assign(value);
}
inline void Chat::add_role_info(const void* value, size_t size) {
  role_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chat::role_info() const {
  return role_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chat::mutable_role_info() {
  return &role_info_;
}

// repeated bytes merc_info = 8;
inline int Chat::merc_info_size() const {
  return merc_info_.size();
}
inline void Chat::clear_merc_info() {
  merc_info_.Clear();
}
inline const ::std::string& Chat::merc_info(int index) const {
  return merc_info_.Get(index);
}
inline ::std::string* Chat::mutable_merc_info(int index) {
  return merc_info_.Mutable(index);
}
inline void Chat::set_merc_info(int index, const ::std::string& value) {
  merc_info_.Mutable(index)->assign(value);
}
inline void Chat::set_merc_info(int index, const char* value) {
  merc_info_.Mutable(index)->assign(value);
}
inline void Chat::set_merc_info(int index, const void* value, size_t size) {
  merc_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::add_merc_info() {
  return merc_info_.Add();
}
inline void Chat::add_merc_info(const ::std::string& value) {
  merc_info_.Add()->assign(value);
}
inline void Chat::add_merc_info(const char* value) {
  merc_info_.Add()->assign(value);
}
inline void Chat::add_merc_info(const void* value, size_t size) {
  merc_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chat::merc_info() const {
  return merc_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chat::mutable_merc_info() {
  return &merc_info_;
}

// optional uint32 sex = 9;
inline bool Chat::has_sex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Chat::set_has_sex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Chat::clear_has_sex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Chat::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 Chat::sex() const {
  return sex_;
}
inline void Chat::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 vip_lv = 10;
inline bool Chat::has_vip_lv() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Chat::set_has_vip_lv() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Chat::clear_has_vip_lv() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Chat::clear_vip_lv() {
  vip_lv_ = 0u;
  clear_has_vip_lv();
}
inline ::google::protobuf::uint32 Chat::vip_lv() const {
  return vip_lv_;
}
inline void Chat::set_vip_lv(::google::protobuf::uint32 value) {
  set_has_vip_lv();
  vip_lv_ = value;
}

// optional uint32 notice_type = 11;
inline bool Chat::has_notice_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Chat::set_has_notice_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Chat::clear_has_notice_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Chat::clear_notice_type() {
  notice_type_ = 0u;
  clear_has_notice_type();
}
inline ::google::protobuf::uint32 Chat::notice_type() const {
  return notice_type_;
}
inline void Chat::set_notice_type(::google::protobuf::uint32 value) {
  set_has_notice_type();
  notice_type_ = value;
}

// optional uint32 server_id = 12;
inline bool Chat::has_server_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Chat::set_has_server_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Chat::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Chat::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 Chat::server_id() const {
  return server_id_;
}
inline void Chat::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// -------------------------------------------------------------------

// ChangeRemainVar

// required uint32 remain_type = 1;
inline bool ChangeRemainVar::has_remain_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeRemainVar::set_has_remain_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeRemainVar::clear_has_remain_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeRemainVar::clear_remain_type() {
  remain_type_ = 0u;
  clear_has_remain_type();
}
inline ::google::protobuf::uint32 ChangeRemainVar::remain_type() const {
  return remain_type_;
}
inline void ChangeRemainVar::set_remain_type(::google::protobuf::uint32 value) {
  set_has_remain_type();
  remain_type_ = value;
}

// required uint32 remain_value = 2;
inline bool ChangeRemainVar::has_remain_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeRemainVar::set_has_remain_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeRemainVar::clear_has_remain_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeRemainVar::clear_remain_value() {
  remain_value_ = 0u;
  clear_has_remain_value();
}
inline ::google::protobuf::uint32 ChangeRemainVar::remain_value() const {
  return remain_value_;
}
inline void ChangeRemainVar::set_remain_value(::google::protobuf::uint32 value) {
  set_has_remain_value();
  remain_value_ = value;
}

// -------------------------------------------------------------------

// ChangeClientData

// repeated bytes clie_data = 1;
inline int ChangeClientData::clie_data_size() const {
  return clie_data_.size();
}
inline void ChangeClientData::clear_clie_data() {
  clie_data_.Clear();
}
inline const ::std::string& ChangeClientData::clie_data(int index) const {
  return clie_data_.Get(index);
}
inline ::std::string* ChangeClientData::mutable_clie_data(int index) {
  return clie_data_.Mutable(index);
}
inline void ChangeClientData::set_clie_data(int index, const ::std::string& value) {
  clie_data_.Mutable(index)->assign(value);
}
inline void ChangeClientData::set_clie_data(int index, const char* value) {
  clie_data_.Mutable(index)->assign(value);
}
inline void ChangeClientData::set_clie_data(int index, const void* value, size_t size) {
  clie_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeClientData::add_clie_data() {
  return clie_data_.Add();
}
inline void ChangeClientData::add_clie_data(const ::std::string& value) {
  clie_data_.Add()->assign(value);
}
inline void ChangeClientData::add_clie_data(const char* value) {
  clie_data_.Add()->assign(value);
}
inline void ChangeClientData::add_clie_data(const void* value, size_t size) {
  clie_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChangeClientData::clie_data() const {
  return clie_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChangeClientData::mutable_clie_data() {
  return &clie_data_;
}

// -------------------------------------------------------------------

// ReqFriendData

// required uint32 char_id = 1;
inline bool ReqFriendData::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqFriendData::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqFriendData::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqFriendData::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 ReqFriendData::char_id() const {
  return char_id_;
}
inline void ReqFriendData::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// AckFriendData_DBFriendInfo

// required uint32 char_id = 1;
inline bool AckFriendData_DBFriendInfo::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFriendData_DBFriendInfo::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFriendData_DBFriendInfo::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 AckFriendData_DBFriendInfo::char_id() const {
  return char_id_;
}
inline void AckFriendData_DBFriendInfo::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required uint32 target_char_id = 2;
inline bool AckFriendData_DBFriendInfo::has_target_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_target_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckFriendData_DBFriendInfo::clear_has_target_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckFriendData_DBFriendInfo::clear_target_char_id() {
  target_char_id_ = 0u;
  clear_has_target_char_id();
}
inline ::google::protobuf::uint32 AckFriendData_DBFriendInfo::target_char_id() const {
  return target_char_id_;
}
inline void AckFriendData_DBFriendInfo::set_target_char_id(::google::protobuf::uint32 value) {
  set_has_target_char_id();
  target_char_id_ = value;
}

// required bytes target_char_name = 3;
inline bool AckFriendData_DBFriendInfo::has_target_char_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_target_char_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckFriendData_DBFriendInfo::clear_has_target_char_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckFriendData_DBFriendInfo::clear_target_char_name() {
  if (target_char_name_ != &::google::protobuf::internal::kEmptyString) {
    target_char_name_->clear();
  }
  clear_has_target_char_name();
}
inline const ::std::string& AckFriendData_DBFriendInfo::target_char_name() const {
  return *target_char_name_;
}
inline void AckFriendData_DBFriendInfo::set_target_char_name(const ::std::string& value) {
  set_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    target_char_name_ = new ::std::string;
  }
  target_char_name_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_target_char_name(const char* value) {
  set_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    target_char_name_ = new ::std::string;
  }
  target_char_name_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_target_char_name(const void* value, size_t size) {
  set_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    target_char_name_ = new ::std::string;
  }
  target_char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFriendData_DBFriendInfo::mutable_target_char_name() {
  set_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    target_char_name_ = new ::std::string;
  }
  return target_char_name_;
}
inline ::std::string* AckFriendData_DBFriendInfo::release_target_char_name() {
  clear_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_char_name_;
    target_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckFriendData_DBFriendInfo::set_allocated_target_char_name(::std::string* target_char_name) {
  if (target_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_char_name_;
  }
  if (target_char_name) {
    set_has_target_char_name();
    target_char_name_ = target_char_name;
  } else {
    clear_has_target_char_name();
    target_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 friend_type = 4;
inline bool AckFriendData_DBFriendInfo::has_friend_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_friend_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckFriendData_DBFriendInfo::clear_has_friend_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckFriendData_DBFriendInfo::clear_friend_type() {
  friend_type_ = 0u;
  clear_has_friend_type();
}
inline ::google::protobuf::uint32 AckFriendData_DBFriendInfo::friend_type() const {
  return friend_type_;
}
inline void AckFriendData_DBFriendInfo::set_friend_type(::google::protobuf::uint32 value) {
  set_has_friend_type();
  friend_type_ = value;
}

// required uint32 love = 5;
inline bool AckFriendData_DBFriendInfo::has_love() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_love() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckFriendData_DBFriendInfo::clear_has_love() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckFriendData_DBFriendInfo::clear_love() {
  love_ = 0u;
  clear_has_love();
}
inline ::google::protobuf::uint32 AckFriendData_DBFriendInfo::love() const {
  return love_;
}
inline void AckFriendData_DBFriendInfo::set_love(::google::protobuf::uint32 value) {
  set_has_love();
  love_ = value;
}

// required bytes last_love_date = 6;
inline bool AckFriendData_DBFriendInfo::has_last_love_date() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_last_love_date() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckFriendData_DBFriendInfo::clear_has_last_love_date() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckFriendData_DBFriendInfo::clear_last_love_date() {
  if (last_love_date_ != &::google::protobuf::internal::kEmptyString) {
    last_love_date_->clear();
  }
  clear_has_last_love_date();
}
inline const ::std::string& AckFriendData_DBFriendInfo::last_love_date() const {
  return *last_love_date_;
}
inline void AckFriendData_DBFriendInfo::set_last_love_date(const ::std::string& value) {
  set_has_last_love_date();
  if (last_love_date_ == &::google::protobuf::internal::kEmptyString) {
    last_love_date_ = new ::std::string;
  }
  last_love_date_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_last_love_date(const char* value) {
  set_has_last_love_date();
  if (last_love_date_ == &::google::protobuf::internal::kEmptyString) {
    last_love_date_ = new ::std::string;
  }
  last_love_date_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_last_love_date(const void* value, size_t size) {
  set_has_last_love_date();
  if (last_love_date_ == &::google::protobuf::internal::kEmptyString) {
    last_love_date_ = new ::std::string;
  }
  last_love_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFriendData_DBFriendInfo::mutable_last_love_date() {
  set_has_last_love_date();
  if (last_love_date_ == &::google::protobuf::internal::kEmptyString) {
    last_love_date_ = new ::std::string;
  }
  return last_love_date_;
}
inline ::std::string* AckFriendData_DBFriendInfo::release_last_love_date() {
  clear_has_last_love_date();
  if (last_love_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_love_date_;
    last_love_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckFriendData_DBFriendInfo::set_allocated_last_love_date(::std::string* last_love_date) {
  if (last_love_date_ != &::google::protobuf::internal::kEmptyString) {
    delete last_love_date_;
  }
  if (last_love_date) {
    set_has_last_love_date();
    last_love_date_ = last_love_date;
  } else {
    clear_has_last_love_date();
    last_love_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fight_data = 7;
inline bool AckFriendData_DBFriendInfo::has_fight_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_fight_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckFriendData_DBFriendInfo::clear_has_fight_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckFriendData_DBFriendInfo::clear_fight_data() {
  if (fight_data_ != &::google::protobuf::internal::kEmptyString) {
    fight_data_->clear();
  }
  clear_has_fight_data();
}
inline const ::std::string& AckFriendData_DBFriendInfo::fight_data() const {
  return *fight_data_;
}
inline void AckFriendData_DBFriendInfo::set_fight_data(const ::std::string& value) {
  set_has_fight_data();
  if (fight_data_ == &::google::protobuf::internal::kEmptyString) {
    fight_data_ = new ::std::string;
  }
  fight_data_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_fight_data(const char* value) {
  set_has_fight_data();
  if (fight_data_ == &::google::protobuf::internal::kEmptyString) {
    fight_data_ = new ::std::string;
  }
  fight_data_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_fight_data(const void* value, size_t size) {
  set_has_fight_data();
  if (fight_data_ == &::google::protobuf::internal::kEmptyString) {
    fight_data_ = new ::std::string;
  }
  fight_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFriendData_DBFriendInfo::mutable_fight_data() {
  set_has_fight_data();
  if (fight_data_ == &::google::protobuf::internal::kEmptyString) {
    fight_data_ = new ::std::string;
  }
  return fight_data_;
}
inline ::std::string* AckFriendData_DBFriendInfo::release_fight_data() {
  clear_has_fight_data();
  if (fight_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fight_data_;
    fight_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckFriendData_DBFriendInfo::set_allocated_fight_data(::std::string* fight_data) {
  if (fight_data_ != &::google::protobuf::internal::kEmptyString) {
    delete fight_data_;
  }
  if (fight_data) {
    set_has_fight_data();
    fight_data_ = fight_data;
  } else {
    clear_has_fight_data();
    fight_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes mercenary_data = 8;
inline bool AckFriendData_DBFriendInfo::has_mercenary_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_mercenary_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckFriendData_DBFriendInfo::clear_has_mercenary_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckFriendData_DBFriendInfo::clear_mercenary_data() {
  if (mercenary_data_ != &::google::protobuf::internal::kEmptyString) {
    mercenary_data_->clear();
  }
  clear_has_mercenary_data();
}
inline const ::std::string& AckFriendData_DBFriendInfo::mercenary_data() const {
  return *mercenary_data_;
}
inline void AckFriendData_DBFriendInfo::set_mercenary_data(const ::std::string& value) {
  set_has_mercenary_data();
  if (mercenary_data_ == &::google::protobuf::internal::kEmptyString) {
    mercenary_data_ = new ::std::string;
  }
  mercenary_data_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_mercenary_data(const char* value) {
  set_has_mercenary_data();
  if (mercenary_data_ == &::google::protobuf::internal::kEmptyString) {
    mercenary_data_ = new ::std::string;
  }
  mercenary_data_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_mercenary_data(const void* value, size_t size) {
  set_has_mercenary_data();
  if (mercenary_data_ == &::google::protobuf::internal::kEmptyString) {
    mercenary_data_ = new ::std::string;
  }
  mercenary_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFriendData_DBFriendInfo::mutable_mercenary_data() {
  set_has_mercenary_data();
  if (mercenary_data_ == &::google::protobuf::internal::kEmptyString) {
    mercenary_data_ = new ::std::string;
  }
  return mercenary_data_;
}
inline ::std::string* AckFriendData_DBFriendInfo::release_mercenary_data() {
  clear_has_mercenary_data();
  if (mercenary_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mercenary_data_;
    mercenary_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckFriendData_DBFriendInfo::set_allocated_mercenary_data(::std::string* mercenary_data) {
  if (mercenary_data_ != &::google::protobuf::internal::kEmptyString) {
    delete mercenary_data_;
  }
  if (mercenary_data) {
    set_has_mercenary_data();
    mercenary_data_ = mercenary_data;
  } else {
    clear_has_mercenary_data();
    mercenary_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes other_data = 9;
inline bool AckFriendData_DBFriendInfo::has_other_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_other_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckFriendData_DBFriendInfo::clear_has_other_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckFriendData_DBFriendInfo::clear_other_data() {
  if (other_data_ != &::google::protobuf::internal::kEmptyString) {
    other_data_->clear();
  }
  clear_has_other_data();
}
inline const ::std::string& AckFriendData_DBFriendInfo::other_data() const {
  return *other_data_;
}
inline void AckFriendData_DBFriendInfo::set_other_data(const ::std::string& value) {
  set_has_other_data();
  if (other_data_ == &::google::protobuf::internal::kEmptyString) {
    other_data_ = new ::std::string;
  }
  other_data_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_other_data(const char* value) {
  set_has_other_data();
  if (other_data_ == &::google::protobuf::internal::kEmptyString) {
    other_data_ = new ::std::string;
  }
  other_data_->assign(value);
}
inline void AckFriendData_DBFriendInfo::set_other_data(const void* value, size_t size) {
  set_has_other_data();
  if (other_data_ == &::google::protobuf::internal::kEmptyString) {
    other_data_ = new ::std::string;
  }
  other_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFriendData_DBFriendInfo::mutable_other_data() {
  set_has_other_data();
  if (other_data_ == &::google::protobuf::internal::kEmptyString) {
    other_data_ = new ::std::string;
  }
  return other_data_;
}
inline ::std::string* AckFriendData_DBFriendInfo::release_other_data() {
  clear_has_other_data();
  if (other_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = other_data_;
    other_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckFriendData_DBFriendInfo::set_allocated_other_data(::std::string* other_data) {
  if (other_data_ != &::google::protobuf::internal::kEmptyString) {
    delete other_data_;
  }
  if (other_data) {
    set_has_other_data();
    other_data_ = other_data;
  } else {
    clear_has_other_data();
    other_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 job = 10;
inline bool AckFriendData_DBFriendInfo::has_job() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_job() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckFriendData_DBFriendInfo::clear_has_job() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckFriendData_DBFriendInfo::clear_job() {
  job_ = 0u;
  clear_has_job();
}
inline ::google::protobuf::uint32 AckFriendData_DBFriendInfo::job() const {
  return job_;
}
inline void AckFriendData_DBFriendInfo::set_job(::google::protobuf::uint32 value) {
  set_has_job();
  job_ = value;
}

// optional uint32 sex = 11;
inline bool AckFriendData_DBFriendInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AckFriendData_DBFriendInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AckFriendData_DBFriendInfo::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 AckFriendData_DBFriendInfo::sex() const {
  return sex_;
}
inline void AckFriendData_DBFriendInfo::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 level = 12;
inline bool AckFriendData_DBFriendInfo::has_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AckFriendData_DBFriendInfo::set_has_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AckFriendData_DBFriendInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AckFriendData_DBFriendInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 AckFriendData_DBFriendInfo::level() const {
  return level_;
}
inline void AckFriendData_DBFriendInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// AckFriendData

// repeated .message.AckFriendData.DBFriendInfo friend_info = 1;
inline int AckFriendData::friend_info_size() const {
  return friend_info_.size();
}
inline void AckFriendData::clear_friend_info() {
  friend_info_.Clear();
}
inline const ::message::AckFriendData_DBFriendInfo& AckFriendData::friend_info(int index) const {
  return friend_info_.Get(index);
}
inline ::message::AckFriendData_DBFriendInfo* AckFriendData::mutable_friend_info(int index) {
  return friend_info_.Mutable(index);
}
inline ::message::AckFriendData_DBFriendInfo* AckFriendData::add_friend_info() {
  return friend_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::AckFriendData_DBFriendInfo >&
AckFriendData::friend_info() const {
  return friend_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::AckFriendData_DBFriendInfo >*
AckFriendData::mutable_friend_info() {
  return &friend_info_;
}

// -------------------------------------------------------------------

// FriendData_FriendInfo

// required uint32 friend_id = 1;
inline bool FriendData_FriendInfo::has_friend_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendData_FriendInfo::set_has_friend_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendData_FriendInfo::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendData_FriendInfo::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 FriendData_FriendInfo::friend_id() const {
  return friend_id_;
}
inline void FriendData_FriendInfo::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
}

// optional bytes friend_name = 2;
inline bool FriendData_FriendInfo::has_friend_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendData_FriendInfo::set_has_friend_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendData_FriendInfo::clear_has_friend_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendData_FriendInfo::clear_friend_name() {
  if (friend_name_ != &::google::protobuf::internal::kEmptyString) {
    friend_name_->clear();
  }
  clear_has_friend_name();
}
inline const ::std::string& FriendData_FriendInfo::friend_name() const {
  return *friend_name_;
}
inline void FriendData_FriendInfo::set_friend_name(const ::std::string& value) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(value);
}
inline void FriendData_FriendInfo::set_friend_name(const char* value) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(value);
}
inline void FriendData_FriendInfo::set_friend_name(const void* value, size_t size) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendData_FriendInfo::mutable_friend_name() {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_name_ = new ::std::string;
  }
  return friend_name_;
}
inline ::std::string* FriendData_FriendInfo::release_friend_name() {
  clear_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friend_name_;
    friend_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendData_FriendInfo::set_allocated_friend_name(::std::string* friend_name) {
  if (friend_name_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_name_;
  }
  if (friend_name) {
    set_has_friend_name();
    friend_name_ = friend_name;
  } else {
    clear_has_friend_name();
    friend_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 friend_type = 3;
inline bool FriendData_FriendInfo::has_friend_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendData_FriendInfo::set_has_friend_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendData_FriendInfo::clear_has_friend_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendData_FriendInfo::clear_friend_type() {
  friend_type_ = 0u;
  clear_has_friend_type();
}
inline ::google::protobuf::uint32 FriendData_FriendInfo::friend_type() const {
  return friend_type_;
}
inline void FriendData_FriendInfo::set_friend_type(::google::protobuf::uint32 value) {
  set_has_friend_type();
  friend_type_ = value;
}

// optional uint32 friend_lv = 4;
inline bool FriendData_FriendInfo::has_friend_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendData_FriendInfo::set_has_friend_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendData_FriendInfo::clear_has_friend_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendData_FriendInfo::clear_friend_lv() {
  friend_lv_ = 0u;
  clear_has_friend_lv();
}
inline ::google::protobuf::uint32 FriendData_FriendInfo::friend_lv() const {
  return friend_lv_;
}
inline void FriendData_FriendInfo::set_friend_lv(::google::protobuf::uint32 value) {
  set_has_friend_lv();
  friend_lv_ = value;
}

// optional uint32 friend_job = 5;
inline bool FriendData_FriendInfo::has_friend_job() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FriendData_FriendInfo::set_has_friend_job() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FriendData_FriendInfo::clear_has_friend_job() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FriendData_FriendInfo::clear_friend_job() {
  friend_job_ = 0u;
  clear_has_friend_job();
}
inline ::google::protobuf::uint32 FriendData_FriendInfo::friend_job() const {
  return friend_job_;
}
inline void FriendData_FriendInfo::set_friend_job(::google::protobuf::uint32 value) {
  set_has_friend_job();
  friend_job_ = value;
}

// optional uint32 friend_sex = 6;
inline bool FriendData_FriendInfo::has_friend_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FriendData_FriendInfo::set_has_friend_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FriendData_FriendInfo::clear_has_friend_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FriendData_FriendInfo::clear_friend_sex() {
  friend_sex_ = 0u;
  clear_has_friend_sex();
}
inline ::google::protobuf::uint32 FriendData_FriendInfo::friend_sex() const {
  return friend_sex_;
}
inline void FriendData_FriendInfo::set_friend_sex(::google::protobuf::uint32 value) {
  set_has_friend_sex();
  friend_sex_ = value;
}

// optional uint32 friend_love = 7;
inline bool FriendData_FriendInfo::has_friend_love() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FriendData_FriendInfo::set_has_friend_love() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FriendData_FriendInfo::clear_has_friend_love() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FriendData_FriendInfo::clear_friend_love() {
  friend_love_ = 0u;
  clear_has_friend_love();
}
inline ::google::protobuf::uint32 FriendData_FriendInfo::friend_love() const {
  return friend_love_;
}
inline void FriendData_FriendInfo::set_friend_love(::google::protobuf::uint32 value) {
  set_has_friend_love();
  friend_love_ = value;
}

// optional uint32 friend_online = 8;
inline bool FriendData_FriendInfo::has_friend_online() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FriendData_FriendInfo::set_has_friend_online() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FriendData_FriendInfo::clear_has_friend_online() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FriendData_FriendInfo::clear_friend_online() {
  friend_online_ = 0u;
  clear_has_friend_online();
}
inline ::google::protobuf::uint32 FriendData_FriendInfo::friend_online() const {
  return friend_online_;
}
inline void FriendData_FriendInfo::set_friend_online(::google::protobuf::uint32 value) {
  set_has_friend_online();
  friend_online_ = value;
}

// -------------------------------------------------------------------

// FriendData

// repeated .message.FriendData.FriendInfo friend_info = 1;
inline int FriendData::friend_info_size() const {
  return friend_info_.size();
}
inline void FriendData::clear_friend_info() {
  friend_info_.Clear();
}
inline const ::message::FriendData_FriendInfo& FriendData::friend_info(int index) const {
  return friend_info_.Get(index);
}
inline ::message::FriendData_FriendInfo* FriendData::mutable_friend_info(int index) {
  return friend_info_.Mutable(index);
}
inline ::message::FriendData_FriendInfo* FriendData::add_friend_info() {
  return friend_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::FriendData_FriendInfo >&
FriendData::friend_info() const {
  return friend_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::FriendData_FriendInfo >*
FriendData::mutable_friend_info() {
  return &friend_info_;
}

// optional uint32 friend_operation = 2;
inline bool FriendData::has_friend_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendData::set_has_friend_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendData::clear_has_friend_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendData::clear_friend_operation() {
  friend_operation_ = 0u;
  clear_has_friend_operation();
}
inline ::google::protobuf::uint32 FriendData::friend_operation() const {
  return friend_operation_;
}
inline void FriendData::set_friend_operation(::google::protobuf::uint32 value) {
  set_has_friend_operation();
  friend_operation_ = value;
}

// -------------------------------------------------------------------

// SocietyOperationData_SocietyOperationInfo

// optional bytes time = 1;
inline bool SocietyOperationData_SocietyOperationInfo::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& SocietyOperationData_SocietyOperationInfo::time() const {
  return *time_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void SocietyOperationData_SocietyOperationInfo::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void SocietyOperationData_SocietyOperationInfo::set_time(const void* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SocietyOperationData_SocietyOperationInfo::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* SocietyOperationData_SocietyOperationInfo::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SocietyOperationData_SocietyOperationInfo::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 source_id = 2;
inline bool SocietyOperationData_SocietyOperationInfo::has_source_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_source_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 SocietyOperationData_SocietyOperationInfo::source_id() const {
  return source_id_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
}

// optional bytes source_name = 3;
inline bool SocietyOperationData_SocietyOperationInfo::has_source_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_source_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_source_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_source_name() {
  if (source_name_ != &::google::protobuf::internal::kEmptyString) {
    source_name_->clear();
  }
  clear_has_source_name();
}
inline const ::std::string& SocietyOperationData_SocietyOperationInfo::source_name() const {
  return *source_name_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_source_name(const ::std::string& value) {
  set_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    source_name_ = new ::std::string;
  }
  source_name_->assign(value);
}
inline void SocietyOperationData_SocietyOperationInfo::set_source_name(const char* value) {
  set_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    source_name_ = new ::std::string;
  }
  source_name_->assign(value);
}
inline void SocietyOperationData_SocietyOperationInfo::set_source_name(const void* value, size_t size) {
  set_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    source_name_ = new ::std::string;
  }
  source_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SocietyOperationData_SocietyOperationInfo::mutable_source_name() {
  set_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    source_name_ = new ::std::string;
  }
  return source_name_;
}
inline ::std::string* SocietyOperationData_SocietyOperationInfo::release_source_name() {
  clear_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_name_;
    source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SocietyOperationData_SocietyOperationInfo::set_allocated_source_name(::std::string* source_name) {
  if (source_name_ != &::google::protobuf::internal::kEmptyString) {
    delete source_name_;
  }
  if (source_name) {
    set_has_source_name();
    source_name_ = source_name;
  } else {
    clear_has_source_name();
    source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 target_id = 4;
inline bool SocietyOperationData_SocietyOperationInfo::has_target_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_target_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_target_id() {
  target_id_ = 0u;
  clear_has_target_id();
}
inline ::google::protobuf::uint32 SocietyOperationData_SocietyOperationInfo::target_id() const {
  return target_id_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_target_id(::google::protobuf::uint32 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional bytes target_name = 5;
inline bool SocietyOperationData_SocietyOperationInfo::has_target_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_target_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_target_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_target_name() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    target_name_->clear();
  }
  clear_has_target_name();
}
inline const ::std::string& SocietyOperationData_SocietyOperationInfo::target_name() const {
  return *target_name_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_target_name(const ::std::string& value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void SocietyOperationData_SocietyOperationInfo::set_target_name(const char* value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void SocietyOperationData_SocietyOperationInfo::set_target_name(const void* value, size_t size) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SocietyOperationData_SocietyOperationInfo::mutable_target_name() {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  return target_name_;
}
inline ::std::string* SocietyOperationData_SocietyOperationInfo::release_target_name() {
  clear_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_name_;
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SocietyOperationData_SocietyOperationInfo::set_allocated_target_name(::std::string* target_name) {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (target_name) {
    set_has_target_name();
    target_name_ = target_name;
  } else {
    clear_has_target_name();
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 operation_type = 6;
inline bool SocietyOperationData_SocietyOperationInfo::has_operation_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_operation_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_operation_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_operation_type() {
  operation_type_ = 0u;
  clear_has_operation_type();
}
inline ::google::protobuf::uint32 SocietyOperationData_SocietyOperationInfo::operation_type() const {
  return operation_type_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_operation_type(::google::protobuf::uint32 value) {
  set_has_operation_type();
  operation_type_ = value;
}

// optional uint32 operation_result = 7;
inline bool SocietyOperationData_SocietyOperationInfo::has_operation_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_operation_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_operation_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_operation_result() {
  operation_result_ = 0u;
  clear_has_operation_result();
}
inline ::google::protobuf::uint32 SocietyOperationData_SocietyOperationInfo::operation_result() const {
  return operation_result_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_operation_result(::google::protobuf::uint32 value) {
  set_has_operation_result();
  operation_result_ = value;
}

// repeated uint32 operation_value = 8;
inline int SocietyOperationData_SocietyOperationInfo::operation_value_size() const {
  return operation_value_.size();
}
inline void SocietyOperationData_SocietyOperationInfo::clear_operation_value() {
  operation_value_.Clear();
}
inline ::google::protobuf::uint32 SocietyOperationData_SocietyOperationInfo::operation_value(int index) const {
  return operation_value_.Get(index);
}
inline void SocietyOperationData_SocietyOperationInfo::set_operation_value(int index, ::google::protobuf::uint32 value) {
  operation_value_.Set(index, value);
}
inline void SocietyOperationData_SocietyOperationInfo::add_operation_value(::google::protobuf::uint32 value) {
  operation_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SocietyOperationData_SocietyOperationInfo::operation_value() const {
  return operation_value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SocietyOperationData_SocietyOperationInfo::mutable_operation_value() {
  return &operation_value_;
}

// optional uint32 job = 9;
inline bool SocietyOperationData_SocietyOperationInfo::has_job() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_job() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_job() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_job() {
  job_ = 0u;
  clear_has_job();
}
inline ::google::protobuf::uint32 SocietyOperationData_SocietyOperationInfo::job() const {
  return job_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_job(::google::protobuf::uint32 value) {
  set_has_job();
  job_ = value;
}

// optional uint32 sex = 10;
inline bool SocietyOperationData_SocietyOperationInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 SocietyOperationData_SocietyOperationInfo::sex() const {
  return sex_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 level = 11;
inline bool SocietyOperationData_SocietyOperationInfo::has_level() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SocietyOperationData_SocietyOperationInfo::set_has_level() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SocietyOperationData_SocietyOperationInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 SocietyOperationData_SocietyOperationInfo::level() const {
  return level_;
}
inline void SocietyOperationData_SocietyOperationInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// SocietyOperationData

// repeated .message.SocietyOperationData.SocietyOperationInfo society_info = 1;
inline int SocietyOperationData::society_info_size() const {
  return society_info_.size();
}
inline void SocietyOperationData::clear_society_info() {
  society_info_.Clear();
}
inline const ::message::SocietyOperationData_SocietyOperationInfo& SocietyOperationData::society_info(int index) const {
  return society_info_.Get(index);
}
inline ::message::SocietyOperationData_SocietyOperationInfo* SocietyOperationData::mutable_society_info(int index) {
  return society_info_.Mutable(index);
}
inline ::message::SocietyOperationData_SocietyOperationInfo* SocietyOperationData::add_society_info() {
  return society_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::SocietyOperationData_SocietyOperationInfo >&
SocietyOperationData::society_info() const {
  return society_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::SocietyOperationData_SocietyOperationInfo >*
SocietyOperationData::mutable_society_info() {
  return &society_info_;
}

// -------------------------------------------------------------------

// GetPvPData

// required uint32 pvp_type = 1;
inline bool GetPvPData::has_pvp_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPvPData::set_has_pvp_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPvPData::clear_has_pvp_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPvPData::clear_pvp_type() {
  pvp_type_ = 0u;
  clear_has_pvp_type();
}
inline ::google::protobuf::uint32 GetPvPData::pvp_type() const {
  return pvp_type_;
}
inline void GetPvPData::set_pvp_type(::google::protobuf::uint32 value) {
  set_has_pvp_type();
  pvp_type_ = value;
}

// optional uint32 is_ladder = 2;
inline bool GetPvPData::has_is_ladder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPvPData::set_has_is_ladder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPvPData::clear_has_is_ladder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPvPData::clear_is_ladder() {
  is_ladder_ = 0u;
  clear_has_is_ladder();
}
inline ::google::protobuf::uint32 GetPvPData::is_ladder() const {
  return is_ladder_;
}
inline void GetPvPData::set_is_ladder(::google::protobuf::uint32 value) {
  set_has_is_ladder();
  is_ladder_ = value;
}

// -------------------------------------------------------------------

// PvpOpeResult

// optional uint32 ope_type = 1;
inline bool PvpOpeResult::has_ope_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpOpeResult::set_has_ope_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpOpeResult::clear_has_ope_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpOpeResult::clear_ope_type() {
  ope_type_ = 0u;
  clear_has_ope_type();
}
inline ::google::protobuf::uint32 PvpOpeResult::ope_type() const {
  return ope_type_;
}
inline void PvpOpeResult::set_ope_type(::google::protobuf::uint32 value) {
  set_has_ope_type();
  ope_type_ = value;
}

// optional uint32 ope_result = 2;
inline bool PvpOpeResult::has_ope_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpOpeResult::set_has_ope_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpOpeResult::clear_has_ope_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpOpeResult::clear_ope_result() {
  ope_result_ = 0u;
  clear_has_ope_result();
}
inline ::google::protobuf::uint32 PvpOpeResult::ope_result() const {
  return ope_result_;
}
inline void PvpOpeResult::set_ope_result(::google::protobuf::uint32 value) {
  set_has_ope_result();
  ope_result_ = value;
}

// optional uint32 remain_time = 3;
inline bool PvpOpeResult::has_remain_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpOpeResult::set_has_remain_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpOpeResult::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpOpeResult::clear_remain_time() {
  remain_time_ = 0u;
  clear_has_remain_time();
}
inline ::google::protobuf::uint32 PvpOpeResult::remain_time() const {
  return remain_time_;
}
inline void PvpOpeResult::set_remain_time(::google::protobuf::uint32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// optional uint32 left_times = 4;
inline bool PvpOpeResult::has_left_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpOpeResult::set_has_left_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpOpeResult::clear_has_left_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpOpeResult::clear_left_times() {
  left_times_ = 0u;
  clear_has_left_times();
}
inline ::google::protobuf::uint32 PvpOpeResult::left_times() const {
  return left_times_;
}
inline void PvpOpeResult::set_left_times(::google::protobuf::uint32 value) {
  set_has_left_times();
  left_times_ = value;
}

// -------------------------------------------------------------------

// ReqPVPData

// repeated uint32 target_id = 1;
inline int ReqPVPData::target_id_size() const {
  return target_id_.size();
}
inline void ReqPVPData::clear_target_id() {
  target_id_.Clear();
}
inline ::google::protobuf::uint32 ReqPVPData::target_id(int index) const {
  return target_id_.Get(index);
}
inline void ReqPVPData::set_target_id(int index, ::google::protobuf::uint32 value) {
  target_id_.Set(index, value);
}
inline void ReqPVPData::add_target_id(::google::protobuf::uint32 value) {
  target_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ReqPVPData::target_id() const {
  return target_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ReqPVPData::mutable_target_id() {
  return &target_id_;
}

// -------------------------------------------------------------------

// AckPVPData_DBPVPInfo

// optional uint32 target_char_id = 1;
inline bool AckPVPData_DBPVPInfo::has_target_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_target_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPVPData_DBPVPInfo::clear_has_target_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPVPData_DBPVPInfo::clear_target_char_id() {
  target_char_id_ = 0u;
  clear_has_target_char_id();
}
inline ::google::protobuf::uint32 AckPVPData_DBPVPInfo::target_char_id() const {
  return target_char_id_;
}
inline void AckPVPData_DBPVPInfo::set_target_char_id(::google::protobuf::uint32 value) {
  set_has_target_char_id();
  target_char_id_ = value;
}

// optional uint32 target_job = 2;
inline bool AckPVPData_DBPVPInfo::has_target_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_target_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPVPData_DBPVPInfo::clear_has_target_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPVPData_DBPVPInfo::clear_target_job() {
  target_job_ = 0u;
  clear_has_target_job();
}
inline ::google::protobuf::uint32 AckPVPData_DBPVPInfo::target_job() const {
  return target_job_;
}
inline void AckPVPData_DBPVPInfo::set_target_job(::google::protobuf::uint32 value) {
  set_has_target_job();
  target_job_ = value;
}

// optional uint32 target_sex = 3;
inline bool AckPVPData_DBPVPInfo::has_target_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_target_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckPVPData_DBPVPInfo::clear_has_target_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckPVPData_DBPVPInfo::clear_target_sex() {
  target_sex_ = 0u;
  clear_has_target_sex();
}
inline ::google::protobuf::uint32 AckPVPData_DBPVPInfo::target_sex() const {
  return target_sex_;
}
inline void AckPVPData_DBPVPInfo::set_target_sex(::google::protobuf::uint32 value) {
  set_has_target_sex();
  target_sex_ = value;
}

// optional bytes target_char_name = 4;
inline bool AckPVPData_DBPVPInfo::has_target_char_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_target_char_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckPVPData_DBPVPInfo::clear_has_target_char_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckPVPData_DBPVPInfo::clear_target_char_name() {
  if (target_char_name_ != &::google::protobuf::internal::kEmptyString) {
    target_char_name_->clear();
  }
  clear_has_target_char_name();
}
inline const ::std::string& AckPVPData_DBPVPInfo::target_char_name() const {
  return *target_char_name_;
}
inline void AckPVPData_DBPVPInfo::set_target_char_name(const ::std::string& value) {
  set_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    target_char_name_ = new ::std::string;
  }
  target_char_name_->assign(value);
}
inline void AckPVPData_DBPVPInfo::set_target_char_name(const char* value) {
  set_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    target_char_name_ = new ::std::string;
  }
  target_char_name_->assign(value);
}
inline void AckPVPData_DBPVPInfo::set_target_char_name(const void* value, size_t size) {
  set_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    target_char_name_ = new ::std::string;
  }
  target_char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPVPData_DBPVPInfo::mutable_target_char_name() {
  set_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    target_char_name_ = new ::std::string;
  }
  return target_char_name_;
}
inline ::std::string* AckPVPData_DBPVPInfo::release_target_char_name() {
  clear_has_target_char_name();
  if (target_char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_char_name_;
    target_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPVPData_DBPVPInfo::set_allocated_target_char_name(::std::string* target_char_name) {
  if (target_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_char_name_;
  }
  if (target_char_name) {
    set_has_target_char_name();
    target_char_name_ = target_char_name;
  } else {
    clear_has_target_char_name();
    target_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 target_lv = 5;
inline bool AckPVPData_DBPVPInfo::has_target_lv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_target_lv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckPVPData_DBPVPInfo::clear_has_target_lv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckPVPData_DBPVPInfo::clear_target_lv() {
  target_lv_ = 0u;
  clear_has_target_lv();
}
inline ::google::protobuf::uint32 AckPVPData_DBPVPInfo::target_lv() const {
  return target_lv_;
}
inline void AckPVPData_DBPVPInfo::set_target_lv(::google::protobuf::uint32 value) {
  set_has_target_lv();
  target_lv_ = value;
}

// optional uint32 success_num = 6;
inline bool AckPVPData_DBPVPInfo::has_success_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_success_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckPVPData_DBPVPInfo::clear_has_success_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckPVPData_DBPVPInfo::clear_success_num() {
  success_num_ = 0u;
  clear_has_success_num();
}
inline ::google::protobuf::uint32 AckPVPData_DBPVPInfo::success_num() const {
  return success_num_;
}
inline void AckPVPData_DBPVPInfo::set_success_num(::google::protobuf::uint32 value) {
  set_has_success_num();
  success_num_ = value;
}

// optional uint32 target_rank = 7;
inline bool AckPVPData_DBPVPInfo::has_target_rank() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_target_rank() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckPVPData_DBPVPInfo::clear_has_target_rank() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckPVPData_DBPVPInfo::clear_target_rank() {
  target_rank_ = 0u;
  clear_has_target_rank();
}
inline ::google::protobuf::uint32 AckPVPData_DBPVPInfo::target_rank() const {
  return target_rank_;
}
inline void AckPVPData_DBPVPInfo::set_target_rank(::google::protobuf::uint32 value) {
  set_has_target_rank();
  target_rank_ = value;
}

// optional uint32 fight_score = 8;
inline bool AckPVPData_DBPVPInfo::has_fight_score() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_fight_score() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckPVPData_DBPVPInfo::clear_has_fight_score() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckPVPData_DBPVPInfo::clear_fight_score() {
  fight_score_ = 0u;
  clear_has_fight_score();
}
inline ::google::protobuf::uint32 AckPVPData_DBPVPInfo::fight_score() const {
  return fight_score_;
}
inline void AckPVPData_DBPVPInfo::set_fight_score(::google::protobuf::uint32 value) {
  set_has_fight_score();
  fight_score_ = value;
}

// optional bytes merc_bag = 9;
inline bool AckPVPData_DBPVPInfo::has_merc_bag() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_merc_bag() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckPVPData_DBPVPInfo::clear_has_merc_bag() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckPVPData_DBPVPInfo::clear_merc_bag() {
  if (merc_bag_ != &::google::protobuf::internal::kEmptyString) {
    merc_bag_->clear();
  }
  clear_has_merc_bag();
}
inline const ::std::string& AckPVPData_DBPVPInfo::merc_bag() const {
  return *merc_bag_;
}
inline void AckPVPData_DBPVPInfo::set_merc_bag(const ::std::string& value) {
  set_has_merc_bag();
  if (merc_bag_ == &::google::protobuf::internal::kEmptyString) {
    merc_bag_ = new ::std::string;
  }
  merc_bag_->assign(value);
}
inline void AckPVPData_DBPVPInfo::set_merc_bag(const char* value) {
  set_has_merc_bag();
  if (merc_bag_ == &::google::protobuf::internal::kEmptyString) {
    merc_bag_ = new ::std::string;
  }
  merc_bag_->assign(value);
}
inline void AckPVPData_DBPVPInfo::set_merc_bag(const void* value, size_t size) {
  set_has_merc_bag();
  if (merc_bag_ == &::google::protobuf::internal::kEmptyString) {
    merc_bag_ = new ::std::string;
  }
  merc_bag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPVPData_DBPVPInfo::mutable_merc_bag() {
  set_has_merc_bag();
  if (merc_bag_ == &::google::protobuf::internal::kEmptyString) {
    merc_bag_ = new ::std::string;
  }
  return merc_bag_;
}
inline ::std::string* AckPVPData_DBPVPInfo::release_merc_bag() {
  clear_has_merc_bag();
  if (merc_bag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merc_bag_;
    merc_bag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPVPData_DBPVPInfo::set_allocated_merc_bag(::std::string* merc_bag) {
  if (merc_bag_ != &::google::protobuf::internal::kEmptyString) {
    delete merc_bag_;
  }
  if (merc_bag) {
    set_has_merc_bag();
    merc_bag_ = merc_bag;
  } else {
    clear_has_merc_bag();
    merc_bag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes equip_pos = 10;
inline bool AckPVPData_DBPVPInfo::has_equip_pos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckPVPData_DBPVPInfo::set_has_equip_pos() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckPVPData_DBPVPInfo::clear_has_equip_pos() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckPVPData_DBPVPInfo::clear_equip_pos() {
  if (equip_pos_ != &::google::protobuf::internal::kEmptyString) {
    equip_pos_->clear();
  }
  clear_has_equip_pos();
}
inline const ::std::string& AckPVPData_DBPVPInfo::equip_pos() const {
  return *equip_pos_;
}
inline void AckPVPData_DBPVPInfo::set_equip_pos(const ::std::string& value) {
  set_has_equip_pos();
  if (equip_pos_ == &::google::protobuf::internal::kEmptyString) {
    equip_pos_ = new ::std::string;
  }
  equip_pos_->assign(value);
}
inline void AckPVPData_DBPVPInfo::set_equip_pos(const char* value) {
  set_has_equip_pos();
  if (equip_pos_ == &::google::protobuf::internal::kEmptyString) {
    equip_pos_ = new ::std::string;
  }
  equip_pos_->assign(value);
}
inline void AckPVPData_DBPVPInfo::set_equip_pos(const void* value, size_t size) {
  set_has_equip_pos();
  if (equip_pos_ == &::google::protobuf::internal::kEmptyString) {
    equip_pos_ = new ::std::string;
  }
  equip_pos_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPVPData_DBPVPInfo::mutable_equip_pos() {
  set_has_equip_pos();
  if (equip_pos_ == &::google::protobuf::internal::kEmptyString) {
    equip_pos_ = new ::std::string;
  }
  return equip_pos_;
}
inline ::std::string* AckPVPData_DBPVPInfo::release_equip_pos() {
  clear_has_equip_pos();
  if (equip_pos_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equip_pos_;
    equip_pos_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPVPData_DBPVPInfo::set_allocated_equip_pos(::std::string* equip_pos) {
  if (equip_pos_ != &::google::protobuf::internal::kEmptyString) {
    delete equip_pos_;
  }
  if (equip_pos) {
    set_has_equip_pos();
    equip_pos_ = equip_pos;
  } else {
    clear_has_equip_pos();
    equip_pos_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckPVPData

// repeated .message.AckPVPData.DBPVPInfo pvp_info = 1;
inline int AckPVPData::pvp_info_size() const {
  return pvp_info_.size();
}
inline void AckPVPData::clear_pvp_info() {
  pvp_info_.Clear();
}
inline const ::message::AckPVPData_DBPVPInfo& AckPVPData::pvp_info(int index) const {
  return pvp_info_.Get(index);
}
inline ::message::AckPVPData_DBPVPInfo* AckPVPData::mutable_pvp_info(int index) {
  return pvp_info_.Mutable(index);
}
inline ::message::AckPVPData_DBPVPInfo* AckPVPData::add_pvp_info() {
  return pvp_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::AckPVPData_DBPVPInfo >&
AckPVPData::pvp_info() const {
  return pvp_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::AckPVPData_DBPVPInfo >*
AckPVPData::mutable_pvp_info() {
  return &pvp_info_;
}

// optional uint32 my_ladder = 2;
inline bool AckPVPData::has_my_ladder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPVPData::set_has_my_ladder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPVPData::clear_has_my_ladder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPVPData::clear_my_ladder() {
  my_ladder_ = 0u;
  clear_has_my_ladder();
}
inline ::google::protobuf::uint32 AckPVPData::my_ladder() const {
  return my_ladder_;
}
inline void AckPVPData::set_my_ladder(::google::protobuf::uint32 value) {
  set_has_my_ladder();
  my_ladder_ = value;
}

// -------------------------------------------------------------------

// PVPData_MercInfo

// required uint32 merc_id = 1;
inline bool PVPData_MercInfo::has_merc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVPData_MercInfo::set_has_merc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVPData_MercInfo::clear_has_merc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVPData_MercInfo::clear_merc_id() {
  merc_id_ = 0u;
  clear_has_merc_id();
}
inline ::google::protobuf::uint32 PVPData_MercInfo::merc_id() const {
  return merc_id_;
}
inline void PVPData_MercInfo::set_merc_id(::google::protobuf::uint32 value) {
  set_has_merc_id();
  merc_id_ = value;
}

// required uint32 merc_lv = 2;
inline bool PVPData_MercInfo::has_merc_lv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVPData_MercInfo::set_has_merc_lv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVPData_MercInfo::clear_has_merc_lv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVPData_MercInfo::clear_merc_lv() {
  merc_lv_ = 0u;
  clear_has_merc_lv();
}
inline ::google::protobuf::uint32 PVPData_MercInfo::merc_lv() const {
  return merc_lv_;
}
inline void PVPData_MercInfo::set_merc_lv(::google::protobuf::uint32 value) {
  set_has_merc_lv();
  merc_lv_ = value;
}

// required uint32 merc_color = 3;
inline bool PVPData_MercInfo::has_merc_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PVPData_MercInfo::set_has_merc_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PVPData_MercInfo::clear_has_merc_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PVPData_MercInfo::clear_merc_color() {
  merc_color_ = 0u;
  clear_has_merc_color();
}
inline ::google::protobuf::uint32 PVPData_MercInfo::merc_color() const {
  return merc_color_;
}
inline void PVPData_MercInfo::set_merc_color(::google::protobuf::uint32 value) {
  set_has_merc_color();
  merc_color_ = value;
}

// required uint32 merc_star = 4;
inline bool PVPData_MercInfo::has_merc_star() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PVPData_MercInfo::set_has_merc_star() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PVPData_MercInfo::clear_has_merc_star() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PVPData_MercInfo::clear_merc_star() {
  merc_star_ = 0u;
  clear_has_merc_star();
}
inline ::google::protobuf::uint32 PVPData_MercInfo::merc_star() const {
  return merc_star_;
}
inline void PVPData_MercInfo::set_merc_star(::google::protobuf::uint32 value) {
  set_has_merc_star();
  merc_star_ = value;
}

// -------------------------------------------------------------------

// PVPData_PVPInfo

// optional uint32 target_char_id = 1;
inline bool PVPData_PVPInfo::has_target_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVPData_PVPInfo::set_has_target_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVPData_PVPInfo::clear_has_target_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVPData_PVPInfo::clear_target_char_id() {
  target_char_id_ = 0u;
  clear_has_target_char_id();
}
inline ::google::protobuf::uint32 PVPData_PVPInfo::target_char_id() const {
  return target_char_id_;
}
inline void PVPData_PVPInfo::set_target_char_id(::google::protobuf::uint32 value) {
  set_has_target_char_id();
  target_char_id_ = value;
}

// optional uint32 target_job = 2;
inline bool PVPData_PVPInfo::has_target_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVPData_PVPInfo::set_has_target_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVPData_PVPInfo::clear_has_target_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVPData_PVPInfo::clear_target_job() {
  target_job_ = 0u;
  clear_has_target_job();
}
inline ::google::protobuf::uint32 PVPData_PVPInfo::target_job() const {
  return target_job_;
}
inline void PVPData_PVPInfo::set_target_job(::google::protobuf::uint32 value) {
  set_has_target_job();
  target_job_ = value;
}

// optional uint32 target_sex = 3;
inline bool PVPData_PVPInfo::has_target_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PVPData_PVPInfo::set_has_target_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PVPData_PVPInfo::clear_has_target_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PVPData_PVPInfo::clear_target_sex() {
  target_sex_ = 0u;
  clear_has_target_sex();
}
inline ::google::protobuf::uint32 PVPData_PVPInfo::target_sex() const {
  return target_sex_;
}
inline void PVPData_PVPInfo::set_target_sex(::google::protobuf::uint32 value) {
  set_has_target_sex();
  target_sex_ = value;
}

// optional uint32 target_level = 4;
inline bool PVPData_PVPInfo::has_target_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PVPData_PVPInfo::set_has_target_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PVPData_PVPInfo::clear_has_target_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PVPData_PVPInfo::clear_target_level() {
  target_level_ = 0u;
  clear_has_target_level();
}
inline ::google::protobuf::uint32 PVPData_PVPInfo::target_level() const {
  return target_level_;
}
inline void PVPData_PVPInfo::set_target_level(::google::protobuf::uint32 value) {
  set_has_target_level();
  target_level_ = value;
}

// optional bytes target_name = 5;
inline bool PVPData_PVPInfo::has_target_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PVPData_PVPInfo::set_has_target_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PVPData_PVPInfo::clear_has_target_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PVPData_PVPInfo::clear_target_name() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    target_name_->clear();
  }
  clear_has_target_name();
}
inline const ::std::string& PVPData_PVPInfo::target_name() const {
  return *target_name_;
}
inline void PVPData_PVPInfo::set_target_name(const ::std::string& value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void PVPData_PVPInfo::set_target_name(const char* value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void PVPData_PVPInfo::set_target_name(const void* value, size_t size) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PVPData_PVPInfo::mutable_target_name() {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  return target_name_;
}
inline ::std::string* PVPData_PVPInfo::release_target_name() {
  clear_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_name_;
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PVPData_PVPInfo::set_allocated_target_name(::std::string* target_name) {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (target_name) {
    set_has_target_name();
    target_name_ = target_name;
  } else {
    clear_has_target_name();
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 target_pvp_rank = 6;
inline bool PVPData_PVPInfo::has_target_pvp_rank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PVPData_PVPInfo::set_has_target_pvp_rank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PVPData_PVPInfo::clear_has_target_pvp_rank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PVPData_PVPInfo::clear_target_pvp_rank() {
  target_pvp_rank_ = 0u;
  clear_has_target_pvp_rank();
}
inline ::google::protobuf::uint32 PVPData_PVPInfo::target_pvp_rank() const {
  return target_pvp_rank_;
}
inline void PVPData_PVPInfo::set_target_pvp_rank(::google::protobuf::uint32 value) {
  set_has_target_pvp_rank();
  target_pvp_rank_ = value;
}

// optional uint32 target_fight_score = 7;
inline bool PVPData_PVPInfo::has_target_fight_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PVPData_PVPInfo::set_has_target_fight_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PVPData_PVPInfo::clear_has_target_fight_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PVPData_PVPInfo::clear_target_fight_score() {
  target_fight_score_ = 0u;
  clear_has_target_fight_score();
}
inline ::google::protobuf::uint32 PVPData_PVPInfo::target_fight_score() const {
  return target_fight_score_;
}
inline void PVPData_PVPInfo::set_target_fight_score(::google::protobuf::uint32 value) {
  set_has_target_fight_score();
  target_fight_score_ = value;
}

// optional uint32 target_success_times = 8;
inline bool PVPData_PVPInfo::has_target_success_times() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PVPData_PVPInfo::set_has_target_success_times() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PVPData_PVPInfo::clear_has_target_success_times() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PVPData_PVPInfo::clear_target_success_times() {
  target_success_times_ = 0u;
  clear_has_target_success_times();
}
inline ::google::protobuf::uint32 PVPData_PVPInfo::target_success_times() const {
  return target_success_times_;
}
inline void PVPData_PVPInfo::set_target_success_times(::google::protobuf::uint32 value) {
  set_has_target_success_times();
  target_success_times_ = value;
}

// repeated .message.PVPData.MercInfo target_merc_data = 9;
inline int PVPData_PVPInfo::target_merc_data_size() const {
  return target_merc_data_.size();
}
inline void PVPData_PVPInfo::clear_target_merc_data() {
  target_merc_data_.Clear();
}
inline const ::message::PVPData_MercInfo& PVPData_PVPInfo::target_merc_data(int index) const {
  return target_merc_data_.Get(index);
}
inline ::message::PVPData_MercInfo* PVPData_PVPInfo::mutable_target_merc_data(int index) {
  return target_merc_data_.Mutable(index);
}
inline ::message::PVPData_MercInfo* PVPData_PVPInfo::add_target_merc_data() {
  return target_merc_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::PVPData_MercInfo >&
PVPData_PVPInfo::target_merc_data() const {
  return target_merc_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::PVPData_MercInfo >*
PVPData_PVPInfo::mutable_target_merc_data() {
  return &target_merc_data_;
}

// -------------------------------------------------------------------

// PVPData

// repeated .message.PVPData.PVPInfo pvp_info = 1;
inline int PVPData::pvp_info_size() const {
  return pvp_info_.size();
}
inline void PVPData::clear_pvp_info() {
  pvp_info_.Clear();
}
inline const ::message::PVPData_PVPInfo& PVPData::pvp_info(int index) const {
  return pvp_info_.Get(index);
}
inline ::message::PVPData_PVPInfo* PVPData::mutable_pvp_info(int index) {
  return pvp_info_.Mutable(index);
}
inline ::message::PVPData_PVPInfo* PVPData::add_pvp_info() {
  return pvp_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::PVPData_PVPInfo >&
PVPData::pvp_info() const {
  return pvp_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::PVPData_PVPInfo >*
PVPData::mutable_pvp_info() {
  return &pvp_info_;
}

// optional uint32 remain_time = 2;
inline bool PVPData::has_remain_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVPData::set_has_remain_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVPData::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVPData::clear_remain_time() {
  remain_time_ = 0u;
  clear_has_remain_time();
}
inline ::google::protobuf::uint32 PVPData::remain_time() const {
  return remain_time_;
}
inline void PVPData::set_remain_time(::google::protobuf::uint32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// optional uint32 left_pvp_times = 3;
inline bool PVPData::has_left_pvp_times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PVPData::set_has_left_pvp_times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PVPData::clear_has_left_pvp_times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PVPData::clear_left_pvp_times() {
  left_pvp_times_ = 0u;
  clear_has_left_pvp_times();
}
inline ::google::protobuf::uint32 PVPData::left_pvp_times() const {
  return left_pvp_times_;
}
inline void PVPData::set_left_pvp_times(::google::protobuf::uint32 value) {
  set_has_left_pvp_times();
  left_pvp_times_ = value;
}

// optional uint32 my_rank = 4;
inline bool PVPData::has_my_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PVPData::set_has_my_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PVPData::clear_has_my_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PVPData::clear_my_rank() {
  my_rank_ = 0u;
  clear_has_my_rank();
}
inline ::google::protobuf::uint32 PVPData::my_rank() const {
  return my_rank_;
}
inline void PVPData::set_my_rank(::google::protobuf::uint32 value) {
  set_has_my_rank();
  my_rank_ = value;
}

// optional uint32 error_code = 5;
inline bool PVPData::has_error_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PVPData::set_has_error_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PVPData::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PVPData::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 PVPData::error_code() const {
  return error_code_;
}
inline void PVPData::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// PVPBattle

// required uint32 target_id = 1;
inline bool PVPBattle::has_target_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVPBattle::set_has_target_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVPBattle::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVPBattle::clear_target_id() {
  target_id_ = 0u;
  clear_has_target_id();
}
inline ::google::protobuf::uint32 PVPBattle::target_id() const {
  return target_id_;
}
inline void PVPBattle::set_target_id(::google::protobuf::uint32 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional uint32 is_ladder = 2;
inline bool PVPBattle::has_is_ladder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVPBattle::set_has_is_ladder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVPBattle::clear_has_is_ladder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVPBattle::clear_is_ladder() {
  is_ladder_ = 0u;
  clear_has_is_ladder();
}
inline ::google::protobuf::uint32 PVPBattle::is_ladder() const {
  return is_ladder_;
}
inline void PVPBattle::set_is_ladder(::google::protobuf::uint32 value) {
  set_has_is_ladder();
  is_ladder_ = value;
}

// -------------------------------------------------------------------

// StartLadder

// required uint32 char_id = 1;
inline bool StartLadder::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartLadder::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartLadder::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartLadder::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 StartLadder::char_id() const {
  return char_id_;
}
inline void StartLadder::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// BuyLadderTimes

// required uint32 char_id = 1;
inline bool BuyLadderTimes::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyLadderTimes::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyLadderTimes::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyLadderTimes::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 BuyLadderTimes::char_id() const {
  return char_id_;
}
inline void BuyLadderTimes::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// BuyPvPTimes

// required uint32 char_id = 1;
inline bool BuyPvPTimes::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyPvPTimes::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyPvPTimes::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyPvPTimes::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 BuyPvPTimes::char_id() const {
  return char_id_;
}
inline void BuyPvPTimes::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// UpdateLadder

// optional uint32 char_id = 1;
inline bool UpdateLadder::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateLadder::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateLadder::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateLadder::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 UpdateLadder::char_id() const {
  return char_id_;
}
inline void UpdateLadder::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// optional uint32 target_char_id = 2;
inline bool UpdateLadder::has_target_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateLadder::set_has_target_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateLadder::clear_has_target_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateLadder::clear_target_char_id() {
  target_char_id_ = 0u;
  clear_has_target_char_id();
}
inline ::google::protobuf::uint32 UpdateLadder::target_char_id() const {
  return target_char_id_;
}
inline void UpdateLadder::set_target_char_id(::google::protobuf::uint32 value) {
  set_has_target_char_id();
  target_char_id_ = value;
}

// -------------------------------------------------------------------

// UpdateLadderReward_RewardInfo

// required uint32 from_ladder = 1;
inline bool UpdateLadderReward_RewardInfo::has_from_ladder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateLadderReward_RewardInfo::set_has_from_ladder() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateLadderReward_RewardInfo::clear_has_from_ladder() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateLadderReward_RewardInfo::clear_from_ladder() {
  from_ladder_ = 0u;
  clear_has_from_ladder();
}
inline ::google::protobuf::uint32 UpdateLadderReward_RewardInfo::from_ladder() const {
  return from_ladder_;
}
inline void UpdateLadderReward_RewardInfo::set_from_ladder(::google::protobuf::uint32 value) {
  set_has_from_ladder();
  from_ladder_ = value;
}

// required uint32 to_ladder = 2;
inline bool UpdateLadderReward_RewardInfo::has_to_ladder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateLadderReward_RewardInfo::set_has_to_ladder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateLadderReward_RewardInfo::clear_has_to_ladder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateLadderReward_RewardInfo::clear_to_ladder() {
  to_ladder_ = 0u;
  clear_has_to_ladder();
}
inline ::google::protobuf::uint32 UpdateLadderReward_RewardInfo::to_ladder() const {
  return to_ladder_;
}
inline void UpdateLadderReward_RewardInfo::set_to_ladder(::google::protobuf::uint32 value) {
  set_has_to_ladder();
  to_ladder_ = value;
}

// required uint32 reward_ladder = 3;
inline bool UpdateLadderReward_RewardInfo::has_reward_ladder() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateLadderReward_RewardInfo::set_has_reward_ladder() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateLadderReward_RewardInfo::clear_has_reward_ladder() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateLadderReward_RewardInfo::clear_reward_ladder() {
  reward_ladder_ = 0u;
  clear_has_reward_ladder();
}
inline ::google::protobuf::uint32 UpdateLadderReward_RewardInfo::reward_ladder() const {
  return reward_ladder_;
}
inline void UpdateLadderReward_RewardInfo::set_reward_ladder(::google::protobuf::uint32 value) {
  set_has_reward_ladder();
  reward_ladder_ = value;
}

// -------------------------------------------------------------------

// UpdateLadderReward

// repeated .message.UpdateLadderReward.RewardInfo reward_info = 1;
inline int UpdateLadderReward::reward_info_size() const {
  return reward_info_.size();
}
inline void UpdateLadderReward::clear_reward_info() {
  reward_info_.Clear();
}
inline const ::message::UpdateLadderReward_RewardInfo& UpdateLadderReward::reward_info(int index) const {
  return reward_info_.Get(index);
}
inline ::message::UpdateLadderReward_RewardInfo* UpdateLadderReward::mutable_reward_info(int index) {
  return reward_info_.Mutable(index);
}
inline ::message::UpdateLadderReward_RewardInfo* UpdateLadderReward::add_reward_info() {
  return reward_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::UpdateLadderReward_RewardInfo >&
UpdateLadderReward::reward_info() const {
  return reward_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::UpdateLadderReward_RewardInfo >*
UpdateLadderReward::mutable_reward_info() {
  return &reward_info_;
}

// optional uint32 acc_id = 2;
inline bool UpdateLadderReward::has_acc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateLadderReward::set_has_acc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateLadderReward::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateLadderReward::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 UpdateLadderReward::acc_id() const {
  return acc_id_;
}
inline void UpdateLadderReward::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// GetLadderReward

// required uint32 item_id = 1;
inline bool GetLadderReward::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLadderReward::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLadderReward::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLadderReward::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 GetLadderReward::item_id() const {
  return item_id_;
}
inline void GetLadderReward::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// -------------------------------------------------------------------

// GetRoleData

// required uint32 type = 1;
inline bool GetRoleData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoleData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoleData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoleData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 GetRoleData::type() const {
  return type_;
}
inline void GetRoleData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required bytes char_name = 2;
inline bool GetRoleData::has_char_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRoleData::set_has_char_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetRoleData::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetRoleData::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& GetRoleData::char_name() const {
  return *char_name_;
}
inline void GetRoleData::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void GetRoleData::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void GetRoleData::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRoleData::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* GetRoleData::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetRoleData::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes mer_name = 3;
inline bool GetRoleData::has_mer_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetRoleData::set_has_mer_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetRoleData::clear_has_mer_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetRoleData::clear_mer_name() {
  if (mer_name_ != &::google::protobuf::internal::kEmptyString) {
    mer_name_->clear();
  }
  clear_has_mer_name();
}
inline const ::std::string& GetRoleData::mer_name() const {
  return *mer_name_;
}
inline void GetRoleData::set_mer_name(const ::std::string& value) {
  set_has_mer_name();
  if (mer_name_ == &::google::protobuf::internal::kEmptyString) {
    mer_name_ = new ::std::string;
  }
  mer_name_->assign(value);
}
inline void GetRoleData::set_mer_name(const char* value) {
  set_has_mer_name();
  if (mer_name_ == &::google::protobuf::internal::kEmptyString) {
    mer_name_ = new ::std::string;
  }
  mer_name_->assign(value);
}
inline void GetRoleData::set_mer_name(const void* value, size_t size) {
  set_has_mer_name();
  if (mer_name_ == &::google::protobuf::internal::kEmptyString) {
    mer_name_ = new ::std::string;
  }
  mer_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRoleData::mutable_mer_name() {
  set_has_mer_name();
  if (mer_name_ == &::google::protobuf::internal::kEmptyString) {
    mer_name_ = new ::std::string;
  }
  return mer_name_;
}
inline ::std::string* GetRoleData::release_mer_name() {
  clear_has_mer_name();
  if (mer_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mer_name_;
    mer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetRoleData::set_allocated_mer_name(::std::string* mer_name) {
  if (mer_name_ != &::google::protobuf::internal::kEmptyString) {
    delete mer_name_;
  }
  if (mer_name) {
    set_has_mer_name();
    mer_name_ = mer_name;
  } else {
    clear_has_mer_name();
    mer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 is_pk = 4;
inline bool GetRoleData::has_is_pk() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetRoleData::set_has_is_pk() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetRoleData::clear_has_is_pk() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetRoleData::clear_is_pk() {
  is_pk_ = 0u;
  clear_has_is_pk();
}
inline ::google::protobuf::uint32 GetRoleData::is_pk() const {
  return is_pk_;
}
inline void GetRoleData::set_is_pk(::google::protobuf::uint32 value) {
  set_has_is_pk();
  is_pk_ = value;
}

// -------------------------------------------------------------------

// RoleData_MercInfo

// optional uint32 merc_pos = 1;
inline bool RoleData_MercInfo::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleData_MercInfo::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleData_MercInfo::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleData_MercInfo::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 RoleData_MercInfo::merc_pos() const {
  return merc_pos_;
}
inline void RoleData_MercInfo::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// optional bytes merc_data = 2;
inline bool RoleData_MercInfo::has_merc_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleData_MercInfo::set_has_merc_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleData_MercInfo::clear_has_merc_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleData_MercInfo::clear_merc_data() {
  if (merc_data_ != &::google::protobuf::internal::kEmptyString) {
    merc_data_->clear();
  }
  clear_has_merc_data();
}
inline const ::std::string& RoleData_MercInfo::merc_data() const {
  return *merc_data_;
}
inline void RoleData_MercInfo::set_merc_data(const ::std::string& value) {
  set_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    merc_data_ = new ::std::string;
  }
  merc_data_->assign(value);
}
inline void RoleData_MercInfo::set_merc_data(const char* value) {
  set_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    merc_data_ = new ::std::string;
  }
  merc_data_->assign(value);
}
inline void RoleData_MercInfo::set_merc_data(const void* value, size_t size) {
  set_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    merc_data_ = new ::std::string;
  }
  merc_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleData_MercInfo::mutable_merc_data() {
  set_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    merc_data_ = new ::std::string;
  }
  return merc_data_;
}
inline ::std::string* RoleData_MercInfo::release_merc_data() {
  clear_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merc_data_;
    merc_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleData_MercInfo::set_allocated_merc_data(::std::string* merc_data) {
  if (merc_data_ != &::google::protobuf::internal::kEmptyString) {
    delete merc_data_;
  }
  if (merc_data) {
    set_has_merc_data();
    merc_data_ = merc_data;
  } else {
    clear_has_merc_data();
    merc_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes equip_data = 3;
inline bool RoleData_MercInfo::has_equip_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleData_MercInfo::set_has_equip_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleData_MercInfo::clear_has_equip_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleData_MercInfo::clear_equip_data() {
  if (equip_data_ != &::google::protobuf::internal::kEmptyString) {
    equip_data_->clear();
  }
  clear_has_equip_data();
}
inline const ::std::string& RoleData_MercInfo::equip_data() const {
  return *equip_data_;
}
inline void RoleData_MercInfo::set_equip_data(const ::std::string& value) {
  set_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    equip_data_ = new ::std::string;
  }
  equip_data_->assign(value);
}
inline void RoleData_MercInfo::set_equip_data(const char* value) {
  set_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    equip_data_ = new ::std::string;
  }
  equip_data_->assign(value);
}
inline void RoleData_MercInfo::set_equip_data(const void* value, size_t size) {
  set_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    equip_data_ = new ::std::string;
  }
  equip_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleData_MercInfo::mutable_equip_data() {
  set_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    equip_data_ = new ::std::string;
  }
  return equip_data_;
}
inline ::std::string* RoleData_MercInfo::release_equip_data() {
  clear_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equip_data_;
    equip_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleData_MercInfo::set_allocated_equip_data(::std::string* equip_data) {
  if (equip_data_ != &::google::protobuf::internal::kEmptyString) {
    delete equip_data_;
  }
  if (equip_data) {
    set_has_equip_data();
    equip_data_ = equip_data;
  } else {
    clear_has_equip_data();
    equip_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoleData

// optional uint32 target_char_id = 1;
inline bool RoleData::has_target_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleData::set_has_target_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleData::clear_has_target_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleData::clear_target_char_id() {
  target_char_id_ = 0u;
  clear_has_target_char_id();
}
inline ::google::protobuf::uint32 RoleData::target_char_id() const {
  return target_char_id_;
}
inline void RoleData::set_target_char_id(::google::protobuf::uint32 value) {
  set_has_target_char_id();
  target_char_id_ = value;
}

// optional uint32 target_lv = 2;
inline bool RoleData::has_target_lv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleData::set_has_target_lv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleData::clear_has_target_lv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleData::clear_target_lv() {
  target_lv_ = 0u;
  clear_has_target_lv();
}
inline ::google::protobuf::uint32 RoleData::target_lv() const {
  return target_lv_;
}
inline void RoleData::set_target_lv(::google::protobuf::uint32 value) {
  set_has_target_lv();
  target_lv_ = value;
}

// optional bytes target_name = 3;
inline bool RoleData::has_target_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleData::set_has_target_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleData::clear_has_target_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleData::clear_target_name() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    target_name_->clear();
  }
  clear_has_target_name();
}
inline const ::std::string& RoleData::target_name() const {
  return *target_name_;
}
inline void RoleData::set_target_name(const ::std::string& value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void RoleData::set_target_name(const char* value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void RoleData::set_target_name(const void* value, size_t size) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleData::mutable_target_name() {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  return target_name_;
}
inline ::std::string* RoleData::release_target_name() {
  clear_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_name_;
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleData::set_allocated_target_name(::std::string* target_name) {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (target_name) {
    set_has_target_name();
    target_name_ = target_name;
  } else {
    clear_has_target_name();
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 target_job = 4;
inline bool RoleData::has_target_job() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleData::set_has_target_job() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleData::clear_has_target_job() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleData::clear_target_job() {
  target_job_ = 0u;
  clear_has_target_job();
}
inline ::google::protobuf::uint32 RoleData::target_job() const {
  return target_job_;
}
inline void RoleData::set_target_job(::google::protobuf::uint32 value) {
  set_has_target_job();
  target_job_ = value;
}

// optional uint32 target_sex = 5;
inline bool RoleData::has_target_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoleData::set_has_target_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoleData::clear_has_target_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoleData::clear_target_sex() {
  target_sex_ = 0u;
  clear_has_target_sex();
}
inline ::google::protobuf::uint32 RoleData::target_sex() const {
  return target_sex_;
}
inline void RoleData::set_target_sex(::google::protobuf::uint32 value) {
  set_has_target_sex();
  target_sex_ = value;
}

// optional uint32 success_num = 6;
inline bool RoleData::has_success_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoleData::set_has_success_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoleData::clear_has_success_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoleData::clear_success_num() {
  success_num_ = 0u;
  clear_has_success_num();
}
inline ::google::protobuf::uint32 RoleData::success_num() const {
  return success_num_;
}
inline void RoleData::set_success_num(::google::protobuf::uint32 value) {
  set_has_success_num();
  success_num_ = value;
}

// optional uint32 fight_score = 7;
inline bool RoleData::has_fight_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoleData::set_has_fight_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoleData::clear_has_fight_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoleData::clear_fight_score() {
  fight_score_ = 0u;
  clear_has_fight_score();
}
inline ::google::protobuf::uint32 RoleData::fight_score() const {
  return fight_score_;
}
inline void RoleData::set_fight_score(::google::protobuf::uint32 value) {
  set_has_fight_score();
  fight_score_ = value;
}

// repeated .message.RoleData.MercInfo merc_info = 8;
inline int RoleData::merc_info_size() const {
  return merc_info_.size();
}
inline void RoleData::clear_merc_info() {
  merc_info_.Clear();
}
inline const ::message::RoleData_MercInfo& RoleData::merc_info(int index) const {
  return merc_info_.Get(index);
}
inline ::message::RoleData_MercInfo* RoleData::mutable_merc_info(int index) {
  return merc_info_.Mutable(index);
}
inline ::message::RoleData_MercInfo* RoleData::add_merc_info() {
  return merc_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::RoleData_MercInfo >&
RoleData::merc_info() const {
  return merc_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::RoleData_MercInfo >*
RoleData::mutable_merc_info() {
  return &merc_info_;
}

// optional uint32 error_code = 9;
inline bool RoleData::has_error_code() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoleData::set_has_error_code() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoleData::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoleData::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 RoleData::error_code() const {
  return error_code_;
}
inline void RoleData::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// ReqRoleData

// required bytes char_name = 1;
inline bool ReqRoleData::has_char_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqRoleData::set_has_char_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqRoleData::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqRoleData::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& ReqRoleData::char_name() const {
  return *char_name_;
}
inline void ReqRoleData::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void ReqRoleData::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void ReqRoleData::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRoleData::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* ReqRoleData::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqRoleData::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 2;
inline bool ReqRoleData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqRoleData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqRoleData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqRoleData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ReqRoleData::type() const {
  return type_;
}
inline void ReqRoleData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AckRoleData

// required uint32 target_char_id = 1;
inline bool AckRoleData::has_target_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRoleData::set_has_target_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRoleData::clear_has_target_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRoleData::clear_target_char_id() {
  target_char_id_ = 0u;
  clear_has_target_char_id();
}
inline ::google::protobuf::uint32 AckRoleData::target_char_id() const {
  return target_char_id_;
}
inline void AckRoleData::set_target_char_id(::google::protobuf::uint32 value) {
  set_has_target_char_id();
  target_char_id_ = value;
}

// optional uint32 target_job = 2;
inline bool AckRoleData::has_target_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRoleData::set_has_target_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRoleData::clear_has_target_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRoleData::clear_target_job() {
  target_job_ = 0u;
  clear_has_target_job();
}
inline ::google::protobuf::uint32 AckRoleData::target_job() const {
  return target_job_;
}
inline void AckRoleData::set_target_job(::google::protobuf::uint32 value) {
  set_has_target_job();
  target_job_ = value;
}

// optional uint32 target_sex = 3;
inline bool AckRoleData::has_target_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckRoleData::set_has_target_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckRoleData::clear_has_target_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckRoleData::clear_target_sex() {
  target_sex_ = 0u;
  clear_has_target_sex();
}
inline ::google::protobuf::uint32 AckRoleData::target_sex() const {
  return target_sex_;
}
inline void AckRoleData::set_target_sex(::google::protobuf::uint32 value) {
  set_has_target_sex();
  target_sex_ = value;
}

// optional bytes target_name = 4;
inline bool AckRoleData::has_target_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckRoleData::set_has_target_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckRoleData::clear_has_target_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckRoleData::clear_target_name() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    target_name_->clear();
  }
  clear_has_target_name();
}
inline const ::std::string& AckRoleData::target_name() const {
  return *target_name_;
}
inline void AckRoleData::set_target_name(const ::std::string& value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void AckRoleData::set_target_name(const char* value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void AckRoleData::set_target_name(const void* value, size_t size) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRoleData::mutable_target_name() {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  return target_name_;
}
inline ::std::string* AckRoleData::release_target_name() {
  clear_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_name_;
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckRoleData::set_allocated_target_name(::std::string* target_name) {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (target_name) {
    set_has_target_name();
    target_name_ = target_name;
  } else {
    clear_has_target_name();
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 target_level = 5;
inline bool AckRoleData::has_target_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckRoleData::set_has_target_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckRoleData::clear_has_target_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckRoleData::clear_target_level() {
  target_level_ = 0u;
  clear_has_target_level();
}
inline ::google::protobuf::uint32 AckRoleData::target_level() const {
  return target_level_;
}
inline void AckRoleData::set_target_level(::google::protobuf::uint32 value) {
  set_has_target_level();
  target_level_ = value;
}

// optional uint32 success_num = 6;
inline bool AckRoleData::has_success_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckRoleData::set_has_success_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckRoleData::clear_has_success_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckRoleData::clear_success_num() {
  success_num_ = 0u;
  clear_has_success_num();
}
inline ::google::protobuf::uint32 AckRoleData::success_num() const {
  return success_num_;
}
inline void AckRoleData::set_success_num(::google::protobuf::uint32 value) {
  set_has_success_num();
  success_num_ = value;
}

// optional uint32 fight_score = 7;
inline bool AckRoleData::has_fight_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckRoleData::set_has_fight_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckRoleData::clear_has_fight_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckRoleData::clear_fight_score() {
  fight_score_ = 0u;
  clear_has_fight_score();
}
inline ::google::protobuf::uint32 AckRoleData::fight_score() const {
  return fight_score_;
}
inline void AckRoleData::set_fight_score(::google::protobuf::uint32 value) {
  set_has_fight_score();
  fight_score_ = value;
}

// optional uint32 target_rank = 8;
inline bool AckRoleData::has_target_rank() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckRoleData::set_has_target_rank() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckRoleData::clear_has_target_rank() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckRoleData::clear_target_rank() {
  target_rank_ = 0u;
  clear_has_target_rank();
}
inline ::google::protobuf::uint32 AckRoleData::target_rank() const {
  return target_rank_;
}
inline void AckRoleData::set_target_rank(::google::protobuf::uint32 value) {
  set_has_target_rank();
  target_rank_ = value;
}

// optional bytes char_merc = 9;
inline bool AckRoleData::has_char_merc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckRoleData::set_has_char_merc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckRoleData::clear_has_char_merc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckRoleData::clear_char_merc() {
  if (char_merc_ != &::google::protobuf::internal::kEmptyString) {
    char_merc_->clear();
  }
  clear_has_char_merc();
}
inline const ::std::string& AckRoleData::char_merc() const {
  return *char_merc_;
}
inline void AckRoleData::set_char_merc(const ::std::string& value) {
  set_has_char_merc();
  if (char_merc_ == &::google::protobuf::internal::kEmptyString) {
    char_merc_ = new ::std::string;
  }
  char_merc_->assign(value);
}
inline void AckRoleData::set_char_merc(const char* value) {
  set_has_char_merc();
  if (char_merc_ == &::google::protobuf::internal::kEmptyString) {
    char_merc_ = new ::std::string;
  }
  char_merc_->assign(value);
}
inline void AckRoleData::set_char_merc(const void* value, size_t size) {
  set_has_char_merc();
  if (char_merc_ == &::google::protobuf::internal::kEmptyString) {
    char_merc_ = new ::std::string;
  }
  char_merc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRoleData::mutable_char_merc() {
  set_has_char_merc();
  if (char_merc_ == &::google::protobuf::internal::kEmptyString) {
    char_merc_ = new ::std::string;
  }
  return char_merc_;
}
inline ::std::string* AckRoleData::release_char_merc() {
  clear_has_char_merc();
  if (char_merc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_merc_;
    char_merc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckRoleData::set_allocated_char_merc(::std::string* char_merc) {
  if (char_merc_ != &::google::protobuf::internal::kEmptyString) {
    delete char_merc_;
  }
  if (char_merc) {
    set_has_char_merc();
    char_merc_ = char_merc;
  } else {
    clear_has_char_merc();
    char_merc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes char_equip = 10;
inline bool AckRoleData::has_char_equip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckRoleData::set_has_char_equip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckRoleData::clear_has_char_equip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckRoleData::clear_char_equip() {
  if (char_equip_ != &::google::protobuf::internal::kEmptyString) {
    char_equip_->clear();
  }
  clear_has_char_equip();
}
inline const ::std::string& AckRoleData::char_equip() const {
  return *char_equip_;
}
inline void AckRoleData::set_char_equip(const ::std::string& value) {
  set_has_char_equip();
  if (char_equip_ == &::google::protobuf::internal::kEmptyString) {
    char_equip_ = new ::std::string;
  }
  char_equip_->assign(value);
}
inline void AckRoleData::set_char_equip(const char* value) {
  set_has_char_equip();
  if (char_equip_ == &::google::protobuf::internal::kEmptyString) {
    char_equip_ = new ::std::string;
  }
  char_equip_->assign(value);
}
inline void AckRoleData::set_char_equip(const void* value, size_t size) {
  set_has_char_equip();
  if (char_equip_ == &::google::protobuf::internal::kEmptyString) {
    char_equip_ = new ::std::string;
  }
  char_equip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRoleData::mutable_char_equip() {
  set_has_char_equip();
  if (char_equip_ == &::google::protobuf::internal::kEmptyString) {
    char_equip_ = new ::std::string;
  }
  return char_equip_;
}
inline ::std::string* AckRoleData::release_char_equip() {
  clear_has_char_equip();
  if (char_equip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_equip_;
    char_equip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckRoleData::set_allocated_char_equip(::std::string* char_equip) {
  if (char_equip_ != &::google::protobuf::internal::kEmptyString) {
    delete char_equip_;
  }
  if (char_equip) {
    set_has_char_equip();
    char_equip_ = char_equip;
  } else {
    clear_has_char_equip();
    char_equip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 source_rank = 11;
inline bool AckRoleData::has_source_rank() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AckRoleData::set_has_source_rank() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AckRoleData::clear_has_source_rank() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AckRoleData::clear_source_rank() {
  source_rank_ = 0u;
  clear_has_source_rank();
}
inline ::google::protobuf::uint32 AckRoleData::source_rank() const {
  return source_rank_;
}
inline void AckRoleData::set_source_rank(::google::protobuf::uint32 value) {
  set_has_source_rank();
  source_rank_ = value;
}

// -------------------------------------------------------------------

// GetShopItemFromDB

// optional uint32 acc_id = 1;
inline bool GetShopItemFromDB::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetShopItemFromDB::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetShopItemFromDB::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetShopItemFromDB::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 GetShopItemFromDB::acc_id() const {
  return acc_id_;
}
inline void GetShopItemFromDB::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// GetShopItemAck

// repeated uint32 shop_type = 1;
inline int GetShopItemAck::shop_type_size() const {
  return shop_type_.size();
}
inline void GetShopItemAck::clear_shop_type() {
  shop_type_.Clear();
}
inline ::google::protobuf::uint32 GetShopItemAck::shop_type(int index) const {
  return shop_type_.Get(index);
}
inline void GetShopItemAck::set_shop_type(int index, ::google::protobuf::uint32 value) {
  shop_type_.Set(index, value);
}
inline void GetShopItemAck::add_shop_type(::google::protobuf::uint32 value) {
  shop_type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetShopItemAck::shop_type() const {
  return shop_type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetShopItemAck::mutable_shop_type() {
  return &shop_type_;
}

// repeated bytes item_data = 2;
inline int GetShopItemAck::item_data_size() const {
  return item_data_.size();
}
inline void GetShopItemAck::clear_item_data() {
  item_data_.Clear();
}
inline const ::std::string& GetShopItemAck::item_data(int index) const {
  return item_data_.Get(index);
}
inline ::std::string* GetShopItemAck::mutable_item_data(int index) {
  return item_data_.Mutable(index);
}
inline void GetShopItemAck::set_item_data(int index, const ::std::string& value) {
  item_data_.Mutable(index)->assign(value);
}
inline void GetShopItemAck::set_item_data(int index, const char* value) {
  item_data_.Mutable(index)->assign(value);
}
inline void GetShopItemAck::set_item_data(int index, const void* value, size_t size) {
  item_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetShopItemAck::add_item_data() {
  return item_data_.Add();
}
inline void GetShopItemAck::add_item_data(const ::std::string& value) {
  item_data_.Add()->assign(value);
}
inline void GetShopItemAck::add_item_data(const char* value) {
  item_data_.Add()->assign(value);
}
inline void GetShopItemAck::add_item_data(const void* value, size_t size) {
  item_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetShopItemAck::item_data() const {
  return item_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetShopItemAck::mutable_item_data() {
  return &item_data_;
}

// optional uint32 is_empty = 3;
inline bool GetShopItemAck::has_is_empty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetShopItemAck::set_has_is_empty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetShopItemAck::clear_has_is_empty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetShopItemAck::clear_is_empty() {
  is_empty_ = 0u;
  clear_has_is_empty();
}
inline ::google::protobuf::uint32 GetShopItemAck::is_empty() const {
  return is_empty_;
}
inline void GetShopItemAck::set_is_empty(::google::protobuf::uint32 value) {
  set_has_is_empty();
  is_empty_ = value;
}

// -------------------------------------------------------------------

// OpenShopUiReq

// optional uint32 shop_type = 1;
inline bool OpenShopUiReq::has_shop_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenShopUiReq::set_has_shop_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenShopUiReq::clear_has_shop_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenShopUiReq::clear_shop_type() {
  shop_type_ = 0u;
  clear_has_shop_type();
}
inline ::google::protobuf::uint32 OpenShopUiReq::shop_type() const {
  return shop_type_;
}
inline void OpenShopUiReq::set_shop_type(::google::protobuf::uint32 value) {
  set_has_shop_type();
  shop_type_ = value;
}

// -------------------------------------------------------------------

// OpenShopUiAck

// optional uint32 error_code = 1;
inline bool OpenShopUiAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenShopUiAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenShopUiAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenShopUiAck::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 OpenShopUiAck::error_code() const {
  return error_code_;
}
inline void OpenShopUiAck::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional uint32 oper_type = 2;
inline bool OpenShopUiAck::has_oper_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenShopUiAck::set_has_oper_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenShopUiAck::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenShopUiAck::clear_oper_type() {
  oper_type_ = 0u;
  clear_has_oper_type();
}
inline ::google::protobuf::uint32 OpenShopUiAck::oper_type() const {
  return oper_type_;
}
inline void OpenShopUiAck::set_oper_type(::google::protobuf::uint32 value) {
  set_has_oper_type();
  oper_type_ = value;
}

// repeated bytes item_data = 3;
inline int OpenShopUiAck::item_data_size() const {
  return item_data_.size();
}
inline void OpenShopUiAck::clear_item_data() {
  item_data_.Clear();
}
inline const ::std::string& OpenShopUiAck::item_data(int index) const {
  return item_data_.Get(index);
}
inline ::std::string* OpenShopUiAck::mutable_item_data(int index) {
  return item_data_.Mutable(index);
}
inline void OpenShopUiAck::set_item_data(int index, const ::std::string& value) {
  item_data_.Mutable(index)->assign(value);
}
inline void OpenShopUiAck::set_item_data(int index, const char* value) {
  item_data_.Mutable(index)->assign(value);
}
inline void OpenShopUiAck::set_item_data(int index, const void* value, size_t size) {
  item_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenShopUiAck::add_item_data() {
  return item_data_.Add();
}
inline void OpenShopUiAck::add_item_data(const ::std::string& value) {
  item_data_.Add()->assign(value);
}
inline void OpenShopUiAck::add_item_data(const char* value) {
  item_data_.Add()->assign(value);
}
inline void OpenShopUiAck::add_item_data(const void* value, size_t size) {
  item_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OpenShopUiAck::item_data() const {
  return item_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OpenShopUiAck::mutable_item_data() {
  return &item_data_;
}

// -------------------------------------------------------------------

// BuyItem

// optional uint32 shop_type = 1;
inline bool BuyItem::has_shop_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyItem::set_has_shop_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyItem::clear_has_shop_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyItem::clear_shop_type() {
  shop_type_ = 0u;
  clear_has_shop_type();
}
inline ::google::protobuf::uint32 BuyItem::shop_type() const {
  return shop_type_;
}
inline void BuyItem::set_shop_type(::google::protobuf::uint32 value) {
  set_has_shop_type();
  shop_type_ = value;
}

// optional uint32 item_pos = 2;
inline bool BuyItem::has_item_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyItem::set_has_item_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyItem::clear_has_item_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyItem::clear_item_pos() {
  item_pos_ = 0u;
  clear_has_item_pos();
}
inline ::google::protobuf::uint32 BuyItem::item_pos() const {
  return item_pos_;
}
inline void BuyItem::set_item_pos(::google::protobuf::uint32 value) {
  set_has_item_pos();
  item_pos_ = value;
}

// -------------------------------------------------------------------

// RefreshShopReq

// optional uint32 shop_type = 1;
inline bool RefreshShopReq::has_shop_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefreshShopReq::set_has_shop_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefreshShopReq::clear_has_shop_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefreshShopReq::clear_shop_type() {
  shop_type_ = 0u;
  clear_has_shop_type();
}
inline ::google::protobuf::uint32 RefreshShopReq::shop_type() const {
  return shop_type_;
}
inline void RefreshShopReq::set_shop_type(::google::protobuf::uint32 value) {
  set_has_shop_type();
  shop_type_ = value;
}

// -------------------------------------------------------------------

// SellItem

// required uint64 item_only_id = 1;
inline bool SellItem::has_item_only_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SellItem::set_has_item_only_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SellItem::clear_has_item_only_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SellItem::clear_item_only_id() {
  item_only_id_ = GOOGLE_ULONGLONG(0);
  clear_has_item_only_id();
}
inline ::google::protobuf::uint64 SellItem::item_only_id() const {
  return item_only_id_;
}
inline void SellItem::set_item_only_id(::google::protobuf::uint64 value) {
  set_has_item_only_id();
  item_only_id_ = value;
}

// required uint32 item_num = 2;
inline bool SellItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SellItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SellItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SellItem::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 SellItem::item_num() const {
  return item_num_;
}
inline void SellItem::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional uint32 is_choose = 3;
inline bool SellItem::has_is_choose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SellItem::set_has_is_choose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SellItem::clear_has_is_choose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SellItem::clear_is_choose() {
  is_choose_ = 0u;
  clear_has_is_choose();
}
inline ::google::protobuf::uint32 SellItem::is_choose() const {
  return is_choose_;
}
inline void SellItem::set_is_choose(::google::protobuf::uint32 value) {
  set_has_is_choose();
  is_choose_ = value;
}

// -------------------------------------------------------------------

// ChangeSkill

// required uint32 pos = 1;
inline bool ChangeSkill::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeSkill::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeSkill::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeSkill::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 ChangeSkill::pos() const {
  return pos_;
}
inline void ChangeSkill::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// required uint32 skill_id = 2;
inline bool ChangeSkill::has_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeSkill::set_has_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeSkill::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeSkill::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 ChangeSkill::skill_id() const {
  return skill_id_;
}
inline void ChangeSkill::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// -------------------------------------------------------------------

// SkillLevelUp

// required uint32 pos = 1;
inline bool SkillLevelUp::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillLevelUp::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillLevelUp::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillLevelUp::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 SkillLevelUp::pos() const {
  return pos_;
}
inline void SkillLevelUp::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// required uint32 skill_id = 2;
inline bool SkillLevelUp::has_skill_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillLevelUp::set_has_skill_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillLevelUp::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillLevelUp::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 SkillLevelUp::skill_id() const {
  return skill_id_;
}
inline void SkillLevelUp::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// -------------------------------------------------------------------

// ReqLevelUpStar

// required uint32 pos = 1;
inline bool ReqLevelUpStar::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLevelUpStar::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLevelUpStar::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLevelUpStar::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 ReqLevelUpStar::pos() const {
  return pos_;
}
inline void ReqLevelUpStar::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional uint32 is_choose = 2;
inline bool ReqLevelUpStar::has_is_choose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLevelUpStar::set_has_is_choose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLevelUpStar::clear_has_is_choose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLevelUpStar::clear_is_choose() {
  is_choose_ = 0u;
  clear_has_is_choose();
}
inline ::google::protobuf::uint32 ReqLevelUpStar::is_choose() const {
  return is_choose_;
}
inline void ReqLevelUpStar::set_is_choose(::google::protobuf::uint32 value) {
  set_has_is_choose();
  is_choose_ = value;
}

// -------------------------------------------------------------------

// UpgradeItem

// required uint32 char_pos = 1;
inline bool UpgradeItem::has_char_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeItem::set_has_char_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeItem::clear_has_char_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeItem::clear_char_pos() {
  char_pos_ = 0u;
  clear_has_char_pos();
}
inline ::google::protobuf::uint32 UpgradeItem::char_pos() const {
  return char_pos_;
}
inline void UpgradeItem::set_char_pos(::google::protobuf::uint32 value) {
  set_has_char_pos();
  char_pos_ = value;
}

// required uint32 item_pos = 2;
inline bool UpgradeItem::has_item_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeItem::set_has_item_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeItem::clear_has_item_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeItem::clear_item_pos() {
  item_pos_ = 0u;
  clear_has_item_pos();
}
inline ::google::protobuf::uint32 UpgradeItem::item_pos() const {
  return item_pos_;
}
inline void UpgradeItem::set_item_pos(::google::protobuf::uint32 value) {
  set_has_item_pos();
  item_pos_ = value;
}

// required uint64 item_only_id = 3;
inline bool UpgradeItem::has_item_only_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeItem::set_has_item_only_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeItem::clear_has_item_only_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeItem::clear_item_only_id() {
  item_only_id_ = GOOGLE_ULONGLONG(0);
  clear_has_item_only_id();
}
inline ::google::protobuf::uint64 UpgradeItem::item_only_id() const {
  return item_only_id_;
}
inline void UpgradeItem::set_item_only_id(::google::protobuf::uint64 value) {
  set_has_item_only_id();
  item_only_id_ = value;
}

// optional uint32 is_dest = 4;
inline bool UpgradeItem::has_is_dest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeItem::set_has_is_dest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeItem::clear_has_is_dest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeItem::clear_is_dest() {
  is_dest_ = 0u;
  clear_has_is_dest();
}
inline ::google::protobuf::uint32 UpgradeItem::is_dest() const {
  return is_dest_;
}
inline void UpgradeItem::set_is_dest(::google::protobuf::uint32 value) {
  set_has_is_dest();
  is_dest_ = value;
}

// optional uint32 quick_upgrade = 5;
inline bool UpgradeItem::has_quick_upgrade() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpgradeItem::set_has_quick_upgrade() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpgradeItem::clear_has_quick_upgrade() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpgradeItem::clear_quick_upgrade() {
  quick_upgrade_ = 0u;
  clear_has_quick_upgrade();
}
inline ::google::protobuf::uint32 UpgradeItem::quick_upgrade() const {
  return quick_upgrade_;
}
inline void UpgradeItem::set_quick_upgrade(::google::protobuf::uint32 value) {
  set_has_quick_upgrade();
  quick_upgrade_ = value;
}

// -------------------------------------------------------------------

// ReqRankList

// required uint32 rank_type = 1;
inline bool ReqRankList::has_rank_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqRankList::set_has_rank_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqRankList::clear_has_rank_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqRankList::clear_rank_type() {
  rank_type_ = 0u;
  clear_has_rank_type();
}
inline ::google::protobuf::uint32 ReqRankList::rank_type() const {
  return rank_type_;
}
inline void ReqRankList::set_rank_type(::google::protobuf::uint32 value) {
  set_has_rank_type();
  rank_type_ = value;
}

// optional uint32 page = 2;
inline bool ReqRankList::has_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqRankList::set_has_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqRankList::clear_has_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqRankList::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 ReqRankList::page() const {
  return page_;
}
inline void ReqRankList::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// -------------------------------------------------------------------

// AckRankList_RankInfo

// required uint32 rank_id = 1;
inline bool AckRankList_RankInfo::has_rank_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRankList_RankInfo::set_has_rank_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRankList_RankInfo::clear_has_rank_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRankList_RankInfo::clear_rank_id() {
  rank_id_ = 0u;
  clear_has_rank_id();
}
inline ::google::protobuf::uint32 AckRankList_RankInfo::rank_id() const {
  return rank_id_;
}
inline void AckRankList_RankInfo::set_rank_id(::google::protobuf::uint32 value) {
  set_has_rank_id();
  rank_id_ = value;
}

// required bytes char_name = 2;
inline bool AckRankList_RankInfo::has_char_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRankList_RankInfo::set_has_char_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRankList_RankInfo::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRankList_RankInfo::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& AckRankList_RankInfo::char_name() const {
  return *char_name_;
}
inline void AckRankList_RankInfo::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void AckRankList_RankInfo::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void AckRankList_RankInfo::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRankList_RankInfo::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* AckRankList_RankInfo::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckRankList_RankInfo::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 char_rank = 3;
inline bool AckRankList_RankInfo::has_char_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckRankList_RankInfo::set_has_char_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckRankList_RankInfo::clear_has_char_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckRankList_RankInfo::clear_char_rank() {
  char_rank_ = 0u;
  clear_has_char_rank();
}
inline ::google::protobuf::uint32 AckRankList_RankInfo::char_rank() const {
  return char_rank_;
}
inline void AckRankList_RankInfo::set_char_rank(::google::protobuf::uint32 value) {
  set_has_char_rank();
  char_rank_ = value;
}

// required uint32 rank_value = 4;
inline bool AckRankList_RankInfo::has_rank_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckRankList_RankInfo::set_has_rank_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckRankList_RankInfo::clear_has_rank_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckRankList_RankInfo::clear_rank_value() {
  rank_value_ = 0u;
  clear_has_rank_value();
}
inline ::google::protobuf::uint32 AckRankList_RankInfo::rank_value() const {
  return rank_value_;
}
inline void AckRankList_RankInfo::set_rank_value(::google::protobuf::uint32 value) {
  set_has_rank_value();
  rank_value_ = value;
}

// optional uint32 is_myself = 5;
inline bool AckRankList_RankInfo::has_is_myself() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckRankList_RankInfo::set_has_is_myself() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckRankList_RankInfo::clear_has_is_myself() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckRankList_RankInfo::clear_is_myself() {
  is_myself_ = 0u;
  clear_has_is_myself();
}
inline ::google::protobuf::uint32 AckRankList_RankInfo::is_myself() const {
  return is_myself_;
}
inline void AckRankList_RankInfo::set_is_myself(::google::protobuf::uint32 value) {
  set_has_is_myself();
  is_myself_ = value;
}

// optional uint32 fight_score = 6;
inline bool AckRankList_RankInfo::has_fight_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckRankList_RankInfo::set_has_fight_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckRankList_RankInfo::clear_has_fight_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckRankList_RankInfo::clear_fight_score() {
  fight_score_ = 0u;
  clear_has_fight_score();
}
inline ::google::protobuf::uint32 AckRankList_RankInfo::fight_score() const {
  return fight_score_;
}
inline void AckRankList_RankInfo::set_fight_score(::google::protobuf::uint32 value) {
  set_has_fight_score();
  fight_score_ = value;
}

// optional uint32 char_level = 7;
inline bool AckRankList_RankInfo::has_char_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckRankList_RankInfo::set_has_char_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckRankList_RankInfo::clear_has_char_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckRankList_RankInfo::clear_char_level() {
  char_level_ = 0u;
  clear_has_char_level();
}
inline ::google::protobuf::uint32 AckRankList_RankInfo::char_level() const {
  return char_level_;
}
inline void AckRankList_RankInfo::set_char_level(::google::protobuf::uint32 value) {
  set_has_char_level();
  char_level_ = value;
}

// -------------------------------------------------------------------

// AckRankList

// repeated .message.AckRankList.RankInfo rank_info = 1;
inline int AckRankList::rank_info_size() const {
  return rank_info_.size();
}
inline void AckRankList::clear_rank_info() {
  rank_info_.Clear();
}
inline const ::message::AckRankList_RankInfo& AckRankList::rank_info(int index) const {
  return rank_info_.Get(index);
}
inline ::message::AckRankList_RankInfo* AckRankList::mutable_rank_info(int index) {
  return rank_info_.Mutable(index);
}
inline ::message::AckRankList_RankInfo* AckRankList::add_rank_info() {
  return rank_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::AckRankList_RankInfo >&
AckRankList::rank_info() const {
  return rank_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::AckRankList_RankInfo >*
AckRankList::mutable_rank_info() {
  return &rank_info_;
}

// optional bytes rank_time = 2;
inline bool AckRankList::has_rank_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRankList::set_has_rank_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRankList::clear_has_rank_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRankList::clear_rank_time() {
  if (rank_time_ != &::google::protobuf::internal::kEmptyString) {
    rank_time_->clear();
  }
  clear_has_rank_time();
}
inline const ::std::string& AckRankList::rank_time() const {
  return *rank_time_;
}
inline void AckRankList::set_rank_time(const ::std::string& value) {
  set_has_rank_time();
  if (rank_time_ == &::google::protobuf::internal::kEmptyString) {
    rank_time_ = new ::std::string;
  }
  rank_time_->assign(value);
}
inline void AckRankList::set_rank_time(const char* value) {
  set_has_rank_time();
  if (rank_time_ == &::google::protobuf::internal::kEmptyString) {
    rank_time_ = new ::std::string;
  }
  rank_time_->assign(value);
}
inline void AckRankList::set_rank_time(const void* value, size_t size) {
  set_has_rank_time();
  if (rank_time_ == &::google::protobuf::internal::kEmptyString) {
    rank_time_ = new ::std::string;
  }
  rank_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRankList::mutable_rank_time() {
  set_has_rank_time();
  if (rank_time_ == &::google::protobuf::internal::kEmptyString) {
    rank_time_ = new ::std::string;
  }
  return rank_time_;
}
inline ::std::string* AckRankList::release_rank_time() {
  clear_has_rank_time();
  if (rank_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rank_time_;
    rank_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckRankList::set_allocated_rank_time(::std::string* rank_time) {
  if (rank_time_ != &::google::protobuf::internal::kEmptyString) {
    delete rank_time_;
  }
  if (rank_time) {
    set_has_rank_time();
    rank_time_ = rank_time;
  } else {
    clear_has_rank_time();
    rank_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 my_rank = 3;
inline bool AckRankList::has_my_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckRankList::set_has_my_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckRankList::clear_has_my_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckRankList::clear_my_rank() {
  my_rank_ = 0u;
  clear_has_my_rank();
}
inline ::google::protobuf::uint32 AckRankList::my_rank() const {
  return my_rank_;
}
inline void AckRankList::set_my_rank(::google::protobuf::uint32 value) {
  set_has_my_rank();
  my_rank_ = value;
}

// optional uint32 page = 4;
inline bool AckRankList::has_page() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckRankList::set_has_page() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckRankList::clear_has_page() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckRankList::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 AckRankList::page() const {
  return page_;
}
inline void AckRankList::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// -------------------------------------------------------------------

// ReqServerRank

// required uint32 rank_id = 1;
inline bool ReqServerRank::has_rank_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqServerRank::set_has_rank_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqServerRank::clear_has_rank_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqServerRank::clear_rank_id() {
  rank_id_ = 0u;
  clear_has_rank_id();
}
inline ::google::protobuf::uint32 ReqServerRank::rank_id() const {
  return rank_id_;
}
inline void ReqServerRank::set_rank_id(::google::protobuf::uint32 value) {
  set_has_rank_id();
  rank_id_ = value;
}

// -------------------------------------------------------------------

// AckServerRank_RankInfo

// optional uint32 char_id = 1;
inline bool AckServerRank_RankInfo::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckServerRank_RankInfo::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckServerRank_RankInfo::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckServerRank_RankInfo::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 AckServerRank_RankInfo::char_id() const {
  return char_id_;
}
inline void AckServerRank_RankInfo::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// optional bytes name = 2;
inline bool AckServerRank_RankInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckServerRank_RankInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckServerRank_RankInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckServerRank_RankInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckServerRank_RankInfo::name() const {
  return *name_;
}
inline void AckServerRank_RankInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckServerRank_RankInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckServerRank_RankInfo::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckServerRank_RankInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckServerRank_RankInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckServerRank_RankInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rank = 3;
inline bool AckServerRank_RankInfo::has_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckServerRank_RankInfo::set_has_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckServerRank_RankInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckServerRank_RankInfo::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 AckServerRank_RankInfo::rank() const {
  return rank_;
}
inline void AckServerRank_RankInfo::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
}

// optional uint32 level = 4;
inline bool AckServerRank_RankInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckServerRank_RankInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckServerRank_RankInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckServerRank_RankInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 AckServerRank_RankInfo::level() const {
  return level_;
}
inline void AckServerRank_RankInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 sex = 5;
inline bool AckServerRank_RankInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckServerRank_RankInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckServerRank_RankInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckServerRank_RankInfo::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 AckServerRank_RankInfo::sex() const {
  return sex_;
}
inline void AckServerRank_RankInfo::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 job = 6;
inline bool AckServerRank_RankInfo::has_job() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckServerRank_RankInfo::set_has_job() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckServerRank_RankInfo::clear_has_job() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckServerRank_RankInfo::clear_job() {
  job_ = 0u;
  clear_has_job();
}
inline ::google::protobuf::uint32 AckServerRank_RankInfo::job() const {
  return job_;
}
inline void AckServerRank_RankInfo::set_job(::google::protobuf::uint32 value) {
  set_has_job();
  job_ = value;
}

// optional uint32 rank_value = 7;
inline bool AckServerRank_RankInfo::has_rank_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckServerRank_RankInfo::set_has_rank_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckServerRank_RankInfo::clear_has_rank_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckServerRank_RankInfo::clear_rank_value() {
  rank_value_ = 0u;
  clear_has_rank_value();
}
inline ::google::protobuf::uint32 AckServerRank_RankInfo::rank_value() const {
  return rank_value_;
}
inline void AckServerRank_RankInfo::set_rank_value(::google::protobuf::uint32 value) {
  set_has_rank_value();
  rank_value_ = value;
}

// -------------------------------------------------------------------

// AckServerRank

// repeated .message.AckServerRank.RankInfo rank_info = 1;
inline int AckServerRank::rank_info_size() const {
  return rank_info_.size();
}
inline void AckServerRank::clear_rank_info() {
  rank_info_.Clear();
}
inline const ::message::AckServerRank_RankInfo& AckServerRank::rank_info(int index) const {
  return rank_info_.Get(index);
}
inline ::message::AckServerRank_RankInfo* AckServerRank::mutable_rank_info(int index) {
  return rank_info_.Mutable(index);
}
inline ::message::AckServerRank_RankInfo* AckServerRank::add_rank_info() {
  return rank_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::AckServerRank_RankInfo >&
AckServerRank::rank_info() const {
  return rank_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::AckServerRank_RankInfo >*
AckServerRank::mutable_rank_info() {
  return &rank_info_;
}

// optional uint32 rank_type = 2;
inline bool AckServerRank::has_rank_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckServerRank::set_has_rank_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckServerRank::clear_has_rank_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckServerRank::clear_rank_type() {
  rank_type_ = 0u;
  clear_has_rank_type();
}
inline ::google::protobuf::uint32 AckServerRank::rank_type() const {
  return rank_type_;
}
inline void AckServerRank::set_rank_type(::google::protobuf::uint32 value) {
  set_has_rank_type();
  rank_type_ = value;
}

// -------------------------------------------------------------------

// ReqChessData

// required uint32 chess_type = 1;
inline bool ReqChessData::has_chess_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqChessData::set_has_chess_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqChessData::clear_has_chess_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqChessData::clear_chess_type() {
  chess_type_ = 0u;
  clear_has_chess_type();
}
inline ::google::protobuf::uint32 ReqChessData::chess_type() const {
  return chess_type_;
}
inline void ReqChessData::set_chess_type(::google::protobuf::uint32 value) {
  set_has_chess_type();
  chess_type_ = value;
}

// required uint32 friend_id = 2;
inline bool ReqChessData::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqChessData::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqChessData::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqChessData::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 ReqChessData::friend_id() const {
  return friend_id_;
}
inline void ReqChessData::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
}

// -------------------------------------------------------------------

// AckChessData

// required uint32 remain_time = 1;
inline bool AckChessData::has_remain_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckChessData::set_has_remain_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckChessData::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckChessData::clear_remain_time() {
  remain_time_ = 0u;
  clear_has_remain_time();
}
inline ::google::protobuf::uint32 AckChessData::remain_time() const {
  return remain_time_;
}
inline void AckChessData::set_remain_time(::google::protobuf::uint32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// -------------------------------------------------------------------

// ReqRunChess

// required uint32 chess_type = 1;
inline bool ReqRunChess::has_chess_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqRunChess::set_has_chess_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqRunChess::clear_has_chess_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqRunChess::clear_chess_type() {
  chess_type_ = 0u;
  clear_has_chess_type();
}
inline ::google::protobuf::uint32 ReqRunChess::chess_type() const {
  return chess_type_;
}
inline void ReqRunChess::set_chess_type(::google::protobuf::uint32 value) {
  set_has_chess_type();
  chess_type_ = value;
}

// optional bytes friend_id = 2;
inline bool ReqRunChess::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqRunChess::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqRunChess::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqRunChess::clear_friend_id() {
  if (friend_id_ != &::google::protobuf::internal::kEmptyString) {
    friend_id_->clear();
  }
  clear_has_friend_id();
}
inline const ::std::string& ReqRunChess::friend_id() const {
  return *friend_id_;
}
inline void ReqRunChess::set_friend_id(const ::std::string& value) {
  set_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_id_ = new ::std::string;
  }
  friend_id_->assign(value);
}
inline void ReqRunChess::set_friend_id(const char* value) {
  set_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_id_ = new ::std::string;
  }
  friend_id_->assign(value);
}
inline void ReqRunChess::set_friend_id(const void* value, size_t size) {
  set_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_id_ = new ::std::string;
  }
  friend_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRunChess::mutable_friend_id() {
  set_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_id_ = new ::std::string;
  }
  return friend_id_;
}
inline ::std::string* ReqRunChess::release_friend_id() {
  clear_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friend_id_;
    friend_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqRunChess::set_allocated_friend_id(::std::string* friend_id) {
  if (friend_id_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_id_;
  }
  if (friend_id) {
    set_has_friend_id();
    friend_id_ = friend_id;
  } else {
    clear_has_friend_id();
    friend_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 is_fast = 3;
inline bool ReqRunChess::has_is_fast() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqRunChess::set_has_is_fast() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqRunChess::clear_has_is_fast() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqRunChess::clear_is_fast() {
  is_fast_ = 0u;
  clear_has_is_fast();
}
inline ::google::protobuf::uint32 ReqRunChess::is_fast() const {
  return is_fast_;
}
inline void ReqRunChess::set_is_fast(::google::protobuf::uint32 value) {
  set_has_is_fast();
  is_fast_ = value;
}

// -------------------------------------------------------------------

// AckRunChess

// required uint32 chess_type = 1;
inline bool AckRunChess::has_chess_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRunChess::set_has_chess_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRunChess::clear_has_chess_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRunChess::clear_chess_type() {
  chess_type_ = 0u;
  clear_has_chess_type();
}
inline ::google::protobuf::uint32 AckRunChess::chess_type() const {
  return chess_type_;
}
inline void AckRunChess::set_chess_type(::google::protobuf::uint32 value) {
  set_has_chess_type();
  chess_type_ = value;
}

// required uint32 chess_move = 2;
inline bool AckRunChess::has_chess_move() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRunChess::set_has_chess_move() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRunChess::clear_has_chess_move() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRunChess::clear_chess_move() {
  chess_move_ = 0u;
  clear_has_chess_move();
}
inline ::google::protobuf::uint32 AckRunChess::chess_move() const {
  return chess_move_;
}
inline void AckRunChess::set_chess_move(::google::protobuf::uint32 value) {
  set_has_chess_move();
  chess_move_ = value;
}

// repeated uint32 reward_item = 3;
inline int AckRunChess::reward_item_size() const {
  return reward_item_.size();
}
inline void AckRunChess::clear_reward_item() {
  reward_item_.Clear();
}
inline ::google::protobuf::uint32 AckRunChess::reward_item(int index) const {
  return reward_item_.Get(index);
}
inline void AckRunChess::set_reward_item(int index, ::google::protobuf::uint32 value) {
  reward_item_.Set(index, value);
}
inline void AckRunChess::add_reward_item(::google::protobuf::uint32 value) {
  reward_item_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckRunChess::reward_item() const {
  return reward_item_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckRunChess::mutable_reward_item() {
  return &reward_item_;
}

// repeated uint32 reward_item_num = 4;
inline int AckRunChess::reward_item_num_size() const {
  return reward_item_num_.size();
}
inline void AckRunChess::clear_reward_item_num() {
  reward_item_num_.Clear();
}
inline ::google::protobuf::uint32 AckRunChess::reward_item_num(int index) const {
  return reward_item_num_.Get(index);
}
inline void AckRunChess::set_reward_item_num(int index, ::google::protobuf::uint32 value) {
  reward_item_num_.Set(index, value);
}
inline void AckRunChess::add_reward_item_num(::google::protobuf::uint32 value) {
  reward_item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckRunChess::reward_item_num() const {
  return reward_item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckRunChess::mutable_reward_item_num() {
  return &reward_item_num_;
}

// optional uint32 event_id = 5;
inline bool AckRunChess::has_event_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckRunChess::set_has_event_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckRunChess::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckRunChess::clear_event_id() {
  event_id_ = 0u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 AckRunChess::event_id() const {
  return event_id_;
}
inline void AckRunChess::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint32 is_friend = 6;
inline bool AckRunChess::has_is_friend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckRunChess::set_has_is_friend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckRunChess::clear_has_is_friend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckRunChess::clear_is_friend() {
  is_friend_ = 0u;
  clear_has_is_friend();
}
inline ::google::protobuf::uint32 AckRunChess::is_friend() const {
  return is_friend_;
}
inline void AckRunChess::set_is_friend(::google::protobuf::uint32 value) {
  set_has_is_friend();
  is_friend_ = value;
}

// optional uint32 is_fast = 7;
inline bool AckRunChess::has_is_fast() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckRunChess::set_has_is_fast() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckRunChess::clear_has_is_fast() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckRunChess::clear_is_fast() {
  is_fast_ = 0u;
  clear_has_is_fast();
}
inline ::google::protobuf::uint32 AckRunChess::is_fast() const {
  return is_fast_;
}
inline void AckRunChess::set_is_fast(::google::protobuf::uint32 value) {
  set_has_is_fast();
  is_fast_ = value;
}

// optional uint32 is_big = 8;
inline bool AckRunChess::has_is_big() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckRunChess::set_has_is_big() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckRunChess::clear_has_is_big() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckRunChess::clear_is_big() {
  is_big_ = 0u;
  clear_has_is_big();
}
inline ::google::protobuf::uint32 AckRunChess::is_big() const {
  return is_big_;
}
inline void AckRunChess::set_is_big(::google::protobuf::uint32 value) {
  set_has_is_big();
  is_big_ = value;
}

// -------------------------------------------------------------------

// AckChessRank_RankInfo

// required uint32 char_id = 1;
inline bool AckChessRank_RankInfo::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckChessRank_RankInfo::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckChessRank_RankInfo::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckChessRank_RankInfo::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 AckChessRank_RankInfo::char_id() const {
  return char_id_;
}
inline void AckChessRank_RankInfo::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// required bytes char_name = 2;
inline bool AckChessRank_RankInfo::has_char_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckChessRank_RankInfo::set_has_char_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckChessRank_RankInfo::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckChessRank_RankInfo::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& AckChessRank_RankInfo::char_name() const {
  return *char_name_;
}
inline void AckChessRank_RankInfo::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void AckChessRank_RankInfo::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void AckChessRank_RankInfo::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckChessRank_RankInfo::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* AckChessRank_RankInfo::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckChessRank_RankInfo::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 char_rank = 3;
inline bool AckChessRank_RankInfo::has_char_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckChessRank_RankInfo::set_has_char_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckChessRank_RankInfo::clear_has_char_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckChessRank_RankInfo::clear_char_rank() {
  char_rank_ = 0u;
  clear_has_char_rank();
}
inline ::google::protobuf::uint32 AckChessRank_RankInfo::char_rank() const {
  return char_rank_;
}
inline void AckChessRank_RankInfo::set_char_rank(::google::protobuf::uint32 value) {
  set_has_char_rank();
  char_rank_ = value;
}

// required uint32 rank_value = 4;
inline bool AckChessRank_RankInfo::has_rank_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckChessRank_RankInfo::set_has_rank_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckChessRank_RankInfo::clear_has_rank_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckChessRank_RankInfo::clear_rank_value() {
  rank_value_ = 0u;
  clear_has_rank_value();
}
inline ::google::protobuf::uint32 AckChessRank_RankInfo::rank_value() const {
  return rank_value_;
}
inline void AckChessRank_RankInfo::set_rank_value(::google::protobuf::uint32 value) {
  set_has_rank_value();
  rank_value_ = value;
}

// -------------------------------------------------------------------

// AckChessRank

// repeated .message.AckChessRank.RankInfo rank_info = 1;
inline int AckChessRank::rank_info_size() const {
  return rank_info_.size();
}
inline void AckChessRank::clear_rank_info() {
  rank_info_.Clear();
}
inline const ::message::AckChessRank_RankInfo& AckChessRank::rank_info(int index) const {
  return rank_info_.Get(index);
}
inline ::message::AckChessRank_RankInfo* AckChessRank::mutable_rank_info(int index) {
  return rank_info_.Mutable(index);
}
inline ::message::AckChessRank_RankInfo* AckChessRank::add_rank_info() {
  return rank_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::AckChessRank_RankInfo >&
AckChessRank::rank_info() const {
  return rank_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::AckChessRank_RankInfo >*
AckChessRank::mutable_rank_info() {
  return &rank_info_;
}

// required uint32 chess_type = 2;
inline bool AckChessRank::has_chess_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckChessRank::set_has_chess_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckChessRank::clear_has_chess_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckChessRank::clear_chess_type() {
  chess_type_ = 0u;
  clear_has_chess_type();
}
inline ::google::protobuf::uint32 AckChessRank::chess_type() const {
  return chess_type_;
}
inline void AckChessRank::set_chess_type(::google::protobuf::uint32 value) {
  set_has_chess_type();
  chess_type_ = value;
}

// -------------------------------------------------------------------

// UnlockTrainMercenary

// required uint32 pos = 1;
inline bool UnlockTrainMercenary::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlockTrainMercenary::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlockTrainMercenary::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlockTrainMercenary::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 UnlockTrainMercenary::pos() const {
  return pos_;
}
inline void UnlockTrainMercenary::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// TrainMercenary

// required uint32 merc_pos = 1;
inline bool TrainMercenary::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrainMercenary::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrainMercenary::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrainMercenary::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 TrainMercenary::merc_pos() const {
  return merc_pos_;
}
inline void TrainMercenary::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// required uint32 train_type = 2;
inline bool TrainMercenary::has_train_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrainMercenary::set_has_train_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrainMercenary::clear_has_train_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrainMercenary::clear_train_type() {
  train_type_ = 0u;
  clear_has_train_type();
}
inline ::google::protobuf::uint32 TrainMercenary::train_type() const {
  return train_type_;
}
inline void TrainMercenary::set_train_type(::google::protobuf::uint32 value) {
  set_has_train_type();
  train_type_ = value;
}

// optional uint32 friend_id = 3;
inline bool TrainMercenary::has_friend_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrainMercenary::set_has_friend_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrainMercenary::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrainMercenary::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 TrainMercenary::friend_id() const {
  return friend_id_;
}
inline void TrainMercenary::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
}

// -------------------------------------------------------------------

// ReqTrainMercenaryTime

// required uint32 train_id = 1;
inline bool ReqTrainMercenaryTime::has_train_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqTrainMercenaryTime::set_has_train_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqTrainMercenaryTime::clear_has_train_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqTrainMercenaryTime::clear_train_id() {
  train_id_ = 0u;
  clear_has_train_id();
}
inline ::google::protobuf::uint32 ReqTrainMercenaryTime::train_id() const {
  return train_id_;
}
inline void ReqTrainMercenaryTime::set_train_id(::google::protobuf::uint32 value) {
  set_has_train_id();
  train_id_ = value;
}

// -------------------------------------------------------------------

// AckTrainMercenaryTime

// repeated uint32 merc_pos = 1;
inline int AckTrainMercenaryTime::merc_pos_size() const {
  return merc_pos_.size();
}
inline void AckTrainMercenaryTime::clear_merc_pos() {
  merc_pos_.Clear();
}
inline ::google::protobuf::uint32 AckTrainMercenaryTime::merc_pos(int index) const {
  return merc_pos_.Get(index);
}
inline void AckTrainMercenaryTime::set_merc_pos(int index, ::google::protobuf::uint32 value) {
  merc_pos_.Set(index, value);
}
inline void AckTrainMercenaryTime::add_merc_pos(::google::protobuf::uint32 value) {
  merc_pos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckTrainMercenaryTime::merc_pos() const {
  return merc_pos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckTrainMercenaryTime::mutable_merc_pos() {
  return &merc_pos_;
}

// repeated uint32 remain_time = 2;
inline int AckTrainMercenaryTime::remain_time_size() const {
  return remain_time_.size();
}
inline void AckTrainMercenaryTime::clear_remain_time() {
  remain_time_.Clear();
}
inline ::google::protobuf::uint32 AckTrainMercenaryTime::remain_time(int index) const {
  return remain_time_.Get(index);
}
inline void AckTrainMercenaryTime::set_remain_time(int index, ::google::protobuf::uint32 value) {
  remain_time_.Set(index, value);
}
inline void AckTrainMercenaryTime::add_remain_time(::google::protobuf::uint32 value) {
  remain_time_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckTrainMercenaryTime::remain_time() const {
  return remain_time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckTrainMercenaryTime::mutable_remain_time() {
  return &remain_time_;
}

// -------------------------------------------------------------------

// ReqFriendTrainMercenaryTime

// required uint32 train_id = 1;
inline bool ReqFriendTrainMercenaryTime::has_train_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqFriendTrainMercenaryTime::set_has_train_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqFriendTrainMercenaryTime::clear_has_train_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqFriendTrainMercenaryTime::clear_train_id() {
  train_id_ = 0u;
  clear_has_train_id();
}
inline ::google::protobuf::uint32 ReqFriendTrainMercenaryTime::train_id() const {
  return train_id_;
}
inline void ReqFriendTrainMercenaryTime::set_train_id(::google::protobuf::uint32 value) {
  set_has_train_id();
  train_id_ = value;
}

// -------------------------------------------------------------------

// ReqAccelerateTrainMercenary

// required uint32 merc_pos = 1;
inline bool ReqAccelerateTrainMercenary::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAccelerateTrainMercenary::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAccelerateTrainMercenary::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAccelerateTrainMercenary::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 ReqAccelerateTrainMercenary::merc_pos() const {
  return merc_pos_;
}
inline void ReqAccelerateTrainMercenary::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// -------------------------------------------------------------------

// AckFriendTrainMercenaryTime_FriendTrainInfo

// required uint32 type_id = 1;
inline bool AckFriendTrainMercenaryTime_FriendTrainInfo::has_type_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::set_has_type_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::clear_has_type_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::clear_type_id() {
  type_id_ = 0u;
  clear_has_type_id();
}
inline ::google::protobuf::uint32 AckFriendTrainMercenaryTime_FriendTrainInfo::type_id() const {
  return type_id_;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::set_type_id(::google::protobuf::uint32 value) {
  set_has_type_id();
  type_id_ = value;
}

// required uint32 merc_pos = 2;
inline bool AckFriendTrainMercenaryTime_FriendTrainInfo::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 AckFriendTrainMercenaryTime_FriendTrainInfo::merc_pos() const {
  return merc_pos_;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// required bool is_help = 3;
inline bool AckFriendTrainMercenaryTime_FriendTrainInfo::has_is_help() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::set_has_is_help() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::clear_has_is_help() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::clear_is_help() {
  is_help_ = false;
  clear_has_is_help();
}
inline bool AckFriendTrainMercenaryTime_FriendTrainInfo::is_help() const {
  return is_help_;
}
inline void AckFriendTrainMercenaryTime_FriendTrainInfo::set_is_help(bool value) {
  set_has_is_help();
  is_help_ = value;
}

// -------------------------------------------------------------------

// AckFriendTrainMercenaryTime

// repeated .message.AckFriendTrainMercenaryTime.FriendTrainInfo friend_train_info = 1;
inline int AckFriendTrainMercenaryTime::friend_train_info_size() const {
  return friend_train_info_.size();
}
inline void AckFriendTrainMercenaryTime::clear_friend_train_info() {
  friend_train_info_.Clear();
}
inline const ::message::AckFriendTrainMercenaryTime_FriendTrainInfo& AckFriendTrainMercenaryTime::friend_train_info(int index) const {
  return friend_train_info_.Get(index);
}
inline ::message::AckFriendTrainMercenaryTime_FriendTrainInfo* AckFriendTrainMercenaryTime::mutable_friend_train_info(int index) {
  return friend_train_info_.Mutable(index);
}
inline ::message::AckFriendTrainMercenaryTime_FriendTrainInfo* AckFriendTrainMercenaryTime::add_friend_train_info() {
  return friend_train_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::AckFriendTrainMercenaryTime_FriendTrainInfo >&
AckFriendTrainMercenaryTime::friend_train_info() const {
  return friend_train_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::AckFriendTrainMercenaryTime_FriendTrainInfo >*
AckFriendTrainMercenaryTime::mutable_friend_train_info() {
  return &friend_train_info_;
}

// -------------------------------------------------------------------

// BuyMallItem

// required uint32 mall_id = 1;
inline bool BuyMallItem::has_mall_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyMallItem::set_has_mall_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyMallItem::clear_has_mall_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyMallItem::clear_mall_id() {
  mall_id_ = 0u;
  clear_has_mall_id();
}
inline ::google::protobuf::uint32 BuyMallItem::mall_id() const {
  return mall_id_;
}
inline void BuyMallItem::set_mall_id(::google::protobuf::uint32 value) {
  set_has_mall_id();
  mall_id_ = value;
}

// required uint32 item_num = 2;
inline bool BuyMallItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyMallItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyMallItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyMallItem::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 BuyMallItem::item_num() const {
  return item_num_;
}
inline void BuyMallItem::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// -------------------------------------------------------------------

// DailyWeekOnline

// required uint32 day_id = 1;
inline bool DailyWeekOnline::has_day_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyWeekOnline::set_has_day_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyWeekOnline::clear_has_day_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyWeekOnline::clear_day_id() {
  day_id_ = 0u;
  clear_has_day_id();
}
inline ::google::protobuf::uint32 DailyWeekOnline::day_id() const {
  return day_id_;
}
inline void DailyWeekOnline::set_day_id(::google::protobuf::uint32 value) {
  set_has_day_id();
  day_id_ = value;
}

// -------------------------------------------------------------------

// GetMonthSignInDataReq

// optional uint32 value = 1;
inline bool GetMonthSignInDataReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMonthSignInDataReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMonthSignInDataReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMonthSignInDataReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 GetMonthSignInDataReq::value() const {
  return value_;
}
inline void GetMonthSignInDataReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// GetMonthSignInDataAck

// required uint32 refresh_time = 1;
inline bool GetMonthSignInDataAck::has_refresh_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMonthSignInDataAck::set_has_refresh_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMonthSignInDataAck::clear_has_refresh_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMonthSignInDataAck::clear_refresh_time() {
  refresh_time_ = 0u;
  clear_has_refresh_time();
}
inline ::google::protobuf::uint32 GetMonthSignInDataAck::refresh_time() const {
  return refresh_time_;
}
inline void GetMonthSignInDataAck::set_refresh_time(::google::protobuf::uint32 value) {
  set_has_refresh_time();
  refresh_time_ = value;
}

// repeated uint32 item_id = 2;
inline int GetMonthSignInDataAck::item_id_size() const {
  return item_id_.size();
}
inline void GetMonthSignInDataAck::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::uint32 GetMonthSignInDataAck::item_id(int index) const {
  return item_id_.Get(index);
}
inline void GetMonthSignInDataAck::set_item_id(int index, ::google::protobuf::uint32 value) {
  item_id_.Set(index, value);
}
inline void GetMonthSignInDataAck::add_item_id(::google::protobuf::uint32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetMonthSignInDataAck::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetMonthSignInDataAck::mutable_item_id() {
  return &item_id_;
}

// repeated uint32 item_num = 3;
inline int GetMonthSignInDataAck::item_num_size() const {
  return item_num_.size();
}
inline void GetMonthSignInDataAck::clear_item_num() {
  item_num_.Clear();
}
inline ::google::protobuf::uint32 GetMonthSignInDataAck::item_num(int index) const {
  return item_num_.Get(index);
}
inline void GetMonthSignInDataAck::set_item_num(int index, ::google::protobuf::uint32 value) {
  item_num_.Set(index, value);
}
inline void GetMonthSignInDataAck::add_item_num(::google::protobuf::uint32 value) {
  item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetMonthSignInDataAck::item_num() const {
  return item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetMonthSignInDataAck::mutable_item_num() {
  return &item_num_;
}

// repeated uint32 vip_limit = 4;
inline int GetMonthSignInDataAck::vip_limit_size() const {
  return vip_limit_.size();
}
inline void GetMonthSignInDataAck::clear_vip_limit() {
  vip_limit_.Clear();
}
inline ::google::protobuf::uint32 GetMonthSignInDataAck::vip_limit(int index) const {
  return vip_limit_.Get(index);
}
inline void GetMonthSignInDataAck::set_vip_limit(int index, ::google::protobuf::uint32 value) {
  vip_limit_.Set(index, value);
}
inline void GetMonthSignInDataAck::add_vip_limit(::google::protobuf::uint32 value) {
  vip_limit_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetMonthSignInDataAck::vip_limit() const {
  return vip_limit_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetMonthSignInDataAck::mutable_vip_limit() {
  return &vip_limit_;
}

// repeated uint32 reward_times = 5;
inline int GetMonthSignInDataAck::reward_times_size() const {
  return reward_times_.size();
}
inline void GetMonthSignInDataAck::clear_reward_times() {
  reward_times_.Clear();
}
inline ::google::protobuf::uint32 GetMonthSignInDataAck::reward_times(int index) const {
  return reward_times_.Get(index);
}
inline void GetMonthSignInDataAck::set_reward_times(int index, ::google::protobuf::uint32 value) {
  reward_times_.Set(index, value);
}
inline void GetMonthSignInDataAck::add_reward_times(::google::protobuf::uint32 value) {
  reward_times_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetMonthSignInDataAck::reward_times() const {
  return reward_times_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetMonthSignInDataAck::mutable_reward_times() {
  return &reward_times_;
}

// repeated uint32 week_item_id = 6;
inline int GetMonthSignInDataAck::week_item_id_size() const {
  return week_item_id_.size();
}
inline void GetMonthSignInDataAck::clear_week_item_id() {
  week_item_id_.Clear();
}
inline ::google::protobuf::uint32 GetMonthSignInDataAck::week_item_id(int index) const {
  return week_item_id_.Get(index);
}
inline void GetMonthSignInDataAck::set_week_item_id(int index, ::google::protobuf::uint32 value) {
  week_item_id_.Set(index, value);
}
inline void GetMonthSignInDataAck::add_week_item_id(::google::protobuf::uint32 value) {
  week_item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetMonthSignInDataAck::week_item_id() const {
  return week_item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetMonthSignInDataAck::mutable_week_item_id() {
  return &week_item_id_;
}

// repeated uint32 week_item_num = 7;
inline int GetMonthSignInDataAck::week_item_num_size() const {
  return week_item_num_.size();
}
inline void GetMonthSignInDataAck::clear_week_item_num() {
  week_item_num_.Clear();
}
inline ::google::protobuf::uint32 GetMonthSignInDataAck::week_item_num(int index) const {
  return week_item_num_.Get(index);
}
inline void GetMonthSignInDataAck::set_week_item_num(int index, ::google::protobuf::uint32 value) {
  week_item_num_.Set(index, value);
}
inline void GetMonthSignInDataAck::add_week_item_num(::google::protobuf::uint32 value) {
  week_item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetMonthSignInDataAck::week_item_num() const {
  return week_item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetMonthSignInDataAck::mutable_week_item_num() {
  return &week_item_num_;
}

// -------------------------------------------------------------------

// DailyMonthOnline

// required uint32 day_id = 1;
inline bool DailyMonthOnline::has_day_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyMonthOnline::set_has_day_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyMonthOnline::clear_has_day_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyMonthOnline::clear_day_id() {
  day_id_ = 0u;
  clear_has_day_id();
}
inline ::google::protobuf::uint32 DailyMonthOnline::day_id() const {
  return day_id_;
}
inline void DailyMonthOnline::set_day_id(::google::protobuf::uint32 value) {
  set_has_day_id();
  day_id_ = value;
}

// -------------------------------------------------------------------

// ReqDailyMonthOnlineData

// required uint32 data_id = 1;
inline bool ReqDailyMonthOnlineData::has_data_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqDailyMonthOnlineData::set_has_data_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqDailyMonthOnlineData::clear_has_data_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqDailyMonthOnlineData::clear_data_id() {
  data_id_ = 0u;
  clear_has_data_id();
}
inline ::google::protobuf::uint32 ReqDailyMonthOnlineData::data_id() const {
  return data_id_;
}
inline void ReqDailyMonthOnlineData::set_data_id(::google::protobuf::uint32 value) {
  set_has_data_id();
  data_id_ = value;
}

// -------------------------------------------------------------------

// AckDailyMonthOnlineData

// repeated bytes daily_data = 1;
inline int AckDailyMonthOnlineData::daily_data_size() const {
  return daily_data_.size();
}
inline void AckDailyMonthOnlineData::clear_daily_data() {
  daily_data_.Clear();
}
inline const ::std::string& AckDailyMonthOnlineData::daily_data(int index) const {
  return daily_data_.Get(index);
}
inline ::std::string* AckDailyMonthOnlineData::mutable_daily_data(int index) {
  return daily_data_.Mutable(index);
}
inline void AckDailyMonthOnlineData::set_daily_data(int index, const ::std::string& value) {
  daily_data_.Mutable(index)->assign(value);
}
inline void AckDailyMonthOnlineData::set_daily_data(int index, const char* value) {
  daily_data_.Mutable(index)->assign(value);
}
inline void AckDailyMonthOnlineData::set_daily_data(int index, const void* value, size_t size) {
  daily_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckDailyMonthOnlineData::add_daily_data() {
  return daily_data_.Add();
}
inline void AckDailyMonthOnlineData::add_daily_data(const ::std::string& value) {
  daily_data_.Add()->assign(value);
}
inline void AckDailyMonthOnlineData::add_daily_data(const char* value) {
  daily_data_.Add()->assign(value);
}
inline void AckDailyMonthOnlineData::add_daily_data(const void* value, size_t size) {
  daily_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AckDailyMonthOnlineData::daily_data() const {
  return daily_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AckDailyMonthOnlineData::mutable_daily_data() {
  return &daily_data_;
}

// -------------------------------------------------------------------

// ReqSoulBag

// required uint32 bag_id = 1;
inline bool ReqSoulBag::has_bag_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSoulBag::set_has_bag_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSoulBag::clear_has_bag_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSoulBag::clear_bag_id() {
  bag_id_ = 0u;
  clear_has_bag_id();
}
inline ::google::protobuf::uint32 ReqSoulBag::bag_id() const {
  return bag_id_;
}
inline void ReqSoulBag::set_bag_id(::google::protobuf::uint32 value) {
  set_has_bag_id();
  bag_id_ = value;
}

// optional uint32 is_dest = 2;
inline bool ReqSoulBag::has_is_dest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqSoulBag::set_has_is_dest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqSoulBag::clear_has_is_dest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqSoulBag::clear_is_dest() {
  is_dest_ = 0u;
  clear_has_is_dest();
}
inline ::google::protobuf::uint32 ReqSoulBag::is_dest() const {
  return is_dest_;
}
inline void ReqSoulBag::set_is_dest(::google::protobuf::uint32 value) {
  set_has_is_dest();
  is_dest_ = value;
}

// -------------------------------------------------------------------

// ReqQuickSoulBag

// optional uint32 is_choose = 1;
inline bool ReqQuickSoulBag::has_is_choose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqQuickSoulBag::set_has_is_choose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqQuickSoulBag::clear_has_is_choose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqQuickSoulBag::clear_is_choose() {
  is_choose_ = 0u;
  clear_has_is_choose();
}
inline ::google::protobuf::uint32 ReqQuickSoulBag::is_choose() const {
  return is_choose_;
}
inline void ReqQuickSoulBag::set_is_choose(::google::protobuf::uint32 value) {
  set_has_is_choose();
  is_choose_ = value;
}

// -------------------------------------------------------------------

// ReqChangeType

// optional uint32 value = 1;
inline bool ReqChangeType::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqChangeType::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqChangeType::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqChangeType::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqChangeType::value() const {
  return value_;
}
inline void ReqChangeType::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// AckSoulBag

// repeated uint32 item_id = 1;
inline int AckSoulBag::item_id_size() const {
  return item_id_.size();
}
inline void AckSoulBag::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::uint32 AckSoulBag::item_id(int index) const {
  return item_id_.Get(index);
}
inline void AckSoulBag::set_item_id(int index, ::google::protobuf::uint32 value) {
  item_id_.Set(index, value);
}
inline void AckSoulBag::add_item_id(::google::protobuf::uint32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckSoulBag::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckSoulBag::mutable_item_id() {
  return &item_id_;
}

// optional uint32 is_dest = 2;
inline bool AckSoulBag::has_is_dest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckSoulBag::set_has_is_dest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckSoulBag::clear_has_is_dest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckSoulBag::clear_is_dest() {
  is_dest_ = 0u;
  clear_has_is_dest();
}
inline ::google::protobuf::uint32 AckSoulBag::is_dest() const {
  return is_dest_;
}
inline void AckSoulBag::set_is_dest(::google::protobuf::uint32 value) {
  set_has_is_dest();
  is_dest_ = value;
}

// -------------------------------------------------------------------

// ReqSoulBagAction

// repeated uint32 item_pos = 1;
inline int ReqSoulBagAction::item_pos_size() const {
  return item_pos_.size();
}
inline void ReqSoulBagAction::clear_item_pos() {
  item_pos_.Clear();
}
inline ::google::protobuf::uint32 ReqSoulBagAction::item_pos(int index) const {
  return item_pos_.Get(index);
}
inline void ReqSoulBagAction::set_item_pos(int index, ::google::protobuf::uint32 value) {
  item_pos_.Set(index, value);
}
inline void ReqSoulBagAction::add_item_pos(::google::protobuf::uint32 value) {
  item_pos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ReqSoulBagAction::item_pos() const {
  return item_pos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ReqSoulBagAction::mutable_item_pos() {
  return &item_pos_;
}

// repeated uint64 item_only_id = 2;
inline int ReqSoulBagAction::item_only_id_size() const {
  return item_only_id_.size();
}
inline void ReqSoulBagAction::clear_item_only_id() {
  item_only_id_.Clear();
}
inline ::google::protobuf::uint64 ReqSoulBagAction::item_only_id(int index) const {
  return item_only_id_.Get(index);
}
inline void ReqSoulBagAction::set_item_only_id(int index, ::google::protobuf::uint64 value) {
  item_only_id_.Set(index, value);
}
inline void ReqSoulBagAction::add_item_only_id(::google::protobuf::uint64 value) {
  item_only_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ReqSoulBagAction::item_only_id() const {
  return item_only_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ReqSoulBagAction::mutable_item_only_id() {
  return &item_only_id_;
}

// repeated uint32 oper_id = 3;
inline int ReqSoulBagAction::oper_id_size() const {
  return oper_id_.size();
}
inline void ReqSoulBagAction::clear_oper_id() {
  oper_id_.Clear();
}
inline ::google::protobuf::uint32 ReqSoulBagAction::oper_id(int index) const {
  return oper_id_.Get(index);
}
inline void ReqSoulBagAction::set_oper_id(int index, ::google::protobuf::uint32 value) {
  oper_id_.Set(index, value);
}
inline void ReqSoulBagAction::add_oper_id(::google::protobuf::uint32 value) {
  oper_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ReqSoulBagAction::oper_id() const {
  return oper_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ReqSoulBagAction::mutable_oper_id() {
  return &oper_id_;
}

// optional uint32 merc_pos = 4;
inline bool ReqSoulBagAction::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqSoulBagAction::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqSoulBagAction::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqSoulBagAction::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 ReqSoulBagAction::merc_pos() const {
  return merc_pos_;
}
inline void ReqSoulBagAction::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// optional uint32 is_dest = 5;
inline bool ReqSoulBagAction::has_is_dest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqSoulBagAction::set_has_is_dest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqSoulBagAction::clear_has_is_dest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqSoulBagAction::clear_is_dest() {
  is_dest_ = 0u;
  clear_has_is_dest();
}
inline ::google::protobuf::uint32 ReqSoulBagAction::is_dest() const {
  return is_dest_;
}
inline void ReqSoulBagAction::set_is_dest(::google::protobuf::uint32 value) {
  set_has_is_dest();
  is_dest_ = value;
}

// optional uint32 item_num = 6;
inline bool ReqSoulBagAction::has_item_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqSoulBagAction::set_has_item_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqSoulBagAction::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqSoulBagAction::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 ReqSoulBagAction::item_num() const {
  return item_num_;
}
inline void ReqSoulBagAction::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// -------------------------------------------------------------------

// AckSoulBagAction

// repeated uint32 money = 1;
inline int AckSoulBagAction::money_size() const {
  return money_.size();
}
inline void AckSoulBagAction::clear_money() {
  money_.Clear();
}
inline ::google::protobuf::uint32 AckSoulBagAction::money(int index) const {
  return money_.Get(index);
}
inline void AckSoulBagAction::set_money(int index, ::google::protobuf::uint32 value) {
  money_.Set(index, value);
}
inline void AckSoulBagAction::add_money(::google::protobuf::uint32 value) {
  money_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckSoulBagAction::money() const {
  return money_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckSoulBagAction::mutable_money() {
  return &money_;
}

// repeated uint32 attr_point = 2;
inline int AckSoulBagAction::attr_point_size() const {
  return attr_point_.size();
}
inline void AckSoulBagAction::clear_attr_point() {
  attr_point_.Clear();
}
inline ::google::protobuf::uint32 AckSoulBagAction::attr_point(int index) const {
  return attr_point_.Get(index);
}
inline void AckSoulBagAction::set_attr_point(int index, ::google::protobuf::uint32 value) {
  attr_point_.Set(index, value);
}
inline void AckSoulBagAction::add_attr_point(::google::protobuf::uint32 value) {
  attr_point_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckSoulBagAction::attr_point() const {
  return attr_point_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckSoulBagAction::mutable_attr_point() {
  return &attr_point_;
}

// repeated uint32 dest_glod = 3;
inline int AckSoulBagAction::dest_glod_size() const {
  return dest_glod_.size();
}
inline void AckSoulBagAction::clear_dest_glod() {
  dest_glod_.Clear();
}
inline ::google::protobuf::uint32 AckSoulBagAction::dest_glod(int index) const {
  return dest_glod_.Get(index);
}
inline void AckSoulBagAction::set_dest_glod(int index, ::google::protobuf::uint32 value) {
  dest_glod_.Set(index, value);
}
inline void AckSoulBagAction::add_dest_glod(::google::protobuf::uint32 value) {
  dest_glod_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckSoulBagAction::dest_glod() const {
  return dest_glod_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckSoulBagAction::mutable_dest_glod() {
  return &dest_glod_;
}

// -------------------------------------------------------------------

// ReqSoulCombine

// required uint32 combine_id = 1;
inline bool ReqSoulCombine::has_combine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSoulCombine::set_has_combine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSoulCombine::clear_has_combine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSoulCombine::clear_combine_id() {
  combine_id_ = 0u;
  clear_has_combine_id();
}
inline ::google::protobuf::uint32 ReqSoulCombine::combine_id() const {
  return combine_id_;
}
inline void ReqSoulCombine::set_combine_id(::google::protobuf::uint32 value) {
  set_has_combine_id();
  combine_id_ = value;
}

// -------------------------------------------------------------------

// ReqPlatMoney

// required uint32 app_id = 1;
inline bool ReqPlatMoney::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPlatMoney::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPlatMoney::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPlatMoney::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 ReqPlatMoney::app_id() const {
  return app_id_;
}
inline void ReqPlatMoney::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// required bytes order_id = 2;
inline bool ReqPlatMoney::has_order_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqPlatMoney::set_has_order_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqPlatMoney::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqPlatMoney::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& ReqPlatMoney::order_id() const {
  return *order_id_;
}
inline void ReqPlatMoney::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ReqPlatMoney::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ReqPlatMoney::set_order_id(const void* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqPlatMoney::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* ReqPlatMoney::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqPlatMoney::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqPlatOrderID

// required uint32 app_id = 1;
inline bool ReqPlatOrderID::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPlatOrderID::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPlatOrderID::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPlatOrderID::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 ReqPlatOrderID::app_id() const {
  return app_id_;
}
inline void ReqPlatOrderID::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// -------------------------------------------------------------------

// AckPlatOrderID

// required uint64 order_id = 1;
inline bool AckPlatOrderID::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPlatOrderID::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPlatOrderID::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPlatOrderID::clear_order_id() {
  order_id_ = GOOGLE_ULONGLONG(0);
  clear_has_order_id();
}
inline ::google::protobuf::uint64 AckPlatOrderID::order_id() const {
  return order_id_;
}
inline void AckPlatOrderID::set_order_id(::google::protobuf::uint64 value) {
  set_has_order_id();
  order_id_ = value;
}

// -------------------------------------------------------------------

// ReqAddStamina

// required uint32 stamina = 1;
inline bool ReqAddStamina::has_stamina() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAddStamina::set_has_stamina() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAddStamina::clear_has_stamina() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAddStamina::clear_stamina() {
  stamina_ = 0u;
  clear_has_stamina();
}
inline ::google::protobuf::uint32 ReqAddStamina::stamina() const {
  return stamina_;
}
inline void ReqAddStamina::set_stamina(::google::protobuf::uint32 value) {
  set_has_stamina();
  stamina_ = value;
}

// -------------------------------------------------------------------

// OfflineTrainMercenary

// required uint32 nmercpos = 1;
inline bool OfflineTrainMercenary::has_nmercpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfflineTrainMercenary::set_has_nmercpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfflineTrainMercenary::clear_has_nmercpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfflineTrainMercenary::clear_nmercpos() {
  nmercpos_ = 0u;
  clear_has_nmercpos();
}
inline ::google::protobuf::uint32 OfflineTrainMercenary::nmercpos() const {
  return nmercpos_;
}
inline void OfflineTrainMercenary::set_nmercpos(::google::protobuf::uint32 value) {
  set_has_nmercpos();
  nmercpos_ = value;
}

// required uint32 ntraintype = 2;
inline bool OfflineTrainMercenary::has_ntraintype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfflineTrainMercenary::set_has_ntraintype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfflineTrainMercenary::clear_has_ntraintype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfflineTrainMercenary::clear_ntraintype() {
  ntraintype_ = 0u;
  clear_has_ntraintype();
}
inline ::google::protobuf::uint32 OfflineTrainMercenary::ntraintype() const {
  return ntraintype_;
}
inline void OfflineTrainMercenary::set_ntraintype(::google::protobuf::uint32 value) {
  set_has_ntraintype();
  ntraintype_ = value;
}

// required uint32 nfriendid = 3;
inline bool OfflineTrainMercenary::has_nfriendid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OfflineTrainMercenary::set_has_nfriendid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OfflineTrainMercenary::clear_has_nfriendid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OfflineTrainMercenary::clear_nfriendid() {
  nfriendid_ = 0u;
  clear_has_nfriendid();
}
inline ::google::protobuf::uint32 OfflineTrainMercenary::nfriendid() const {
  return nfriendid_;
}
inline void OfflineTrainMercenary::set_nfriendid(::google::protobuf::uint32 value) {
  set_has_nfriendid();
  nfriendid_ = value;
}

// -------------------------------------------------------------------

// OfflineOper

// required uint32 from_char_id = 1;
inline bool OfflineOper::has_from_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfflineOper::set_has_from_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfflineOper::clear_has_from_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfflineOper::clear_from_char_id() {
  from_char_id_ = 0u;
  clear_has_from_char_id();
}
inline ::google::protobuf::uint32 OfflineOper::from_char_id() const {
  return from_char_id_;
}
inline void OfflineOper::set_from_char_id(::google::protobuf::uint32 value) {
  set_has_from_char_id();
  from_char_id_ = value;
}

// required uint32 to_char_id = 2;
inline bool OfflineOper::has_to_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfflineOper::set_has_to_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfflineOper::clear_has_to_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfflineOper::clear_to_char_id() {
  to_char_id_ = 0u;
  clear_has_to_char_id();
}
inline ::google::protobuf::uint32 OfflineOper::to_char_id() const {
  return to_char_id_;
}
inline void OfflineOper::set_to_char_id(::google::protobuf::uint32 value) {
  set_has_to_char_id();
  to_char_id_ = value;
}

// required uint32 oper_id = 3;
inline bool OfflineOper::has_oper_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OfflineOper::set_has_oper_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OfflineOper::clear_has_oper_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OfflineOper::clear_oper_id() {
  oper_id_ = 0u;
  clear_has_oper_id();
}
inline ::google::protobuf::uint32 OfflineOper::oper_id() const {
  return oper_id_;
}
inline void OfflineOper::set_oper_id(::google::protobuf::uint32 value) {
  set_has_oper_id();
  oper_id_ = value;
}

// required uint32 oper_value1 = 4;
inline bool OfflineOper::has_oper_value1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OfflineOper::set_has_oper_value1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OfflineOper::clear_has_oper_value1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OfflineOper::clear_oper_value1() {
  oper_value1_ = 0u;
  clear_has_oper_value1();
}
inline ::google::protobuf::uint32 OfflineOper::oper_value1() const {
  return oper_value1_;
}
inline void OfflineOper::set_oper_value1(::google::protobuf::uint32 value) {
  set_has_oper_value1();
  oper_value1_ = value;
}

// required uint32 oper_value2 = 5;
inline bool OfflineOper::has_oper_value2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OfflineOper::set_has_oper_value2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OfflineOper::clear_has_oper_value2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OfflineOper::clear_oper_value2() {
  oper_value2_ = 0u;
  clear_has_oper_value2();
}
inline ::google::protobuf::uint32 OfflineOper::oper_value2() const {
  return oper_value2_;
}
inline void OfflineOper::set_oper_value2(::google::protobuf::uint32 value) {
  set_has_oper_value2();
  oper_value2_ = value;
}

// required uint32 oper_pos = 6;
inline bool OfflineOper::has_oper_pos() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OfflineOper::set_has_oper_pos() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OfflineOper::clear_has_oper_pos() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OfflineOper::clear_oper_pos() {
  oper_pos_ = 0u;
  clear_has_oper_pos();
}
inline ::google::protobuf::uint32 OfflineOper::oper_pos() const {
  return oper_pos_;
}
inline void OfflineOper::set_oper_pos(::google::protobuf::uint32 value) {
  set_has_oper_pos();
  oper_pos_ = value;
}

// required uint64 oper_time = 7;
inline bool OfflineOper::has_oper_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OfflineOper::set_has_oper_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OfflineOper::clear_has_oper_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OfflineOper::clear_oper_time() {
  oper_time_ = GOOGLE_ULONGLONG(0);
  clear_has_oper_time();
}
inline ::google::protobuf::uint64 OfflineOper::oper_time() const {
  return oper_time_;
}
inline void OfflineOper::set_oper_time(::google::protobuf::uint64 value) {
  set_has_oper_time();
  oper_time_ = value;
}

// optional uint32 mode_id = 8;
inline bool OfflineOper::has_mode_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OfflineOper::set_has_mode_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OfflineOper::clear_has_mode_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OfflineOper::clear_mode_id() {
  mode_id_ = 0u;
  clear_has_mode_id();
}
inline ::google::protobuf::uint32 OfflineOper::mode_id() const {
  return mode_id_;
}
inline void OfflineOper::set_mode_id(::google::protobuf::uint32 value) {
  set_has_mode_id();
  mode_id_ = value;
}

// -------------------------------------------------------------------

// ReqOfflineOperList

// required uint32 acc_id = 1;
inline bool ReqOfflineOperList::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqOfflineOperList::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqOfflineOperList::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqOfflineOperList::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 ReqOfflineOperList::acc_id() const {
  return acc_id_;
}
inline void ReqOfflineOperList::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// repeated uint32 char_id = 2;
inline int ReqOfflineOperList::char_id_size() const {
  return char_id_.size();
}
inline void ReqOfflineOperList::clear_char_id() {
  char_id_.Clear();
}
inline ::google::protobuf::uint32 ReqOfflineOperList::char_id(int index) const {
  return char_id_.Get(index);
}
inline void ReqOfflineOperList::set_char_id(int index, ::google::protobuf::uint32 value) {
  char_id_.Set(index, value);
}
inline void ReqOfflineOperList::add_char_id(::google::protobuf::uint32 value) {
  char_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ReqOfflineOperList::char_id() const {
  return char_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ReqOfflineOperList::mutable_char_id() {
  return &char_id_;
}

// optional uint32 is_delete = 3;
inline bool ReqOfflineOperList::has_is_delete() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqOfflineOperList::set_has_is_delete() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqOfflineOperList::clear_has_is_delete() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqOfflineOperList::clear_is_delete() {
  is_delete_ = 0u;
  clear_has_is_delete();
}
inline ::google::protobuf::uint32 ReqOfflineOperList::is_delete() const {
  return is_delete_;
}
inline void ReqOfflineOperList::set_is_delete(::google::protobuf::uint32 value) {
  set_has_is_delete();
  is_delete_ = value;
}

// optional uint32 oper_id = 4;
inline bool ReqOfflineOperList::has_oper_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqOfflineOperList::set_has_oper_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqOfflineOperList::clear_has_oper_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqOfflineOperList::clear_oper_id() {
  oper_id_ = 0u;
  clear_has_oper_id();
}
inline ::google::protobuf::uint32 ReqOfflineOperList::oper_id() const {
  return oper_id_;
}
inline void ReqOfflineOperList::set_oper_id(::google::protobuf::uint32 value) {
  set_has_oper_id();
  oper_id_ = value;
}

// -------------------------------------------------------------------

// AckOfflineOperList

// repeated uint32 from_char_id = 1;
inline int AckOfflineOperList::from_char_id_size() const {
  return from_char_id_.size();
}
inline void AckOfflineOperList::clear_from_char_id() {
  from_char_id_.Clear();
}
inline ::google::protobuf::uint32 AckOfflineOperList::from_char_id(int index) const {
  return from_char_id_.Get(index);
}
inline void AckOfflineOperList::set_from_char_id(int index, ::google::protobuf::uint32 value) {
  from_char_id_.Set(index, value);
}
inline void AckOfflineOperList::add_from_char_id(::google::protobuf::uint32 value) {
  from_char_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckOfflineOperList::from_char_id() const {
  return from_char_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckOfflineOperList::mutable_from_char_id() {
  return &from_char_id_;
}

// repeated uint32 to_char_id = 2;
inline int AckOfflineOperList::to_char_id_size() const {
  return to_char_id_.size();
}
inline void AckOfflineOperList::clear_to_char_id() {
  to_char_id_.Clear();
}
inline ::google::protobuf::uint32 AckOfflineOperList::to_char_id(int index) const {
  return to_char_id_.Get(index);
}
inline void AckOfflineOperList::set_to_char_id(int index, ::google::protobuf::uint32 value) {
  to_char_id_.Set(index, value);
}
inline void AckOfflineOperList::add_to_char_id(::google::protobuf::uint32 value) {
  to_char_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckOfflineOperList::to_char_id() const {
  return to_char_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckOfflineOperList::mutable_to_char_id() {
  return &to_char_id_;
}

// repeated uint32 oper_id = 3;
inline int AckOfflineOperList::oper_id_size() const {
  return oper_id_.size();
}
inline void AckOfflineOperList::clear_oper_id() {
  oper_id_.Clear();
}
inline ::google::protobuf::uint32 AckOfflineOperList::oper_id(int index) const {
  return oper_id_.Get(index);
}
inline void AckOfflineOperList::set_oper_id(int index, ::google::protobuf::uint32 value) {
  oper_id_.Set(index, value);
}
inline void AckOfflineOperList::add_oper_id(::google::protobuf::uint32 value) {
  oper_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckOfflineOperList::oper_id() const {
  return oper_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckOfflineOperList::mutable_oper_id() {
  return &oper_id_;
}

// repeated uint32 oper_value1 = 4;
inline int AckOfflineOperList::oper_value1_size() const {
  return oper_value1_.size();
}
inline void AckOfflineOperList::clear_oper_value1() {
  oper_value1_.Clear();
}
inline ::google::protobuf::uint32 AckOfflineOperList::oper_value1(int index) const {
  return oper_value1_.Get(index);
}
inline void AckOfflineOperList::set_oper_value1(int index, ::google::protobuf::uint32 value) {
  oper_value1_.Set(index, value);
}
inline void AckOfflineOperList::add_oper_value1(::google::protobuf::uint32 value) {
  oper_value1_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckOfflineOperList::oper_value1() const {
  return oper_value1_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckOfflineOperList::mutable_oper_value1() {
  return &oper_value1_;
}

// repeated uint32 oper_value2 = 5;
inline int AckOfflineOperList::oper_value2_size() const {
  return oper_value2_.size();
}
inline void AckOfflineOperList::clear_oper_value2() {
  oper_value2_.Clear();
}
inline ::google::protobuf::uint32 AckOfflineOperList::oper_value2(int index) const {
  return oper_value2_.Get(index);
}
inline void AckOfflineOperList::set_oper_value2(int index, ::google::protobuf::uint32 value) {
  oper_value2_.Set(index, value);
}
inline void AckOfflineOperList::add_oper_value2(::google::protobuf::uint32 value) {
  oper_value2_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckOfflineOperList::oper_value2() const {
  return oper_value2_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckOfflineOperList::mutable_oper_value2() {
  return &oper_value2_;
}

// repeated uint32 oper_pos = 6;
inline int AckOfflineOperList::oper_pos_size() const {
  return oper_pos_.size();
}
inline void AckOfflineOperList::clear_oper_pos() {
  oper_pos_.Clear();
}
inline ::google::protobuf::uint32 AckOfflineOperList::oper_pos(int index) const {
  return oper_pos_.Get(index);
}
inline void AckOfflineOperList::set_oper_pos(int index, ::google::protobuf::uint32 value) {
  oper_pos_.Set(index, value);
}
inline void AckOfflineOperList::add_oper_pos(::google::protobuf::uint32 value) {
  oper_pos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckOfflineOperList::oper_pos() const {
  return oper_pos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckOfflineOperList::mutable_oper_pos() {
  return &oper_pos_;
}

// repeated uint64 oper_time = 7;
inline int AckOfflineOperList::oper_time_size() const {
  return oper_time_.size();
}
inline void AckOfflineOperList::clear_oper_time() {
  oper_time_.Clear();
}
inline ::google::protobuf::uint64 AckOfflineOperList::oper_time(int index) const {
  return oper_time_.Get(index);
}
inline void AckOfflineOperList::set_oper_time(int index, ::google::protobuf::uint64 value) {
  oper_time_.Set(index, value);
}
inline void AckOfflineOperList::add_oper_time(::google::protobuf::uint64 value) {
  oper_time_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AckOfflineOperList::oper_time() const {
  return oper_time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AckOfflineOperList::mutable_oper_time() {
  return &oper_time_;
}

// repeated uint32 mode_id = 8;
inline int AckOfflineOperList::mode_id_size() const {
  return mode_id_.size();
}
inline void AckOfflineOperList::clear_mode_id() {
  mode_id_.Clear();
}
inline ::google::protobuf::uint32 AckOfflineOperList::mode_id(int index) const {
  return mode_id_.Get(index);
}
inline void AckOfflineOperList::set_mode_id(int index, ::google::protobuf::uint32 value) {
  mode_id_.Set(index, value);
}
inline void AckOfflineOperList::add_mode_id(::google::protobuf::uint32 value) {
  mode_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckOfflineOperList::mode_id() const {
  return mode_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckOfflineOperList::mutable_mode_id() {
  return &mode_id_;
}

// repeated bytes sys_msg = 9;
inline int AckOfflineOperList::sys_msg_size() const {
  return sys_msg_.size();
}
inline void AckOfflineOperList::clear_sys_msg() {
  sys_msg_.Clear();
}
inline const ::std::string& AckOfflineOperList::sys_msg(int index) const {
  return sys_msg_.Get(index);
}
inline ::std::string* AckOfflineOperList::mutable_sys_msg(int index) {
  return sys_msg_.Mutable(index);
}
inline void AckOfflineOperList::set_sys_msg(int index, const ::std::string& value) {
  sys_msg_.Mutable(index)->assign(value);
}
inline void AckOfflineOperList::set_sys_msg(int index, const char* value) {
  sys_msg_.Mutable(index)->assign(value);
}
inline void AckOfflineOperList::set_sys_msg(int index, const void* value, size_t size) {
  sys_msg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckOfflineOperList::add_sys_msg() {
  return sys_msg_.Add();
}
inline void AckOfflineOperList::add_sys_msg(const ::std::string& value) {
  sys_msg_.Add()->assign(value);
}
inline void AckOfflineOperList::add_sys_msg(const char* value) {
  sys_msg_.Add()->assign(value);
}
inline void AckOfflineOperList::add_sys_msg(const void* value, size_t size) {
  sys_msg_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AckOfflineOperList::sys_msg() const {
  return sys_msg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AckOfflineOperList::mutable_sys_msg() {
  return &sys_msg_;
}

// -------------------------------------------------------------------

// ReqActiveCode

// repeated bytes code = 1;
inline int ReqActiveCode::code_size() const {
  return code_.size();
}
inline void ReqActiveCode::clear_code() {
  code_.Clear();
}
inline const ::std::string& ReqActiveCode::code(int index) const {
  return code_.Get(index);
}
inline ::std::string* ReqActiveCode::mutable_code(int index) {
  return code_.Mutable(index);
}
inline void ReqActiveCode::set_code(int index, const ::std::string& value) {
  code_.Mutable(index)->assign(value);
}
inline void ReqActiveCode::set_code(int index, const char* value) {
  code_.Mutable(index)->assign(value);
}
inline void ReqActiveCode::set_code(int index, const void* value, size_t size) {
  code_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqActiveCode::add_code() {
  return code_.Add();
}
inline void ReqActiveCode::add_code(const ::std::string& value) {
  code_.Add()->assign(value);
}
inline void ReqActiveCode::add_code(const char* value) {
  code_.Add()->assign(value);
}
inline void ReqActiveCode::add_code(const void* value, size_t size) {
  code_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReqActiveCode::code() const {
  return code_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReqActiveCode::mutable_code() {
  return &code_;
}

// optional int32 is_invite = 2;
inline bool ReqActiveCode::has_is_invite() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqActiveCode::set_has_is_invite() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqActiveCode::clear_has_is_invite() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqActiveCode::clear_is_invite() {
  is_invite_ = 0;
  clear_has_is_invite();
}
inline ::google::protobuf::int32 ReqActiveCode::is_invite() const {
  return is_invite_;
}
inline void ReqActiveCode::set_is_invite(::google::protobuf::int32 value) {
  set_has_is_invite();
  is_invite_ = value;
}

// -------------------------------------------------------------------

// ReqServerActiveCode

// repeated bytes code = 1;
inline int ReqServerActiveCode::code_size() const {
  return code_.size();
}
inline void ReqServerActiveCode::clear_code() {
  code_.Clear();
}
inline const ::std::string& ReqServerActiveCode::code(int index) const {
  return code_.Get(index);
}
inline ::std::string* ReqServerActiveCode::mutable_code(int index) {
  return code_.Mutable(index);
}
inline void ReqServerActiveCode::set_code(int index, const ::std::string& value) {
  code_.Mutable(index)->assign(value);
}
inline void ReqServerActiveCode::set_code(int index, const char* value) {
  code_.Mutable(index)->assign(value);
}
inline void ReqServerActiveCode::set_code(int index, const void* value, size_t size) {
  code_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqServerActiveCode::add_code() {
  return code_.Add();
}
inline void ReqServerActiveCode::add_code(const ::std::string& value) {
  code_.Add()->assign(value);
}
inline void ReqServerActiveCode::add_code(const char* value) {
  code_.Add()->assign(value);
}
inline void ReqServerActiveCode::add_code(const void* value, size_t size) {
  code_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReqServerActiveCode::code() const {
  return code_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReqServerActiveCode::mutable_code() {
  return &code_;
}

// optional uint32 is_delete = 2;
inline bool ReqServerActiveCode::has_is_delete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqServerActiveCode::set_has_is_delete() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqServerActiveCode::clear_has_is_delete() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqServerActiveCode::clear_is_delete() {
  is_delete_ = 0u;
  clear_has_is_delete();
}
inline ::google::protobuf::uint32 ReqServerActiveCode::is_delete() const {
  return is_delete_;
}
inline void ReqServerActiveCode::set_is_delete(::google::protobuf::uint32 value) {
  set_has_is_delete();
  is_delete_ = value;
}

// optional uint32 item_id = 3;
inline bool ReqServerActiveCode::has_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqServerActiveCode::set_has_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqServerActiveCode::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqServerActiveCode::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 ReqServerActiveCode::item_id() const {
  return item_id_;
}
inline void ReqServerActiveCode::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional uint32 is_invite = 4;
inline bool ReqServerActiveCode::has_is_invite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqServerActiveCode::set_has_is_invite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqServerActiveCode::clear_has_is_invite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqServerActiveCode::clear_is_invite() {
  is_invite_ = 0u;
  clear_has_is_invite();
}
inline ::google::protobuf::uint32 ReqServerActiveCode::is_invite() const {
  return is_invite_;
}
inline void ReqServerActiveCode::set_is_invite(::google::protobuf::uint32 value) {
  set_has_is_invite();
  is_invite_ = value;
}

// -------------------------------------------------------------------

// AckServerActiveCode

// required uint32 item_id = 1;
inline bool AckServerActiveCode::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckServerActiveCode::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckServerActiveCode::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckServerActiveCode::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 AckServerActiveCode::item_id() const {
  return item_id_;
}
inline void AckServerActiveCode::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional uint32 is_invite = 2;
inline bool AckServerActiveCode::has_is_invite() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckServerActiveCode::set_has_is_invite() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckServerActiveCode::clear_has_is_invite() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckServerActiveCode::clear_is_invite() {
  is_invite_ = 0u;
  clear_has_is_invite();
}
inline ::google::protobuf::uint32 AckServerActiveCode::is_invite() const {
  return is_invite_;
}
inline void AckServerActiveCode::set_is_invite(::google::protobuf::uint32 value) {
  set_has_is_invite();
  is_invite_ = value;
}

// -------------------------------------------------------------------

// ReqRefreshGate

// required uint32 refresh_gate = 1;
inline bool ReqRefreshGate::has_refresh_gate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqRefreshGate::set_has_refresh_gate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqRefreshGate::clear_has_refresh_gate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqRefreshGate::clear_refresh_gate() {
  refresh_gate_ = 0u;
  clear_has_refresh_gate();
}
inline ::google::protobuf::uint32 ReqRefreshGate::refresh_gate() const {
  return refresh_gate_;
}
inline void ReqRefreshGate::set_refresh_gate(::google::protobuf::uint32 value) {
  set_has_refresh_gate();
  refresh_gate_ = value;
}

// -------------------------------------------------------------------

// RefreshGateCost

// required uint32 cost = 1;
inline bool RefreshGateCost::has_cost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefreshGateCost::set_has_cost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefreshGateCost::clear_has_cost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefreshGateCost::clear_cost() {
  cost_ = 0u;
  clear_has_cost();
}
inline ::google::protobuf::uint32 RefreshGateCost::cost() const {
  return cost_;
}
inline void RefreshGateCost::set_cost(::google::protobuf::uint32 value) {
  set_has_cost();
  cost_ = value;
}

// -------------------------------------------------------------------

// RefreshGate

// required uint32 value = 1;
inline bool RefreshGate::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefreshGate::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefreshGate::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefreshGate::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 RefreshGate::value() const {
  return value_;
}
inline void RefreshGate::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ReqGateLevelUp

// required uint32 type = 1;
inline bool ReqGateLevelUp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGateLevelUp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGateLevelUp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGateLevelUp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ReqGateLevelUp::type() const {
  return type_;
}
inline void ReqGateLevelUp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 gate_num = 2;
inline bool ReqGateLevelUp::has_gate_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqGateLevelUp::set_has_gate_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqGateLevelUp::clear_has_gate_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqGateLevelUp::clear_gate_num() {
  gate_num_ = 0u;
  clear_has_gate_num();
}
inline ::google::protobuf::uint32 ReqGateLevelUp::gate_num() const {
  return gate_num_;
}
inline void ReqGateLevelUp::set_gate_num(::google::protobuf::uint32 value) {
  set_has_gate_num();
  gate_num_ = value;
}

// -------------------------------------------------------------------

// ReqChooseBigGate

// required uint32 oper_type = 1;
inline bool ReqChooseBigGate::has_oper_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqChooseBigGate::set_has_oper_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqChooseBigGate::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqChooseBigGate::clear_oper_type() {
  oper_type_ = 0u;
  clear_has_oper_type();
}
inline ::google::protobuf::uint32 ReqChooseBigGate::oper_type() const {
  return oper_type_;
}
inline void ReqChooseBigGate::set_oper_type(::google::protobuf::uint32 value) {
  set_has_oper_type();
  oper_type_ = value;
}

// -------------------------------------------------------------------

// ReqMercenaryUpgrade

// required uint32 pos = 1;
inline bool ReqMercenaryUpgrade::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqMercenaryUpgrade::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqMercenaryUpgrade::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqMercenaryUpgrade::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 ReqMercenaryUpgrade::pos() const {
  return pos_;
}
inline void ReqMercenaryUpgrade::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// ReqLadderReward

// required uint32 pos = 1;
inline bool ReqLadderReward::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLadderReward::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLadderReward::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLadderReward::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 ReqLadderReward::pos() const {
  return pos_;
}
inline void ReqLadderReward::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// ReqGetLevelReward

// required uint32 value = 1;
inline bool ReqGetLevelReward::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetLevelReward::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetLevelReward::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetLevelReward::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqGetLevelReward::value() const {
  return value_;
}
inline void ReqGetLevelReward::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ReqGetActiveReward

// required uint32 value = 1;
inline bool ReqGetActiveReward::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetActiveReward::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetActiveReward::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetActiveReward::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqGetActiveReward::value() const {
  return value_;
}
inline void ReqGetActiveReward::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// RechargeLogInfo

// optional uint32 acc_id = 1;
inline bool RechargeLogInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RechargeLogInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RechargeLogInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RechargeLogInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 RechargeLogInfo::acc_id() const {
  return acc_id_;
}
inline void RechargeLogInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// optional uint32 server_id = 2;
inline bool RechargeLogInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RechargeLogInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RechargeLogInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RechargeLogInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 RechargeLogInfo::server_id() const {
  return server_id_;
}
inline void RechargeLogInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 recharge_platid = 3;
inline bool RechargeLogInfo::has_recharge_platid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RechargeLogInfo::set_has_recharge_platid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RechargeLogInfo::clear_has_recharge_platid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RechargeLogInfo::clear_recharge_platid() {
  recharge_platid_ = 0u;
  clear_has_recharge_platid();
}
inline ::google::protobuf::uint32 RechargeLogInfo::recharge_platid() const {
  return recharge_platid_;
}
inline void RechargeLogInfo::set_recharge_platid(::google::protobuf::uint32 value) {
  set_has_recharge_platid();
  recharge_platid_ = value;
}

// optional uint32 recharge_amount = 4;
inline bool RechargeLogInfo::has_recharge_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RechargeLogInfo::set_has_recharge_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RechargeLogInfo::clear_has_recharge_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RechargeLogInfo::clear_recharge_amount() {
  recharge_amount_ = 0u;
  clear_has_recharge_amount();
}
inline ::google::protobuf::uint32 RechargeLogInfo::recharge_amount() const {
  return recharge_amount_;
}
inline void RechargeLogInfo::set_recharge_amount(::google::protobuf::uint32 value) {
  set_has_recharge_amount();
  recharge_amount_ = value;
}

// optional bytes char_name = 5;
inline bool RechargeLogInfo::has_char_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RechargeLogInfo::set_has_char_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RechargeLogInfo::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RechargeLogInfo::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& RechargeLogInfo::char_name() const {
  return *char_name_;
}
inline void RechargeLogInfo::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void RechargeLogInfo::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void RechargeLogInfo::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RechargeLogInfo::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* RechargeLogInfo::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RechargeLogInfo::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes recharge_time = 6;
inline bool RechargeLogInfo::has_recharge_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RechargeLogInfo::set_has_recharge_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RechargeLogInfo::clear_has_recharge_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RechargeLogInfo::clear_recharge_time() {
  if (recharge_time_ != &::google::protobuf::internal::kEmptyString) {
    recharge_time_->clear();
  }
  clear_has_recharge_time();
}
inline const ::std::string& RechargeLogInfo::recharge_time() const {
  return *recharge_time_;
}
inline void RechargeLogInfo::set_recharge_time(const ::std::string& value) {
  set_has_recharge_time();
  if (recharge_time_ == &::google::protobuf::internal::kEmptyString) {
    recharge_time_ = new ::std::string;
  }
  recharge_time_->assign(value);
}
inline void RechargeLogInfo::set_recharge_time(const char* value) {
  set_has_recharge_time();
  if (recharge_time_ == &::google::protobuf::internal::kEmptyString) {
    recharge_time_ = new ::std::string;
  }
  recharge_time_->assign(value);
}
inline void RechargeLogInfo::set_recharge_time(const void* value, size_t size) {
  set_has_recharge_time();
  if (recharge_time_ == &::google::protobuf::internal::kEmptyString) {
    recharge_time_ = new ::std::string;
  }
  recharge_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RechargeLogInfo::mutable_recharge_time() {
  set_has_recharge_time();
  if (recharge_time_ == &::google::protobuf::internal::kEmptyString) {
    recharge_time_ = new ::std::string;
  }
  return recharge_time_;
}
inline ::std::string* RechargeLogInfo::release_recharge_time() {
  clear_has_recharge_time();
  if (recharge_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recharge_time_;
    recharge_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RechargeLogInfo::set_allocated_recharge_time(::std::string* recharge_time) {
  if (recharge_time_ != &::google::protobuf::internal::kEmptyString) {
    delete recharge_time_;
  }
  if (recharge_time) {
    set_has_recharge_time();
    recharge_time_ = recharge_time;
  } else {
    clear_has_recharge_time();
    recharge_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResetByDay

// optional bool isDailyOnline = 1;
inline bool ResetByDay::has_isdailyonline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetByDay::set_has_isdailyonline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetByDay::clear_has_isdailyonline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetByDay::clear_isdailyonline() {
  isdailyonline_ = false;
  clear_has_isdailyonline();
}
inline bool ResetByDay::isdailyonline() const {
  return isdailyonline_;
}
inline void ResetByDay::set_isdailyonline(bool value) {
  set_has_isdailyonline();
  isdailyonline_ = value;
}

// -------------------------------------------------------------------

// UserBehaviorLogInfo

// optional uint32 acc_id = 1;
inline bool UserBehaviorLogInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBehaviorLogInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBehaviorLogInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBehaviorLogInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::acc_id() const {
  return acc_id_;
}
inline void UserBehaviorLogInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// optional uint32 server_id = 2;
inline bool UserBehaviorLogInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserBehaviorLogInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserBehaviorLogInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserBehaviorLogInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::server_id() const {
  return server_id_;
}
inline void UserBehaviorLogInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 enum_intent = 3;
inline bool UserBehaviorLogInfo::has_enum_intent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserBehaviorLogInfo::set_has_enum_intent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserBehaviorLogInfo::clear_has_enum_intent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserBehaviorLogInfo::clear_enum_intent() {
  enum_intent_ = 0u;
  clear_has_enum_intent();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::enum_intent() const {
  return enum_intent_;
}
inline void UserBehaviorLogInfo::set_enum_intent(::google::protobuf::uint32 value) {
  set_has_enum_intent();
  enum_intent_ = value;
}

// optional uint32 enum_oper = 4;
inline bool UserBehaviorLogInfo::has_enum_oper() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserBehaviorLogInfo::set_has_enum_oper() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserBehaviorLogInfo::clear_has_enum_oper() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserBehaviorLogInfo::clear_enum_oper() {
  enum_oper_ = 0u;
  clear_has_enum_oper();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::enum_oper() const {
  return enum_oper_;
}
inline void UserBehaviorLogInfo::set_enum_oper(::google::protobuf::uint32 value) {
  set_has_enum_oper();
  enum_oper_ = value;
}

// optional uint32 enum_attr = 5;
inline bool UserBehaviorLogInfo::has_enum_attr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserBehaviorLogInfo::set_has_enum_attr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserBehaviorLogInfo::clear_has_enum_attr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserBehaviorLogInfo::clear_enum_attr() {
  enum_attr_ = 0u;
  clear_has_enum_attr();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::enum_attr() const {
  return enum_attr_;
}
inline void UserBehaviorLogInfo::set_enum_attr(::google::protobuf::uint32 value) {
  set_has_enum_attr();
  enum_attr_ = value;
}

// optional uint32 attr_amount = 6;
inline bool UserBehaviorLogInfo::has_attr_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserBehaviorLogInfo::set_has_attr_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserBehaviorLogInfo::clear_has_attr_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserBehaviorLogInfo::clear_attr_amount() {
  attr_amount_ = 0u;
  clear_has_attr_amount();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::attr_amount() const {
  return attr_amount_;
}
inline void UserBehaviorLogInfo::set_attr_amount(::google::protobuf::uint32 value) {
  set_has_attr_amount();
  attr_amount_ = value;
}

// optional uint32 item_amount = 7;
inline bool UserBehaviorLogInfo::has_item_amount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserBehaviorLogInfo::set_has_item_amount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserBehaviorLogInfo::clear_has_item_amount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserBehaviorLogInfo::clear_item_amount() {
  item_amount_ = 0u;
  clear_has_item_amount();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::item_amount() const {
  return item_amount_;
}
inline void UserBehaviorLogInfo::set_item_amount(::google::protobuf::uint32 value) {
  set_has_item_amount();
  item_amount_ = value;
}

// optional uint32 item_id = 8;
inline bool UserBehaviorLogInfo::has_item_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserBehaviorLogInfo::set_has_item_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserBehaviorLogInfo::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserBehaviorLogInfo::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::item_id() const {
  return item_id_;
}
inline void UserBehaviorLogInfo::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional uint32 pre_amount = 9;
inline bool UserBehaviorLogInfo::has_pre_amount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserBehaviorLogInfo::set_has_pre_amount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserBehaviorLogInfo::clear_has_pre_amount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserBehaviorLogInfo::clear_pre_amount() {
  pre_amount_ = 0u;
  clear_has_pre_amount();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::pre_amount() const {
  return pre_amount_;
}
inline void UserBehaviorLogInfo::set_pre_amount(::google::protobuf::uint32 value) {
  set_has_pre_amount();
  pre_amount_ = value;
}

// optional uint32 after_amount = 10;
inline bool UserBehaviorLogInfo::has_after_amount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserBehaviorLogInfo::set_has_after_amount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserBehaviorLogInfo::clear_has_after_amount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserBehaviorLogInfo::clear_after_amount() {
  after_amount_ = 0u;
  clear_has_after_amount();
}
inline ::google::protobuf::uint32 UserBehaviorLogInfo::after_amount() const {
  return after_amount_;
}
inline void UserBehaviorLogInfo::set_after_amount(::google::protobuf::uint32 value) {
  set_has_after_amount();
  after_amount_ = value;
}

// optional bytes char_name = 11;
inline bool UserBehaviorLogInfo::has_char_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserBehaviorLogInfo::set_has_char_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserBehaviorLogInfo::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserBehaviorLogInfo::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& UserBehaviorLogInfo::char_name() const {
  return *char_name_;
}
inline void UserBehaviorLogInfo::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void UserBehaviorLogInfo::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void UserBehaviorLogInfo::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBehaviorLogInfo::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* UserBehaviorLogInfo::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBehaviorLogInfo::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes behavior_time = 12;
inline bool UserBehaviorLogInfo::has_behavior_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserBehaviorLogInfo::set_has_behavior_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserBehaviorLogInfo::clear_has_behavior_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserBehaviorLogInfo::clear_behavior_time() {
  if (behavior_time_ != &::google::protobuf::internal::kEmptyString) {
    behavior_time_->clear();
  }
  clear_has_behavior_time();
}
inline const ::std::string& UserBehaviorLogInfo::behavior_time() const {
  return *behavior_time_;
}
inline void UserBehaviorLogInfo::set_behavior_time(const ::std::string& value) {
  set_has_behavior_time();
  if (behavior_time_ == &::google::protobuf::internal::kEmptyString) {
    behavior_time_ = new ::std::string;
  }
  behavior_time_->assign(value);
}
inline void UserBehaviorLogInfo::set_behavior_time(const char* value) {
  set_has_behavior_time();
  if (behavior_time_ == &::google::protobuf::internal::kEmptyString) {
    behavior_time_ = new ::std::string;
  }
  behavior_time_->assign(value);
}
inline void UserBehaviorLogInfo::set_behavior_time(const void* value, size_t size) {
  set_has_behavior_time();
  if (behavior_time_ == &::google::protobuf::internal::kEmptyString) {
    behavior_time_ = new ::std::string;
  }
  behavior_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBehaviorLogInfo::mutable_behavior_time() {
  set_has_behavior_time();
  if (behavior_time_ == &::google::protobuf::internal::kEmptyString) {
    behavior_time_ = new ::std::string;
  }
  return behavior_time_;
}
inline ::std::string* UserBehaviorLogInfo::release_behavior_time() {
  clear_has_behavior_time();
  if (behavior_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = behavior_time_;
    behavior_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBehaviorLogInfo::set_allocated_behavior_time(::std::string* behavior_time) {
  if (behavior_time_ != &::google::protobuf::internal::kEmptyString) {
    delete behavior_time_;
  }
  if (behavior_time) {
    set_has_behavior_time();
    behavior_time_ = behavior_time;
  } else {
    clear_has_behavior_time();
    behavior_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OnlineNumberInfo

// optional uint32 server_id = 1;
inline bool OnlineNumberInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlineNumberInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlineNumberInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlineNumberInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 OnlineNumberInfo::server_id() const {
  return server_id_;
}
inline void OnlineNumberInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 online_num = 2;
inline bool OnlineNumberInfo::has_online_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineNumberInfo::set_has_online_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineNumberInfo::clear_has_online_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineNumberInfo::clear_online_num() {
  online_num_ = 0u;
  clear_has_online_num();
}
inline ::google::protobuf::uint32 OnlineNumberInfo::online_num() const {
  return online_num_;
}
inline void OnlineNumberInfo::set_online_num(::google::protobuf::uint32 value) {
  set_has_online_num();
  online_num_ = value;
}

// -------------------------------------------------------------------

// ReqVIPOperation

// optional uint32 oper_id = 1;
inline bool ReqVIPOperation::has_oper_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqVIPOperation::set_has_oper_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqVIPOperation::clear_has_oper_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqVIPOperation::clear_oper_id() {
  oper_id_ = 0u;
  clear_has_oper_id();
}
inline ::google::protobuf::uint32 ReqVIPOperation::oper_id() const {
  return oper_id_;
}
inline void ReqVIPOperation::set_oper_id(::google::protobuf::uint32 value) {
  set_has_oper_id();
  oper_id_ = value;
}

// optional uint32 oper_value1 = 2;
inline bool ReqVIPOperation::has_oper_value1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqVIPOperation::set_has_oper_value1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqVIPOperation::clear_has_oper_value1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqVIPOperation::clear_oper_value1() {
  oper_value1_ = 0u;
  clear_has_oper_value1();
}
inline ::google::protobuf::uint32 ReqVIPOperation::oper_value1() const {
  return oper_value1_;
}
inline void ReqVIPOperation::set_oper_value1(::google::protobuf::uint32 value) {
  set_has_oper_value1();
  oper_value1_ = value;
}

// optional uint32 oper_value2 = 3;
inline bool ReqVIPOperation::has_oper_value2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqVIPOperation::set_has_oper_value2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqVIPOperation::clear_has_oper_value2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqVIPOperation::clear_oper_value2() {
  oper_value2_ = 0u;
  clear_has_oper_value2();
}
inline ::google::protobuf::uint32 ReqVIPOperation::oper_value2() const {
  return oper_value2_;
}
inline void ReqVIPOperation::set_oper_value2(::google::protobuf::uint32 value) {
  set_has_oper_value2();
  oper_value2_ = value;
}

// optional uint32 oper_value3 = 4;
inline bool ReqVIPOperation::has_oper_value3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqVIPOperation::set_has_oper_value3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqVIPOperation::clear_has_oper_value3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqVIPOperation::clear_oper_value3() {
  oper_value3_ = 0u;
  clear_has_oper_value3();
}
inline ::google::protobuf::uint32 ReqVIPOperation::oper_value3() const {
  return oper_value3_;
}
inline void ReqVIPOperation::set_oper_value3(::google::protobuf::uint32 value) {
  set_has_oper_value3();
  oper_value3_ = value;
}

// optional uint32 oper_value4 = 5;
inline bool ReqVIPOperation::has_oper_value4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqVIPOperation::set_has_oper_value4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqVIPOperation::clear_has_oper_value4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqVIPOperation::clear_oper_value4() {
  oper_value4_ = 0u;
  clear_has_oper_value4();
}
inline ::google::protobuf::uint32 ReqVIPOperation::oper_value4() const {
  return oper_value4_;
}
inline void ReqVIPOperation::set_oper_value4(::google::protobuf::uint32 value) {
  set_has_oper_value4();
  oper_value4_ = value;
}

// -------------------------------------------------------------------

// UserFeedback_UserFeedbackInfo

// optional uint32 acc_id = 1;
inline bool UserFeedback_UserFeedbackInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserFeedback_UserFeedbackInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 UserFeedback_UserFeedbackInfo::acc_id() const {
  return acc_id_;
}
inline void UserFeedback_UserFeedbackInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// optional uint32 fb_id = 2;
inline bool UserFeedback_UserFeedbackInfo::has_fb_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_fb_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_fb_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserFeedback_UserFeedbackInfo::clear_fb_id() {
  fb_id_ = 0u;
  clear_has_fb_id();
}
inline ::google::protobuf::uint32 UserFeedback_UserFeedbackInfo::fb_id() const {
  return fb_id_;
}
inline void UserFeedback_UserFeedbackInfo::set_fb_id(::google::protobuf::uint32 value) {
  set_has_fb_id();
  fb_id_ = value;
}

// optional uint32 fb_type = 3;
inline bool UserFeedback_UserFeedbackInfo::has_fb_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_fb_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_fb_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserFeedback_UserFeedbackInfo::clear_fb_type() {
  fb_type_ = 0u;
  clear_has_fb_type();
}
inline ::google::protobuf::uint32 UserFeedback_UserFeedbackInfo::fb_type() const {
  return fb_type_;
}
inline void UserFeedback_UserFeedbackInfo::set_fb_type(::google::protobuf::uint32 value) {
  set_has_fb_type();
  fb_type_ = value;
}

// optional uint32 finish = 4;
inline bool UserFeedback_UserFeedbackInfo::has_finish() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_finish() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_finish() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserFeedback_UserFeedbackInfo::clear_finish() {
  finish_ = 0u;
  clear_has_finish();
}
inline ::google::protobuf::uint32 UserFeedback_UserFeedbackInfo::finish() const {
  return finish_;
}
inline void UserFeedback_UserFeedbackInfo::set_finish(::google::protobuf::uint32 value) {
  set_has_finish();
  finish_ = value;
}

// optional bytes fb_content = 5;
inline bool UserFeedback_UserFeedbackInfo::has_fb_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_fb_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_fb_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserFeedback_UserFeedbackInfo::clear_fb_content() {
  if (fb_content_ != &::google::protobuf::internal::kEmptyString) {
    fb_content_->clear();
  }
  clear_has_fb_content();
}
inline const ::std::string& UserFeedback_UserFeedbackInfo::fb_content() const {
  return *fb_content_;
}
inline void UserFeedback_UserFeedbackInfo::set_fb_content(const ::std::string& value) {
  set_has_fb_content();
  if (fb_content_ == &::google::protobuf::internal::kEmptyString) {
    fb_content_ = new ::std::string;
  }
  fb_content_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_fb_content(const char* value) {
  set_has_fb_content();
  if (fb_content_ == &::google::protobuf::internal::kEmptyString) {
    fb_content_ = new ::std::string;
  }
  fb_content_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_fb_content(const void* value, size_t size) {
  set_has_fb_content();
  if (fb_content_ == &::google::protobuf::internal::kEmptyString) {
    fb_content_ = new ::std::string;
  }
  fb_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback_UserFeedbackInfo::mutable_fb_content() {
  set_has_fb_content();
  if (fb_content_ == &::google::protobuf::internal::kEmptyString) {
    fb_content_ = new ::std::string;
  }
  return fb_content_;
}
inline ::std::string* UserFeedback_UserFeedbackInfo::release_fb_content() {
  clear_has_fb_content();
  if (fb_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fb_content_;
    fb_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback_UserFeedbackInfo::set_allocated_fb_content(::std::string* fb_content) {
  if (fb_content_ != &::google::protobuf::internal::kEmptyString) {
    delete fb_content_;
  }
  if (fb_content) {
    set_has_fb_content();
    fb_content_ = fb_content;
  } else {
    clear_has_fb_content();
    fb_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fb_reply = 6;
inline bool UserFeedback_UserFeedbackInfo::has_fb_reply() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_fb_reply() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_fb_reply() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserFeedback_UserFeedbackInfo::clear_fb_reply() {
  if (fb_reply_ != &::google::protobuf::internal::kEmptyString) {
    fb_reply_->clear();
  }
  clear_has_fb_reply();
}
inline const ::std::string& UserFeedback_UserFeedbackInfo::fb_reply() const {
  return *fb_reply_;
}
inline void UserFeedback_UserFeedbackInfo::set_fb_reply(const ::std::string& value) {
  set_has_fb_reply();
  if (fb_reply_ == &::google::protobuf::internal::kEmptyString) {
    fb_reply_ = new ::std::string;
  }
  fb_reply_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_fb_reply(const char* value) {
  set_has_fb_reply();
  if (fb_reply_ == &::google::protobuf::internal::kEmptyString) {
    fb_reply_ = new ::std::string;
  }
  fb_reply_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_fb_reply(const void* value, size_t size) {
  set_has_fb_reply();
  if (fb_reply_ == &::google::protobuf::internal::kEmptyString) {
    fb_reply_ = new ::std::string;
  }
  fb_reply_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback_UserFeedbackInfo::mutable_fb_reply() {
  set_has_fb_reply();
  if (fb_reply_ == &::google::protobuf::internal::kEmptyString) {
    fb_reply_ = new ::std::string;
  }
  return fb_reply_;
}
inline ::std::string* UserFeedback_UserFeedbackInfo::release_fb_reply() {
  clear_has_fb_reply();
  if (fb_reply_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fb_reply_;
    fb_reply_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback_UserFeedbackInfo::set_allocated_fb_reply(::std::string* fb_reply) {
  if (fb_reply_ != &::google::protobuf::internal::kEmptyString) {
    delete fb_reply_;
  }
  if (fb_reply) {
    set_has_fb_reply();
    fb_reply_ = fb_reply;
  } else {
    clear_has_fb_reply();
    fb_reply_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes commit_time = 7;
inline bool UserFeedback_UserFeedbackInfo::has_commit_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_commit_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_commit_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserFeedback_UserFeedbackInfo::clear_commit_time() {
  if (commit_time_ != &::google::protobuf::internal::kEmptyString) {
    commit_time_->clear();
  }
  clear_has_commit_time();
}
inline const ::std::string& UserFeedback_UserFeedbackInfo::commit_time() const {
  return *commit_time_;
}
inline void UserFeedback_UserFeedbackInfo::set_commit_time(const ::std::string& value) {
  set_has_commit_time();
  if (commit_time_ == &::google::protobuf::internal::kEmptyString) {
    commit_time_ = new ::std::string;
  }
  commit_time_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_commit_time(const char* value) {
  set_has_commit_time();
  if (commit_time_ == &::google::protobuf::internal::kEmptyString) {
    commit_time_ = new ::std::string;
  }
  commit_time_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_commit_time(const void* value, size_t size) {
  set_has_commit_time();
  if (commit_time_ == &::google::protobuf::internal::kEmptyString) {
    commit_time_ = new ::std::string;
  }
  commit_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback_UserFeedbackInfo::mutable_commit_time() {
  set_has_commit_time();
  if (commit_time_ == &::google::protobuf::internal::kEmptyString) {
    commit_time_ = new ::std::string;
  }
  return commit_time_;
}
inline ::std::string* UserFeedback_UserFeedbackInfo::release_commit_time() {
  clear_has_commit_time();
  if (commit_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commit_time_;
    commit_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback_UserFeedbackInfo::set_allocated_commit_time(::std::string* commit_time) {
  if (commit_time_ != &::google::protobuf::internal::kEmptyString) {
    delete commit_time_;
  }
  if (commit_time) {
    set_has_commit_time();
    commit_time_ = commit_time;
  } else {
    clear_has_commit_time();
    commit_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes reply_time = 8;
inline bool UserFeedback_UserFeedbackInfo::has_reply_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_reply_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_reply_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserFeedback_UserFeedbackInfo::clear_reply_time() {
  if (reply_time_ != &::google::protobuf::internal::kEmptyString) {
    reply_time_->clear();
  }
  clear_has_reply_time();
}
inline const ::std::string& UserFeedback_UserFeedbackInfo::reply_time() const {
  return *reply_time_;
}
inline void UserFeedback_UserFeedbackInfo::set_reply_time(const ::std::string& value) {
  set_has_reply_time();
  if (reply_time_ == &::google::protobuf::internal::kEmptyString) {
    reply_time_ = new ::std::string;
  }
  reply_time_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_reply_time(const char* value) {
  set_has_reply_time();
  if (reply_time_ == &::google::protobuf::internal::kEmptyString) {
    reply_time_ = new ::std::string;
  }
  reply_time_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_reply_time(const void* value, size_t size) {
  set_has_reply_time();
  if (reply_time_ == &::google::protobuf::internal::kEmptyString) {
    reply_time_ = new ::std::string;
  }
  reply_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback_UserFeedbackInfo::mutable_reply_time() {
  set_has_reply_time();
  if (reply_time_ == &::google::protobuf::internal::kEmptyString) {
    reply_time_ = new ::std::string;
  }
  return reply_time_;
}
inline ::std::string* UserFeedback_UserFeedbackInfo::release_reply_time() {
  clear_has_reply_time();
  if (reply_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reply_time_;
    reply_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback_UserFeedbackInfo::set_allocated_reply_time(::std::string* reply_time) {
  if (reply_time_ != &::google::protobuf::internal::kEmptyString) {
    delete reply_time_;
  }
  if (reply_time) {
    set_has_reply_time();
    reply_time_ = reply_time;
  } else {
    clear_has_reply_time();
    reply_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 answer_id = 9;
inline bool UserFeedback_UserFeedbackInfo::has_answer_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_answer_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_answer_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserFeedback_UserFeedbackInfo::clear_answer_id() {
  answer_id_ = 0u;
  clear_has_answer_id();
}
inline ::google::protobuf::uint32 UserFeedback_UserFeedbackInfo::answer_id() const {
  return answer_id_;
}
inline void UserFeedback_UserFeedbackInfo::set_answer_id(::google::protobuf::uint32 value) {
  set_has_answer_id();
  answer_id_ = value;
}

// optional bytes char_name = 10;
inline bool UserFeedback_UserFeedbackInfo::has_char_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_char_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserFeedback_UserFeedbackInfo::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& UserFeedback_UserFeedbackInfo::char_name() const {
  return *char_name_;
}
inline void UserFeedback_UserFeedbackInfo::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void UserFeedback_UserFeedbackInfo::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback_UserFeedbackInfo::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* UserFeedback_UserFeedbackInfo::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback_UserFeedbackInfo::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 log_id = 11;
inline bool UserFeedback_UserFeedbackInfo::has_log_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_log_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_log_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserFeedback_UserFeedbackInfo::clear_log_id() {
  log_id_ = 0u;
  clear_has_log_id();
}
inline ::google::protobuf::uint32 UserFeedback_UserFeedbackInfo::log_id() const {
  return log_id_;
}
inline void UserFeedback_UserFeedbackInfo::set_log_id(::google::protobuf::uint32 value) {
  set_has_log_id();
  log_id_ = value;
}

// optional uint32 server_id = 12;
inline bool UserFeedback_UserFeedbackInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserFeedback_UserFeedbackInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserFeedback_UserFeedbackInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserFeedback_UserFeedbackInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 UserFeedback_UserFeedbackInfo::server_id() const {
  return server_id_;
}
inline void UserFeedback_UserFeedbackInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// -------------------------------------------------------------------

// UserFeedback

// repeated .message.UserFeedback.UserFeedbackInfo user_feedback_info = 1;
inline int UserFeedback::user_feedback_info_size() const {
  return user_feedback_info_.size();
}
inline void UserFeedback::clear_user_feedback_info() {
  user_feedback_info_.Clear();
}
inline const ::message::UserFeedback_UserFeedbackInfo& UserFeedback::user_feedback_info(int index) const {
  return user_feedback_info_.Get(index);
}
inline ::message::UserFeedback_UserFeedbackInfo* UserFeedback::mutable_user_feedback_info(int index) {
  return user_feedback_info_.Mutable(index);
}
inline ::message::UserFeedback_UserFeedbackInfo* UserFeedback::add_user_feedback_info() {
  return user_feedback_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::UserFeedback_UserFeedbackInfo >&
UserFeedback::user_feedback_info() const {
  return user_feedback_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::UserFeedback_UserFeedbackInfo >*
UserFeedback::mutable_user_feedback_info() {
  return &user_feedback_info_;
}

// optional bytes gm_comit_time = 2;
inline bool UserFeedback::has_gm_comit_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserFeedback::set_has_gm_comit_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserFeedback::clear_has_gm_comit_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserFeedback::clear_gm_comit_time() {
  if (gm_comit_time_ != &::google::protobuf::internal::kEmptyString) {
    gm_comit_time_->clear();
  }
  clear_has_gm_comit_time();
}
inline const ::std::string& UserFeedback::gm_comit_time() const {
  return *gm_comit_time_;
}
inline void UserFeedback::set_gm_comit_time(const ::std::string& value) {
  set_has_gm_comit_time();
  if (gm_comit_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_comit_time_ = new ::std::string;
  }
  gm_comit_time_->assign(value);
}
inline void UserFeedback::set_gm_comit_time(const char* value) {
  set_has_gm_comit_time();
  if (gm_comit_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_comit_time_ = new ::std::string;
  }
  gm_comit_time_->assign(value);
}
inline void UserFeedback::set_gm_comit_time(const void* value, size_t size) {
  set_has_gm_comit_time();
  if (gm_comit_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_comit_time_ = new ::std::string;
  }
  gm_comit_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback::mutable_gm_comit_time() {
  set_has_gm_comit_time();
  if (gm_comit_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_comit_time_ = new ::std::string;
  }
  return gm_comit_time_;
}
inline ::std::string* UserFeedback::release_gm_comit_time() {
  clear_has_gm_comit_time();
  if (gm_comit_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_comit_time_;
    gm_comit_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback::set_allocated_gm_comit_time(::std::string* gm_comit_time) {
  if (gm_comit_time_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_comit_time_;
  }
  if (gm_comit_time) {
    set_has_gm_comit_time();
    gm_comit_time_ = gm_comit_time;
  } else {
    clear_has_gm_comit_time();
    gm_comit_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gm_reply_time = 3;
inline bool UserFeedback::has_gm_reply_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserFeedback::set_has_gm_reply_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserFeedback::clear_has_gm_reply_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserFeedback::clear_gm_reply_time() {
  if (gm_reply_time_ != &::google::protobuf::internal::kEmptyString) {
    gm_reply_time_->clear();
  }
  clear_has_gm_reply_time();
}
inline const ::std::string& UserFeedback::gm_reply_time() const {
  return *gm_reply_time_;
}
inline void UserFeedback::set_gm_reply_time(const ::std::string& value) {
  set_has_gm_reply_time();
  if (gm_reply_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_reply_time_ = new ::std::string;
  }
  gm_reply_time_->assign(value);
}
inline void UserFeedback::set_gm_reply_time(const char* value) {
  set_has_gm_reply_time();
  if (gm_reply_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_reply_time_ = new ::std::string;
  }
  gm_reply_time_->assign(value);
}
inline void UserFeedback::set_gm_reply_time(const void* value, size_t size) {
  set_has_gm_reply_time();
  if (gm_reply_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_reply_time_ = new ::std::string;
  }
  gm_reply_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback::mutable_gm_reply_time() {
  set_has_gm_reply_time();
  if (gm_reply_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_reply_time_ = new ::std::string;
  }
  return gm_reply_time_;
}
inline ::std::string* UserFeedback::release_gm_reply_time() {
  clear_has_gm_reply_time();
  if (gm_reply_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_reply_time_;
    gm_reply_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback::set_allocated_gm_reply_time(::std::string* gm_reply_time) {
  if (gm_reply_time_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_reply_time_;
  }
  if (gm_reply_time) {
    set_has_gm_reply_time();
    gm_reply_time_ = gm_reply_time;
  } else {
    clear_has_gm_reply_time();
    gm_reply_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gm_char_name = 4;
inline bool UserFeedback::has_gm_char_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserFeedback::set_has_gm_char_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserFeedback::clear_has_gm_char_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserFeedback::clear_gm_char_name() {
  if (gm_char_name_ != &::google::protobuf::internal::kEmptyString) {
    gm_char_name_->clear();
  }
  clear_has_gm_char_name();
}
inline const ::std::string& UserFeedback::gm_char_name() const {
  return *gm_char_name_;
}
inline void UserFeedback::set_gm_char_name(const ::std::string& value) {
  set_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_char_name_ = new ::std::string;
  }
  gm_char_name_->assign(value);
}
inline void UserFeedback::set_gm_char_name(const char* value) {
  set_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_char_name_ = new ::std::string;
  }
  gm_char_name_->assign(value);
}
inline void UserFeedback::set_gm_char_name(const void* value, size_t size) {
  set_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_char_name_ = new ::std::string;
  }
  gm_char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback::mutable_gm_char_name() {
  set_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_char_name_ = new ::std::string;
  }
  return gm_char_name_;
}
inline ::std::string* UserFeedback::release_gm_char_name() {
  clear_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_char_name_;
    gm_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback::set_allocated_gm_char_name(::std::string* gm_char_name) {
  if (gm_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_char_name_;
  }
  if (gm_char_name) {
    set_has_gm_char_name();
    gm_char_name_ = gm_char_name;
  } else {
    clear_has_gm_char_name();
    gm_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sendfb_type = 5;
inline bool UserFeedback::has_sendfb_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserFeedback::set_has_sendfb_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserFeedback::clear_has_sendfb_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserFeedback::clear_sendfb_type() {
  sendfb_type_ = 0u;
  clear_has_sendfb_type();
}
inline ::google::protobuf::uint32 UserFeedback::sendfb_type() const {
  return sendfb_type_;
}
inline void UserFeedback::set_sendfb_type(::google::protobuf::uint32 value) {
  set_has_sendfb_type();
  sendfb_type_ = value;
}

// optional bytes gm_talk = 6;
inline bool UserFeedback::has_gm_talk() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserFeedback::set_has_gm_talk() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserFeedback::clear_has_gm_talk() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserFeedback::clear_gm_talk() {
  if (gm_talk_ != &::google::protobuf::internal::kEmptyString) {
    gm_talk_->clear();
  }
  clear_has_gm_talk();
}
inline const ::std::string& UserFeedback::gm_talk() const {
  return *gm_talk_;
}
inline void UserFeedback::set_gm_talk(const ::std::string& value) {
  set_has_gm_talk();
  if (gm_talk_ == &::google::protobuf::internal::kEmptyString) {
    gm_talk_ = new ::std::string;
  }
  gm_talk_->assign(value);
}
inline void UserFeedback::set_gm_talk(const char* value) {
  set_has_gm_talk();
  if (gm_talk_ == &::google::protobuf::internal::kEmptyString) {
    gm_talk_ = new ::std::string;
  }
  gm_talk_->assign(value);
}
inline void UserFeedback::set_gm_talk(const void* value, size_t size) {
  set_has_gm_talk();
  if (gm_talk_ == &::google::protobuf::internal::kEmptyString) {
    gm_talk_ = new ::std::string;
  }
  gm_talk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFeedback::mutable_gm_talk() {
  set_has_gm_talk();
  if (gm_talk_ == &::google::protobuf::internal::kEmptyString) {
    gm_talk_ = new ::std::string;
  }
  return gm_talk_;
}
inline ::std::string* UserFeedback::release_gm_talk() {
  clear_has_gm_talk();
  if (gm_talk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_talk_;
    gm_talk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFeedback::set_allocated_gm_talk(::std::string* gm_talk) {
  if (gm_talk_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_talk_;
  }
  if (gm_talk) {
    set_has_gm_talk();
    gm_talk_ = gm_talk;
  } else {
    clear_has_gm_talk();
    gm_talk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 fb_id_new = 7;
inline bool UserFeedback::has_fb_id_new() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserFeedback::set_has_fb_id_new() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserFeedback::clear_has_fb_id_new() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserFeedback::clear_fb_id_new() {
  fb_id_new_ = 0u;
  clear_has_fb_id_new();
}
inline ::google::protobuf::uint32 UserFeedback::fb_id_new() const {
  return fb_id_new_;
}
inline void UserFeedback::set_fb_id_new(::google::protobuf::uint32 value) {
  set_has_fb_id_new();
  fb_id_new_ = value;
}

// -------------------------------------------------------------------

// SystemReward

// repeated uint32 oper_id = 1;
inline int SystemReward::oper_id_size() const {
  return oper_id_.size();
}
inline void SystemReward::clear_oper_id() {
  oper_id_.Clear();
}
inline ::google::protobuf::uint32 SystemReward::oper_id(int index) const {
  return oper_id_.Get(index);
}
inline void SystemReward::set_oper_id(int index, ::google::protobuf::uint32 value) {
  oper_id_.Set(index, value);
}
inline void SystemReward::add_oper_id(::google::protobuf::uint32 value) {
  oper_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SystemReward::oper_id() const {
  return oper_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SystemReward::mutable_oper_id() {
  return &oper_id_;
}

// repeated uint32 reward_item = 2;
inline int SystemReward::reward_item_size() const {
  return reward_item_.size();
}
inline void SystemReward::clear_reward_item() {
  reward_item_.Clear();
}
inline ::google::protobuf::uint32 SystemReward::reward_item(int index) const {
  return reward_item_.Get(index);
}
inline void SystemReward::set_reward_item(int index, ::google::protobuf::uint32 value) {
  reward_item_.Set(index, value);
}
inline void SystemReward::add_reward_item(::google::protobuf::uint32 value) {
  reward_item_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SystemReward::reward_item() const {
  return reward_item_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SystemReward::mutable_reward_item() {
  return &reward_item_;
}

// repeated uint32 reward_item_num = 3;
inline int SystemReward::reward_item_num_size() const {
  return reward_item_num_.size();
}
inline void SystemReward::clear_reward_item_num() {
  reward_item_num_.Clear();
}
inline ::google::protobuf::uint32 SystemReward::reward_item_num(int index) const {
  return reward_item_num_.Get(index);
}
inline void SystemReward::set_reward_item_num(int index, ::google::protobuf::uint32 value) {
  reward_item_num_.Set(index, value);
}
inline void SystemReward::add_reward_item_num(::google::protobuf::uint32 value) {
  reward_item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SystemReward::reward_item_num() const {
  return reward_item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SystemReward::mutable_reward_item_num() {
  return &reward_item_num_;
}

// repeated uint32 oper_pos = 4;
inline int SystemReward::oper_pos_size() const {
  return oper_pos_.size();
}
inline void SystemReward::clear_oper_pos() {
  oper_pos_.Clear();
}
inline ::google::protobuf::uint32 SystemReward::oper_pos(int index) const {
  return oper_pos_.Get(index);
}
inline void SystemReward::set_oper_pos(int index, ::google::protobuf::uint32 value) {
  oper_pos_.Set(index, value);
}
inline void SystemReward::add_oper_pos(::google::protobuf::uint32 value) {
  oper_pos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SystemReward::oper_pos() const {
  return oper_pos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SystemReward::mutable_oper_pos() {
  return &oper_pos_;
}

// repeated bytes sys_msg = 5;
inline int SystemReward::sys_msg_size() const {
  return sys_msg_.size();
}
inline void SystemReward::clear_sys_msg() {
  sys_msg_.Clear();
}
inline const ::std::string& SystemReward::sys_msg(int index) const {
  return sys_msg_.Get(index);
}
inline ::std::string* SystemReward::mutable_sys_msg(int index) {
  return sys_msg_.Mutable(index);
}
inline void SystemReward::set_sys_msg(int index, const ::std::string& value) {
  sys_msg_.Mutable(index)->assign(value);
}
inline void SystemReward::set_sys_msg(int index, const char* value) {
  sys_msg_.Mutable(index)->assign(value);
}
inline void SystemReward::set_sys_msg(int index, const void* value, size_t size) {
  sys_msg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemReward::add_sys_msg() {
  return sys_msg_.Add();
}
inline void SystemReward::add_sys_msg(const ::std::string& value) {
  sys_msg_.Add()->assign(value);
}
inline void SystemReward::add_sys_msg(const char* value) {
  sys_msg_.Add()->assign(value);
}
inline void SystemReward::add_sys_msg(const void* value, size_t size) {
  sys_msg_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SystemReward::sys_msg() const {
  return sys_msg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SystemReward::mutable_sys_msg() {
  return &sys_msg_;
}

// optional uint32 send_type = 6;
inline bool SystemReward::has_send_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SystemReward::set_has_send_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SystemReward::clear_has_send_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SystemReward::clear_send_type() {
  send_type_ = 0u;
  clear_has_send_type();
}
inline ::google::protobuf::uint32 SystemReward::send_type() const {
  return send_type_;
}
inline void SystemReward::set_send_type(::google::protobuf::uint32 value) {
  set_has_send_type();
  send_type_ = value;
}

// optional uint32 glass = 7;
inline bool SystemReward::has_glass() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SystemReward::set_has_glass() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SystemReward::clear_has_glass() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SystemReward::clear_glass() {
  glass_ = 0u;
  clear_has_glass();
}
inline ::google::protobuf::uint32 SystemReward::glass() const {
  return glass_;
}
inline void SystemReward::set_glass(::google::protobuf::uint32 value) {
  set_has_glass();
  glass_ = value;
}

// optional bytes name = 8;
inline bool SystemReward::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SystemReward::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SystemReward::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SystemReward::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SystemReward::name() const {
  return *name_;
}
inline void SystemReward::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SystemReward::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SystemReward::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemReward::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SystemReward::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemReward::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sdk = 9;
inline bool SystemReward::has_sdk() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SystemReward::set_has_sdk() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SystemReward::clear_has_sdk() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SystemReward::clear_sdk() {
  if (sdk_ != &::google::protobuf::internal::kEmptyString) {
    sdk_->clear();
  }
  clear_has_sdk();
}
inline const ::std::string& SystemReward::sdk() const {
  return *sdk_;
}
inline void SystemReward::set_sdk(const ::std::string& value) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(value);
}
inline void SystemReward::set_sdk(const char* value) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(value);
}
inline void SystemReward::set_sdk(const void* value, size_t size) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemReward::mutable_sdk() {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  return sdk_;
}
inline ::std::string* SystemReward::release_sdk() {
  clear_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_;
    sdk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemReward::set_allocated_sdk(::std::string* sdk) {
  if (sdk_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_;
  }
  if (sdk) {
    set_has_sdk();
    sdk_ = sdk;
  } else {
    clear_has_sdk();
    sdk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 server_id = 10;
inline bool SystemReward::has_server_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SystemReward::set_has_server_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SystemReward::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SystemReward::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 SystemReward::server_id() const {
  return server_id_;
}
inline void SystemReward::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 gm_accid = 11;
inline bool SystemReward::has_gm_accid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SystemReward::set_has_gm_accid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SystemReward::clear_has_gm_accid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SystemReward::clear_gm_accid() {
  gm_accid_ = 0u;
  clear_has_gm_accid();
}
inline ::google::protobuf::uint32 SystemReward::gm_accid() const {
  return gm_accid_;
}
inline void SystemReward::set_gm_accid(::google::protobuf::uint32 value) {
  set_has_gm_accid();
  gm_accid_ = value;
}

// -------------------------------------------------------------------

// GMFreezeSystem_GMFreezeSystemInfo

// optional uint32 acc_id = 1;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 GMFreezeSystem_GMFreezeSystemInfo::acc_id() const {
  return acc_id_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// optional uint32 server_id = 2;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 GMFreezeSystem_GMFreezeSystemInfo::server_id() const {
  return server_id_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 gm_type = 3;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_gm_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_gm_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_gm_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_gm_type() {
  gm_type_ = 0u;
  clear_has_gm_type();
}
inline ::google::protobuf::uint32 GMFreezeSystem_GMFreezeSystemInfo::gm_type() const {
  return gm_type_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_gm_type(::google::protobuf::uint32 value) {
  set_has_gm_type();
  gm_type_ = value;
}

// optional uint32 hour = 4;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_hour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_hour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_hour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_hour() {
  hour_ = 0u;
  clear_has_hour();
}
inline ::google::protobuf::uint32 GMFreezeSystem_GMFreezeSystemInfo::hour() const {
  return hour_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_hour(::google::protobuf::uint32 value) {
  set_has_hour();
  hour_ = value;
}

// optional bytes reason = 5;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& GMFreezeSystem_GMFreezeSystemInfo::reason() const {
  return *reason_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_reason(const void* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes freeze_time = 6;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_freeze_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_freeze_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_freeze_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_freeze_time() {
  if (freeze_time_ != &::google::protobuf::internal::kEmptyString) {
    freeze_time_->clear();
  }
  clear_has_freeze_time();
}
inline const ::std::string& GMFreezeSystem_GMFreezeSystemInfo::freeze_time() const {
  return *freeze_time_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_freeze_time(const ::std::string& value) {
  set_has_freeze_time();
  if (freeze_time_ == &::google::protobuf::internal::kEmptyString) {
    freeze_time_ = new ::std::string;
  }
  freeze_time_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_freeze_time(const char* value) {
  set_has_freeze_time();
  if (freeze_time_ == &::google::protobuf::internal::kEmptyString) {
    freeze_time_ = new ::std::string;
  }
  freeze_time_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_freeze_time(const void* value, size_t size) {
  set_has_freeze_time();
  if (freeze_time_ == &::google::protobuf::internal::kEmptyString) {
    freeze_time_ = new ::std::string;
  }
  freeze_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::mutable_freeze_time() {
  set_has_freeze_time();
  if (freeze_time_ == &::google::protobuf::internal::kEmptyString) {
    freeze_time_ = new ::std::string;
  }
  return freeze_time_;
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::release_freeze_time() {
  clear_has_freeze_time();
  if (freeze_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = freeze_time_;
    freeze_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_allocated_freeze_time(::std::string* freeze_time) {
  if (freeze_time_ != &::google::protobuf::internal::kEmptyString) {
    delete freeze_time_;
  }
  if (freeze_time) {
    set_has_freeze_time();
    freeze_time_ = freeze_time;
  } else {
    clear_has_freeze_time();
    freeze_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes end_time = 7;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_end_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_end_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_end_time() {
  if (end_time_ != &::google::protobuf::internal::kEmptyString) {
    end_time_->clear();
  }
  clear_has_end_time();
}
inline const ::std::string& GMFreezeSystem_GMFreezeSystemInfo::end_time() const {
  return *end_time_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_end_time(const ::std::string& value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_end_time(const char* value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_end_time(const void* value, size_t size) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::mutable_end_time() {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  return end_time_;
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::release_end_time() {
  clear_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = end_time_;
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_allocated_end_time(::std::string* end_time) {
  if (end_time_ != &::google::protobuf::internal::kEmptyString) {
    delete end_time_;
  }
  if (end_time) {
    set_has_end_time();
    end_time_ = end_time;
  } else {
    clear_has_end_time();
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gm_name = 8;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_gm_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_gm_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_gm_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_gm_name() {
  if (gm_name_ != &::google::protobuf::internal::kEmptyString) {
    gm_name_->clear();
  }
  clear_has_gm_name();
}
inline const ::std::string& GMFreezeSystem_GMFreezeSystemInfo::gm_name() const {
  return *gm_name_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_gm_name(const ::std::string& value) {
  set_has_gm_name();
  if (gm_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_name_ = new ::std::string;
  }
  gm_name_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_gm_name(const char* value) {
  set_has_gm_name();
  if (gm_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_name_ = new ::std::string;
  }
  gm_name_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_gm_name(const void* value, size_t size) {
  set_has_gm_name();
  if (gm_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_name_ = new ::std::string;
  }
  gm_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::mutable_gm_name() {
  set_has_gm_name();
  if (gm_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_name_ = new ::std::string;
  }
  return gm_name_;
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::release_gm_name() {
  clear_has_gm_name();
  if (gm_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_name_;
    gm_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_allocated_gm_name(::std::string* gm_name) {
  if (gm_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_name_;
  }
  if (gm_name) {
    set_has_gm_name();
    gm_name_ = gm_name;
  } else {
    clear_has_gm_name();
    gm_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes char_name = 9;
inline bool GMFreezeSystem_GMFreezeSystemInfo::has_char_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_has_char_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& GMFreezeSystem_GMFreezeSystemInfo::char_name() const {
  return *char_name_;
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* GMFreezeSystem_GMFreezeSystemInfo::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFreezeSystem_GMFreezeSystemInfo::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GMFreezeSystem

// repeated .message.GMFreezeSystem.GMFreezeSystemInfo gm_freeze_info = 1;
inline int GMFreezeSystem::gm_freeze_info_size() const {
  return gm_freeze_info_.size();
}
inline void GMFreezeSystem::clear_gm_freeze_info() {
  gm_freeze_info_.Clear();
}
inline const ::message::GMFreezeSystem_GMFreezeSystemInfo& GMFreezeSystem::gm_freeze_info(int index) const {
  return gm_freeze_info_.Get(index);
}
inline ::message::GMFreezeSystem_GMFreezeSystemInfo* GMFreezeSystem::mutable_gm_freeze_info(int index) {
  return gm_freeze_info_.Mutable(index);
}
inline ::message::GMFreezeSystem_GMFreezeSystemInfo* GMFreezeSystem::add_gm_freeze_info() {
  return gm_freeze_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GMFreezeSystem_GMFreezeSystemInfo >&
GMFreezeSystem::gm_freeze_info() const {
  return gm_freeze_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GMFreezeSystem_GMFreezeSystemInfo >*
GMFreezeSystem::mutable_gm_freeze_info() {
  return &gm_freeze_info_;
}

// optional uint32 gm_acc_id = 2;
inline bool GMFreezeSystem::has_gm_acc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMFreezeSystem::set_has_gm_acc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMFreezeSystem::clear_has_gm_acc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMFreezeSystem::clear_gm_acc_id() {
  gm_acc_id_ = 0u;
  clear_has_gm_acc_id();
}
inline ::google::protobuf::uint32 GMFreezeSystem::gm_acc_id() const {
  return gm_acc_id_;
}
inline void GMFreezeSystem::set_gm_acc_id(::google::protobuf::uint32 value) {
  set_has_gm_acc_id();
  gm_acc_id_ = value;
}

// optional uint32 send_type = 3;
inline bool GMFreezeSystem::has_send_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMFreezeSystem::set_has_send_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMFreezeSystem::clear_has_send_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMFreezeSystem::clear_send_type() {
  send_type_ = 0u;
  clear_has_send_type();
}
inline ::google::protobuf::uint32 GMFreezeSystem::send_type() const {
  return send_type_;
}
inline void GMFreezeSystem::set_send_type(::google::protobuf::uint32 value) {
  set_has_send_type();
  send_type_ = value;
}

// optional bytes gm_check_time = 4;
inline bool GMFreezeSystem::has_gm_check_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMFreezeSystem::set_has_gm_check_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMFreezeSystem::clear_has_gm_check_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMFreezeSystem::clear_gm_check_time() {
  if (gm_check_time_ != &::google::protobuf::internal::kEmptyString) {
    gm_check_time_->clear();
  }
  clear_has_gm_check_time();
}
inline const ::std::string& GMFreezeSystem::gm_check_time() const {
  return *gm_check_time_;
}
inline void GMFreezeSystem::set_gm_check_time(const ::std::string& value) {
  set_has_gm_check_time();
  if (gm_check_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_check_time_ = new ::std::string;
  }
  gm_check_time_->assign(value);
}
inline void GMFreezeSystem::set_gm_check_time(const char* value) {
  set_has_gm_check_time();
  if (gm_check_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_check_time_ = new ::std::string;
  }
  gm_check_time_->assign(value);
}
inline void GMFreezeSystem::set_gm_check_time(const void* value, size_t size) {
  set_has_gm_check_time();
  if (gm_check_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_check_time_ = new ::std::string;
  }
  gm_check_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFreezeSystem::mutable_gm_check_time() {
  set_has_gm_check_time();
  if (gm_check_time_ == &::google::protobuf::internal::kEmptyString) {
    gm_check_time_ = new ::std::string;
  }
  return gm_check_time_;
}
inline ::std::string* GMFreezeSystem::release_gm_check_time() {
  clear_has_gm_check_time();
  if (gm_check_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_check_time_;
    gm_check_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFreezeSystem::set_allocated_gm_check_time(::std::string* gm_check_time) {
  if (gm_check_time_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_check_time_;
  }
  if (gm_check_time) {
    set_has_gm_check_time();
    gm_check_time_ = gm_check_time;
  } else {
    clear_has_gm_check_time();
    gm_check_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gm_char_name = 5;
inline bool GMFreezeSystem::has_gm_char_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMFreezeSystem::set_has_gm_char_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMFreezeSystem::clear_has_gm_char_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMFreezeSystem::clear_gm_char_name() {
  if (gm_char_name_ != &::google::protobuf::internal::kEmptyString) {
    gm_char_name_->clear();
  }
  clear_has_gm_char_name();
}
inline const ::std::string& GMFreezeSystem::gm_char_name() const {
  return *gm_char_name_;
}
inline void GMFreezeSystem::set_gm_char_name(const ::std::string& value) {
  set_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_char_name_ = new ::std::string;
  }
  gm_char_name_->assign(value);
}
inline void GMFreezeSystem::set_gm_char_name(const char* value) {
  set_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_char_name_ = new ::std::string;
  }
  gm_char_name_->assign(value);
}
inline void GMFreezeSystem::set_gm_char_name(const void* value, size_t size) {
  set_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_char_name_ = new ::std::string;
  }
  gm_char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFreezeSystem::mutable_gm_char_name() {
  set_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    gm_char_name_ = new ::std::string;
  }
  return gm_char_name_;
}
inline ::std::string* GMFreezeSystem::release_gm_char_name() {
  clear_has_gm_char_name();
  if (gm_char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_char_name_;
    gm_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFreezeSystem::set_allocated_gm_char_name(::std::string* gm_char_name) {
  if (gm_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_char_name_;
  }
  if (gm_char_name) {
    set_has_gm_char_name();
    gm_char_name_ = gm_char_name;
  } else {
    clear_has_gm_char_name();
    gm_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginSystemNotice

// optional uint32 notice_type = 1;
inline bool LoginSystemNotice::has_notice_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginSystemNotice::set_has_notice_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginSystemNotice::clear_has_notice_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginSystemNotice::clear_notice_type() {
  notice_type_ = 0u;
  clear_has_notice_type();
}
inline ::google::protobuf::uint32 LoginSystemNotice::notice_type() const {
  return notice_type_;
}
inline void LoginSystemNotice::set_notice_type(::google::protobuf::uint32 value) {
  set_has_notice_type();
  notice_type_ = value;
}

// optional uint32 acc_id = 2;
inline bool LoginSystemNotice::has_acc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginSystemNotice::set_has_acc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginSystemNotice::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginSystemNotice::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 LoginSystemNotice::acc_id() const {
  return acc_id_;
}
inline void LoginSystemNotice::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// optional bytes notice = 3;
inline bool LoginSystemNotice::has_notice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginSystemNotice::set_has_notice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginSystemNotice::clear_has_notice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginSystemNotice::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& LoginSystemNotice::notice() const {
  return *notice_;
}
inline void LoginSystemNotice::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void LoginSystemNotice::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void LoginSystemNotice::set_notice(const void* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginSystemNotice::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* LoginSystemNotice::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginSystemNotice::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes notice_time = 4;
inline bool LoginSystemNotice::has_notice_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginSystemNotice::set_has_notice_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginSystemNotice::clear_has_notice_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginSystemNotice::clear_notice_time() {
  if (notice_time_ != &::google::protobuf::internal::kEmptyString) {
    notice_time_->clear();
  }
  clear_has_notice_time();
}
inline const ::std::string& LoginSystemNotice::notice_time() const {
  return *notice_time_;
}
inline void LoginSystemNotice::set_notice_time(const ::std::string& value) {
  set_has_notice_time();
  if (notice_time_ == &::google::protobuf::internal::kEmptyString) {
    notice_time_ = new ::std::string;
  }
  notice_time_->assign(value);
}
inline void LoginSystemNotice::set_notice_time(const char* value) {
  set_has_notice_time();
  if (notice_time_ == &::google::protobuf::internal::kEmptyString) {
    notice_time_ = new ::std::string;
  }
  notice_time_->assign(value);
}
inline void LoginSystemNotice::set_notice_time(const void* value, size_t size) {
  set_has_notice_time();
  if (notice_time_ == &::google::protobuf::internal::kEmptyString) {
    notice_time_ = new ::std::string;
  }
  notice_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginSystemNotice::mutable_notice_time() {
  set_has_notice_time();
  if (notice_time_ == &::google::protobuf::internal::kEmptyString) {
    notice_time_ = new ::std::string;
  }
  return notice_time_;
}
inline ::std::string* LoginSystemNotice::release_notice_time() {
  clear_has_notice_time();
  if (notice_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_time_;
    notice_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginSystemNotice::set_allocated_notice_time(::std::string* notice_time) {
  if (notice_time_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_time_;
  }
  if (notice_time) {
    set_has_notice_time();
    notice_time_ = notice_time;
  } else {
    clear_has_notice_time();
    notice_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sdk = 5;
inline bool LoginSystemNotice::has_sdk() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginSystemNotice::set_has_sdk() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginSystemNotice::clear_has_sdk() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginSystemNotice::clear_sdk() {
  if (sdk_ != &::google::protobuf::internal::kEmptyString) {
    sdk_->clear();
  }
  clear_has_sdk();
}
inline const ::std::string& LoginSystemNotice::sdk() const {
  return *sdk_;
}
inline void LoginSystemNotice::set_sdk(const ::std::string& value) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(value);
}
inline void LoginSystemNotice::set_sdk(const char* value) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(value);
}
inline void LoginSystemNotice::set_sdk(const void* value, size_t size) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginSystemNotice::mutable_sdk() {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  return sdk_;
}
inline ::std::string* LoginSystemNotice::release_sdk() {
  clear_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_;
    sdk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginSystemNotice::set_allocated_sdk(::std::string* sdk) {
  if (sdk_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_;
  }
  if (sdk) {
    set_has_sdk();
    sdk_ = sdk;
  } else {
    clear_has_sdk();
    sdk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GMOperationResult

// optional uint32 gm_accid = 1;
inline bool GMOperationResult::has_gm_accid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMOperationResult::set_has_gm_accid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMOperationResult::clear_has_gm_accid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMOperationResult::clear_gm_accid() {
  gm_accid_ = 0u;
  clear_has_gm_accid();
}
inline ::google::protobuf::uint32 GMOperationResult::gm_accid() const {
  return gm_accid_;
}
inline void GMOperationResult::set_gm_accid(::google::protobuf::uint32 value) {
  set_has_gm_accid();
  gm_accid_ = value;
}

// optional uint32 gm_optype = 2;
inline bool GMOperationResult::has_gm_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMOperationResult::set_has_gm_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMOperationResult::clear_has_gm_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMOperationResult::clear_gm_optype() {
  gm_optype_ = 0u;
  clear_has_gm_optype();
}
inline ::google::protobuf::uint32 GMOperationResult::gm_optype() const {
  return gm_optype_;
}
inline void GMOperationResult::set_gm_optype(::google::protobuf::uint32 value) {
  set_has_gm_optype();
  gm_optype_ = value;
}

// optional bytes rolename = 3;
inline bool GMOperationResult::has_rolename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMOperationResult::set_has_rolename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMOperationResult::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMOperationResult::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& GMOperationResult::rolename() const {
  return *rolename_;
}
inline void GMOperationResult::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void GMOperationResult::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void GMOperationResult::set_rolename(const void* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMOperationResult::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* GMOperationResult::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMOperationResult::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fail_reason = 4;
inline bool GMOperationResult::has_fail_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMOperationResult::set_has_fail_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMOperationResult::clear_has_fail_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMOperationResult::clear_fail_reason() {
  if (fail_reason_ != &::google::protobuf::internal::kEmptyString) {
    fail_reason_->clear();
  }
  clear_has_fail_reason();
}
inline const ::std::string& GMOperationResult::fail_reason() const {
  return *fail_reason_;
}
inline void GMOperationResult::set_fail_reason(const ::std::string& value) {
  set_has_fail_reason();
  if (fail_reason_ == &::google::protobuf::internal::kEmptyString) {
    fail_reason_ = new ::std::string;
  }
  fail_reason_->assign(value);
}
inline void GMOperationResult::set_fail_reason(const char* value) {
  set_has_fail_reason();
  if (fail_reason_ == &::google::protobuf::internal::kEmptyString) {
    fail_reason_ = new ::std::string;
  }
  fail_reason_->assign(value);
}
inline void GMOperationResult::set_fail_reason(const void* value, size_t size) {
  set_has_fail_reason();
  if (fail_reason_ == &::google::protobuf::internal::kEmptyString) {
    fail_reason_ = new ::std::string;
  }
  fail_reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMOperationResult::mutable_fail_reason() {
  set_has_fail_reason();
  if (fail_reason_ == &::google::protobuf::internal::kEmptyString) {
    fail_reason_ = new ::std::string;
  }
  return fail_reason_;
}
inline ::std::string* GMOperationResult::release_fail_reason() {
  clear_has_fail_reason();
  if (fail_reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fail_reason_;
    fail_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMOperationResult::set_allocated_fail_reason(::std::string* fail_reason) {
  if (fail_reason_ != &::google::protobuf::internal::kEmptyString) {
    delete fail_reason_;
  }
  if (fail_reason) {
    set_has_fail_reason();
    fail_reason_ = fail_reason;
  } else {
    clear_has_fail_reason();
    fail_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckGetInviteCode

// required bytes value = 1;
inline bool AckGetInviteCode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGetInviteCode::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGetInviteCode::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGetInviteCode::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& AckGetInviteCode::value() const {
  return *value_;
}
inline void AckGetInviteCode::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AckGetInviteCode::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AckGetInviteCode::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGetInviteCode::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* AckGetInviteCode::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckGetInviteCode::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqDrawLottery

// required uint32 value = 1;
inline bool ReqDrawLottery::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqDrawLottery::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqDrawLottery::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqDrawLottery::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqDrawLottery::value() const {
  return value_;
}
inline void ReqDrawLottery::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// GetLotteryReward

// required uint32 value = 1;
inline bool GetLotteryReward::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLotteryReward::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLotteryReward::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLotteryReward::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 GetLotteryReward::value() const {
  return value_;
}
inline void GetLotteryReward::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// GiveUpHighGradeDrawLottery

// required uint32 value = 1;
inline bool GiveUpHighGradeDrawLottery::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiveUpHighGradeDrawLottery::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiveUpHighGradeDrawLottery::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiveUpHighGradeDrawLottery::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 GiveUpHighGradeDrawLottery::value() const {
  return value_;
}
inline void GiveUpHighGradeDrawLottery::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// LotteryReward

// required uint32 item_id = 1;
inline bool LotteryReward::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LotteryReward::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LotteryReward::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LotteryReward::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 LotteryReward::item_id() const {
  return item_id_;
}
inline void LotteryReward::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// required uint32 item_num = 2;
inline bool LotteryReward::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LotteryReward::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LotteryReward::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LotteryReward::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 LotteryReward::item_num() const {
  return item_num_;
}
inline void LotteryReward::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// required uint32 man_quality = 3;
inline bool LotteryReward::has_man_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LotteryReward::set_has_man_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LotteryReward::clear_has_man_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LotteryReward::clear_man_quality() {
  man_quality_ = 0u;
  clear_has_man_quality();
}
inline ::google::protobuf::uint32 LotteryReward::man_quality() const {
  return man_quality_;
}
inline void LotteryReward::set_man_quality(::google::protobuf::uint32 value) {
  set_has_man_quality();
  man_quality_ = value;
}

// -------------------------------------------------------------------

// LotteryRewardData

// required uint32 value = 1;
inline bool LotteryRewardData::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LotteryRewardData::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LotteryRewardData::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LotteryRewardData::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 LotteryRewardData::value() const {
  return value_;
}
inline void LotteryRewardData::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ReqQuickDrawLottery

// required uint32 value = 1;
inline bool ReqQuickDrawLottery::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqQuickDrawLottery::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqQuickDrawLottery::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqQuickDrawLottery::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqQuickDrawLottery::value() const {
  return value_;
}
inline void ReqQuickDrawLottery::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ReqGetInviteReward

// required uint32 value = 1;
inline bool ReqGetInviteReward::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetInviteReward::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetInviteReward::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetInviteReward::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqGetInviteReward::value() const {
  return value_;
}
inline void ReqGetInviteReward::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// AckGetInviteNum

// required uint32 value = 1;
inline bool AckGetInviteNum::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGetInviteNum::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGetInviteNum::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGetInviteNum::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 AckGetInviteNum::value() const {
  return value_;
}
inline void AckGetInviteNum::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// optional bytes code = 2;
inline bool AckGetInviteNum::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGetInviteNum::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGetInviteNum::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGetInviteNum::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& AckGetInviteNum::code() const {
  return *code_;
}
inline void AckGetInviteNum::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void AckGetInviteNum::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void AckGetInviteNum::set_code(const void* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGetInviteNum::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* AckGetInviteNum::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckGetInviteNum::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqGetInviteNum

// required uint32 value = 1;
inline bool ReqGetInviteNum::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetInviteNum::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetInviteNum::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetInviteNum::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqGetInviteNum::value() const {
  return value_;
}
inline void ReqGetInviteNum::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ReqAddMoney

// required uint32 value = 1;
inline bool ReqAddMoney::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAddMoney::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAddMoney::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAddMoney::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqAddMoney::value() const {
  return value_;
}
inline void ReqAddMoney::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// AddMoneyCost

// required uint32 cost = 1;
inline bool AddMoneyCost::has_cost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddMoneyCost::set_has_cost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddMoneyCost::clear_has_cost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddMoneyCost::clear_cost() {
  cost_ = 0u;
  clear_has_cost();
}
inline ::google::protobuf::uint32 AddMoneyCost::cost() const {
  return cost_;
}
inline void AddMoneyCost::set_cost(::google::protobuf::uint32 value) {
  set_has_cost();
  cost_ = value;
}

// -------------------------------------------------------------------

// ChooseAddMoney

// required uint32 value = 1;
inline bool ChooseAddMoney::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChooseAddMoney::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChooseAddMoney::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChooseAddMoney::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ChooseAddMoney::value() const {
  return value_;
}
inline void ChooseAddMoney::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// RightPosition

// required uint32 value = 1;
inline bool RightPosition::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RightPosition::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RightPosition::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RightPosition::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 RightPosition::value() const {
  return value_;
}
inline void RightPosition::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// OpenBowl

// required uint32 pos = 1;
inline bool OpenBowl::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenBowl::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenBowl::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenBowl::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 OpenBowl::pos() const {
  return pos_;
}
inline void OpenBowl::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// AddMoneyReward

// required uint32 result = 1;
inline bool AddMoneyReward::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddMoneyReward::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddMoneyReward::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddMoneyReward::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 AddMoneyReward::result() const {
  return result_;
}
inline void AddMoneyReward::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// required uint32 money = 2;
inline bool AddMoneyReward::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddMoneyReward::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddMoneyReward::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddMoneyReward::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 AddMoneyReward::money() const {
  return money_;
}
inline void AddMoneyReward::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// GetFirstRechargeGift

// required uint32 value = 1;
inline bool GetFirstRechargeGift::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFirstRechargeGift::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFirstRechargeGift::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFirstRechargeGift::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 GetFirstRechargeGift::value() const {
  return value_;
}
inline void GetFirstRechargeGift::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ReqAccelerateAction

// required uint32 action_id = 1;
inline bool ReqAccelerateAction::has_action_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAccelerateAction::set_has_action_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAccelerateAction::clear_has_action_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAccelerateAction::clear_action_id() {
  action_id_ = 0u;
  clear_has_action_id();
}
inline ::google::protobuf::uint32 ReqAccelerateAction::action_id() const {
  return action_id_;
}
inline void ReqAccelerateAction::set_action_id(::google::protobuf::uint32 value) {
  set_has_action_id();
  action_id_ = value;
}

// optional uint32 action_value = 2;
inline bool ReqAccelerateAction::has_action_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAccelerateAction::set_has_action_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAccelerateAction::clear_has_action_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAccelerateAction::clear_action_value() {
  action_value_ = 0u;
  clear_has_action_value();
}
inline ::google::protobuf::uint32 ReqAccelerateAction::action_value() const {
  return action_value_;
}
inline void ReqAccelerateAction::set_action_value(::google::protobuf::uint32 value) {
  set_has_action_value();
  action_value_ = value;
}

// -------------------------------------------------------------------

// ReqBuyTimesAction

// required uint32 action_id = 1;
inline bool ReqBuyTimesAction::has_action_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqBuyTimesAction::set_has_action_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqBuyTimesAction::clear_has_action_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqBuyTimesAction::clear_action_id() {
  action_id_ = 0u;
  clear_has_action_id();
}
inline ::google::protobuf::uint32 ReqBuyTimesAction::action_id() const {
  return action_id_;
}
inline void ReqBuyTimesAction::set_action_id(::google::protobuf::uint32 value) {
  set_has_action_id();
  action_id_ = value;
}

// optional uint32 action_value = 2;
inline bool ReqBuyTimesAction::has_action_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqBuyTimesAction::set_has_action_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqBuyTimesAction::clear_has_action_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqBuyTimesAction::clear_action_value() {
  action_value_ = 0u;
  clear_has_action_value();
}
inline ::google::protobuf::uint32 ReqBuyTimesAction::action_value() const {
  return action_value_;
}
inline void ReqBuyTimesAction::set_action_value(::google::protobuf::uint32 value) {
  set_has_action_value();
  action_value_ = value;
}

// -------------------------------------------------------------------

// ReqIsMercTraining

// required uint32 merc_pos = 1;
inline bool ReqIsMercTraining::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqIsMercTraining::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqIsMercTraining::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqIsMercTraining::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 ReqIsMercTraining::merc_pos() const {
  return merc_pos_;
}
inline void ReqIsMercTraining::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// -------------------------------------------------------------------

// AckOtherLevelUp

// required uint32 char_id = 1;
inline bool AckOtherLevelUp::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckOtherLevelUp::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckOtherLevelUp::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckOtherLevelUp::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 AckOtherLevelUp::char_id() const {
  return char_id_;
}
inline void AckOtherLevelUp::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// -------------------------------------------------------------------

// SendHeartBeatMsg

// optional uint32 value = 1;
inline bool SendHeartBeatMsg::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendHeartBeatMsg::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendHeartBeatMsg::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendHeartBeatMsg::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 SendHeartBeatMsg::value() const {
  return value_;
}
inline void SendHeartBeatMsg::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// SendStoneMsg

// required uint32 merc_pos = 1;
inline bool SendStoneMsg::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendStoneMsg::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendStoneMsg::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendStoneMsg::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 SendStoneMsg::merc_pos() const {
  return merc_pos_;
}
inline void SendStoneMsg::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// optional uint64 oper_pos = 2;
inline bool SendStoneMsg::has_oper_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendStoneMsg::set_has_oper_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendStoneMsg::clear_has_oper_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendStoneMsg::clear_oper_pos() {
  oper_pos_ = GOOGLE_ULONGLONG(0);
  clear_has_oper_pos();
}
inline ::google::protobuf::uint64 SendStoneMsg::oper_pos() const {
  return oper_pos_;
}
inline void SendStoneMsg::set_oper_pos(::google::protobuf::uint64 value) {
  set_has_oper_pos();
  oper_pos_ = value;
}

// optional uint64 item_pos = 3;
inline bool SendStoneMsg::has_item_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendStoneMsg::set_has_item_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendStoneMsg::clear_has_item_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendStoneMsg::clear_item_pos() {
  item_pos_ = GOOGLE_ULONGLONG(0);
  clear_has_item_pos();
}
inline ::google::protobuf::uint64 SendStoneMsg::item_pos() const {
  return item_pos_;
}
inline void SendStoneMsg::set_item_pos(::google::protobuf::uint64 value) {
  set_has_item_pos();
  item_pos_ = value;
}

// optional uint32 oper_id = 4;
inline bool SendStoneMsg::has_oper_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendStoneMsg::set_has_oper_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendStoneMsg::clear_has_oper_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendStoneMsg::clear_oper_id() {
  oper_id_ = 0u;
  clear_has_oper_id();
}
inline ::google::protobuf::uint32 SendStoneMsg::oper_id() const {
  return oper_id_;
}
inline void SendStoneMsg::set_oper_id(::google::protobuf::uint32 value) {
  set_has_oper_id();
  oper_id_ = value;
}

// -------------------------------------------------------------------

// ReqWorldBossInfo

// optional uint32 value = 1;
inline bool ReqWorldBossInfo::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqWorldBossInfo::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqWorldBossInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqWorldBossInfo::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqWorldBossInfo::value() const {
  return value_;
}
inline void ReqWorldBossInfo::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// AckWorldBossInfo

// required uint32 boss_id = 1;
inline bool AckWorldBossInfo::has_boss_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckWorldBossInfo::set_has_boss_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckWorldBossInfo::clear_has_boss_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckWorldBossInfo::clear_boss_id() {
  boss_id_ = 0u;
  clear_has_boss_id();
}
inline ::google::protobuf::uint32 AckWorldBossInfo::boss_id() const {
  return boss_id_;
}
inline void AckWorldBossInfo::set_boss_id(::google::protobuf::uint32 value) {
  set_has_boss_id();
  boss_id_ = value;
}

// required uint32 boss_hp = 2;
inline bool AckWorldBossInfo::has_boss_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckWorldBossInfo::set_has_boss_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckWorldBossInfo::clear_has_boss_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckWorldBossInfo::clear_boss_hp() {
  boss_hp_ = 0u;
  clear_has_boss_hp();
}
inline ::google::protobuf::uint32 AckWorldBossInfo::boss_hp() const {
  return boss_hp_;
}
inline void AckWorldBossInfo::set_boss_hp(::google::protobuf::uint32 value) {
  set_has_boss_hp();
  boss_hp_ = value;
}

// required uint32 if_used = 3;
inline bool AckWorldBossInfo::has_if_used() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckWorldBossInfo::set_has_if_used() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckWorldBossInfo::clear_has_if_used() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckWorldBossInfo::clear_if_used() {
  if_used_ = 0u;
  clear_has_if_used();
}
inline ::google::protobuf::uint32 AckWorldBossInfo::if_used() const {
  return if_used_;
}
inline void AckWorldBossInfo::set_if_used(::google::protobuf::uint32 value) {
  set_has_if_used();
  if_used_ = value;
}

// required uint32 server_id = 4;
inline bool AckWorldBossInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckWorldBossInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckWorldBossInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckWorldBossInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 AckWorldBossInfo::server_id() const {
  return server_id_;
}
inline void AckWorldBossInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// -------------------------------------------------------------------

// ExecuteSQL

// required bytes sql = 1;
inline bool ExecuteSQL::has_sql() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteSQL::set_has_sql() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteSQL::clear_has_sql() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteSQL::clear_sql() {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    sql_->clear();
  }
  clear_has_sql();
}
inline const ::std::string& ExecuteSQL::sql() const {
  return *sql_;
}
inline void ExecuteSQL::set_sql(const ::std::string& value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void ExecuteSQL::set_sql(const char* value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void ExecuteSQL::set_sql(const void* value, size_t size) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecuteSQL::mutable_sql() {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  return sql_;
}
inline ::std::string* ExecuteSQL::release_sql() {
  clear_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sql_;
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecuteSQL::set_allocated_sql(::std::string* sql) {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    delete sql_;
  }
  if (sql) {
    set_has_sql();
    sql_ = sql;
  } else {
    clear_has_sql();
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 if_return = 2;
inline bool ExecuteSQL::has_if_return() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecuteSQL::set_has_if_return() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecuteSQL::clear_has_if_return() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecuteSQL::clear_if_return() {
  if_return_ = 0u;
  clear_has_if_return();
}
inline ::google::protobuf::uint32 ExecuteSQL::if_return() const {
  return if_return_;
}
inline void ExecuteSQL::set_if_return(::google::protobuf::uint32 value) {
  set_has_if_return();
  if_return_ = value;
}

// optional uint32 acc_id = 3;
inline bool ExecuteSQL::has_acc_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecuteSQL::set_has_acc_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecuteSQL::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecuteSQL::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 ExecuteSQL::acc_id() const {
  return acc_id_;
}
inline void ExecuteSQL::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// LoadAllActivityDataReq

// optional uint32 value = 1;
inline bool LoadAllActivityDataReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadAllActivityDataReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadAllActivityDataReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadAllActivityDataReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 LoadAllActivityDataReq::value() const {
  return value_;
}
inline void LoadAllActivityDataReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// LoadAllActivityDataAck_ActivityData

// required uint32 id = 1;
inline bool LoadAllActivityDataAck_ActivityData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadAllActivityDataAck_ActivityData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadAllActivityDataAck_ActivityData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadAllActivityDataAck_ActivityData::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 LoadAllActivityDataAck_ActivityData::id() const {
  return id_;
}
inline void LoadAllActivityDataAck_ActivityData::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 begin_time = 2;
inline bool LoadAllActivityDataAck_ActivityData::has_begin_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadAllActivityDataAck_ActivityData::set_has_begin_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadAllActivityDataAck_ActivityData::clear_has_begin_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadAllActivityDataAck_ActivityData::clear_begin_time() {
  begin_time_ = 0u;
  clear_has_begin_time();
}
inline ::google::protobuf::uint32 LoadAllActivityDataAck_ActivityData::begin_time() const {
  return begin_time_;
}
inline void LoadAllActivityDataAck_ActivityData::set_begin_time(::google::protobuf::uint32 value) {
  set_has_begin_time();
  begin_time_ = value;
}

// required uint32 end_time = 3;
inline bool LoadAllActivityDataAck_ActivityData::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadAllActivityDataAck_ActivityData::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadAllActivityDataAck_ActivityData::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadAllActivityDataAck_ActivityData::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 LoadAllActivityDataAck_ActivityData::end_time() const {
  return end_time_;
}
inline void LoadAllActivityDataAck_ActivityData::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// required uint32 open = 4;
inline bool LoadAllActivityDataAck_ActivityData::has_open() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadAllActivityDataAck_ActivityData::set_has_open() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadAllActivityDataAck_ActivityData::clear_has_open() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadAllActivityDataAck_ActivityData::clear_open() {
  open_ = 0u;
  clear_has_open();
}
inline ::google::protobuf::uint32 LoadAllActivityDataAck_ActivityData::open() const {
  return open_;
}
inline void LoadAllActivityDataAck_ActivityData::set_open(::google::protobuf::uint32 value) {
  set_has_open();
  open_ = value;
}

// -------------------------------------------------------------------

// LoadAllActivityDataAck

// repeated .message.LoadAllActivityDataAck.ActivityData data = 1;
inline int LoadAllActivityDataAck::data_size() const {
  return data_.size();
}
inline void LoadAllActivityDataAck::clear_data() {
  data_.Clear();
}
inline const ::message::LoadAllActivityDataAck_ActivityData& LoadAllActivityDataAck::data(int index) const {
  return data_.Get(index);
}
inline ::message::LoadAllActivityDataAck_ActivityData* LoadAllActivityDataAck::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::message::LoadAllActivityDataAck_ActivityData* LoadAllActivityDataAck::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::LoadAllActivityDataAck_ActivityData >&
LoadAllActivityDataAck::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::LoadAllActivityDataAck_ActivityData >*
LoadAllActivityDataAck::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// CanGetFirstRechargeReward

// optional uint32 value = 1;
inline bool CanGetFirstRechargeReward::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CanGetFirstRechargeReward::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CanGetFirstRechargeReward::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CanGetFirstRechargeReward::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 CanGetFirstRechargeReward::value() const {
  return value_;
}
inline void CanGetFirstRechargeReward::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// LoadAllSysBroadcastDataReq

// optional uint32 value = 1;
inline bool LoadAllSysBroadcastDataReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadAllSysBroadcastDataReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadAllSysBroadcastDataReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadAllSysBroadcastDataReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 LoadAllSysBroadcastDataReq::value() const {
  return value_;
}
inline void LoadAllSysBroadcastDataReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// LoadAllSysBroadcastDataAck_SysBroadcastData

// required uint32 type = 1;
inline bool LoadAllSysBroadcastDataAck_SysBroadcastData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 LoadAllSysBroadcastDataAck_SysBroadcastData::type() const {
  return type_;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 begin_time = 2;
inline bool LoadAllSysBroadcastDataAck_SysBroadcastData::has_begin_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_has_begin_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_has_begin_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_begin_time() {
  begin_time_ = 0u;
  clear_has_begin_time();
}
inline ::google::protobuf::uint32 LoadAllSysBroadcastDataAck_SysBroadcastData::begin_time() const {
  return begin_time_;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_begin_time(::google::protobuf::uint32 value) {
  set_has_begin_time();
  begin_time_ = value;
}

// required uint32 end_time = 3;
inline bool LoadAllSysBroadcastDataAck_SysBroadcastData::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 LoadAllSysBroadcastDataAck_SysBroadcastData::end_time() const {
  return end_time_;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// required uint32 next_time = 4;
inline bool LoadAllSysBroadcastDataAck_SysBroadcastData::has_next_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_has_next_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_has_next_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_next_time() {
  next_time_ = 0u;
  clear_has_next_time();
}
inline ::google::protobuf::uint32 LoadAllSysBroadcastDataAck_SysBroadcastData::next_time() const {
  return next_time_;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_next_time(::google::protobuf::uint32 value) {
  set_has_next_time();
  next_time_ = value;
}

// required uint32 minutes = 5;
inline bool LoadAllSysBroadcastDataAck_SysBroadcastData::has_minutes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_has_minutes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_has_minutes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_minutes() {
  minutes_ = 0u;
  clear_has_minutes();
}
inline ::google::protobuf::uint32 LoadAllSysBroadcastDataAck_SysBroadcastData::minutes() const {
  return minutes_;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_minutes(::google::protobuf::uint32 value) {
  set_has_minutes();
  minutes_ = value;
}

// required bytes text = 6;
inline bool LoadAllSysBroadcastDataAck_SysBroadcastData::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& LoadAllSysBroadcastDataAck_SysBroadcastData::text() const {
  return *text_;
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_text(const void* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadAllSysBroadcastDataAck_SysBroadcastData::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* LoadAllSysBroadcastDataAck_SysBroadcastData::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadAllSysBroadcastDataAck_SysBroadcastData::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoadAllSysBroadcastDataAck

// repeated .message.LoadAllSysBroadcastDataAck.SysBroadcastData data = 1;
inline int LoadAllSysBroadcastDataAck::data_size() const {
  return data_.size();
}
inline void LoadAllSysBroadcastDataAck::clear_data() {
  data_.Clear();
}
inline const ::message::LoadAllSysBroadcastDataAck_SysBroadcastData& LoadAllSysBroadcastDataAck::data(int index) const {
  return data_.Get(index);
}
inline ::message::LoadAllSysBroadcastDataAck_SysBroadcastData* LoadAllSysBroadcastDataAck::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::message::LoadAllSysBroadcastDataAck_SysBroadcastData* LoadAllSysBroadcastDataAck::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::LoadAllSysBroadcastDataAck_SysBroadcastData >&
LoadAllSysBroadcastDataAck::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::LoadAllSysBroadcastDataAck_SysBroadcastData >*
LoadAllSysBroadcastDataAck::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// QueryAccidByAccnameReq

// required bytes acc_name = 1;
inline bool QueryAccidByAccnameReq::has_acc_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryAccidByAccnameReq::set_has_acc_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryAccidByAccnameReq::clear_has_acc_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryAccidByAccnameReq::clear_acc_name() {
  if (acc_name_ != &::google::protobuf::internal::kEmptyString) {
    acc_name_->clear();
  }
  clear_has_acc_name();
}
inline const ::std::string& QueryAccidByAccnameReq::acc_name() const {
  return *acc_name_;
}
inline void QueryAccidByAccnameReq::set_acc_name(const ::std::string& value) {
  set_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    acc_name_ = new ::std::string;
  }
  acc_name_->assign(value);
}
inline void QueryAccidByAccnameReq::set_acc_name(const char* value) {
  set_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    acc_name_ = new ::std::string;
  }
  acc_name_->assign(value);
}
inline void QueryAccidByAccnameReq::set_acc_name(const void* value, size_t size) {
  set_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    acc_name_ = new ::std::string;
  }
  acc_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryAccidByAccnameReq::mutable_acc_name() {
  set_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    acc_name_ = new ::std::string;
  }
  return acc_name_;
}
inline ::std::string* QueryAccidByAccnameReq::release_acc_name() {
  clear_has_acc_name();
  if (acc_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_name_;
    acc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryAccidByAccnameReq::set_allocated_acc_name(::std::string* acc_name) {
  if (acc_name_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_name_;
  }
  if (acc_name) {
    set_has_acc_name();
    acc_name_ = acc_name;
  } else {
    clear_has_acc_name();
    acc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 serial_id = 2;
inline bool QueryAccidByAccnameReq::has_serial_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryAccidByAccnameReq::set_has_serial_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryAccidByAccnameReq::clear_has_serial_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryAccidByAccnameReq::clear_serial_id() {
  serial_id_ = 0u;
  clear_has_serial_id();
}
inline ::google::protobuf::uint32 QueryAccidByAccnameReq::serial_id() const {
  return serial_id_;
}
inline void QueryAccidByAccnameReq::set_serial_id(::google::protobuf::uint32 value) {
  set_has_serial_id();
  serial_id_ = value;
}

// -------------------------------------------------------------------

// QueryAccidByAccnameAck

// required uint32 acc_id = 1;
inline bool QueryAccidByAccnameAck::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryAccidByAccnameAck::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryAccidByAccnameAck::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryAccidByAccnameAck::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 QueryAccidByAccnameAck::acc_id() const {
  return acc_id_;
}
inline void QueryAccidByAccnameAck::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 serial_id = 2;
inline bool QueryAccidByAccnameAck::has_serial_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryAccidByAccnameAck::set_has_serial_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryAccidByAccnameAck::clear_has_serial_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryAccidByAccnameAck::clear_serial_id() {
  serial_id_ = 0u;
  clear_has_serial_id();
}
inline ::google::protobuf::uint32 QueryAccidByAccnameAck::serial_id() const {
  return serial_id_;
}
inline void QueryAccidByAccnameAck::set_serial_id(::google::protobuf::uint32 value) {
  set_has_serial_id();
  serial_id_ = value;
}

// -------------------------------------------------------------------

// PkBattle

// required uint32 target_id = 1;
inline bool PkBattle::has_target_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PkBattle::set_has_target_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PkBattle::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PkBattle::clear_target_id() {
  target_id_ = 0u;
  clear_has_target_id();
}
inline ::google::protobuf::uint32 PkBattle::target_id() const {
  return target_id_;
}
inline void PkBattle::set_target_id(::google::protobuf::uint32 value) {
  set_has_target_id();
  target_id_ = value;
}

// -------------------------------------------------------------------

// HorseData_HorseAttr

// required uint32 id = 1;
inline bool HorseData_HorseAttr::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HorseData_HorseAttr::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HorseData_HorseAttr::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HorseData_HorseAttr::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HorseData_HorseAttr::id() const {
  return id_;
}
inline void HorseData_HorseAttr::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 value = 2;
inline bool HorseData_HorseAttr::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HorseData_HorseAttr::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HorseData_HorseAttr::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HorseData_HorseAttr::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 HorseData_HorseAttr::value() const {
  return value_;
}
inline void HorseData_HorseAttr::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// HorseData

// required uint32 acc_id = 1;
inline bool HorseData::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HorseData::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HorseData::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HorseData::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 HorseData::acc_id() const {
  return acc_id_;
}
inline void HorseData::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 id = 2;
inline bool HorseData::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HorseData::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HorseData::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HorseData::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HorseData::id() const {
  return id_;
}
inline void HorseData::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required bytes change_name = 3;
inline bool HorseData::has_change_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HorseData::set_has_change_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HorseData::clear_has_change_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HorseData::clear_change_name() {
  if (change_name_ != &::google::protobuf::internal::kEmptyString) {
    change_name_->clear();
  }
  clear_has_change_name();
}
inline const ::std::string& HorseData::change_name() const {
  return *change_name_;
}
inline void HorseData::set_change_name(const ::std::string& value) {
  set_has_change_name();
  if (change_name_ == &::google::protobuf::internal::kEmptyString) {
    change_name_ = new ::std::string;
  }
  change_name_->assign(value);
}
inline void HorseData::set_change_name(const char* value) {
  set_has_change_name();
  if (change_name_ == &::google::protobuf::internal::kEmptyString) {
    change_name_ = new ::std::string;
  }
  change_name_->assign(value);
}
inline void HorseData::set_change_name(const void* value, size_t size) {
  set_has_change_name();
  if (change_name_ == &::google::protobuf::internal::kEmptyString) {
    change_name_ = new ::std::string;
  }
  change_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HorseData::mutable_change_name() {
  set_has_change_name();
  if (change_name_ == &::google::protobuf::internal::kEmptyString) {
    change_name_ = new ::std::string;
  }
  return change_name_;
}
inline ::std::string* HorseData::release_change_name() {
  clear_has_change_name();
  if (change_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = change_name_;
    change_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HorseData::set_allocated_change_name(::std::string* change_name) {
  if (change_name_ != &::google::protobuf::internal::kEmptyString) {
    delete change_name_;
  }
  if (change_name) {
    set_has_change_name();
    change_name_ = change_name;
  } else {
    clear_has_change_name();
    change_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 image = 4;
inline bool HorseData::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HorseData::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HorseData::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HorseData::clear_image() {
  image_ = 0u;
  clear_has_image();
}
inline ::google::protobuf::uint32 HorseData::image() const {
  return image_;
}
inline void HorseData::set_image(::google::protobuf::uint32 value) {
  set_has_image();
  image_ = value;
}

// required uint32 high_level = 5;
inline bool HorseData::has_high_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HorseData::set_has_high_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HorseData::clear_has_high_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HorseData::clear_high_level() {
  high_level_ = 0u;
  clear_has_high_level();
}
inline ::google::protobuf::uint32 HorseData::high_level() const {
  return high_level_;
}
inline void HorseData::set_high_level(::google::protobuf::uint32 value) {
  set_has_high_level();
  high_level_ = value;
}

// required uint32 low_level = 6;
inline bool HorseData::has_low_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HorseData::set_has_low_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HorseData::clear_has_low_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HorseData::clear_low_level() {
  low_level_ = 0u;
  clear_has_low_level();
}
inline ::google::protobuf::uint32 HorseData::low_level() const {
  return low_level_;
}
inline void HorseData::set_low_level(::google::protobuf::uint32 value) {
  set_has_low_level();
  low_level_ = value;
}

// required uint32 exp = 7;
inline bool HorseData::has_exp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HorseData::set_has_exp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HorseData::clear_has_exp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HorseData::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 HorseData::exp() const {
  return exp_;
}
inline void HorseData::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 train = 8;
inline bool HorseData::has_train() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HorseData::set_has_train() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HorseData::clear_has_train() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HorseData::clear_train() {
  train_ = 0u;
  clear_has_train();
}
inline ::google::protobuf::uint32 HorseData::train() const {
  return train_;
}
inline void HorseData::set_train(::google::protobuf::uint32 value) {
  set_has_train();
  train_ = value;
}

// required uint32 bless = 9;
inline bool HorseData::has_bless() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HorseData::set_has_bless() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HorseData::clear_has_bless() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HorseData::clear_bless() {
  bless_ = 0u;
  clear_has_bless();
}
inline ::google::protobuf::uint32 HorseData::bless() const {
  return bless_;
}
inline void HorseData::set_bless(::google::protobuf::uint32 value) {
  set_has_bless();
  bless_ = value;
}

// repeated .message.HorseData.HorseAttr attr = 10;
inline int HorseData::attr_size() const {
  return attr_.size();
}
inline void HorseData::clear_attr() {
  attr_.Clear();
}
inline const ::message::HorseData_HorseAttr& HorseData::attr(int index) const {
  return attr_.Get(index);
}
inline ::message::HorseData_HorseAttr* HorseData::mutable_attr(int index) {
  return attr_.Mutable(index);
}
inline ::message::HorseData_HorseAttr* HorseData::add_attr() {
  return attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::HorseData_HorseAttr >&
HorseData::attr() const {
  return attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::HorseData_HorseAttr >*
HorseData::mutable_attr() {
  return &attr_;
}

// repeated uint32 skill_id = 11;
inline int HorseData::skill_id_size() const {
  return skill_id_.size();
}
inline void HorseData::clear_skill_id() {
  skill_id_.Clear();
}
inline ::google::protobuf::uint32 HorseData::skill_id(int index) const {
  return skill_id_.Get(index);
}
inline void HorseData::set_skill_id(int index, ::google::protobuf::uint32 value) {
  skill_id_.Set(index, value);
}
inline void HorseData::add_skill_id(::google::protobuf::uint32 value) {
  skill_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HorseData::skill_id() const {
  return skill_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HorseData::mutable_skill_id() {
  return &skill_id_;
}

// required uint32 is_show = 12;
inline bool HorseData::has_is_show() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HorseData::set_has_is_show() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HorseData::clear_has_is_show() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HorseData::clear_is_show() {
  is_show_ = 0u;
  clear_has_is_show();
}
inline ::google::protobuf::uint32 HorseData::is_show() const {
  return is_show_;
}
inline void HorseData::set_is_show(::google::protobuf::uint32 value) {
  set_has_is_show();
  is_show_ = value;
}

// required uint32 card_type = 13;
inline bool HorseData::has_card_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HorseData::set_has_card_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HorseData::clear_has_card_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HorseData::clear_card_type() {
  card_type_ = 0u;
  clear_has_card_type();
}
inline ::google::protobuf::uint32 HorseData::card_type() const {
  return card_type_;
}
inline void HorseData::set_card_type(::google::protobuf::uint32 value) {
  set_has_card_type();
  card_type_ = value;
}

// repeated uint32 card_id = 14;
inline int HorseData::card_id_size() const {
  return card_id_.size();
}
inline void HorseData::clear_card_id() {
  card_id_.Clear();
}
inline ::google::protobuf::uint32 HorseData::card_id(int index) const {
  return card_id_.Get(index);
}
inline void HorseData::set_card_id(int index, ::google::protobuf::uint32 value) {
  card_id_.Set(index, value);
}
inline void HorseData::add_card_id(::google::protobuf::uint32 value) {
  card_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HorseData::card_id() const {
  return card_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HorseData::mutable_card_id() {
  return &card_id_;
}

// -------------------------------------------------------------------

// GetHorseDataReq

// optional uint32 type = 1;
inline bool GetHorseDataReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetHorseDataReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetHorseDataReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetHorseDataReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 GetHorseDataReq::type() const {
  return type_;
}
inline void GetHorseDataReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// GetHorseDataAck

// repeated .message.HorseData horse_data = 1;
inline int GetHorseDataAck::horse_data_size() const {
  return horse_data_.size();
}
inline void GetHorseDataAck::clear_horse_data() {
  horse_data_.Clear();
}
inline const ::message::HorseData& GetHorseDataAck::horse_data(int index) const {
  return horse_data_.Get(index);
}
inline ::message::HorseData* GetHorseDataAck::mutable_horse_data(int index) {
  return horse_data_.Mutable(index);
}
inline ::message::HorseData* GetHorseDataAck::add_horse_data() {
  return horse_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::HorseData >&
GetHorseDataAck::horse_data() const {
  return horse_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::HorseData >*
GetHorseDataAck::mutable_horse_data() {
  return &horse_data_;
}

// required uint32 count = 2;
inline bool GetHorseDataAck::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetHorseDataAck::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetHorseDataAck::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetHorseDataAck::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetHorseDataAck::count() const {
  return count_;
}
inline void GetHorseDataAck::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// HorseGroomReq

// required uint32 id = 1;
inline bool HorseGroomReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HorseGroomReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HorseGroomReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HorseGroomReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HorseGroomReq::id() const {
  return id_;
}
inline void HorseGroomReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 type = 2;
inline bool HorseGroomReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HorseGroomReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HorseGroomReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HorseGroomReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 HorseGroomReq::type() const {
  return type_;
}
inline void HorseGroomReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// repeated uint32 value = 3;
inline int HorseGroomReq::value_size() const {
  return value_.size();
}
inline void HorseGroomReq::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 HorseGroomReq::value(int index) const {
  return value_.Get(index);
}
inline void HorseGroomReq::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
}
inline void HorseGroomReq::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HorseGroomReq::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HorseGroomReq::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// HorseGroomAck

// required .message.HorseData horse_data = 1;
inline bool HorseGroomAck::has_horse_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HorseGroomAck::set_has_horse_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HorseGroomAck::clear_has_horse_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HorseGroomAck::clear_horse_data() {
  if (horse_data_ != NULL) horse_data_->::message::HorseData::Clear();
  clear_has_horse_data();
}
inline const ::message::HorseData& HorseGroomAck::horse_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return horse_data_ != NULL ? *horse_data_ : *default_instance().horse_data_;
#else
  return horse_data_ != NULL ? *horse_data_ : *default_instance_->horse_data_;
#endif
}
inline ::message::HorseData* HorseGroomAck::mutable_horse_data() {
  set_has_horse_data();
  if (horse_data_ == NULL) horse_data_ = new ::message::HorseData;
  return horse_data_;
}
inline ::message::HorseData* HorseGroomAck::release_horse_data() {
  clear_has_horse_data();
  ::message::HorseData* temp = horse_data_;
  horse_data_ = NULL;
  return temp;
}
inline void HorseGroomAck::set_allocated_horse_data(::message::HorseData* horse_data) {
  delete horse_data_;
  horse_data_ = horse_data;
  if (horse_data) {
    set_has_horse_data();
  } else {
    clear_has_horse_data();
  }
}

// required uint32 count = 2;
inline bool HorseGroomAck::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HorseGroomAck::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HorseGroomAck::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HorseGroomAck::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 HorseGroomAck::count() const {
  return count_;
}
inline void HorseGroomAck::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 type = 3;
inline bool HorseGroomAck::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HorseGroomAck::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HorseGroomAck::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HorseGroomAck::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 HorseGroomAck::type() const {
  return type_;
}
inline void HorseGroomAck::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// repeated uint32 value = 4;
inline int HorseGroomAck::value_size() const {
  return value_.size();
}
inline void HorseGroomAck::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 HorseGroomAck::value(int index) const {
  return value_.Get(index);
}
inline void HorseGroomAck::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
}
inline void HorseGroomAck::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HorseGroomAck::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HorseGroomAck::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// BuyHorseFeedCountReq

// optional uint32 value = 1;
inline bool BuyHorseFeedCountReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyHorseFeedCountReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyHorseFeedCountReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyHorseFeedCountReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 BuyHorseFeedCountReq::value() const {
  return value_;
}
inline void BuyHorseFeedCountReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// BuyHorseFeedCountAck

// required uint32 count = 1;
inline bool BuyHorseFeedCountAck::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyHorseFeedCountAck::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyHorseFeedCountAck::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyHorseFeedCountAck::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 BuyHorseFeedCountAck::count() const {
  return count_;
}
inline void BuyHorseFeedCountAck::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// HorseShowChangeReq

// required uint32 id = 1;
inline bool HorseShowChangeReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HorseShowChangeReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HorseShowChangeReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HorseShowChangeReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HorseShowChangeReq::id() const {
  return id_;
}
inline void HorseShowChangeReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 type = 2;
inline bool HorseShowChangeReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HorseShowChangeReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HorseShowChangeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HorseShowChangeReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 HorseShowChangeReq::type() const {
  return type_;
}
inline void HorseShowChangeReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// HorseShowChangeAck

// required uint32 ret = 1;
inline bool HorseShowChangeAck::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HorseShowChangeAck::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HorseShowChangeAck::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HorseShowChangeAck::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 HorseShowChangeAck::ret() const {
  return ret_;
}
inline void HorseShowChangeAck::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
}

// required uint32 id = 2;
inline bool HorseShowChangeAck::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HorseShowChangeAck::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HorseShowChangeAck::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HorseShowChangeAck::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HorseShowChangeAck::id() const {
  return id_;
}
inline void HorseShowChangeAck::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 type = 3;
inline bool HorseShowChangeAck::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HorseShowChangeAck::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HorseShowChangeAck::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HorseShowChangeAck::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 HorseShowChangeAck::type() const {
  return type_;
}
inline void HorseShowChangeAck::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// HorseChangeSys

// required uint32 acc_id = 1;
inline bool HorseChangeSys::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HorseChangeSys::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HorseChangeSys::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HorseChangeSys::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 HorseChangeSys::acc_id() const {
  return acc_id_;
}
inline void HorseChangeSys::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 horse_id = 2;
inline bool HorseChangeSys::has_horse_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HorseChangeSys::set_has_horse_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HorseChangeSys::clear_has_horse_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HorseChangeSys::clear_horse_id() {
  horse_id_ = 0u;
  clear_has_horse_id();
}
inline ::google::protobuf::uint32 HorseChangeSys::horse_id() const {
  return horse_id_;
}
inline void HorseChangeSys::set_horse_id(::google::protobuf::uint32 value) {
  set_has_horse_id();
  horse_id_ = value;
}

// optional uint32 horse_image = 3;
inline bool HorseChangeSys::has_horse_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HorseChangeSys::set_has_horse_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HorseChangeSys::clear_has_horse_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HorseChangeSys::clear_horse_image() {
  horse_image_ = 0u;
  clear_has_horse_image();
}
inline ::google::protobuf::uint32 HorseChangeSys::horse_image() const {
  return horse_image_;
}
inline void HorseChangeSys::set_horse_image(::google::protobuf::uint32 value) {
  set_has_horse_image();
  horse_image_ = value;
}

// optional bytes horse_name = 4;
inline bool HorseChangeSys::has_horse_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HorseChangeSys::set_has_horse_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HorseChangeSys::clear_has_horse_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HorseChangeSys::clear_horse_name() {
  if (horse_name_ != &::google::protobuf::internal::kEmptyString) {
    horse_name_->clear();
  }
  clear_has_horse_name();
}
inline const ::std::string& HorseChangeSys::horse_name() const {
  return *horse_name_;
}
inline void HorseChangeSys::set_horse_name(const ::std::string& value) {
  set_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    horse_name_ = new ::std::string;
  }
  horse_name_->assign(value);
}
inline void HorseChangeSys::set_horse_name(const char* value) {
  set_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    horse_name_ = new ::std::string;
  }
  horse_name_->assign(value);
}
inline void HorseChangeSys::set_horse_name(const void* value, size_t size) {
  set_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    horse_name_ = new ::std::string;
  }
  horse_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HorseChangeSys::mutable_horse_name() {
  set_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    horse_name_ = new ::std::string;
  }
  return horse_name_;
}
inline ::std::string* HorseChangeSys::release_horse_name() {
  clear_has_horse_name();
  if (horse_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = horse_name_;
    horse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HorseChangeSys::set_allocated_horse_name(::std::string* horse_name) {
  if (horse_name_ != &::google::protobuf::internal::kEmptyString) {
    delete horse_name_;
  }
  if (horse_name) {
    set_has_horse_name();
    horse_name_ = horse_name;
  } else {
    clear_has_horse_name();
    horse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoadAllHorseDataReq

// optional uint32 value = 1;
inline bool LoadAllHorseDataReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadAllHorseDataReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadAllHorseDataReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadAllHorseDataReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 LoadAllHorseDataReq::value() const {
  return value_;
}
inline void LoadAllHorseDataReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// LoadAllHorseDataAck

// repeated .message.HorseData data = 1;
inline int LoadAllHorseDataAck::data_size() const {
  return data_.size();
}
inline void LoadAllHorseDataAck::clear_data() {
  data_.Clear();
}
inline const ::message::HorseData& LoadAllHorseDataAck::data(int index) const {
  return data_.Get(index);
}
inline ::message::HorseData* LoadAllHorseDataAck::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::message::HorseData* LoadAllHorseDataAck::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::HorseData >&
LoadAllHorseDataAck::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::HorseData >*
LoadAllHorseDataAck::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// ReqStopQuickDestiny

// optional uint32 value = 1;
inline bool ReqStopQuickDestiny::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqStopQuickDestiny::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqStopQuickDestiny::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqStopQuickDestiny::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqStopQuickDestiny::value() const {
  return value_;
}
inline void ReqStopQuickDestiny::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// PlatScrollReq

// optional uint32 id = 1;
inline bool PlatScrollReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlatScrollReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlatScrollReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlatScrollReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PlatScrollReq::id() const {
  return id_;
}
inline void PlatScrollReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// PlatScrollAck

// required bytes order_id = 1;
inline bool PlatScrollAck::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlatScrollAck::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlatScrollAck::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlatScrollAck::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& PlatScrollAck::order_id() const {
  return *order_id_;
}
inline void PlatScrollAck::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void PlatScrollAck::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void PlatScrollAck::set_order_id(const void* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlatScrollAck::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* PlatScrollAck::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlatScrollAck::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes server_url = 2;
inline bool PlatScrollAck::has_server_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlatScrollAck::set_has_server_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlatScrollAck::clear_has_server_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlatScrollAck::clear_server_url() {
  if (server_url_ != &::google::protobuf::internal::kEmptyString) {
    server_url_->clear();
  }
  clear_has_server_url();
}
inline const ::std::string& PlatScrollAck::server_url() const {
  return *server_url_;
}
inline void PlatScrollAck::set_server_url(const ::std::string& value) {
  set_has_server_url();
  if (server_url_ == &::google::protobuf::internal::kEmptyString) {
    server_url_ = new ::std::string;
  }
  server_url_->assign(value);
}
inline void PlatScrollAck::set_server_url(const char* value) {
  set_has_server_url();
  if (server_url_ == &::google::protobuf::internal::kEmptyString) {
    server_url_ = new ::std::string;
  }
  server_url_->assign(value);
}
inline void PlatScrollAck::set_server_url(const void* value, size_t size) {
  set_has_server_url();
  if (server_url_ == &::google::protobuf::internal::kEmptyString) {
    server_url_ = new ::std::string;
  }
  server_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlatScrollAck::mutable_server_url() {
  set_has_server_url();
  if (server_url_ == &::google::protobuf::internal::kEmptyString) {
    server_url_ = new ::std::string;
  }
  return server_url_;
}
inline ::std::string* PlatScrollAck::release_server_url() {
  clear_has_server_url();
  if (server_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_url_;
    server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlatScrollAck::set_allocated_server_url(::std::string* server_url) {
  if (server_url_ != &::google::protobuf::internal::kEmptyString) {
    delete server_url_;
  }
  if (server_url) {
    set_has_server_url();
    server_url_ = server_url;
  } else {
    clear_has_server_url();
    server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqGetVipLevelReward

// required uint32 vip_lv = 1;
inline bool ReqGetVipLevelReward::has_vip_lv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetVipLevelReward::set_has_vip_lv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetVipLevelReward::clear_has_vip_lv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetVipLevelReward::clear_vip_lv() {
  vip_lv_ = 0u;
  clear_has_vip_lv();
}
inline ::google::protobuf::uint32 ReqGetVipLevelReward::vip_lv() const {
  return vip_lv_;
}
inline void ReqGetVipLevelReward::set_vip_lv(::google::protobuf::uint32 value) {
  set_has_vip_lv();
  vip_lv_ = value;
}

// -------------------------------------------------------------------

// SaveBattleInfo

// required uint32 acc_id = 1;
inline bool SaveBattleInfo::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveBattleInfo::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveBattleInfo::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveBattleInfo::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 SaveBattleInfo::acc_id() const {
  return acc_id_;
}
inline void SaveBattleInfo::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// repeated bytes battle_data = 2;
inline int SaveBattleInfo::battle_data_size() const {
  return battle_data_.size();
}
inline void SaveBattleInfo::clear_battle_data() {
  battle_data_.Clear();
}
inline const ::std::string& SaveBattleInfo::battle_data(int index) const {
  return battle_data_.Get(index);
}
inline ::std::string* SaveBattleInfo::mutable_battle_data(int index) {
  return battle_data_.Mutable(index);
}
inline void SaveBattleInfo::set_battle_data(int index, const ::std::string& value) {
  battle_data_.Mutable(index)->assign(value);
}
inline void SaveBattleInfo::set_battle_data(int index, const char* value) {
  battle_data_.Mutable(index)->assign(value);
}
inline void SaveBattleInfo::set_battle_data(int index, const void* value, size_t size) {
  battle_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveBattleInfo::add_battle_data() {
  return battle_data_.Add();
}
inline void SaveBattleInfo::add_battle_data(const ::std::string& value) {
  battle_data_.Add()->assign(value);
}
inline void SaveBattleInfo::add_battle_data(const char* value) {
  battle_data_.Add()->assign(value);
}
inline void SaveBattleInfo::add_battle_data(const void* value, size_t size) {
  battle_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SaveBattleInfo::battle_data() const {
  return battle_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SaveBattleInfo::mutable_battle_data() {
  return &battle_data_;
}

// optional uint32 sequence_id = 3;
inline bool SaveBattleInfo::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SaveBattleInfo::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SaveBattleInfo::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SaveBattleInfo::clear_sequence_id() {
  sequence_id_ = 0u;
  clear_has_sequence_id();
}
inline ::google::protobuf::uint32 SaveBattleInfo::sequence_id() const {
  return sequence_id_;
}
inline void SaveBattleInfo::set_sequence_id(::google::protobuf::uint32 value) {
  set_has_sequence_id();
  sequence_id_ = value;
}

// -------------------------------------------------------------------

// ReqViewBattleHistory

// optional uint32 value = 1;
inline bool ReqViewBattleHistory::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqViewBattleHistory::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqViewBattleHistory::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqViewBattleHistory::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqViewBattleHistory::value() const {
  return value_;
}
inline void ReqViewBattleHistory::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ReqGetBattleHistoryData

// required uint32 acc_id = 1;
inline bool ReqGetBattleHistoryData::has_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetBattleHistoryData::set_has_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetBattleHistoryData::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetBattleHistoryData::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 ReqGetBattleHistoryData::acc_id() const {
  return acc_id_;
}
inline void ReqGetBattleHistoryData::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// required uint32 server_id = 2;
inline bool ReqGetBattleHistoryData::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqGetBattleHistoryData::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqGetBattleHistoryData::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqGetBattleHistoryData::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 ReqGetBattleHistoryData::server_id() const {
  return server_id_;
}
inline void ReqGetBattleHistoryData::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// -------------------------------------------------------------------

// BattleHistoryInfo

// repeated bytes battle_data = 1;
inline int BattleHistoryInfo::battle_data_size() const {
  return battle_data_.size();
}
inline void BattleHistoryInfo::clear_battle_data() {
  battle_data_.Clear();
}
inline const ::std::string& BattleHistoryInfo::battle_data(int index) const {
  return battle_data_.Get(index);
}
inline ::std::string* BattleHistoryInfo::mutable_battle_data(int index) {
  return battle_data_.Mutable(index);
}
inline void BattleHistoryInfo::set_battle_data(int index, const ::std::string& value) {
  battle_data_.Mutable(index)->assign(value);
}
inline void BattleHistoryInfo::set_battle_data(int index, const char* value) {
  battle_data_.Mutable(index)->assign(value);
}
inline void BattleHistoryInfo::set_battle_data(int index, const void* value, size_t size) {
  battle_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistoryInfo::add_battle_data() {
  return battle_data_.Add();
}
inline void BattleHistoryInfo::add_battle_data(const ::std::string& value) {
  battle_data_.Add()->assign(value);
}
inline void BattleHistoryInfo::add_battle_data(const char* value) {
  battle_data_.Add()->assign(value);
}
inline void BattleHistoryInfo::add_battle_data(const void* value, size_t size) {
  battle_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BattleHistoryInfo::battle_data() const {
  return battle_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BattleHistoryInfo::mutable_battle_data() {
  return &battle_data_;
}

// optional uint32 no_battle_history = 2;
inline bool BattleHistoryInfo::has_no_battle_history() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleHistoryInfo::set_has_no_battle_history() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleHistoryInfo::clear_has_no_battle_history() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleHistoryInfo::clear_no_battle_history() {
  no_battle_history_ = 0u;
  clear_has_no_battle_history();
}
inline ::google::protobuf::uint32 BattleHistoryInfo::no_battle_history() const {
  return no_battle_history_;
}
inline void BattleHistoryInfo::set_no_battle_history(::google::protobuf::uint32 value) {
  set_has_no_battle_history();
  no_battle_history_ = value;
}

// optional uint32 is_last_one = 3;
inline bool BattleHistoryInfo::has_is_last_one() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleHistoryInfo::set_has_is_last_one() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleHistoryInfo::clear_has_is_last_one() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleHistoryInfo::clear_is_last_one() {
  is_last_one_ = 0u;
  clear_has_is_last_one();
}
inline ::google::protobuf::uint32 BattleHistoryInfo::is_last_one() const {
  return is_last_one_;
}
inline void BattleHistoryInfo::set_is_last_one(::google::protobuf::uint32 value) {
  set_has_is_last_one();
  is_last_one_ = value;
}

// -------------------------------------------------------------------

// EnterActiveReq

// required uint32 active_id = 1;
inline bool EnterActiveReq::has_active_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterActiveReq::set_has_active_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterActiveReq::clear_has_active_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterActiveReq::clear_active_id() {
  active_id_ = 0u;
  clear_has_active_id();
}
inline ::google::protobuf::uint32 EnterActiveReq::active_id() const {
  return active_id_;
}
inline void EnterActiveReq::set_active_id(::google::protobuf::uint32 value) {
  set_has_active_id();
  active_id_ = value;
}

// -------------------------------------------------------------------

// EnterActiveAck

// optional uint32 active_id = 1;
inline bool EnterActiveAck::has_active_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterActiveAck::set_has_active_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterActiveAck::clear_has_active_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterActiveAck::clear_active_id() {
  active_id_ = 0u;
  clear_has_active_id();
}
inline ::google::protobuf::uint32 EnterActiveAck::active_id() const {
  return active_id_;
}
inline void EnterActiveAck::set_active_id(::google::protobuf::uint32 value) {
  set_has_active_id();
  active_id_ = value;
}

// optional uint32 error_code = 2;
inline bool EnterActiveAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterActiveAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterActiveAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterActiveAck::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 EnterActiveAck::error_code() const {
  return error_code_;
}
inline void EnterActiveAck::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional uint32 remain_time = 3;
inline bool EnterActiveAck::has_remain_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterActiveAck::set_has_remain_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterActiveAck::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterActiveAck::clear_remain_time() {
  remain_time_ = 0u;
  clear_has_remain_time();
}
inline ::google::protobuf::uint32 EnterActiveAck::remain_time() const {
  return remain_time_;
}
inline void EnterActiveAck::set_remain_time(::google::protobuf::uint32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// optional uint32 remain_battle_times = 4;
inline bool EnterActiveAck::has_remain_battle_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterActiveAck::set_has_remain_battle_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterActiveAck::clear_has_remain_battle_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterActiveAck::clear_remain_battle_times() {
  remain_battle_times_ = 0u;
  clear_has_remain_battle_times();
}
inline ::google::protobuf::uint32 EnterActiveAck::remain_battle_times() const {
  return remain_battle_times_;
}
inline void EnterActiveAck::set_remain_battle_times(::google::protobuf::uint32 value) {
  set_has_remain_battle_times();
  remain_battle_times_ = value;
}

// -------------------------------------------------------------------

// OpenTreasureUIReq

// optional uint32 value = 1;
inline bool OpenTreasureUIReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenTreasureUIReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenTreasureUIReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenTreasureUIReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 OpenTreasureUIReq::value() const {
  return value_;
}
inline void OpenTreasureUIReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// OpenTreasureUIAck

// optional uint32 free_times = 1;
inline bool OpenTreasureUIAck::has_free_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenTreasureUIAck::set_has_free_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenTreasureUIAck::clear_has_free_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenTreasureUIAck::clear_free_times() {
  free_times_ = 0u;
  clear_has_free_times();
}
inline ::google::protobuf::uint32 OpenTreasureUIAck::free_times() const {
  return free_times_;
}
inline void OpenTreasureUIAck::set_free_times(::google::protobuf::uint32 value) {
  set_has_free_times();
  free_times_ = value;
}

// optional uint32 coin_next_free_time = 2;
inline bool OpenTreasureUIAck::has_coin_next_free_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenTreasureUIAck::set_has_coin_next_free_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenTreasureUIAck::clear_has_coin_next_free_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenTreasureUIAck::clear_coin_next_free_time() {
  coin_next_free_time_ = 0u;
  clear_has_coin_next_free_time();
}
inline ::google::protobuf::uint32 OpenTreasureUIAck::coin_next_free_time() const {
  return coin_next_free_time_;
}
inline void OpenTreasureUIAck::set_coin_next_free_time(::google::protobuf::uint32 value) {
  set_has_coin_next_free_time();
  coin_next_free_time_ = value;
}

// optional uint32 scroll_next_free_time = 3;
inline bool OpenTreasureUIAck::has_scroll_next_free_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenTreasureUIAck::set_has_scroll_next_free_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenTreasureUIAck::clear_has_scroll_next_free_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenTreasureUIAck::clear_scroll_next_free_time() {
  scroll_next_free_time_ = 0u;
  clear_has_scroll_next_free_time();
}
inline ::google::protobuf::uint32 OpenTreasureUIAck::scroll_next_free_time() const {
  return scroll_next_free_time_;
}
inline void OpenTreasureUIAck::set_scroll_next_free_time(::google::protobuf::uint32 value) {
  set_has_scroll_next_free_time();
  scroll_next_free_time_ = value;
}

// -------------------------------------------------------------------

// GetTreasureReq

// optional uint32 trea_mode = 1;
inline bool GetTreasureReq::has_trea_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTreasureReq::set_has_trea_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTreasureReq::clear_has_trea_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTreasureReq::clear_trea_mode() {
  trea_mode_ = 0u;
  clear_has_trea_mode();
}
inline ::google::protobuf::uint32 GetTreasureReq::trea_mode() const {
  return trea_mode_;
}
inline void GetTreasureReq::set_trea_mode(::google::protobuf::uint32 value) {
  set_has_trea_mode();
  trea_mode_ = value;
}

// optional uint32 cost_type = 2;
inline bool GetTreasureReq::has_cost_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTreasureReq::set_has_cost_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTreasureReq::clear_has_cost_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTreasureReq::clear_cost_type() {
  cost_type_ = 0u;
  clear_has_cost_type();
}
inline ::google::protobuf::uint32 GetTreasureReq::cost_type() const {
  return cost_type_;
}
inline void GetTreasureReq::set_cost_type(::google::protobuf::uint32 value) {
  set_has_cost_type();
  cost_type_ = value;
}

// -------------------------------------------------------------------

// GetTreasureAck

// optional uint32 error_code = 1;
inline bool GetTreasureAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTreasureAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTreasureAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTreasureAck::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 GetTreasureAck::error_code() const {
  return error_code_;
}
inline void GetTreasureAck::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// repeated uint32 item_id = 2;
inline int GetTreasureAck::item_id_size() const {
  return item_id_.size();
}
inline void GetTreasureAck::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::uint32 GetTreasureAck::item_id(int index) const {
  return item_id_.Get(index);
}
inline void GetTreasureAck::set_item_id(int index, ::google::protobuf::uint32 value) {
  item_id_.Set(index, value);
}
inline void GetTreasureAck::add_item_id(::google::protobuf::uint32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetTreasureAck::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetTreasureAck::mutable_item_id() {
  return &item_id_;
}

// repeated uint32 item_num = 3;
inline int GetTreasureAck::item_num_size() const {
  return item_num_.size();
}
inline void GetTreasureAck::clear_item_num() {
  item_num_.Clear();
}
inline ::google::protobuf::uint32 GetTreasureAck::item_num(int index) const {
  return item_num_.Get(index);
}
inline void GetTreasureAck::set_item_num(int index, ::google::protobuf::uint32 value) {
  item_num_.Set(index, value);
}
inline void GetTreasureAck::add_item_num(::google::protobuf::uint32 value) {
  item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetTreasureAck::item_num() const {
  return item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetTreasureAck::mutable_item_num() {
  return &item_num_;
}

// repeated uint32 item_type = 4;
inline int GetTreasureAck::item_type_size() const {
  return item_type_.size();
}
inline void GetTreasureAck::clear_item_type() {
  item_type_.Clear();
}
inline ::google::protobuf::uint32 GetTreasureAck::item_type(int index) const {
  return item_type_.Get(index);
}
inline void GetTreasureAck::set_item_type(int index, ::google::protobuf::uint32 value) {
  item_type_.Set(index, value);
}
inline void GetTreasureAck::add_item_type(::google::protobuf::uint32 value) {
  item_type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetTreasureAck::item_type() const {
  return item_type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetTreasureAck::mutable_item_type() {
  return &item_type_;
}

// -------------------------------------------------------------------

// ResetAck

// optional uint32 value = 1;
inline bool ResetAck::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetAck::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetAck::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetAck::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ResetAck::value() const {
  return value_;
}
inline void ResetAck::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// optional uint32 active_id = 2;
inline bool ResetAck::has_active_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetAck::set_has_active_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetAck::clear_has_active_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetAck::clear_active_id() {
  active_id_ = 0u;
  clear_has_active_id();
}
inline ::google::protobuf::uint32 ResetAck::active_id() const {
  return active_id_;
}
inline void ResetAck::set_active_id(::google::protobuf::uint32 value) {
  set_has_active_id();
  active_id_ = value;
}

// -------------------------------------------------------------------

// AddEquipStarReq

// optional uint32 only_id = 1;
inline bool AddEquipStarReq::has_only_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddEquipStarReq::set_has_only_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddEquipStarReq::clear_has_only_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddEquipStarReq::clear_only_id() {
  only_id_ = 0u;
  clear_has_only_id();
}
inline ::google::protobuf::uint32 AddEquipStarReq::only_id() const {
  return only_id_;
}
inline void AddEquipStarReq::set_only_id(::google::protobuf::uint32 value) {
  set_has_only_id();
  only_id_ = value;
}

// optional bool if_equip = 2;
inline bool AddEquipStarReq::has_if_equip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddEquipStarReq::set_has_if_equip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddEquipStarReq::clear_has_if_equip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddEquipStarReq::clear_if_equip() {
  if_equip_ = false;
  clear_has_if_equip();
}
inline bool AddEquipStarReq::if_equip() const {
  return if_equip_;
}
inline void AddEquipStarReq::set_if_equip(bool value) {
  set_has_if_equip();
  if_equip_ = value;
}

// -------------------------------------------------------------------

// AddEquipStarAck

// optional uint32 only_id = 1;
inline bool AddEquipStarAck::has_only_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddEquipStarAck::set_has_only_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddEquipStarAck::clear_has_only_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddEquipStarAck::clear_only_id() {
  only_id_ = 0u;
  clear_has_only_id();
}
inline ::google::protobuf::uint32 AddEquipStarAck::only_id() const {
  return only_id_;
}
inline void AddEquipStarAck::set_only_id(::google::protobuf::uint32 value) {
  set_has_only_id();
  only_id_ = value;
}

// optional uint32 error_code = 2;
inline bool AddEquipStarAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddEquipStarAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddEquipStarAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddEquipStarAck::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 AddEquipStarAck::error_code() const {
  return error_code_;
}
inline void AddEquipStarAck::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// GetRoleMailInfoReq

// optional uint32 value = 1;
inline bool GetRoleMailInfoReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoleMailInfoReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoleMailInfoReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoleMailInfoReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 GetRoleMailInfoReq::value() const {
  return value_;
}
inline void GetRoleMailInfoReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// SelectMailInfoReq

// optional uint32 server_id = 1;
inline bool SelectMailInfoReq::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectMailInfoReq::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectMailInfoReq::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectMailInfoReq::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 SelectMailInfoReq::server_id() const {
  return server_id_;
}
inline void SelectMailInfoReq::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 acc_id = 2;
inline bool SelectMailInfoReq::has_acc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectMailInfoReq::set_has_acc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectMailInfoReq::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectMailInfoReq::clear_acc_id() {
  acc_id_ = 0u;
  clear_has_acc_id();
}
inline ::google::protobuf::uint32 SelectMailInfoReq::acc_id() const {
  return acc_id_;
}
inline void SelectMailInfoReq::set_acc_id(::google::protobuf::uint32 value) {
  set_has_acc_id();
  acc_id_ = value;
}

// -------------------------------------------------------------------

// RoleMailInfo

// optional uint32 mail_id = 1;
inline bool RoleMailInfo::has_mail_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleMailInfo::set_has_mail_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleMailInfo::clear_has_mail_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleMailInfo::clear_mail_id() {
  mail_id_ = 0u;
  clear_has_mail_id();
}
inline ::google::protobuf::uint32 RoleMailInfo::mail_id() const {
  return mail_id_;
}
inline void RoleMailInfo::set_mail_id(::google::protobuf::uint32 value) {
  set_has_mail_id();
  mail_id_ = value;
}

// optional uint32 mail_type = 2;
inline bool RoleMailInfo::has_mail_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleMailInfo::set_has_mail_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleMailInfo::clear_has_mail_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleMailInfo::clear_mail_type() {
  mail_type_ = 0u;
  clear_has_mail_type();
}
inline ::google::protobuf::uint32 RoleMailInfo::mail_type() const {
  return mail_type_;
}
inline void RoleMailInfo::set_mail_type(::google::protobuf::uint32 value) {
  set_has_mail_type();
  mail_type_ = value;
}

// optional uint32 has_read = 3;
inline bool RoleMailInfo::has_has_read() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleMailInfo::set_has_has_read() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleMailInfo::clear_has_has_read() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleMailInfo::clear_has_read() {
  has_read_ = 0u;
  clear_has_has_read();
}
inline ::google::protobuf::uint32 RoleMailInfo::has_read() const {
  return has_read_;
}
inline void RoleMailInfo::set_has_read(::google::protobuf::uint32 value) {
  set_has_has_read();
  has_read_ = value;
}

// repeated uint32 item_id = 4;
inline int RoleMailInfo::item_id_size() const {
  return item_id_.size();
}
inline void RoleMailInfo::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::uint32 RoleMailInfo::item_id(int index) const {
  return item_id_.Get(index);
}
inline void RoleMailInfo::set_item_id(int index, ::google::protobuf::uint32 value) {
  item_id_.Set(index, value);
}
inline void RoleMailInfo::add_item_id(::google::protobuf::uint32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RoleMailInfo::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RoleMailInfo::mutable_item_id() {
  return &item_id_;
}

// repeated uint32 item_num = 5;
inline int RoleMailInfo::item_num_size() const {
  return item_num_.size();
}
inline void RoleMailInfo::clear_item_num() {
  item_num_.Clear();
}
inline ::google::protobuf::uint32 RoleMailInfo::item_num(int index) const {
  return item_num_.Get(index);
}
inline void RoleMailInfo::set_item_num(int index, ::google::protobuf::uint32 value) {
  item_num_.Set(index, value);
}
inline void RoleMailInfo::add_item_num(::google::protobuf::uint32 value) {
  item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RoleMailInfo::item_num() const {
  return item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RoleMailInfo::mutable_item_num() {
  return &item_num_;
}

// optional bytes mail_title = 6;
inline bool RoleMailInfo::has_mail_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoleMailInfo::set_has_mail_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoleMailInfo::clear_has_mail_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoleMailInfo::clear_mail_title() {
  if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
    mail_title_->clear();
  }
  clear_has_mail_title();
}
inline const ::std::string& RoleMailInfo::mail_title() const {
  return *mail_title_;
}
inline void RoleMailInfo::set_mail_title(const ::std::string& value) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(value);
}
inline void RoleMailInfo::set_mail_title(const char* value) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(value);
}
inline void RoleMailInfo::set_mail_title(const void* value, size_t size) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleMailInfo::mutable_mail_title() {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  return mail_title_;
}
inline ::std::string* RoleMailInfo::release_mail_title() {
  clear_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_title_;
    mail_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleMailInfo::set_allocated_mail_title(::std::string* mail_title) {
  if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_title_;
  }
  if (mail_title) {
    set_has_mail_title();
    mail_title_ = mail_title;
  } else {
    clear_has_mail_title();
    mail_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes mail_content = 7;
inline bool RoleMailInfo::has_mail_content() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoleMailInfo::set_has_mail_content() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoleMailInfo::clear_has_mail_content() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoleMailInfo::clear_mail_content() {
  if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
    mail_content_->clear();
  }
  clear_has_mail_content();
}
inline const ::std::string& RoleMailInfo::mail_content() const {
  return *mail_content_;
}
inline void RoleMailInfo::set_mail_content(const ::std::string& value) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(value);
}
inline void RoleMailInfo::set_mail_content(const char* value) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(value);
}
inline void RoleMailInfo::set_mail_content(const void* value, size_t size) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleMailInfo::mutable_mail_content() {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  return mail_content_;
}
inline ::std::string* RoleMailInfo::release_mail_content() {
  clear_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_content_;
    mail_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleMailInfo::set_allocated_mail_content(::std::string* mail_content) {
  if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_content_;
  }
  if (mail_content) {
    set_has_mail_content();
    mail_content_ = mail_content;
  } else {
    clear_has_mail_content();
    mail_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 mail_time = 9;
inline bool RoleMailInfo::has_mail_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoleMailInfo::set_has_mail_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoleMailInfo::clear_has_mail_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoleMailInfo::clear_mail_time() {
  mail_time_ = 0u;
  clear_has_mail_time();
}
inline ::google::protobuf::uint32 RoleMailInfo::mail_time() const {
  return mail_time_;
}
inline void RoleMailInfo::set_mail_time(::google::protobuf::uint32 value) {
  set_has_mail_time();
  mail_time_ = value;
}

// optional uint32 end_time = 10;
inline bool RoleMailInfo::has_end_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoleMailInfo::set_has_end_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoleMailInfo::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoleMailInfo::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 RoleMailInfo::end_time() const {
  return end_time_;
}
inline void RoleMailInfo::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional uint32 is_last_one = 11;
inline bool RoleMailInfo::has_is_last_one() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoleMailInfo::set_has_is_last_one() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoleMailInfo::clear_has_is_last_one() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoleMailInfo::clear_is_last_one() {
  is_last_one_ = 0u;
  clear_has_is_last_one();
}
inline ::google::protobuf::uint32 RoleMailInfo::is_last_one() const {
  return is_last_one_;
}
inline void RoleMailInfo::set_is_last_one(::google::protobuf::uint32 value) {
  set_has_is_last_one();
  is_last_one_ = value;
}

// -------------------------------------------------------------------

// ReadMailReq

// optional uint32 mail_id = 1;
inline bool ReadMailReq::has_mail_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadMailReq::set_has_mail_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadMailReq::clear_has_mail_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadMailReq::clear_mail_id() {
  mail_id_ = 0u;
  clear_has_mail_id();
}
inline ::google::protobuf::uint32 ReadMailReq::mail_id() const {
  return mail_id_;
}
inline void ReadMailReq::set_mail_id(::google::protobuf::uint32 value) {
  set_has_mail_id();
  mail_id_ = value;
}

// -------------------------------------------------------------------

// ReadMailAck

// optional uint32 mail_id = 1;
inline bool ReadMailAck::has_mail_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadMailAck::set_has_mail_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadMailAck::clear_has_mail_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadMailAck::clear_mail_id() {
  mail_id_ = 0u;
  clear_has_mail_id();
}
inline ::google::protobuf::uint32 ReadMailAck::mail_id() const {
  return mail_id_;
}
inline void ReadMailAck::set_mail_id(::google::protobuf::uint32 value) {
  set_has_mail_id();
  mail_id_ = value;
}

// optional uint32 result = 2;
inline bool ReadMailAck::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadMailAck::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadMailAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadMailAck::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 ReadMailAck::result() const {
  return result_;
}
inline void ReadMailAck::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// GetMailRewardReq

// optional uint32 mail_id = 1;
inline bool GetMailRewardReq::has_mail_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMailRewardReq::set_has_mail_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMailRewardReq::clear_has_mail_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMailRewardReq::clear_mail_id() {
  mail_id_ = 0u;
  clear_has_mail_id();
}
inline ::google::protobuf::uint32 GetMailRewardReq::mail_id() const {
  return mail_id_;
}
inline void GetMailRewardReq::set_mail_id(::google::protobuf::uint32 value) {
  set_has_mail_id();
  mail_id_ = value;
}

// -------------------------------------------------------------------

// GetMailRewardAck

// optional uint32 mail_id = 1;
inline bool GetMailRewardAck::has_mail_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMailRewardAck::set_has_mail_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMailRewardAck::clear_has_mail_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMailRewardAck::clear_mail_id() {
  mail_id_ = 0u;
  clear_has_mail_id();
}
inline ::google::protobuf::uint32 GetMailRewardAck::mail_id() const {
  return mail_id_;
}
inline void GetMailRewardAck::set_mail_id(::google::protobuf::uint32 value) {
  set_has_mail_id();
  mail_id_ = value;
}

// optional uint32 result = 2;
inline bool GetMailRewardAck::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMailRewardAck::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMailRewardAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMailRewardAck::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 GetMailRewardAck::result() const {
  return result_;
}
inline void GetMailRewardAck::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SendGMMailReq

// optional uint32 to_acc_id = 1;
inline bool SendGMMailReq::has_to_acc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendGMMailReq::set_has_to_acc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendGMMailReq::clear_has_to_acc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendGMMailReq::clear_to_acc_id() {
  to_acc_id_ = 0u;
  clear_has_to_acc_id();
}
inline ::google::protobuf::uint32 SendGMMailReq::to_acc_id() const {
  return to_acc_id_;
}
inline void SendGMMailReq::set_to_acc_id(::google::protobuf::uint32 value) {
  set_has_to_acc_id();
  to_acc_id_ = value;
}

// optional uint32 to_char_id = 2;
inline bool SendGMMailReq::has_to_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendGMMailReq::set_has_to_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendGMMailReq::clear_has_to_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendGMMailReq::clear_to_char_id() {
  to_char_id_ = 0u;
  clear_has_to_char_id();
}
inline ::google::protobuf::uint32 SendGMMailReq::to_char_id() const {
  return to_char_id_;
}
inline void SendGMMailReq::set_to_char_id(::google::protobuf::uint32 value) {
  set_has_to_char_id();
  to_char_id_ = value;
}

// optional uint32 to_lv_low = 3;
inline bool SendGMMailReq::has_to_lv_low() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendGMMailReq::set_has_to_lv_low() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendGMMailReq::clear_has_to_lv_low() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendGMMailReq::clear_to_lv_low() {
  to_lv_low_ = 0u;
  clear_has_to_lv_low();
}
inline ::google::protobuf::uint32 SendGMMailReq::to_lv_low() const {
  return to_lv_low_;
}
inline void SendGMMailReq::set_to_lv_low(::google::protobuf::uint32 value) {
  set_has_to_lv_low();
  to_lv_low_ = value;
}

// optional uint32 to_lv_high = 4;
inline bool SendGMMailReq::has_to_lv_high() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendGMMailReq::set_has_to_lv_high() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendGMMailReq::clear_has_to_lv_high() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendGMMailReq::clear_to_lv_high() {
  to_lv_high_ = 0u;
  clear_has_to_lv_high();
}
inline ::google::protobuf::uint32 SendGMMailReq::to_lv_high() const {
  return to_lv_high_;
}
inline void SendGMMailReq::set_to_lv_high(::google::protobuf::uint32 value) {
  set_has_to_lv_high();
  to_lv_high_ = value;
}

// repeated uint32 item_id = 5;
inline int SendGMMailReq::item_id_size() const {
  return item_id_.size();
}
inline void SendGMMailReq::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::uint32 SendGMMailReq::item_id(int index) const {
  return item_id_.Get(index);
}
inline void SendGMMailReq::set_item_id(int index, ::google::protobuf::uint32 value) {
  item_id_.Set(index, value);
}
inline void SendGMMailReq::add_item_id(::google::protobuf::uint32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SendGMMailReq::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SendGMMailReq::mutable_item_id() {
  return &item_id_;
}

// repeated uint32 item_num = 6;
inline int SendGMMailReq::item_num_size() const {
  return item_num_.size();
}
inline void SendGMMailReq::clear_item_num() {
  item_num_.Clear();
}
inline ::google::protobuf::uint32 SendGMMailReq::item_num(int index) const {
  return item_num_.Get(index);
}
inline void SendGMMailReq::set_item_num(int index, ::google::protobuf::uint32 value) {
  item_num_.Set(index, value);
}
inline void SendGMMailReq::add_item_num(::google::protobuf::uint32 value) {
  item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SendGMMailReq::item_num() const {
  return item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SendGMMailReq::mutable_item_num() {
  return &item_num_;
}

// optional uint32 end_time = 7;
inline bool SendGMMailReq::has_end_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SendGMMailReq::set_has_end_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SendGMMailReq::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SendGMMailReq::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 SendGMMailReq::end_time() const {
  return end_time_;
}
inline void SendGMMailReq::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional bytes to_char_name = 8;
inline bool SendGMMailReq::has_to_char_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SendGMMailReq::set_has_to_char_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SendGMMailReq::clear_has_to_char_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SendGMMailReq::clear_to_char_name() {
  if (to_char_name_ != &::google::protobuf::internal::kEmptyString) {
    to_char_name_->clear();
  }
  clear_has_to_char_name();
}
inline const ::std::string& SendGMMailReq::to_char_name() const {
  return *to_char_name_;
}
inline void SendGMMailReq::set_to_char_name(const ::std::string& value) {
  set_has_to_char_name();
  if (to_char_name_ == &::google::protobuf::internal::kEmptyString) {
    to_char_name_ = new ::std::string;
  }
  to_char_name_->assign(value);
}
inline void SendGMMailReq::set_to_char_name(const char* value) {
  set_has_to_char_name();
  if (to_char_name_ == &::google::protobuf::internal::kEmptyString) {
    to_char_name_ = new ::std::string;
  }
  to_char_name_->assign(value);
}
inline void SendGMMailReq::set_to_char_name(const void* value, size_t size) {
  set_has_to_char_name();
  if (to_char_name_ == &::google::protobuf::internal::kEmptyString) {
    to_char_name_ = new ::std::string;
  }
  to_char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendGMMailReq::mutable_to_char_name() {
  set_has_to_char_name();
  if (to_char_name_ == &::google::protobuf::internal::kEmptyString) {
    to_char_name_ = new ::std::string;
  }
  return to_char_name_;
}
inline ::std::string* SendGMMailReq::release_to_char_name() {
  clear_has_to_char_name();
  if (to_char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_char_name_;
    to_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendGMMailReq::set_allocated_to_char_name(::std::string* to_char_name) {
  if (to_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete to_char_name_;
  }
  if (to_char_name) {
    set_has_to_char_name();
    to_char_name_ = to_char_name;
  } else {
    clear_has_to_char_name();
    to_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes mail_title = 9;
inline bool SendGMMailReq::has_mail_title() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SendGMMailReq::set_has_mail_title() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SendGMMailReq::clear_has_mail_title() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SendGMMailReq::clear_mail_title() {
  if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
    mail_title_->clear();
  }
  clear_has_mail_title();
}
inline const ::std::string& SendGMMailReq::mail_title() const {
  return *mail_title_;
}
inline void SendGMMailReq::set_mail_title(const ::std::string& value) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(value);
}
inline void SendGMMailReq::set_mail_title(const char* value) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(value);
}
inline void SendGMMailReq::set_mail_title(const void* value, size_t size) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendGMMailReq::mutable_mail_title() {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  return mail_title_;
}
inline ::std::string* SendGMMailReq::release_mail_title() {
  clear_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_title_;
    mail_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendGMMailReq::set_allocated_mail_title(::std::string* mail_title) {
  if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_title_;
  }
  if (mail_title) {
    set_has_mail_title();
    mail_title_ = mail_title;
  } else {
    clear_has_mail_title();
    mail_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes mail_content = 10;
inline bool SendGMMailReq::has_mail_content() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SendGMMailReq::set_has_mail_content() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SendGMMailReq::clear_has_mail_content() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SendGMMailReq::clear_mail_content() {
  if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
    mail_content_->clear();
  }
  clear_has_mail_content();
}
inline const ::std::string& SendGMMailReq::mail_content() const {
  return *mail_content_;
}
inline void SendGMMailReq::set_mail_content(const ::std::string& value) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(value);
}
inline void SendGMMailReq::set_mail_content(const char* value) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(value);
}
inline void SendGMMailReq::set_mail_content(const void* value, size_t size) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendGMMailReq::mutable_mail_content() {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  return mail_content_;
}
inline ::std::string* SendGMMailReq::release_mail_content() {
  clear_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_content_;
    mail_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendGMMailReq::set_allocated_mail_content(::std::string* mail_content) {
  if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_content_;
  }
  if (mail_content) {
    set_has_mail_content();
    mail_content_ = mail_content;
  } else {
    clear_has_mail_content();
    mail_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SendGMMailAck

// optional uint32 result = 1;
inline bool SendGMMailAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendGMMailAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendGMMailAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendGMMailAck::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 SendGMMailAck::result() const {
  return result_;
}
inline void SendGMMailAck::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// NewMailNotice

// optional uint32 new_mail = 1;
inline bool NewMailNotice::has_new_mail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewMailNotice::set_has_new_mail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewMailNotice::clear_has_new_mail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewMailNotice::clear_new_mail() {
  new_mail_ = 0u;
  clear_has_new_mail();
}
inline ::google::protobuf::uint32 NewMailNotice::new_mail() const {
  return new_mail_;
}
inline void NewMailNotice::set_new_mail(::google::protobuf::uint32 value) {
  set_has_new_mail();
  new_mail_ = value;
}

// -------------------------------------------------------------------

// SelectMailInfoAck

// repeated bytes mail_data = 1;
inline int SelectMailInfoAck::mail_data_size() const {
  return mail_data_.size();
}
inline void SelectMailInfoAck::clear_mail_data() {
  mail_data_.Clear();
}
inline const ::std::string& SelectMailInfoAck::mail_data(int index) const {
  return mail_data_.Get(index);
}
inline ::std::string* SelectMailInfoAck::mutable_mail_data(int index) {
  return mail_data_.Mutable(index);
}
inline void SelectMailInfoAck::set_mail_data(int index, const ::std::string& value) {
  mail_data_.Mutable(index)->assign(value);
}
inline void SelectMailInfoAck::set_mail_data(int index, const char* value) {
  mail_data_.Mutable(index)->assign(value);
}
inline void SelectMailInfoAck::set_mail_data(int index, const void* value, size_t size) {
  mail_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SelectMailInfoAck::add_mail_data() {
  return mail_data_.Add();
}
inline void SelectMailInfoAck::add_mail_data(const ::std::string& value) {
  mail_data_.Add()->assign(value);
}
inline void SelectMailInfoAck::add_mail_data(const char* value) {
  mail_data_.Add()->assign(value);
}
inline void SelectMailInfoAck::add_mail_data(const void* value, size_t size) {
  mail_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SelectMailInfoAck::mail_data() const {
  return mail_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SelectMailInfoAck::mutable_mail_data() {
  return &mail_data_;
}

// optional uint32 is_last_one = 2;
inline bool SelectMailInfoAck::has_is_last_one() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectMailInfoAck::set_has_is_last_one() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectMailInfoAck::clear_has_is_last_one() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectMailInfoAck::clear_is_last_one() {
  is_last_one_ = 0u;
  clear_has_is_last_one();
}
inline ::google::protobuf::uint32 SelectMailInfoAck::is_last_one() const {
  return is_last_one_;
}
inline void SelectMailInfoAck::set_is_last_one(::google::protobuf::uint32 value) {
  set_has_is_last_one();
  is_last_one_ = value;
}

// -------------------------------------------------------------------

// GetSkillInfoReq

// optional uint32 nvalue = 1;
inline bool GetSkillInfoReq::has_nvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSkillInfoReq::set_has_nvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSkillInfoReq::clear_has_nvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSkillInfoReq::clear_nvalue() {
  nvalue_ = 0u;
  clear_has_nvalue();
}
inline ::google::protobuf::uint32 GetSkillInfoReq::nvalue() const {
  return nvalue_;
}
inline void GetSkillInfoReq::set_nvalue(::google::protobuf::uint32 value) {
  set_has_nvalue();
  nvalue_ = value;
}

// -------------------------------------------------------------------

// GetSkillInfoAck

// optional uint32 skill_point = 1;
inline bool GetSkillInfoAck::has_skill_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSkillInfoAck::set_has_skill_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSkillInfoAck::clear_has_skill_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSkillInfoAck::clear_skill_point() {
  skill_point_ = 0u;
  clear_has_skill_point();
}
inline ::google::protobuf::uint32 GetSkillInfoAck::skill_point() const {
  return skill_point_;
}
inline void GetSkillInfoAck::set_skill_point(::google::protobuf::uint32 value) {
  set_has_skill_point();
  skill_point_ = value;
}

// optional uint32 next_add_time = 2;
inline bool GetSkillInfoAck::has_next_add_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSkillInfoAck::set_has_next_add_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSkillInfoAck::clear_has_next_add_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSkillInfoAck::clear_next_add_time() {
  next_add_time_ = 0u;
  clear_has_next_add_time();
}
inline ::google::protobuf::uint32 GetSkillInfoAck::next_add_time() const {
  return next_add_time_;
}
inline void GetSkillInfoAck::set_next_add_time(::google::protobuf::uint32 value) {
  set_has_next_add_time();
  next_add_time_ = value;
}

// -------------------------------------------------------------------

// EquipUpgradeItemReq

// optional uint32 merc_id = 1;
inline bool EquipUpgradeItemReq::has_merc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipUpgradeItemReq::set_has_merc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipUpgradeItemReq::clear_has_merc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipUpgradeItemReq::clear_merc_id() {
  merc_id_ = 0u;
  clear_has_merc_id();
}
inline ::google::protobuf::uint32 EquipUpgradeItemReq::merc_id() const {
  return merc_id_;
}
inline void EquipUpgradeItemReq::set_merc_id(::google::protobuf::uint32 value) {
  set_has_merc_id();
  merc_id_ = value;
}

// optional uint32 equip_pos = 2;
inline bool EquipUpgradeItemReq::has_equip_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipUpgradeItemReq::set_has_equip_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipUpgradeItemReq::clear_has_equip_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipUpgradeItemReq::clear_equip_pos() {
  equip_pos_ = 0u;
  clear_has_equip_pos();
}
inline ::google::protobuf::uint32 EquipUpgradeItemReq::equip_pos() const {
  return equip_pos_;
}
inline void EquipUpgradeItemReq::set_equip_pos(::google::protobuf::uint32 value) {
  set_has_equip_pos();
  equip_pos_ = value;
}

// -------------------------------------------------------------------

// UnlockedSkill

// optional uint32 merc_pos = 1;
inline bool UnlockedSkill::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlockedSkill::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlockedSkill::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlockedSkill::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 UnlockedSkill::merc_pos() const {
  return merc_pos_;
}
inline void UnlockedSkill::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// repeated uint32 skill_pos = 2;
inline int UnlockedSkill::skill_pos_size() const {
  return skill_pos_.size();
}
inline void UnlockedSkill::clear_skill_pos() {
  skill_pos_.Clear();
}
inline ::google::protobuf::uint32 UnlockedSkill::skill_pos(int index) const {
  return skill_pos_.Get(index);
}
inline void UnlockedSkill::set_skill_pos(int index, ::google::protobuf::uint32 value) {
  skill_pos_.Set(index, value);
}
inline void UnlockedSkill::add_skill_pos(::google::protobuf::uint32 value) {
  skill_pos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UnlockedSkill::skill_pos() const {
  return skill_pos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UnlockedSkill::mutable_skill_pos() {
  return &skill_pos_;
}

// -------------------------------------------------------------------

// ReqGetLastPvpRewardTime

// optional uint32 value = 1;
inline bool ReqGetLastPvpRewardTime::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetLastPvpRewardTime::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetLastPvpRewardTime::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetLastPvpRewardTime::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReqGetLastPvpRewardTime::value() const {
  return value_;
}
inline void ReqGetLastPvpRewardTime::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// PvpRewardTimeAck

// optional uint32 last_time = 1;
inline bool PvpRewardTimeAck::has_last_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpRewardTimeAck::set_has_last_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpRewardTimeAck::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpRewardTimeAck::clear_last_time() {
  last_time_ = 0u;
  clear_has_last_time();
}
inline ::google::protobuf::uint32 PvpRewardTimeAck::last_time() const {
  return last_time_;
}
inline void PvpRewardTimeAck::set_last_time(::google::protobuf::uint32 value) {
  set_has_last_time();
  last_time_ = value;
}

// -------------------------------------------------------------------

// GetClimbTowerEnemyReq

// optional uint32 map_id = 1;
inline bool GetClimbTowerEnemyReq::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClimbTowerEnemyReq::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClimbTowerEnemyReq::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClimbTowerEnemyReq::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyReq::map_id() const {
  return map_id_;
}
inline void GetClimbTowerEnemyReq::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// -------------------------------------------------------------------

// SelectClimbTowerEnemy

// optional uint32 map_id = 1;
inline bool SelectClimbTowerEnemy::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectClimbTowerEnemy::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectClimbTowerEnemy::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectClimbTowerEnemy::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 SelectClimbTowerEnemy::map_id() const {
  return map_id_;
}
inline void SelectClimbTowerEnemy::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 char_id = 2;
inline bool SelectClimbTowerEnemy::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectClimbTowerEnemy::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectClimbTowerEnemy::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectClimbTowerEnemy::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 SelectClimbTowerEnemy::char_id() const {
  return char_id_;
}
inline void SelectClimbTowerEnemy::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// optional uint32 server_id = 3;
inline bool SelectClimbTowerEnemy::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SelectClimbTowerEnemy::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SelectClimbTowerEnemy::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SelectClimbTowerEnemy::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 SelectClimbTowerEnemy::server_id() const {
  return server_id_;
}
inline void SelectClimbTowerEnemy::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 battle_score_low = 4;
inline bool SelectClimbTowerEnemy::has_battle_score_low() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SelectClimbTowerEnemy::set_has_battle_score_low() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SelectClimbTowerEnemy::clear_has_battle_score_low() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SelectClimbTowerEnemy::clear_battle_score_low() {
  battle_score_low_ = 0u;
  clear_has_battle_score_low();
}
inline ::google::protobuf::uint32 SelectClimbTowerEnemy::battle_score_low() const {
  return battle_score_low_;
}
inline void SelectClimbTowerEnemy::set_battle_score_low(::google::protobuf::uint32 value) {
  set_has_battle_score_low();
  battle_score_low_ = value;
}

// optional uint32 battle_score_high = 5;
inline bool SelectClimbTowerEnemy::has_battle_score_high() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SelectClimbTowerEnemy::set_has_battle_score_high() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SelectClimbTowerEnemy::clear_has_battle_score_high() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SelectClimbTowerEnemy::clear_battle_score_high() {
  battle_score_high_ = 0u;
  clear_has_battle_score_high();
}
inline ::google::protobuf::uint32 SelectClimbTowerEnemy::battle_score_high() const {
  return battle_score_high_;
}
inline void SelectClimbTowerEnemy::set_battle_score_high(::google::protobuf::uint32 value) {
  set_has_battle_score_high();
  battle_score_high_ = value;
}

// -------------------------------------------------------------------

// ClimbTowerEnemyData

// optional uint32 query_type = 1;
inline bool ClimbTowerEnemyData::has_query_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClimbTowerEnemyData::set_has_query_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClimbTowerEnemyData::clear_has_query_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClimbTowerEnemyData::clear_query_type() {
  query_type_ = 0u;
  clear_has_query_type();
}
inline ::google::protobuf::uint32 ClimbTowerEnemyData::query_type() const {
  return query_type_;
}
inline void ClimbTowerEnemyData::set_query_type(::google::protobuf::uint32 value) {
  set_has_query_type();
  query_type_ = value;
}

// optional uint32 char_id = 2;
inline bool ClimbTowerEnemyData::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClimbTowerEnemyData::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClimbTowerEnemyData::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClimbTowerEnemyData::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 ClimbTowerEnemyData::char_id() const {
  return char_id_;
}
inline void ClimbTowerEnemyData::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// optional uint32 char_sex = 3;
inline bool ClimbTowerEnemyData::has_char_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClimbTowerEnemyData::set_has_char_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClimbTowerEnemyData::clear_has_char_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClimbTowerEnemyData::clear_char_sex() {
  char_sex_ = 0u;
  clear_has_char_sex();
}
inline ::google::protobuf::uint32 ClimbTowerEnemyData::char_sex() const {
  return char_sex_;
}
inline void ClimbTowerEnemyData::set_char_sex(::google::protobuf::uint32 value) {
  set_has_char_sex();
  char_sex_ = value;
}

// optional uint32 char_job = 4;
inline bool ClimbTowerEnemyData::has_char_job() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClimbTowerEnemyData::set_has_char_job() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClimbTowerEnemyData::clear_has_char_job() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClimbTowerEnemyData::clear_char_job() {
  char_job_ = 0u;
  clear_has_char_job();
}
inline ::google::protobuf::uint32 ClimbTowerEnemyData::char_job() const {
  return char_job_;
}
inline void ClimbTowerEnemyData::set_char_job(::google::protobuf::uint32 value) {
  set_has_char_job();
  char_job_ = value;
}

// optional uint32 char_level = 5;
inline bool ClimbTowerEnemyData::has_char_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClimbTowerEnemyData::set_has_char_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClimbTowerEnemyData::clear_has_char_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClimbTowerEnemyData::clear_char_level() {
  char_level_ = 0u;
  clear_has_char_level();
}
inline ::google::protobuf::uint32 ClimbTowerEnemyData::char_level() const {
  return char_level_;
}
inline void ClimbTowerEnemyData::set_char_level(::google::protobuf::uint32 value) {
  set_has_char_level();
  char_level_ = value;
}

// optional bytes char_name = 6;
inline bool ClimbTowerEnemyData::has_char_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClimbTowerEnemyData::set_has_char_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClimbTowerEnemyData::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClimbTowerEnemyData::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& ClimbTowerEnemyData::char_name() const {
  return *char_name_;
}
inline void ClimbTowerEnemyData::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void ClimbTowerEnemyData::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void ClimbTowerEnemyData::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClimbTowerEnemyData::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* ClimbTowerEnemyData::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClimbTowerEnemyData::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes merc_data = 7;
inline bool ClimbTowerEnemyData::has_merc_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClimbTowerEnemyData::set_has_merc_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClimbTowerEnemyData::clear_has_merc_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClimbTowerEnemyData::clear_merc_data() {
  if (merc_data_ != &::google::protobuf::internal::kEmptyString) {
    merc_data_->clear();
  }
  clear_has_merc_data();
}
inline const ::std::string& ClimbTowerEnemyData::merc_data() const {
  return *merc_data_;
}
inline void ClimbTowerEnemyData::set_merc_data(const ::std::string& value) {
  set_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    merc_data_ = new ::std::string;
  }
  merc_data_->assign(value);
}
inline void ClimbTowerEnemyData::set_merc_data(const char* value) {
  set_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    merc_data_ = new ::std::string;
  }
  merc_data_->assign(value);
}
inline void ClimbTowerEnemyData::set_merc_data(const void* value, size_t size) {
  set_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    merc_data_ = new ::std::string;
  }
  merc_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClimbTowerEnemyData::mutable_merc_data() {
  set_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    merc_data_ = new ::std::string;
  }
  return merc_data_;
}
inline ::std::string* ClimbTowerEnemyData::release_merc_data() {
  clear_has_merc_data();
  if (merc_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merc_data_;
    merc_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClimbTowerEnemyData::set_allocated_merc_data(::std::string* merc_data) {
  if (merc_data_ != &::google::protobuf::internal::kEmptyString) {
    delete merc_data_;
  }
  if (merc_data) {
    set_has_merc_data();
    merc_data_ = merc_data;
  } else {
    clear_has_merc_data();
    merc_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes equip_data = 8;
inline bool ClimbTowerEnemyData::has_equip_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClimbTowerEnemyData::set_has_equip_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClimbTowerEnemyData::clear_has_equip_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClimbTowerEnemyData::clear_equip_data() {
  if (equip_data_ != &::google::protobuf::internal::kEmptyString) {
    equip_data_->clear();
  }
  clear_has_equip_data();
}
inline const ::std::string& ClimbTowerEnemyData::equip_data() const {
  return *equip_data_;
}
inline void ClimbTowerEnemyData::set_equip_data(const ::std::string& value) {
  set_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    equip_data_ = new ::std::string;
  }
  equip_data_->assign(value);
}
inline void ClimbTowerEnemyData::set_equip_data(const char* value) {
  set_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    equip_data_ = new ::std::string;
  }
  equip_data_->assign(value);
}
inline void ClimbTowerEnemyData::set_equip_data(const void* value, size_t size) {
  set_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    equip_data_ = new ::std::string;
  }
  equip_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClimbTowerEnemyData::mutable_equip_data() {
  set_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    equip_data_ = new ::std::string;
  }
  return equip_data_;
}
inline ::std::string* ClimbTowerEnemyData::release_equip_data() {
  clear_has_equip_data();
  if (equip_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equip_data_;
    equip_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClimbTowerEnemyData::set_allocated_equip_data(::std::string* equip_data) {
  if (equip_data_ != &::google::protobuf::internal::kEmptyString) {
    delete equip_data_;
  }
  if (equip_data) {
    set_has_equip_data();
    equip_data_ = equip_data;
  } else {
    clear_has_equip_data();
    equip_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetClimbTowerEnemyAck_MercInfo

// optional uint32 merc_id = 1;
inline bool GetClimbTowerEnemyAck_MercInfo::has_merc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_has_merc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_has_merc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_merc_id() {
  merc_id_ = 0u;
  clear_has_merc_id();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck_MercInfo::merc_id() const {
  return merc_id_;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_merc_id(::google::protobuf::uint32 value) {
  set_has_merc_id();
  merc_id_ = value;
}

// optional uint32 merc_level = 2;
inline bool GetClimbTowerEnemyAck_MercInfo::has_merc_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_has_merc_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_has_merc_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_merc_level() {
  merc_level_ = 0u;
  clear_has_merc_level();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck_MercInfo::merc_level() const {
  return merc_level_;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_merc_level(::google::protobuf::uint32 value) {
  set_has_merc_level();
  merc_level_ = value;
}

// optional uint32 merc_color = 3;
inline bool GetClimbTowerEnemyAck_MercInfo::has_merc_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_has_merc_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_has_merc_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_merc_color() {
  merc_color_ = 0u;
  clear_has_merc_color();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck_MercInfo::merc_color() const {
  return merc_color_;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_merc_color(::google::protobuf::uint32 value) {
  set_has_merc_color();
  merc_color_ = value;
}

// optional uint32 merc_star = 4;
inline bool GetClimbTowerEnemyAck_MercInfo::has_merc_star() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_has_merc_star() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_has_merc_star() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_merc_star() {
  merc_star_ = 0u;
  clear_has_merc_star();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck_MercInfo::merc_star() const {
  return merc_star_;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_merc_star(::google::protobuf::uint32 value) {
  set_has_merc_star();
  merc_star_ = value;
}

// optional uint32 merc_blood = 5;
inline bool GetClimbTowerEnemyAck_MercInfo::has_merc_blood() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_has_merc_blood() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_has_merc_blood() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_merc_blood() {
  merc_blood_ = 0u;
  clear_has_merc_blood();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck_MercInfo::merc_blood() const {
  return merc_blood_;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_merc_blood(::google::protobuf::uint32 value) {
  set_has_merc_blood();
  merc_blood_ = value;
}

// optional uint32 merc_skill_energy = 6;
inline bool GetClimbTowerEnemyAck_MercInfo::has_merc_skill_energy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_has_merc_skill_energy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_has_merc_skill_energy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetClimbTowerEnemyAck_MercInfo::clear_merc_skill_energy() {
  merc_skill_energy_ = 0u;
  clear_has_merc_skill_energy();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck_MercInfo::merc_skill_energy() const {
  return merc_skill_energy_;
}
inline void GetClimbTowerEnemyAck_MercInfo::set_merc_skill_energy(::google::protobuf::uint32 value) {
  set_has_merc_skill_energy();
  merc_skill_energy_ = value;
}

// -------------------------------------------------------------------

// GetClimbTowerEnemyAck

// optional uint32 error_code = 1;
inline bool GetClimbTowerEnemyAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClimbTowerEnemyAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClimbTowerEnemyAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClimbTowerEnemyAck::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck::error_code() const {
  return error_code_;
}
inline void GetClimbTowerEnemyAck::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional uint32 char_id = 2;
inline bool GetClimbTowerEnemyAck::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetClimbTowerEnemyAck::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetClimbTowerEnemyAck::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetClimbTowerEnemyAck::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck::char_id() const {
  return char_id_;
}
inline void GetClimbTowerEnemyAck::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// optional bytes char_name = 3;
inline bool GetClimbTowerEnemyAck::has_char_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetClimbTowerEnemyAck::set_has_char_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetClimbTowerEnemyAck::clear_has_char_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetClimbTowerEnemyAck::clear_char_name() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    char_name_->clear();
  }
  clear_has_char_name();
}
inline const ::std::string& GetClimbTowerEnemyAck::char_name() const {
  return *char_name_;
}
inline void GetClimbTowerEnemyAck::set_char_name(const ::std::string& value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void GetClimbTowerEnemyAck::set_char_name(const char* value) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(value);
}
inline void GetClimbTowerEnemyAck::set_char_name(const void* value, size_t size) {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  char_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetClimbTowerEnemyAck::mutable_char_name() {
  set_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    char_name_ = new ::std::string;
  }
  return char_name_;
}
inline ::std::string* GetClimbTowerEnemyAck::release_char_name() {
  clear_has_char_name();
  if (char_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_name_;
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetClimbTowerEnemyAck::set_allocated_char_name(::std::string* char_name) {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (char_name) {
    set_has_char_name();
    char_name_ = char_name;
  } else {
    clear_has_char_name();
    char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 char_sex = 4;
inline bool GetClimbTowerEnemyAck::has_char_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetClimbTowerEnemyAck::set_has_char_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetClimbTowerEnemyAck::clear_has_char_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetClimbTowerEnemyAck::clear_char_sex() {
  char_sex_ = 0u;
  clear_has_char_sex();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck::char_sex() const {
  return char_sex_;
}
inline void GetClimbTowerEnemyAck::set_char_sex(::google::protobuf::uint32 value) {
  set_has_char_sex();
  char_sex_ = value;
}

// optional uint32 char_job = 5;
inline bool GetClimbTowerEnemyAck::has_char_job() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetClimbTowerEnemyAck::set_has_char_job() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetClimbTowerEnemyAck::clear_has_char_job() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetClimbTowerEnemyAck::clear_char_job() {
  char_job_ = 0u;
  clear_has_char_job();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck::char_job() const {
  return char_job_;
}
inline void GetClimbTowerEnemyAck::set_char_job(::google::protobuf::uint32 value) {
  set_has_char_job();
  char_job_ = value;
}

// optional uint32 char_level = 6;
inline bool GetClimbTowerEnemyAck::has_char_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetClimbTowerEnemyAck::set_has_char_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetClimbTowerEnemyAck::clear_has_char_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetClimbTowerEnemyAck::clear_char_level() {
  char_level_ = 0u;
  clear_has_char_level();
}
inline ::google::protobuf::uint32 GetClimbTowerEnemyAck::char_level() const {
  return char_level_;
}
inline void GetClimbTowerEnemyAck::set_char_level(::google::protobuf::uint32 value) {
  set_has_char_level();
  char_level_ = value;
}

// repeated .message.GetClimbTowerEnemyAck.MercInfo merc_data = 7;
inline int GetClimbTowerEnemyAck::merc_data_size() const {
  return merc_data_.size();
}
inline void GetClimbTowerEnemyAck::clear_merc_data() {
  merc_data_.Clear();
}
inline const ::message::GetClimbTowerEnemyAck_MercInfo& GetClimbTowerEnemyAck::merc_data(int index) const {
  return merc_data_.Get(index);
}
inline ::message::GetClimbTowerEnemyAck_MercInfo* GetClimbTowerEnemyAck::mutable_merc_data(int index) {
  return merc_data_.Mutable(index);
}
inline ::message::GetClimbTowerEnemyAck_MercInfo* GetClimbTowerEnemyAck::add_merc_data() {
  return merc_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::GetClimbTowerEnemyAck_MercInfo >&
GetClimbTowerEnemyAck::merc_data() const {
  return merc_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::GetClimbTowerEnemyAck_MercInfo >*
GetClimbTowerEnemyAck::mutable_merc_data() {
  return &merc_data_;
}

// -------------------------------------------------------------------

// GetClimbTowerRewardReq

// optional uint32 value = 1;
inline bool GetClimbTowerRewardReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClimbTowerRewardReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClimbTowerRewardReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClimbTowerRewardReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 GetClimbTowerRewardReq::value() const {
  return value_;
}
inline void GetClimbTowerRewardReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// GetClimbTowerRewardAck

// optional uint32 error_code = 1;
inline bool GetClimbTowerRewardAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClimbTowerRewardAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClimbTowerRewardAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClimbTowerRewardAck::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 GetClimbTowerRewardAck::error_code() const {
  return error_code_;
}
inline void GetClimbTowerRewardAck::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional uint32 money_num = 2;
inline bool GetClimbTowerRewardAck::has_money_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetClimbTowerRewardAck::set_has_money_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetClimbTowerRewardAck::clear_has_money_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetClimbTowerRewardAck::clear_money_num() {
  money_num_ = 0u;
  clear_has_money_num();
}
inline ::google::protobuf::uint32 GetClimbTowerRewardAck::money_num() const {
  return money_num_;
}
inline void GetClimbTowerRewardAck::set_money_num(::google::protobuf::uint32 value) {
  set_has_money_num();
  money_num_ = value;
}

// optional uint32 ct_money = 3;
inline bool GetClimbTowerRewardAck::has_ct_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetClimbTowerRewardAck::set_has_ct_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetClimbTowerRewardAck::clear_has_ct_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetClimbTowerRewardAck::clear_ct_money() {
  ct_money_ = 0u;
  clear_has_ct_money();
}
inline ::google::protobuf::uint32 GetClimbTowerRewardAck::ct_money() const {
  return ct_money_;
}
inline void GetClimbTowerRewardAck::set_ct_money(::google::protobuf::uint32 value) {
  set_has_ct_money();
  ct_money_ = value;
}

// repeated uint32 item_id = 4;
inline int GetClimbTowerRewardAck::item_id_size() const {
  return item_id_.size();
}
inline void GetClimbTowerRewardAck::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::uint32 GetClimbTowerRewardAck::item_id(int index) const {
  return item_id_.Get(index);
}
inline void GetClimbTowerRewardAck::set_item_id(int index, ::google::protobuf::uint32 value) {
  item_id_.Set(index, value);
}
inline void GetClimbTowerRewardAck::add_item_id(::google::protobuf::uint32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetClimbTowerRewardAck::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetClimbTowerRewardAck::mutable_item_id() {
  return &item_id_;
}

// repeated uint32 item_num = 5;
inline int GetClimbTowerRewardAck::item_num_size() const {
  return item_num_.size();
}
inline void GetClimbTowerRewardAck::clear_item_num() {
  item_num_.Clear();
}
inline ::google::protobuf::uint32 GetClimbTowerRewardAck::item_num(int index) const {
  return item_num_.Get(index);
}
inline void GetClimbTowerRewardAck::set_item_num(int index, ::google::protobuf::uint32 value) {
  item_num_.Set(index, value);
}
inline void GetClimbTowerRewardAck::add_item_num(::google::protobuf::uint32 value) {
  item_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetClimbTowerRewardAck::item_num() const {
  return item_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetClimbTowerRewardAck::mutable_item_num() {
  return &item_num_;
}

// -------------------------------------------------------------------

// ReliveMercReq

// optional uint32 merc_id = 1;
inline bool ReliveMercReq::has_merc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReliveMercReq::set_has_merc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReliveMercReq::clear_has_merc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReliveMercReq::clear_merc_id() {
  merc_id_ = 0u;
  clear_has_merc_id();
}
inline ::google::protobuf::uint32 ReliveMercReq::merc_id() const {
  return merc_id_;
}
inline void ReliveMercReq::set_merc_id(::google::protobuf::uint32 value) {
  set_has_merc_id();
  merc_id_ = value;
}

// -------------------------------------------------------------------

// ReliveMercAck

// optional uint32 error_code = 1;
inline bool ReliveMercAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReliveMercAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReliveMercAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReliveMercAck::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 ReliveMercAck::error_code() const {
  return error_code_;
}
inline void ReliveMercAck::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional uint32 merc_pos = 2;
inline bool ReliveMercAck::has_merc_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReliveMercAck::set_has_merc_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReliveMercAck::clear_has_merc_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReliveMercAck::clear_merc_pos() {
  merc_pos_ = 0u;
  clear_has_merc_pos();
}
inline ::google::protobuf::uint32 ReliveMercAck::merc_pos() const {
  return merc_pos_;
}
inline void ReliveMercAck::set_merc_pos(::google::protobuf::uint32 value) {
  set_has_merc_pos();
  merc_pos_ = value;
}

// -------------------------------------------------------------------

// ResetClimbTowerReq

// optional uint32 value = 1;
inline bool ResetClimbTowerReq::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetClimbTowerReq::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetClimbTowerReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetClimbTowerReq::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ResetClimbTowerReq::value() const {
  return value_;
}
inline void ResetClimbTowerReq::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ClimbTowerBattleResult_SaveData

// optional uint32 merc_id = 1;
inline bool ClimbTowerBattleResult_SaveData::has_merc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClimbTowerBattleResult_SaveData::set_has_merc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClimbTowerBattleResult_SaveData::clear_has_merc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClimbTowerBattleResult_SaveData::clear_merc_id() {
  merc_id_ = 0u;
  clear_has_merc_id();
}
inline ::google::protobuf::uint32 ClimbTowerBattleResult_SaveData::merc_id() const {
  return merc_id_;
}
inline void ClimbTowerBattleResult_SaveData::set_merc_id(::google::protobuf::uint32 value) {
  set_has_merc_id();
  merc_id_ = value;
}

// optional uint32 blood_num = 2;
inline bool ClimbTowerBattleResult_SaveData::has_blood_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClimbTowerBattleResult_SaveData::set_has_blood_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClimbTowerBattleResult_SaveData::clear_has_blood_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClimbTowerBattleResult_SaveData::clear_blood_num() {
  blood_num_ = 0u;
  clear_has_blood_num();
}
inline ::google::protobuf::uint32 ClimbTowerBattleResult_SaveData::blood_num() const {
  return blood_num_;
}
inline void ClimbTowerBattleResult_SaveData::set_blood_num(::google::protobuf::uint32 value) {
  set_has_blood_num();
  blood_num_ = value;
}

// optional uint32 skill_energy = 3;
inline bool ClimbTowerBattleResult_SaveData::has_skill_energy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClimbTowerBattleResult_SaveData::set_has_skill_energy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClimbTowerBattleResult_SaveData::clear_has_skill_energy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClimbTowerBattleResult_SaveData::clear_skill_energy() {
  skill_energy_ = 0u;
  clear_has_skill_energy();
}
inline ::google::protobuf::uint32 ClimbTowerBattleResult_SaveData::skill_energy() const {
  return skill_energy_;
}
inline void ClimbTowerBattleResult_SaveData::set_skill_energy(::google::protobuf::uint32 value) {
  set_has_skill_energy();
  skill_energy_ = value;
}

// -------------------------------------------------------------------

// ClimbTowerBattleResult

// optional uint32 map_id = 1;
inline bool ClimbTowerBattleResult::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClimbTowerBattleResult::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClimbTowerBattleResult::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClimbTowerBattleResult::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 ClimbTowerBattleResult::map_id() const {
  return map_id_;
}
inline void ClimbTowerBattleResult::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 battle_result = 2;
inline bool ClimbTowerBattleResult::has_battle_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClimbTowerBattleResult::set_has_battle_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClimbTowerBattleResult::clear_has_battle_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClimbTowerBattleResult::clear_battle_result() {
  battle_result_ = 0u;
  clear_has_battle_result();
}
inline ::google::protobuf::uint32 ClimbTowerBattleResult::battle_result() const {
  return battle_result_;
}
inline void ClimbTowerBattleResult::set_battle_result(::google::protobuf::uint32 value) {
  set_has_battle_result();
  battle_result_ = value;
}

// repeated .message.ClimbTowerBattleResult.SaveData source_data = 3;
inline int ClimbTowerBattleResult::source_data_size() const {
  return source_data_.size();
}
inline void ClimbTowerBattleResult::clear_source_data() {
  source_data_.Clear();
}
inline const ::message::ClimbTowerBattleResult_SaveData& ClimbTowerBattleResult::source_data(int index) const {
  return source_data_.Get(index);
}
inline ::message::ClimbTowerBattleResult_SaveData* ClimbTowerBattleResult::mutable_source_data(int index) {
  return source_data_.Mutable(index);
}
inline ::message::ClimbTowerBattleResult_SaveData* ClimbTowerBattleResult::add_source_data() {
  return source_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData >&
ClimbTowerBattleResult::source_data() const {
  return source_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData >*
ClimbTowerBattleResult::mutable_source_data() {
  return &source_data_;
}

// repeated .message.ClimbTowerBattleResult.SaveData target_data = 4;
inline int ClimbTowerBattleResult::target_data_size() const {
  return target_data_.size();
}
inline void ClimbTowerBattleResult::clear_target_data() {
  target_data_.Clear();
}
inline const ::message::ClimbTowerBattleResult_SaveData& ClimbTowerBattleResult::target_data(int index) const {
  return target_data_.Get(index);
}
inline ::message::ClimbTowerBattleResult_SaveData* ClimbTowerBattleResult::mutable_target_data(int index) {
  return target_data_.Mutable(index);
}
inline ::message::ClimbTowerBattleResult_SaveData* ClimbTowerBattleResult::add_target_data() {
  return target_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData >&
ClimbTowerBattleResult::target_data() const {
  return target_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::ClimbTowerBattleResult_SaveData >*
ClimbTowerBattleResult::mutable_target_data() {
  return &target_data_;
}

// -------------------------------------------------------------------

// SaveCTEnemyInfo

// optional uint32 map_id = 1;
inline bool SaveCTEnemyInfo::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveCTEnemyInfo::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveCTEnemyInfo::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveCTEnemyInfo::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 SaveCTEnemyInfo::map_id() const {
  return map_id_;
}
inline void SaveCTEnemyInfo::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 char_id = 2;
inline bool SaveCTEnemyInfo::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaveCTEnemyInfo::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaveCTEnemyInfo::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaveCTEnemyInfo::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 SaveCTEnemyInfo::char_id() const {
  return char_id_;
}
inline void SaveCTEnemyInfo::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
}

// optional uint32 server_id = 3;
inline bool SaveCTEnemyInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SaveCTEnemyInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SaveCTEnemyInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SaveCTEnemyInfo::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 SaveCTEnemyInfo::server_id() const {
  return server_id_;
}
inline void SaveCTEnemyInfo::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional bytes enemy_info = 4;
inline bool SaveCTEnemyInfo::has_enemy_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SaveCTEnemyInfo::set_has_enemy_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SaveCTEnemyInfo::clear_has_enemy_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SaveCTEnemyInfo::clear_enemy_info() {
  if (enemy_info_ != &::google::protobuf::internal::kEmptyString) {
    enemy_info_->clear();
  }
  clear_has_enemy_info();
}
inline const ::std::string& SaveCTEnemyInfo::enemy_info() const {
  return *enemy_info_;
}
inline void SaveCTEnemyInfo::set_enemy_info(const ::std::string& value) {
  set_has_enemy_info();
  if (enemy_info_ == &::google::protobuf::internal::kEmptyString) {
    enemy_info_ = new ::std::string;
  }
  enemy_info_->assign(value);
}
inline void SaveCTEnemyInfo::set_enemy_info(const char* value) {
  set_has_enemy_info();
  if (enemy_info_ == &::google::protobuf::internal::kEmptyString) {
    enemy_info_ = new ::std::string;
  }
  enemy_info_->assign(value);
}
inline void SaveCTEnemyInfo::set_enemy_info(const void* value, size_t size) {
  set_has_enemy_info();
  if (enemy_info_ == &::google::protobuf::internal::kEmptyString) {
    enemy_info_ = new ::std::string;
  }
  enemy_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveCTEnemyInfo::mutable_enemy_info() {
  set_has_enemy_info();
  if (enemy_info_ == &::google::protobuf::internal::kEmptyString) {
    enemy_info_ = new ::std::string;
  }
  return enemy_info_;
}
inline ::std::string* SaveCTEnemyInfo::release_enemy_info() {
  clear_has_enemy_info();
  if (enemy_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enemy_info_;
    enemy_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SaveCTEnemyInfo::set_allocated_enemy_info(::std::string* enemy_info) {
  if (enemy_info_ != &::google::protobuf::internal::kEmptyString) {
    delete enemy_info_;
  }
  if (enemy_info) {
    set_has_enemy_info();
    enemy_info_ = enemy_info;
  } else {
    clear_has_enemy_info();
    enemy_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SendPvpRankRiseAwards

// optional uint32 history_rank = 1;
inline bool SendPvpRankRiseAwards::has_history_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendPvpRankRiseAwards::set_has_history_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendPvpRankRiseAwards::clear_has_history_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendPvpRankRiseAwards::clear_history_rank() {
  history_rank_ = 0u;
  clear_has_history_rank();
}
inline ::google::protobuf::uint32 SendPvpRankRiseAwards::history_rank() const {
  return history_rank_;
}
inline void SendPvpRankRiseAwards::set_history_rank(::google::protobuf::uint32 value) {
  set_has_history_rank();
  history_rank_ = value;
}

// optional uint32 now_rank = 2;
inline bool SendPvpRankRiseAwards::has_now_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendPvpRankRiseAwards::set_has_now_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendPvpRankRiseAwards::clear_has_now_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendPvpRankRiseAwards::clear_now_rank() {
  now_rank_ = 0u;
  clear_has_now_rank();
}
inline ::google::protobuf::uint32 SendPvpRankRiseAwards::now_rank() const {
  return now_rank_;
}
inline void SendPvpRankRiseAwards::set_now_rank(::google::protobuf::uint32 value) {
  set_has_now_rank();
  now_rank_ = value;
}

// optional uint32 scroll_point = 3;
inline bool SendPvpRankRiseAwards::has_scroll_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendPvpRankRiseAwards::set_has_scroll_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendPvpRankRiseAwards::clear_has_scroll_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendPvpRankRiseAwards::clear_scroll_point() {
  scroll_point_ = 0u;
  clear_has_scroll_point();
}
inline ::google::protobuf::uint32 SendPvpRankRiseAwards::scroll_point() const {
  return scroll_point_;
}
inline void SendPvpRankRiseAwards::set_scroll_point(::google::protobuf::uint32 value) {
  set_has_scroll_point();
  scroll_point_ = value;
}

// optional uint32 rank_rise = 4;
inline bool SendPvpRankRiseAwards::has_rank_rise() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendPvpRankRiseAwards::set_has_rank_rise() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendPvpRankRiseAwards::clear_has_rank_rise() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendPvpRankRiseAwards::clear_rank_rise() {
  rank_rise_ = 0u;
  clear_has_rank_rise();
}
inline ::google::protobuf::uint32 SendPvpRankRiseAwards::rank_rise() const {
  return rank_rise_;
}
inline void SendPvpRankRiseAwards::set_rank_rise(::google::protobuf::uint32 value) {
  set_has_rank_rise();
  rank_rise_ = value;
}

// -------------------------------------------------------------------

// VipOperResult

// optional uint32 oper_type = 1;
inline bool VipOperResult::has_oper_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VipOperResult::set_has_oper_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VipOperResult::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VipOperResult::clear_oper_type() {
  oper_type_ = 0u;
  clear_has_oper_type();
}
inline ::google::protobuf::uint32 VipOperResult::oper_type() const {
  return oper_type_;
}
inline void VipOperResult::set_oper_type(::google::protobuf::uint32 value) {
  set_has_oper_type();
  oper_type_ = value;
}

// optional uint32 oper_result = 2;
inline bool VipOperResult::has_oper_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VipOperResult::set_has_oper_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VipOperResult::clear_has_oper_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VipOperResult::clear_oper_result() {
  oper_result_ = 0u;
  clear_has_oper_result();
}
inline ::google::protobuf::uint32 VipOperResult::oper_result() const {
  return oper_result_;
}
inline void VipOperResult::set_oper_result(::google::protobuf::uint32 value) {
  set_has_oper_result();
  oper_result_ = value;
}

// optional uint32 oper_other = 3;
inline bool VipOperResult::has_oper_other() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VipOperResult::set_has_oper_other() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VipOperResult::clear_has_oper_other() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VipOperResult::clear_oper_other() {
  oper_other_ = 0u;
  clear_has_oper_other();
}
inline ::google::protobuf::uint32 VipOperResult::oper_other() const {
  return oper_other_;
}
inline void VipOperResult::set_oper_other(::google::protobuf::uint32 value) {
  set_has_oper_other();
  oper_other_ = value;
}

// -------------------------------------------------------------------

// ItemCombineReq

// optional uint32 item_id = 1;
inline bool ItemCombineReq::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemCombineReq::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemCombineReq::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemCombineReq::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 ItemCombineReq::item_id() const {
  return item_id_;
}
inline void ItemCombineReq::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
