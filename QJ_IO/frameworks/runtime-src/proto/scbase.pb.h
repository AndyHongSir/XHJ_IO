// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scbase.proto

#ifndef PROTOBUF_scbase_2eproto__INCLUDED
#define PROTOBUF_scbase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace jynetwork {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_scbase_2eproto();
void protobuf_AssignDesc_scbase_2eproto();
void protobuf_ShutdownFile_scbase_2eproto();

class STexturePng;
class SPlistTexture;
class SPlistDB;
class sSimpleItem;
class sChaosStats;

enum eCampBelong {
  kFactionNone = 0,
  kFactionLol = 1,
  kFactionDota = 2,
  kFactionStorm = 3
};
bool eCampBelong_IsValid(int value);
const eCampBelong eCampBelong_MIN = kFactionNone;
const eCampBelong eCampBelong_MAX = kFactionStorm;
const int eCampBelong_ARRAYSIZE = eCampBelong_MAX + 1;

enum eBattleGroup {
  k_bgrp1 = 0,
  k_bgrp2 = 1,
  k_bgrp3 = 2
};
bool eBattleGroup_IsValid(int value);
const eBattleGroup eBattleGroup_MIN = k_bgrp1;
const eBattleGroup eBattleGroup_MAX = k_bgrp3;
const int eBattleGroup_ARRAYSIZE = eBattleGroup_MAX + 1;

enum eMonsterAttackMode {
  kMAMInstance = 1,
  kMAMStart = 2,
  kMAMEnd = 3,
  kMAMIdle = 4
};
bool eMonsterAttackMode_IsValid(int value);
const eMonsterAttackMode eMonsterAttackMode_MIN = kMAMInstance;
const eMonsterAttackMode eMonsterAttackMode_MAX = kMAMIdle;
const int eMonsterAttackMode_ARRAYSIZE = eMonsterAttackMode_MAX + 1;

enum ePackType {
  k_pack_resouce = 0,
  k_pack_equip = 1,
  k_pack_item = 2
};
bool ePackType_IsValid(int value);
const ePackType ePackType_MIN = k_pack_resouce;
const ePackType ePackType_MAX = k_pack_item;
const int ePackType_ARRAYSIZE = ePackType_MAX + 1;

enum eItemType {
  k_noneitem = 0,
  k_equipfrag = 1,
  k_skillfrag = 2,
  k_nofrag = 3,
  k_bufffrag = 4,
  k_cardfrag = 5,
  k_itemfrag = 6,
  k_mapfrag = 7,
  k_equip = 8,
  k_gold = 9,
  k_diamond = 10,
  k_exp = 11
};
bool eItemType_IsValid(int value);
const eItemType eItemType_MIN = k_noneitem;
const eItemType eItemType_MAX = k_exp;
const int eItemType_ARRAYSIZE = eItemType_MAX + 1;

enum eItemFuncType {
  k_none = 0,
  k_addbuff = 1,
  k_addmoney = 2,
  k_adddiamond = 3,
  k_addstamina = 4,
  k_addvip = 5,
  k_openbox = 6,
  k_inject = 7,
  k_addexp = 8,
  k_addcardexp = 9,
  k_fullcard = 10,
  k_summoncard = 11
};
bool eItemFuncType_IsValid(int value);
const eItemFuncType eItemFuncType_MIN = k_none;
const eItemFuncType eItemFuncType_MAX = k_summoncard;
const int eItemFuncType_ARRAYSIZE = eItemFuncType_MAX + 1;

enum eQuipPart {
  k_equipweapon = 1,
  k_equiphead = 2,
  k_equipbody = 3,
  k_equipoffhand = 4,
  k_equipring = 5,
  k_equipneck = 6,
  k_equipall = 7
};
bool eQuipPart_IsValid(int value);
const eQuipPart eQuipPart_MIN = k_equipweapon;
const eQuipPart eQuipPart_MAX = k_equipall;
const int eQuipPart_ARRAYSIZE = eQuipPart_MAX + 1;

enum eEffectPosType {
  k_directpos = 0,
  k_relpos = 1
};
bool eEffectPosType_IsValid(int value);
const eEffectPosType eEffectPosType_MIN = k_directpos;
const eEffectPosType eEffectPosType_MAX = k_relpos;
const int eEffectPosType_ARRAYSIZE = eEffectPosType_MAX + 1;

enum eEffectType {
  ket_bullet = 1,
  ket_assist0 = 2,
  ket_assist1 = 3,
  ket_assist2 = 4,
  ket_assist3 = 5,
  ket_drop = 6,
  ket_swing = 7,
  ket_effect = 8,
  ket_take = 9,
  ket_magic = 10
};
bool eEffectType_IsValid(int value);
const eEffectType eEffectType_MIN = ket_bullet;
const eEffectType eEffectType_MAX = ket_magic;
const int eEffectType_ARRAYSIZE = eEffectType_MAX + 1;

enum eAssitType {
  EAT_ENERGY = 0,
  EAT_GOLD = 1,
  EAT_BUFF = 2,
  EAT_TREASURE = 3
};
bool eAssitType_IsValid(int value);
const eAssitType eAssitType_MIN = EAT_ENERGY;
const eAssitType eAssitType_MAX = EAT_TREASURE;
const int eAssitType_ARRAYSIZE = eAssitType_MAX + 1;

enum ePartnerBuffType {
  EABT_RED = 1,
  EABT_BLUE = 2,
  EABT_YELLOW = 3,
  EABT_GREEN = 4
};
bool ePartnerBuffType_IsValid(int value);
const ePartnerBuffType ePartnerBuffType_MIN = EABT_RED;
const ePartnerBuffType ePartnerBuffType_MAX = EABT_GREEN;
const int ePartnerBuffType_ARRAYSIZE = ePartnerBuffType_MAX + 1;

enum eEffectScreenType {
  EST_NONE = 0,
  EST_BACKGROUNDR = 1,
  EST_FRONTR = 2,
  EST_BACKGROUNDD = 3,
  EST_FRONTD = 4,
  EST_CLOSEUP = 5,
  EST_SKILLRELEASE = 6
};
bool eEffectScreenType_IsValid(int value);
const eEffectScreenType eEffectScreenType_MIN = EST_NONE;
const eEffectScreenType eEffectScreenType_MAX = EST_SKILLRELEASE;
const int eEffectScreenType_ARRAYSIZE = eEffectScreenType_MAX + 1;

enum eTargetType {
  k_self = 1,
  k_enemy = 2,
  k_friend = 3
};
bool eTargetType_IsValid(int value);
const eTargetType eTargetType_MIN = k_self;
const eTargetType eTargetType_MAX = k_friend;
const int eTargetType_ARRAYSIZE = eTargetType_MAX + 1;

enum eMovementType {
  km_none = 0,
  km_follow_player = 1,
  km_random_mov = 2,
  km_random_stop = 3,
  km_random_movup = 4,
  km_random_stopup = 5,
  km_random_player = 6,
  km_bezier_mov1 = 7,
  km_bezier_mov2 = 8
};
bool eMovementType_IsValid(int value);
const eMovementType eMovementType_MIN = km_none;
const eMovementType eMovementType_MAX = km_bezier_mov2;
const int eMovementType_ARRAYSIZE = eMovementType_MAX + 1;

enum eAiId {
  k_easy = 1,
  k_normal = 2,
  k_hard = 3,
  k_expert = 4,
  k_hell = 5
};
bool eAiId_IsValid(int value);
const eAiId eAiId_MIN = k_easy;
const eAiId eAiId_MAX = k_hell;
const int eAiId_ARRAYSIZE = eAiId_MAX + 1;

enum eActorLvlType {
  kalt_normal = 0,
  kalt_elite = 1,
  kalt_boss = 2,
  kalt_player = 3,
  kalt_elite2 = 4,
  kalt_ppl = 5,
  kalt_gift = 6
};
bool eActorLvlType_IsValid(int value);
const eActorLvlType eActorLvlType_MIN = kalt_normal;
const eActorLvlType eActorLvlType_MAX = kalt_gift;
const int eActorLvlType_ARRAYSIZE = eActorLvlType_MAX + 1;

enum eCameraMoveType {
  CMT_NONE = 0,
  CMT_MOVE = 1,
  CMT_EASESINEOUT = 2,
  CMT_EASESINEIN = 3,
  CMT_INSTANT = 4
};
bool eCameraMoveType_IsValid(int value);
const eCameraMoveType eCameraMoveType_MIN = CMT_NONE;
const eCameraMoveType eCameraMoveType_MAX = CMT_INSTANT;
const int eCameraMoveType_ARRAYSIZE = eCameraMoveType_MAX + 1;

enum eRoleType {
  kRT_NONE = 0,
  k_warrior = 1,
  k_mage = 2,
  k_archer = 3,
  k_summoner = 4,
  k_monster = 5,
  k_boss = 6
};
bool eRoleType_IsValid(int value);
const eRoleType eRoleType_MIN = kRT_NONE;
const eRoleType eRoleType_MAX = k_boss;
const int eRoleType_ARRAYSIZE = eRoleType_MAX + 1;

enum eCardQuality {
  CARD_QATLITY0 = 0,
  CARD_QATLITY1 = 1,
  CARD_QATLITY2 = 2,
  CARD_QATLITY3 = 3,
  CARD_QATLITY4 = 4
};
bool eCardQuality_IsValid(int value);
const eCardQuality eCardQuality_MIN = CARD_QATLITY0;
const eCardQuality eCardQuality_MAX = CARD_QATLITY4;
const int eCardQuality_ARRAYSIZE = eCardQuality_MAX + 1;

enum eWeekdayLimit {
  k_all = 1,
  k_weekend = 2,
  k_monday = 3,
  k_tuesday = 4,
  k_wednesday = 5,
  k_thursday = 6,
  k_friday = 7,
  k_saturday = 8,
  k_sunday = 9
};
bool eWeekdayLimit_IsValid(int value);
const eWeekdayLimit eWeekdayLimit_MIN = k_all;
const eWeekdayLimit eWeekdayLimit_MAX = k_sunday;
const int eWeekdayLimit_ARRAYSIZE = eWeekdayLimit_MAX + 1;

enum eGroupShape {
  k_hengxian = 1,
  k_shuxian = 2,
  k_zuoxiexian = 3,
  k_youxiexian = 4,
  k_tuquxiao = 5,
  k_aoquxian = 6
};
bool eGroupShape_IsValid(int value);
const eGroupShape eGroupShape_MIN = k_hengxian;
const eGroupShape eGroupShape_MAX = k_aoquxian;
const int eGroupShape_ARRAYSIZE = eGroupShape_MAX + 1;

enum ePersonalOpertionType {
  eOper_personal_add = 1,
  eOper_personal_update = 2,
  eOper_personal_delete = 3
};
bool ePersonalOpertionType_IsValid(int value);
const ePersonalOpertionType ePersonalOpertionType_MIN = eOper_personal_add;
const ePersonalOpertionType ePersonalOpertionType_MAX = eOper_personal_delete;
const int ePersonalOpertionType_ARRAYSIZE = ePersonalOpertionType_MAX + 1;

enum eTaskType {
  etask_nomal = 1,
  etask_daily = 2,
  etask_achieve = 3,
  etask_legend = 4,
  etask_activity = 5,
  etask_challenge = 6,
  etask_share = 7
};
bool eTaskType_IsValid(int value);
const eTaskType eTaskType_MIN = etask_nomal;
const eTaskType eTaskType_MAX = etask_share;
const int eTaskType_ARRAYSIZE = eTaskType_MAX + 1;

enum eTaskFinishType {
  etask_none = 0,
  etask_stage_finish = 1,
  etask_repeate_stage = 2,
  etask_equip_intensify = 3,
  etask_equip_level_up = 4,
  etask_equip_star = 5,
  etask_char_lv = 6,
  etask_change_job = 7,
  etask_card_intensify = 8,
  etask_card_star = 9,
  etask_card_lv = 10,
  etask_endless_times = 11,
  etask_endless_score = 12,
  etask_areana = 13,
  etask_guild_join = 14,
  etask_buy_gold = 15,
  etask_buy_stamina = 16,
  etask_skill_lv_up = 17,
  etask_repeate_hard_stage = 18,
  etask_inject_max = 19,
  etask_intensify_max = 20,
  etask_boss_stage = 21,
  etask_buy_normal_shop_item = 22,
  etask_buy_random_shop_item = 23,
  etask_buy_black_shop_item = 24,
  etask_glod_box = 25,
  etask_dimond_box = 26,
  etask_advance_box = 27,
  etask_add_stamima = 28,
  etask_cost_stamima = 29,
  etask_add_gold = 30,
  etask_cost_gold = 31,
  etask_add_dimond = 32,
  etask_cost_dimond = 33,
  etask_set_star = 34,
  etask_normal_stage_star = 35,
  etask_hard_stage_star = 36,
  etask_normal_stage_hp = 37,
  etask_hard_stage_hp = 38,
  etask_fight_score = 39,
  etask_card_five_star = 40,
  etask_card_get = 41,
  etask_card_star_up = 42,
  etask_card_lv_up = 43,
  etask_day_task = 44,
  etask_day_charge = 45,
  etask_total_charge = 46,
  etask_stage_scroe = 47,
  etask_repeat_login = 48,
  etask_challenge_1 = 49,
  etask_challenge_2 = 50,
  etask_challenge_3 = 51,
  etask_challenge_4 = 52,
  etask_challenge_5 = 53,
  etask_challenge_6 = 54,
  etask_challenge_7 = 55,
  etask_challenge_8 = 56,
  etask_challenge_9 = 57,
  etask_challenge_10 = 58,
  etask_down_load = 59,
  etask_fighter_lv = 60,
  etask_magic_lv = 61,
  etask_arch_lv = 62,
  etask_fighter_job = 63,
  etask_magic_job = 64,
  etask_arch_job = 65,
  etask_endless = 66,
  etask_vip = 67,
  etask_facebook_1 = 69,
  etask_facebook_2 = 70,
  etask_share_1 = 71,
  etask_share_2 = 72,
  etask_fighter_job_1 = 73,
  etask_fighter_job_2 = 74,
  etask_fighter_job_3 = 75,
  etask_fighter_job_4 = 76,
  etask_fighter_job_5 = 77,
  etask_magic_job_1 = 78,
  etask_magic_job_2 = 79,
  etask_magic_job_3 = 80,
  etask_magic_job_4 = 81,
  etask_magic_job_5 = 82,
  etask_arch_job_1 = 83,
  etask_arch_job_2 = 84,
  etask_arch_job_3 = 85,
  etask_arch_job_4 = 86,
  etask_arch_job_5 = 87,
  etask_arena_battle = 88
};
bool eTaskFinishType_IsValid(int value);
const eTaskFinishType eTaskFinishType_MIN = etask_none;
const eTaskFinishType eTaskFinishType_MAX = etask_arena_battle;
const int eTaskFinishType_ARRAYSIZE = eTaskFinishType_MAX + 1;

enum emExtAttrType {
  emHP = 0,
  emPDamage = 1,
  emDesPDamage = 2,
  emMDamage = 3,
  emDesMDamage = 4,
  emStr = 5,
  emAgi = 6,
  emInt = 7,
  emVit = 8,
  emMortal = 9,
  emToughness = 10,
  emSpeed = 11,
  emAtkSpeed = 12,
  emCrit = 13,
  emPerfect = 14,
  emeExcellent = 15,
  emFire = 16,
  emResFire = 17,
  emWater = 18,
  emResWater = 19,
  emWind = 20,
  emResWind = 21,
  emThunder = 22,
  emResThunder = 23,
  emBolt = 24,
  emResBolt = 25,
  emDark = 26,
  emResDark = 27,
  emPoison = 28,
  emResPoison = 29,
  emPickRange = 30,
  emHPRecover = 31,
  emMPrecover = 32,
  emChaosRate = 33,
  emResChaosRate = 34,
  emSealRate = 35,
  emRescsealRate = 36,
  emFreezerate = 37,
  emResFreezerate = 38,
  emHPPercent = 39,
  emPDamagePercent = 40,
  emDesPDamagePercent = 41,
  emMDamagePercent = 42,
  emDesMDamagePercent = 43,
  emMortalPercent = 44,
  emToughnessPercent = 45,
  emFirePercent = 46,
  emWaterPercent = 47,
  emWindPercent = 48,
  emThunderPercent = 49,
  emBoltPercent = 50,
  emDarkPercent = 51
};
bool emExtAttrType_IsValid(int value);
const emExtAttrType emExtAttrType_MIN = emHP;
const emExtAttrType emExtAttrType_MAX = emDarkPercent;
const int emExtAttrType_ARRAYSIZE = emExtAttrType_MAX + 1;

// ===================================================================

class STexturePng : public ::google::protobuf::MessageLite {
 public:
  STexturePng();
  virtual ~STexturePng();

  STexturePng(const STexturePng& from);

  inline STexturePng& operator=(const STexturePng& from) {
    CopyFrom(from);
    return *this;
  }

  static const STexturePng& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const STexturePng* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(STexturePng* other);

  // implements Message ----------------------------------------------

  STexturePng* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const STexturePng& from);
  void MergeFrom(const STexturePng& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pngname = 1;
  inline bool has_pngname() const;
  inline void clear_pngname();
  static const int kPngnameFieldNumber = 1;
  inline const ::std::string& pngname() const;
  inline void set_pngname(const ::std::string& value);
  inline void set_pngname(const char* value);
  inline void set_pngname(const char* value, size_t size);
  inline ::std::string* mutable_pngname();
  inline ::std::string* release_pngname();
  inline void set_allocated_pngname(::std::string* pngname);

  // optional string plistname = 2;
  inline bool has_plistname() const;
  inline void clear_plistname();
  static const int kPlistnameFieldNumber = 2;
  inline const ::std::string& plistname() const;
  inline void set_plistname(const ::std::string& value);
  inline void set_plistname(const char* value);
  inline void set_plistname(const char* value, size_t size);
  inline ::std::string* mutable_plistname();
  inline ::std::string* release_plistname();
  inline void set_allocated_plistname(::std::string* plistname);

  // optional uint32 nwidth = 3;
  inline bool has_nwidth() const;
  inline void clear_nwidth();
  static const int kNwidthFieldNumber = 3;
  inline ::google::protobuf::uint32 nwidth() const;
  inline void set_nwidth(::google::protobuf::uint32 value);

  // optional uint32 nheight = 4;
  inline bool has_nheight() const;
  inline void clear_nheight();
  static const int kNheightFieldNumber = 4;
  inline ::google::protobuf::uint32 nheight() const;
  inline void set_nheight(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.STexturePng)
 private:
  inline void set_has_pngname();
  inline void clear_has_pngname();
  inline void set_has_plistname();
  inline void clear_has_plistname();
  inline void set_has_nwidth();
  inline void clear_has_nwidth();
  inline void set_has_nheight();
  inline void clear_has_nheight();

  ::std::string* pngname_;
  ::std::string* plistname_;
  ::google::protobuf::uint32 nwidth_;
  ::google::protobuf::uint32 nheight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_scbase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_scbase_2eproto();
  #endif
  friend void protobuf_AssignDesc_scbase_2eproto();
  friend void protobuf_ShutdownFile_scbase_2eproto();

  void InitAsDefaultInstance();
  static STexturePng* default_instance_;
};
// -------------------------------------------------------------------

class SPlistTexture : public ::google::protobuf::MessageLite {
 public:
  SPlistTexture();
  virtual ~SPlistTexture();

  SPlistTexture(const SPlistTexture& from);

  inline SPlistTexture& operator=(const SPlistTexture& from) {
    CopyFrom(from);
    return *this;
  }

  static const SPlistTexture& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SPlistTexture* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SPlistTexture* other);

  // implements Message ----------------------------------------------

  SPlistTexture* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SPlistTexture& from);
  void MergeFrom(const SPlistTexture& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string plist = 1;
  inline bool has_plist() const;
  inline void clear_plist();
  static const int kPlistFieldNumber = 1;
  inline const ::std::string& plist() const;
  inline void set_plist(const ::std::string& value);
  inline void set_plist(const char* value);
  inline void set_plist(const char* value, size_t size);
  inline ::std::string* mutable_plist();
  inline ::std::string* release_plist();
  inline void set_allocated_plist(::std::string* plist);

  // optional string texture = 2;
  inline bool has_texture() const;
  inline void clear_texture();
  static const int kTextureFieldNumber = 2;
  inline const ::std::string& texture() const;
  inline void set_texture(const ::std::string& value);
  inline void set_texture(const char* value);
  inline void set_texture(const char* value, size_t size);
  inline ::std::string* mutable_texture();
  inline ::std::string* release_texture();
  inline void set_allocated_texture(::std::string* texture);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.SPlistTexture)
 private:
  inline void set_has_plist();
  inline void clear_has_plist();
  inline void set_has_texture();
  inline void clear_has_texture();

  ::std::string* plist_;
  ::std::string* texture_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_scbase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_scbase_2eproto();
  #endif
  friend void protobuf_AssignDesc_scbase_2eproto();
  friend void protobuf_ShutdownFile_scbase_2eproto();

  void InitAsDefaultInstance();
  static SPlistTexture* default_instance_;
};
// -------------------------------------------------------------------

class SPlistDB : public ::google::protobuf::MessageLite {
 public:
  SPlistDB();
  virtual ~SPlistDB();

  SPlistDB(const SPlistDB& from);

  inline SPlistDB& operator=(const SPlistDB& from) {
    CopyFrom(from);
    return *this;
  }

  static const SPlistDB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SPlistDB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SPlistDB* other);

  // implements Message ----------------------------------------------

  SPlistDB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SPlistDB& from);
  void MergeFrom(const SPlistDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jynetwork.proto.STexturePng plistdb = 1;
  inline int plistdb_size() const;
  inline void clear_plistdb();
  static const int kPlistdbFieldNumber = 1;
  inline const ::jynetwork::proto::STexturePng& plistdb(int index) const;
  inline ::jynetwork::proto::STexturePng* mutable_plistdb(int index);
  inline ::jynetwork::proto::STexturePng* add_plistdb();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::STexturePng >&
      plistdb() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::STexturePng >*
      mutable_plistdb();

  // repeated .jynetwork.proto.SPlistTexture plist_texture = 2;
  inline int plist_texture_size() const;
  inline void clear_plist_texture();
  static const int kPlistTextureFieldNumber = 2;
  inline const ::jynetwork::proto::SPlistTexture& plist_texture(int index) const;
  inline ::jynetwork::proto::SPlistTexture* mutable_plist_texture(int index);
  inline ::jynetwork::proto::SPlistTexture* add_plist_texture();
  inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::SPlistTexture >&
      plist_texture() const;
  inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::SPlistTexture >*
      mutable_plist_texture();

  // @@protoc_insertion_point(class_scope:jynetwork.proto.SPlistDB)
 private:

  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::STexturePng > plistdb_;
  ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::SPlistTexture > plist_texture_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_scbase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_scbase_2eproto();
  #endif
  friend void protobuf_AssignDesc_scbase_2eproto();
  friend void protobuf_ShutdownFile_scbase_2eproto();

  void InitAsDefaultInstance();
  static SPlistDB* default_instance_;
};
// -------------------------------------------------------------------

class sSimpleItem : public ::google::protobuf::MessageLite {
 public:
  sSimpleItem();
  virtual ~sSimpleItem();

  sSimpleItem(const sSimpleItem& from);

  inline sSimpleItem& operator=(const sSimpleItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const sSimpleItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const sSimpleItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(sSimpleItem* other);

  // implements Message ----------------------------------------------

  sSimpleItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const sSimpleItem& from);
  void MergeFrom(const sSimpleItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // optional uint32 itemnum = 2;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemnumFieldNumber = 2;
  inline ::google::protobuf::uint32 itemnum() const;
  inline void set_itemnum(::google::protobuf::uint32 value);

  // optional uint32 itempricetype = 3;
  inline bool has_itempricetype() const;
  inline void clear_itempricetype();
  static const int kItempricetypeFieldNumber = 3;
  inline ::google::protobuf::uint32 itempricetype() const;
  inline void set_itempricetype(::google::protobuf::uint32 value);

  // optional uint32 itemprice = 4;
  inline bool has_itemprice() const;
  inline void clear_itemprice();
  static const int kItempriceFieldNumber = 4;
  inline ::google::protobuf::uint32 itemprice() const;
  inline void set_itemprice(::google::protobuf::uint32 value);

  // optional uint32 issold = 5;
  inline bool has_issold() const;
  inline void clear_issold();
  static const int kIssoldFieldNumber = 5;
  inline ::google::protobuf::uint32 issold() const;
  inline void set_issold(::google::protobuf::uint32 value);

  // optional uint32 itemuid = 6;
  inline bool has_itemuid() const;
  inline void clear_itemuid();
  static const int kItemuidFieldNumber = 6;
  inline ::google::protobuf::uint32 itemuid() const;
  inline void set_itemuid(::google::protobuf::uint32 value);

  // optional uint32 shoporder = 7;
  inline bool has_shoporder() const;
  inline void clear_shoporder();
  static const int kShoporderFieldNumber = 7;
  inline ::google::protobuf::uint32 shoporder() const;
  inline void set_shoporder(::google::protobuf::uint32 value);

  // optional uint32 decom_card = 8;
  inline bool has_decom_card() const;
  inline void clear_decom_card();
  static const int kDecomCardFieldNumber = 8;
  inline ::google::protobuf::uint32 decom_card() const;
  inline void set_decom_card(::google::protobuf::uint32 value);

  // optional uint32 shop_id = 9;
  inline bool has_shop_id() const;
  inline void clear_shop_id();
  static const int kShopIdFieldNumber = 9;
  inline ::google::protobuf::uint32 shop_id() const;
  inline void set_shop_id(::google::protobuf::uint32 value);

  // optional uint32 buy_times = 10;
  inline bool has_buy_times() const;
  inline void clear_buy_times();
  static const int kBuyTimesFieldNumber = 10;
  inline ::google::protobuf::uint32 buy_times() const;
  inline void set_buy_times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.sSimpleItem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();
  inline void set_has_itempricetype();
  inline void clear_has_itempricetype();
  inline void set_has_itemprice();
  inline void clear_has_itemprice();
  inline void set_has_issold();
  inline void clear_has_issold();
  inline void set_has_itemuid();
  inline void clear_has_itemuid();
  inline void set_has_shoporder();
  inline void clear_has_shoporder();
  inline void set_has_decom_card();
  inline void clear_has_decom_card();
  inline void set_has_shop_id();
  inline void clear_has_shop_id();
  inline void set_has_buy_times();
  inline void clear_has_buy_times();

  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 itemnum_;
  ::google::protobuf::uint32 itempricetype_;
  ::google::protobuf::uint32 itemprice_;
  ::google::protobuf::uint32 issold_;
  ::google::protobuf::uint32 itemuid_;
  ::google::protobuf::uint32 shoporder_;
  ::google::protobuf::uint32 decom_card_;
  ::google::protobuf::uint32 shop_id_;
  ::google::protobuf::uint32 buy_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_scbase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_scbase_2eproto();
  #endif
  friend void protobuf_AssignDesc_scbase_2eproto();
  friend void protobuf_ShutdownFile_scbase_2eproto();

  void InitAsDefaultInstance();
  static sSimpleItem* default_instance_;
};
// -------------------------------------------------------------------

class sChaosStats : public ::google::protobuf::MessageLite {
 public:
  sChaosStats();
  virtual ~sChaosStats();

  sChaosStats(const sChaosStats& from);

  inline sChaosStats& operator=(const sChaosStats& from) {
    CopyFrom(from);
    return *this;
  }

  static const sChaosStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const sChaosStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(sChaosStats* other);

  // implements Message ----------------------------------------------

  sChaosStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const sChaosStats& from);
  void MergeFrom(const sChaosStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 percent = 1;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 1;
  inline ::google::protobuf::uint32 percent() const;
  inline void set_percent(::google::protobuf::uint32 value);

  // optional uint32 map_uid = 2;
  inline bool has_map_uid() const;
  inline void clear_map_uid();
  static const int kMapUidFieldNumber = 2;
  inline ::google::protobuf::uint32 map_uid() const;
  inline void set_map_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jynetwork.proto.sChaosStats)
 private:
  inline void set_has_percent();
  inline void clear_has_percent();
  inline void set_has_map_uid();
  inline void clear_has_map_uid();

  ::google::protobuf::uint32 percent_;
  ::google::protobuf::uint32 map_uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_scbase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_scbase_2eproto();
  #endif
  friend void protobuf_AssignDesc_scbase_2eproto();
  friend void protobuf_ShutdownFile_scbase_2eproto();

  void InitAsDefaultInstance();
  static sChaosStats* default_instance_;
};
// ===================================================================


// ===================================================================

// STexturePng

// optional string pngname = 1;
inline bool STexturePng::has_pngname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void STexturePng::set_has_pngname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void STexturePng::clear_has_pngname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void STexturePng::clear_pngname() {
  if (pngname_ != &::google::protobuf::internal::kEmptyString) {
    pngname_->clear();
  }
  clear_has_pngname();
}
inline const ::std::string& STexturePng::pngname() const {
  return *pngname_;
}
inline void STexturePng::set_pngname(const ::std::string& value) {
  set_has_pngname();
  if (pngname_ == &::google::protobuf::internal::kEmptyString) {
    pngname_ = new ::std::string;
  }
  pngname_->assign(value);
}
inline void STexturePng::set_pngname(const char* value) {
  set_has_pngname();
  if (pngname_ == &::google::protobuf::internal::kEmptyString) {
    pngname_ = new ::std::string;
  }
  pngname_->assign(value);
}
inline void STexturePng::set_pngname(const char* value, size_t size) {
  set_has_pngname();
  if (pngname_ == &::google::protobuf::internal::kEmptyString) {
    pngname_ = new ::std::string;
  }
  pngname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* STexturePng::mutable_pngname() {
  set_has_pngname();
  if (pngname_ == &::google::protobuf::internal::kEmptyString) {
    pngname_ = new ::std::string;
  }
  return pngname_;
}
inline ::std::string* STexturePng::release_pngname() {
  clear_has_pngname();
  if (pngname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pngname_;
    pngname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void STexturePng::set_allocated_pngname(::std::string* pngname) {
  if (pngname_ != &::google::protobuf::internal::kEmptyString) {
    delete pngname_;
  }
  if (pngname) {
    set_has_pngname();
    pngname_ = pngname;
  } else {
    clear_has_pngname();
    pngname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string plistname = 2;
inline bool STexturePng::has_plistname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void STexturePng::set_has_plistname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void STexturePng::clear_has_plistname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void STexturePng::clear_plistname() {
  if (plistname_ != &::google::protobuf::internal::kEmptyString) {
    plistname_->clear();
  }
  clear_has_plistname();
}
inline const ::std::string& STexturePng::plistname() const {
  return *plistname_;
}
inline void STexturePng::set_plistname(const ::std::string& value) {
  set_has_plistname();
  if (plistname_ == &::google::protobuf::internal::kEmptyString) {
    plistname_ = new ::std::string;
  }
  plistname_->assign(value);
}
inline void STexturePng::set_plistname(const char* value) {
  set_has_plistname();
  if (plistname_ == &::google::protobuf::internal::kEmptyString) {
    plistname_ = new ::std::string;
  }
  plistname_->assign(value);
}
inline void STexturePng::set_plistname(const char* value, size_t size) {
  set_has_plistname();
  if (plistname_ == &::google::protobuf::internal::kEmptyString) {
    plistname_ = new ::std::string;
  }
  plistname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* STexturePng::mutable_plistname() {
  set_has_plistname();
  if (plistname_ == &::google::protobuf::internal::kEmptyString) {
    plistname_ = new ::std::string;
  }
  return plistname_;
}
inline ::std::string* STexturePng::release_plistname() {
  clear_has_plistname();
  if (plistname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plistname_;
    plistname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void STexturePng::set_allocated_plistname(::std::string* plistname) {
  if (plistname_ != &::google::protobuf::internal::kEmptyString) {
    delete plistname_;
  }
  if (plistname) {
    set_has_plistname();
    plistname_ = plistname;
  } else {
    clear_has_plistname();
    plistname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nwidth = 3;
inline bool STexturePng::has_nwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void STexturePng::set_has_nwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void STexturePng::clear_has_nwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void STexturePng::clear_nwidth() {
  nwidth_ = 0u;
  clear_has_nwidth();
}
inline ::google::protobuf::uint32 STexturePng::nwidth() const {
  return nwidth_;
}
inline void STexturePng::set_nwidth(::google::protobuf::uint32 value) {
  set_has_nwidth();
  nwidth_ = value;
}

// optional uint32 nheight = 4;
inline bool STexturePng::has_nheight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void STexturePng::set_has_nheight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void STexturePng::clear_has_nheight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void STexturePng::clear_nheight() {
  nheight_ = 0u;
  clear_has_nheight();
}
inline ::google::protobuf::uint32 STexturePng::nheight() const {
  return nheight_;
}
inline void STexturePng::set_nheight(::google::protobuf::uint32 value) {
  set_has_nheight();
  nheight_ = value;
}

// -------------------------------------------------------------------

// SPlistTexture

// optional string plist = 1;
inline bool SPlistTexture::has_plist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SPlistTexture::set_has_plist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SPlistTexture::clear_has_plist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SPlistTexture::clear_plist() {
  if (plist_ != &::google::protobuf::internal::kEmptyString) {
    plist_->clear();
  }
  clear_has_plist();
}
inline const ::std::string& SPlistTexture::plist() const {
  return *plist_;
}
inline void SPlistTexture::set_plist(const ::std::string& value) {
  set_has_plist();
  if (plist_ == &::google::protobuf::internal::kEmptyString) {
    plist_ = new ::std::string;
  }
  plist_->assign(value);
}
inline void SPlistTexture::set_plist(const char* value) {
  set_has_plist();
  if (plist_ == &::google::protobuf::internal::kEmptyString) {
    plist_ = new ::std::string;
  }
  plist_->assign(value);
}
inline void SPlistTexture::set_plist(const char* value, size_t size) {
  set_has_plist();
  if (plist_ == &::google::protobuf::internal::kEmptyString) {
    plist_ = new ::std::string;
  }
  plist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SPlistTexture::mutable_plist() {
  set_has_plist();
  if (plist_ == &::google::protobuf::internal::kEmptyString) {
    plist_ = new ::std::string;
  }
  return plist_;
}
inline ::std::string* SPlistTexture::release_plist() {
  clear_has_plist();
  if (plist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plist_;
    plist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SPlistTexture::set_allocated_plist(::std::string* plist) {
  if (plist_ != &::google::protobuf::internal::kEmptyString) {
    delete plist_;
  }
  if (plist) {
    set_has_plist();
    plist_ = plist;
  } else {
    clear_has_plist();
    plist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string texture = 2;
inline bool SPlistTexture::has_texture() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SPlistTexture::set_has_texture() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SPlistTexture::clear_has_texture() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SPlistTexture::clear_texture() {
  if (texture_ != &::google::protobuf::internal::kEmptyString) {
    texture_->clear();
  }
  clear_has_texture();
}
inline const ::std::string& SPlistTexture::texture() const {
  return *texture_;
}
inline void SPlistTexture::set_texture(const ::std::string& value) {
  set_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    texture_ = new ::std::string;
  }
  texture_->assign(value);
}
inline void SPlistTexture::set_texture(const char* value) {
  set_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    texture_ = new ::std::string;
  }
  texture_->assign(value);
}
inline void SPlistTexture::set_texture(const char* value, size_t size) {
  set_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    texture_ = new ::std::string;
  }
  texture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SPlistTexture::mutable_texture() {
  set_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    texture_ = new ::std::string;
  }
  return texture_;
}
inline ::std::string* SPlistTexture::release_texture() {
  clear_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = texture_;
    texture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SPlistTexture::set_allocated_texture(::std::string* texture) {
  if (texture_ != &::google::protobuf::internal::kEmptyString) {
    delete texture_;
  }
  if (texture) {
    set_has_texture();
    texture_ = texture;
  } else {
    clear_has_texture();
    texture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SPlistDB

// repeated .jynetwork.proto.STexturePng plistdb = 1;
inline int SPlistDB::plistdb_size() const {
  return plistdb_.size();
}
inline void SPlistDB::clear_plistdb() {
  plistdb_.Clear();
}
inline const ::jynetwork::proto::STexturePng& SPlistDB::plistdb(int index) const {
  return plistdb_.Get(index);
}
inline ::jynetwork::proto::STexturePng* SPlistDB::mutable_plistdb(int index) {
  return plistdb_.Mutable(index);
}
inline ::jynetwork::proto::STexturePng* SPlistDB::add_plistdb() {
  return plistdb_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::STexturePng >&
SPlistDB::plistdb() const {
  return plistdb_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::STexturePng >*
SPlistDB::mutable_plistdb() {
  return &plistdb_;
}

// repeated .jynetwork.proto.SPlistTexture plist_texture = 2;
inline int SPlistDB::plist_texture_size() const {
  return plist_texture_.size();
}
inline void SPlistDB::clear_plist_texture() {
  plist_texture_.Clear();
}
inline const ::jynetwork::proto::SPlistTexture& SPlistDB::plist_texture(int index) const {
  return plist_texture_.Get(index);
}
inline ::jynetwork::proto::SPlistTexture* SPlistDB::mutable_plist_texture(int index) {
  return plist_texture_.Mutable(index);
}
inline ::jynetwork::proto::SPlistTexture* SPlistDB::add_plist_texture() {
  return plist_texture_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::SPlistTexture >&
SPlistDB::plist_texture() const {
  return plist_texture_;
}
inline ::google::protobuf::RepeatedPtrField< ::jynetwork::proto::SPlistTexture >*
SPlistDB::mutable_plist_texture() {
  return &plist_texture_;
}

// -------------------------------------------------------------------

// sSimpleItem

// optional uint32 itemid = 1;
inline bool sSimpleItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sSimpleItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sSimpleItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sSimpleItem::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 sSimpleItem::itemid() const {
  return itemid_;
}
inline void sSimpleItem::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional uint32 itemnum = 2;
inline bool sSimpleItem::has_itemnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sSimpleItem::set_has_itemnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sSimpleItem::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sSimpleItem::clear_itemnum() {
  itemnum_ = 0u;
  clear_has_itemnum();
}
inline ::google::protobuf::uint32 sSimpleItem::itemnum() const {
  return itemnum_;
}
inline void sSimpleItem::set_itemnum(::google::protobuf::uint32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// optional uint32 itempricetype = 3;
inline bool sSimpleItem::has_itempricetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sSimpleItem::set_has_itempricetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sSimpleItem::clear_has_itempricetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sSimpleItem::clear_itempricetype() {
  itempricetype_ = 0u;
  clear_has_itempricetype();
}
inline ::google::protobuf::uint32 sSimpleItem::itempricetype() const {
  return itempricetype_;
}
inline void sSimpleItem::set_itempricetype(::google::protobuf::uint32 value) {
  set_has_itempricetype();
  itempricetype_ = value;
}

// optional uint32 itemprice = 4;
inline bool sSimpleItem::has_itemprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sSimpleItem::set_has_itemprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sSimpleItem::clear_has_itemprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sSimpleItem::clear_itemprice() {
  itemprice_ = 0u;
  clear_has_itemprice();
}
inline ::google::protobuf::uint32 sSimpleItem::itemprice() const {
  return itemprice_;
}
inline void sSimpleItem::set_itemprice(::google::protobuf::uint32 value) {
  set_has_itemprice();
  itemprice_ = value;
}

// optional uint32 issold = 5;
inline bool sSimpleItem::has_issold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void sSimpleItem::set_has_issold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void sSimpleItem::clear_has_issold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void sSimpleItem::clear_issold() {
  issold_ = 0u;
  clear_has_issold();
}
inline ::google::protobuf::uint32 sSimpleItem::issold() const {
  return issold_;
}
inline void sSimpleItem::set_issold(::google::protobuf::uint32 value) {
  set_has_issold();
  issold_ = value;
}

// optional uint32 itemuid = 6;
inline bool sSimpleItem::has_itemuid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void sSimpleItem::set_has_itemuid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void sSimpleItem::clear_has_itemuid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void sSimpleItem::clear_itemuid() {
  itemuid_ = 0u;
  clear_has_itemuid();
}
inline ::google::protobuf::uint32 sSimpleItem::itemuid() const {
  return itemuid_;
}
inline void sSimpleItem::set_itemuid(::google::protobuf::uint32 value) {
  set_has_itemuid();
  itemuid_ = value;
}

// optional uint32 shoporder = 7;
inline bool sSimpleItem::has_shoporder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void sSimpleItem::set_has_shoporder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void sSimpleItem::clear_has_shoporder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void sSimpleItem::clear_shoporder() {
  shoporder_ = 0u;
  clear_has_shoporder();
}
inline ::google::protobuf::uint32 sSimpleItem::shoporder() const {
  return shoporder_;
}
inline void sSimpleItem::set_shoporder(::google::protobuf::uint32 value) {
  set_has_shoporder();
  shoporder_ = value;
}

// optional uint32 decom_card = 8;
inline bool sSimpleItem::has_decom_card() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void sSimpleItem::set_has_decom_card() {
  _has_bits_[0] |= 0x00000080u;
}
inline void sSimpleItem::clear_has_decom_card() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void sSimpleItem::clear_decom_card() {
  decom_card_ = 0u;
  clear_has_decom_card();
}
inline ::google::protobuf::uint32 sSimpleItem::decom_card() const {
  return decom_card_;
}
inline void sSimpleItem::set_decom_card(::google::protobuf::uint32 value) {
  set_has_decom_card();
  decom_card_ = value;
}

// optional uint32 shop_id = 9;
inline bool sSimpleItem::has_shop_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void sSimpleItem::set_has_shop_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void sSimpleItem::clear_has_shop_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void sSimpleItem::clear_shop_id() {
  shop_id_ = 0u;
  clear_has_shop_id();
}
inline ::google::protobuf::uint32 sSimpleItem::shop_id() const {
  return shop_id_;
}
inline void sSimpleItem::set_shop_id(::google::protobuf::uint32 value) {
  set_has_shop_id();
  shop_id_ = value;
}

// optional uint32 buy_times = 10;
inline bool sSimpleItem::has_buy_times() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void sSimpleItem::set_has_buy_times() {
  _has_bits_[0] |= 0x00000200u;
}
inline void sSimpleItem::clear_has_buy_times() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void sSimpleItem::clear_buy_times() {
  buy_times_ = 0u;
  clear_has_buy_times();
}
inline ::google::protobuf::uint32 sSimpleItem::buy_times() const {
  return buy_times_;
}
inline void sSimpleItem::set_buy_times(::google::protobuf::uint32 value) {
  set_has_buy_times();
  buy_times_ = value;
}

// -------------------------------------------------------------------

// sChaosStats

// optional uint32 percent = 1;
inline bool sChaosStats::has_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sChaosStats::set_has_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sChaosStats::clear_has_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sChaosStats::clear_percent() {
  percent_ = 0u;
  clear_has_percent();
}
inline ::google::protobuf::uint32 sChaosStats::percent() const {
  return percent_;
}
inline void sChaosStats::set_percent(::google::protobuf::uint32 value) {
  set_has_percent();
  percent_ = value;
}

// optional uint32 map_uid = 2;
inline bool sChaosStats::has_map_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sChaosStats::set_has_map_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sChaosStats::clear_has_map_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sChaosStats::clear_map_uid() {
  map_uid_ = 0u;
  clear_has_map_uid();
}
inline ::google::protobuf::uint32 sChaosStats::map_uid() const {
  return map_uid_;
}
inline void sChaosStats::set_map_uid(::google::protobuf::uint32 value) {
  set_has_map_uid();
  map_uid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace jynetwork

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_scbase_2eproto__INCLUDED
