// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace message {

void protobuf_ShutdownFile_Message_2eproto() {
  delete GateIpPortInfo::default_instance_;
  delete VersionInfoRequest::default_instance_;
  delete VersionInfoResponse::default_instance_;
  delete LoginAuthSys::default_instance_;
  delete LoginCenterAuthReq::default_instance_;
  delete CenterGateState::default_instance_;
  delete CenterGateState_CenterGateStateInfo::default_instance_;
  delete LoginCenterAuthAck::default_instance_;
  delete LoginCenterCharInfo::default_instance_;
  delete LoginCenterCharInfo_LoginServerCharInfo::default_instance_;
  delete LoginAuthAck::default_instance_;
  delete LoginAuthNack::default_instance_;
  delete LoginServerList::default_instance_;
  delete LoginServerList_LoginServerInfo::default_instance_;
  delete LoginServerChoose::default_instance_;
  delete CenterServerChoose::default_instance_;
  delete GateInfoSys::default_instance_;
  delete GateInfoNack::default_instance_;
  delete GateInfoAck::default_instance_;
  delete UserDisconnect::default_instance_;
  delete GateGetNonceSys::default_instance_;
  delete GateAuchNonce::default_instance_;
  delete GateAuthSys::default_instance_;
  delete CenterAuthSys::default_instance_;
  delete CenterAuthAck::default_instance_;
  delete CenterAuthNack::default_instance_;
  delete CenterAuthLogout::default_instance_;
  delete GetPlayerRoleList::default_instance_;
  delete PlayerRoleListData::default_instance_;
  delete EnterSceneSys::default_instance_;
  delete EnterSceneNack::default_instance_;
  delete ChooseSceneCmd::default_instance_;
  delete ServerInfoConnected::default_instance_;
  delete MapServerInfo::default_instance_;
  delete CreateUserInfo::default_instance_;
  delete CreateUserResult::default_instance_;
  delete SaveUserInfo::default_instance_;
  delete GetUserDetailInfo::default_instance_;
  delete UserDetailInfo::default_instance_;
  delete EnterSceneMapSys::default_instance_;
  delete EnterSceneMapNack::default_instance_;
  delete EnterSceneMapAck::default_instance_;
  delete ClientCreateSenceCmd::default_instance_;
  delete ClientEnterSenceSys::default_instance_;
  delete AddPlayerSys::default_instance_;
  delete AddNpcSys::default_instance_;
  delete DelPlayerSys::default_instance_;
  delete DelNpcSys::default_instance_;
  delete GateInfoID::default_instance_;
  delete GateLogoutCmd::default_instance_;
  delete Move::default_instance_;
  delete PlayerJumpMap::default_instance_;
  delete NPCTeleport::default_instance_;
  delete PlayerAttack::default_instance_;
  delete QTEResult::default_instance_;
  delete ClearSkill::default_instance_;
  delete AddSkill::default_instance_;
  delete SkillSequence::default_instance_;
  delete BattleCharInfo::default_instance_;
  delete BattleCharInfo_CharInfo::default_instance_;
  delete BattleActionInfo::default_instance_;
  delete BattleActionInfo_StartStopEvent::default_instance_;
  delete BattleActionInfo_TargetEvent::default_instance_;
  delete BattleActionInfo_AttackEvent::default_instance_;
  delete BattleActionInfo_AttrChangeEvent::default_instance_;
  delete BattleActionInfo_SummonEvent::default_instance_;
  delete BattleActionInfo_SufferEvent::default_instance_;
  delete BattleActionInfo_CastAreaEvent::default_instance_;
  delete BattleActionInfo_ActionInfo::default_instance_;
  delete BattleProcess::default_instance_;
  delete BattleProcess_AttackEvent::default_instance_;
  delete BattleProcess_AttrChangeEvent::default_instance_;
  delete BattleProcess_ActionInfo::default_instance_;
  delete BattleManualSkill::default_instance_;
  delete BattleOperation::default_instance_;
  delete BattleOperationResult::default_instance_;
  delete BattleResultInfo::default_instance_;
  delete BattleRepeat::default_instance_;
  delete BattleQTEInfo::default_instance_;
  delete BattleReward::default_instance_;
  delete BattleRepeatReward::default_instance_;
  delete BattleRepeatReward_RewardInfo::default_instance_;
  delete ExitBattle::default_instance_;
  delete NPCTalk::default_instance_;
  delete NPCTalkResult::default_instance_;
  delete NPCFunction::default_instance_;
  delete AddItem::default_instance_;
  delete DeleteItem::default_instance_;
  delete UpdateItem::default_instance_;
  delete EquipItem::default_instance_;
  delete UseItem::default_instance_;
  delete OtherEquipItem::default_instance_;
  delete ChangeAttr::default_instance_;
  delete ChangeTask::default_instance_;
  delete CheckTime::default_instance_;
  delete MercenaryGet::default_instance_;
  delete MercenaryCardGet::default_instance_;
  delete MercenaryCardGetResult::default_instance_;
  delete MercenaryAttrAdd::default_instance_;
  delete MercenaryToExp::default_instance_;
  delete AddMercenary::default_instance_;
  delete UpdateMercenary::default_instance_;
  delete MercenaryDel::default_instance_;
  delete AddCharBuff::default_instance_;
  delete DelCharBuff::default_instance_;
  delete Chat::default_instance_;
  delete ChangeRemainVar::default_instance_;
  delete ChangeClientData::default_instance_;
  delete ReqFriendData::default_instance_;
  delete AckFriendData::default_instance_;
  delete AckFriendData_DBFriendInfo::default_instance_;
  delete FriendData::default_instance_;
  delete FriendData_FriendInfo::default_instance_;
  delete SocietyOperationData::default_instance_;
  delete SocietyOperationData_SocietyOperationInfo::default_instance_;
  delete GetPvPData::default_instance_;
  delete PvpOpeResult::default_instance_;
  delete ReqPVPData::default_instance_;
  delete AckPVPData::default_instance_;
  delete AckPVPData_DBPVPInfo::default_instance_;
  delete PVPData::default_instance_;
  delete PVPData_MercInfo::default_instance_;
  delete PVPData_PVPInfo::default_instance_;
  delete PVPBattle::default_instance_;
  delete StartLadder::default_instance_;
  delete BuyLadderTimes::default_instance_;
  delete BuyPvPTimes::default_instance_;
  delete UpdateLadder::default_instance_;
  delete UpdateLadderReward::default_instance_;
  delete UpdateLadderReward_RewardInfo::default_instance_;
  delete GetLadderReward::default_instance_;
  delete GetRoleData::default_instance_;
  delete RoleData::default_instance_;
  delete RoleData_MercInfo::default_instance_;
  delete ReqRoleData::default_instance_;
  delete AckRoleData::default_instance_;
  delete GetShopItemFromDB::default_instance_;
  delete GetShopItemAck::default_instance_;
  delete OpenShopUiReq::default_instance_;
  delete OpenShopUiAck::default_instance_;
  delete BuyItem::default_instance_;
  delete RefreshShopReq::default_instance_;
  delete SellItem::default_instance_;
  delete ChangeSkill::default_instance_;
  delete SkillLevelUp::default_instance_;
  delete ReqLevelUpStar::default_instance_;
  delete UpgradeItem::default_instance_;
  delete ReqRankList::default_instance_;
  delete AckRankList::default_instance_;
  delete AckRankList_RankInfo::default_instance_;
  delete ReqServerRank::default_instance_;
  delete AckServerRank::default_instance_;
  delete AckServerRank_RankInfo::default_instance_;
  delete ReqChessData::default_instance_;
  delete AckChessData::default_instance_;
  delete ReqRunChess::default_instance_;
  delete AckRunChess::default_instance_;
  delete AckChessRank::default_instance_;
  delete AckChessRank_RankInfo::default_instance_;
  delete UnlockTrainMercenary::default_instance_;
  delete TrainMercenary::default_instance_;
  delete ReqTrainMercenaryTime::default_instance_;
  delete AckTrainMercenaryTime::default_instance_;
  delete ReqFriendTrainMercenaryTime::default_instance_;
  delete ReqAccelerateTrainMercenary::default_instance_;
  delete AckFriendTrainMercenaryTime::default_instance_;
  delete AckFriendTrainMercenaryTime_FriendTrainInfo::default_instance_;
  delete BuyMallItem::default_instance_;
  delete DailyWeekOnline::default_instance_;
  delete GetMonthSignInDataReq::default_instance_;
  delete GetMonthSignInDataAck::default_instance_;
  delete DailyMonthOnline::default_instance_;
  delete ReqDailyMonthOnlineData::default_instance_;
  delete AckDailyMonthOnlineData::default_instance_;
  delete ReqSoulBag::default_instance_;
  delete ReqQuickSoulBag::default_instance_;
  delete ReqChangeType::default_instance_;
  delete AckSoulBag::default_instance_;
  delete ReqSoulBagAction::default_instance_;
  delete AckSoulBagAction::default_instance_;
  delete ReqSoulCombine::default_instance_;
  delete ReqPlatMoney::default_instance_;
  delete ReqPlatOrderID::default_instance_;
  delete AckPlatOrderID::default_instance_;
  delete ReqAddStamina::default_instance_;
  delete OfflineTrainMercenary::default_instance_;
  delete OfflineOper::default_instance_;
  delete ReqOfflineOperList::default_instance_;
  delete AckOfflineOperList::default_instance_;
  delete ReqActiveCode::default_instance_;
  delete ReqServerActiveCode::default_instance_;
  delete AckServerActiveCode::default_instance_;
  delete ReqRefreshGate::default_instance_;
  delete RefreshGateCost::default_instance_;
  delete RefreshGate::default_instance_;
  delete ReqGateLevelUp::default_instance_;
  delete ReqChooseBigGate::default_instance_;
  delete ReqMercenaryUpgrade::default_instance_;
  delete ReqLadderReward::default_instance_;
  delete ReqGetLevelReward::default_instance_;
  delete ReqGetActiveReward::default_instance_;
  delete RechargeLogInfo::default_instance_;
  delete ResetByDay::default_instance_;
  delete UserBehaviorLogInfo::default_instance_;
  delete OnlineNumberInfo::default_instance_;
  delete ReqVIPOperation::default_instance_;
  delete UserFeedback::default_instance_;
  delete UserFeedback_UserFeedbackInfo::default_instance_;
  delete SystemReward::default_instance_;
  delete GMFreezeSystem::default_instance_;
  delete GMFreezeSystem_GMFreezeSystemInfo::default_instance_;
  delete LoginSystemNotice::default_instance_;
  delete GMOperationResult::default_instance_;
  delete AckGetInviteCode::default_instance_;
  delete ReqDrawLottery::default_instance_;
  delete GetLotteryReward::default_instance_;
  delete GiveUpHighGradeDrawLottery::default_instance_;
  delete LotteryReward::default_instance_;
  delete LotteryRewardData::default_instance_;
  delete ReqQuickDrawLottery::default_instance_;
  delete ReqGetInviteReward::default_instance_;
  delete AckGetInviteNum::default_instance_;
  delete ReqGetInviteNum::default_instance_;
  delete ReqAddMoney::default_instance_;
  delete AddMoneyCost::default_instance_;
  delete ChooseAddMoney::default_instance_;
  delete RightPosition::default_instance_;
  delete OpenBowl::default_instance_;
  delete AddMoneyReward::default_instance_;
  delete GetFirstRechargeGift::default_instance_;
  delete ReqAccelerateAction::default_instance_;
  delete ReqBuyTimesAction::default_instance_;
  delete ReqIsMercTraining::default_instance_;
  delete AckOtherLevelUp::default_instance_;
  delete SendHeartBeatMsg::default_instance_;
  delete SendStoneMsg::default_instance_;
  delete ReqWorldBossInfo::default_instance_;
  delete AckWorldBossInfo::default_instance_;
  delete ExecuteSQL::default_instance_;
  delete LoadAllActivityDataReq::default_instance_;
  delete LoadAllActivityDataAck::default_instance_;
  delete LoadAllActivityDataAck_ActivityData::default_instance_;
  delete CanGetFirstRechargeReward::default_instance_;
  delete LoadAllSysBroadcastDataReq::default_instance_;
  delete LoadAllSysBroadcastDataAck::default_instance_;
  delete LoadAllSysBroadcastDataAck_SysBroadcastData::default_instance_;
  delete QueryAccidByAccnameReq::default_instance_;
  delete QueryAccidByAccnameAck::default_instance_;
  delete PkBattle::default_instance_;
  delete HorseData::default_instance_;
  delete HorseData_HorseAttr::default_instance_;
  delete GetHorseDataReq::default_instance_;
  delete GetHorseDataAck::default_instance_;
  delete HorseGroomReq::default_instance_;
  delete HorseGroomAck::default_instance_;
  delete BuyHorseFeedCountReq::default_instance_;
  delete BuyHorseFeedCountAck::default_instance_;
  delete HorseShowChangeReq::default_instance_;
  delete HorseShowChangeAck::default_instance_;
  delete HorseChangeSys::default_instance_;
  delete LoadAllHorseDataReq::default_instance_;
  delete LoadAllHorseDataAck::default_instance_;
  delete ReqStopQuickDestiny::default_instance_;
  delete PlatScrollReq::default_instance_;
  delete PlatScrollAck::default_instance_;
  delete ReqGetVipLevelReward::default_instance_;
  delete SaveBattleInfo::default_instance_;
  delete ReqViewBattleHistory::default_instance_;
  delete ReqGetBattleHistoryData::default_instance_;
  delete BattleHistoryInfo::default_instance_;
  delete EnterActiveReq::default_instance_;
  delete EnterActiveAck::default_instance_;
  delete OpenTreasureUIReq::default_instance_;
  delete OpenTreasureUIAck::default_instance_;
  delete GetTreasureReq::default_instance_;
  delete GetTreasureAck::default_instance_;
  delete ResetAck::default_instance_;
  delete AddEquipStarReq::default_instance_;
  delete AddEquipStarAck::default_instance_;
  delete GetRoleMailInfoReq::default_instance_;
  delete SelectMailInfoReq::default_instance_;
  delete RoleMailInfo::default_instance_;
  delete ReadMailReq::default_instance_;
  delete ReadMailAck::default_instance_;
  delete GetMailRewardReq::default_instance_;
  delete GetMailRewardAck::default_instance_;
  delete SendGMMailReq::default_instance_;
  delete SendGMMailAck::default_instance_;
  delete NewMailNotice::default_instance_;
  delete SelectMailInfoAck::default_instance_;
  delete GetSkillInfoReq::default_instance_;
  delete GetSkillInfoAck::default_instance_;
  delete EquipUpgradeItemReq::default_instance_;
  delete UnlockedSkill::default_instance_;
  delete ReqGetLastPvpRewardTime::default_instance_;
  delete PvpRewardTimeAck::default_instance_;
  delete GetClimbTowerEnemyReq::default_instance_;
  delete SelectClimbTowerEnemy::default_instance_;
  delete ClimbTowerEnemyData::default_instance_;
  delete GetClimbTowerEnemyAck::default_instance_;
  delete GetClimbTowerEnemyAck_MercInfo::default_instance_;
  delete GetClimbTowerRewardReq::default_instance_;
  delete GetClimbTowerRewardAck::default_instance_;
  delete ReliveMercReq::default_instance_;
  delete ReliveMercAck::default_instance_;
  delete ResetClimbTowerReq::default_instance_;
  delete ClimbTowerBattleResult::default_instance_;
  delete ClimbTowerBattleResult_SaveData::default_instance_;
  delete SaveCTEnemyInfo::default_instance_;
  delete SendPvpRankRiseAwards::default_instance_;
  delete VipOperResult::default_instance_;
  delete ItemCombineReq::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Message_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Message_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  GateIpPortInfo::default_instance_ = new GateIpPortInfo();
  VersionInfoRequest::default_instance_ = new VersionInfoRequest();
  VersionInfoResponse::default_instance_ = new VersionInfoResponse();
  LoginAuthSys::default_instance_ = new LoginAuthSys();
  LoginCenterAuthReq::default_instance_ = new LoginCenterAuthReq();
  CenterGateState::default_instance_ = new CenterGateState();
  CenterGateState_CenterGateStateInfo::default_instance_ = new CenterGateState_CenterGateStateInfo();
  LoginCenterAuthAck::default_instance_ = new LoginCenterAuthAck();
  LoginCenterCharInfo::default_instance_ = new LoginCenterCharInfo();
  LoginCenterCharInfo_LoginServerCharInfo::default_instance_ = new LoginCenterCharInfo_LoginServerCharInfo();
  LoginAuthAck::default_instance_ = new LoginAuthAck();
  LoginAuthNack::default_instance_ = new LoginAuthNack();
  LoginServerList::default_instance_ = new LoginServerList();
  LoginServerList_LoginServerInfo::default_instance_ = new LoginServerList_LoginServerInfo();
  LoginServerChoose::default_instance_ = new LoginServerChoose();
  CenterServerChoose::default_instance_ = new CenterServerChoose();
  GateInfoSys::default_instance_ = new GateInfoSys();
  GateInfoNack::default_instance_ = new GateInfoNack();
  GateInfoAck::default_instance_ = new GateInfoAck();
  UserDisconnect::default_instance_ = new UserDisconnect();
  GateGetNonceSys::default_instance_ = new GateGetNonceSys();
  GateAuchNonce::default_instance_ = new GateAuchNonce();
  GateAuthSys::default_instance_ = new GateAuthSys();
  CenterAuthSys::default_instance_ = new CenterAuthSys();
  CenterAuthAck::default_instance_ = new CenterAuthAck();
  CenterAuthNack::default_instance_ = new CenterAuthNack();
  CenterAuthLogout::default_instance_ = new CenterAuthLogout();
  GetPlayerRoleList::default_instance_ = new GetPlayerRoleList();
  PlayerRoleListData::default_instance_ = new PlayerRoleListData();
  EnterSceneSys::default_instance_ = new EnterSceneSys();
  EnterSceneNack::default_instance_ = new EnterSceneNack();
  ChooseSceneCmd::default_instance_ = new ChooseSceneCmd();
  ServerInfoConnected::default_instance_ = new ServerInfoConnected();
  MapServerInfo::default_instance_ = new MapServerInfo();
  CreateUserInfo::default_instance_ = new CreateUserInfo();
  CreateUserResult::default_instance_ = new CreateUserResult();
  SaveUserInfo::default_instance_ = new SaveUserInfo();
  GetUserDetailInfo::default_instance_ = new GetUserDetailInfo();
  UserDetailInfo::default_instance_ = new UserDetailInfo();
  EnterSceneMapSys::default_instance_ = new EnterSceneMapSys();
  EnterSceneMapNack::default_instance_ = new EnterSceneMapNack();
  EnterSceneMapAck::default_instance_ = new EnterSceneMapAck();
  ClientCreateSenceCmd::default_instance_ = new ClientCreateSenceCmd();
  ClientEnterSenceSys::default_instance_ = new ClientEnterSenceSys();
  AddPlayerSys::default_instance_ = new AddPlayerSys();
  AddNpcSys::default_instance_ = new AddNpcSys();
  DelPlayerSys::default_instance_ = new DelPlayerSys();
  DelNpcSys::default_instance_ = new DelNpcSys();
  GateInfoID::default_instance_ = new GateInfoID();
  GateLogoutCmd::default_instance_ = new GateLogoutCmd();
  Move::default_instance_ = new Move();
  PlayerJumpMap::default_instance_ = new PlayerJumpMap();
  NPCTeleport::default_instance_ = new NPCTeleport();
  PlayerAttack::default_instance_ = new PlayerAttack();
  QTEResult::default_instance_ = new QTEResult();
  ClearSkill::default_instance_ = new ClearSkill();
  AddSkill::default_instance_ = new AddSkill();
  SkillSequence::default_instance_ = new SkillSequence();
  BattleCharInfo::default_instance_ = new BattleCharInfo();
  BattleCharInfo_CharInfo::default_instance_ = new BattleCharInfo_CharInfo();
  BattleActionInfo::default_instance_ = new BattleActionInfo();
  BattleActionInfo_StartStopEvent::default_instance_ = new BattleActionInfo_StartStopEvent();
  BattleActionInfo_TargetEvent::default_instance_ = new BattleActionInfo_TargetEvent();
  BattleActionInfo_AttackEvent::default_instance_ = new BattleActionInfo_AttackEvent();
  BattleActionInfo_AttrChangeEvent::default_instance_ = new BattleActionInfo_AttrChangeEvent();
  BattleActionInfo_SummonEvent::default_instance_ = new BattleActionInfo_SummonEvent();
  BattleActionInfo_SufferEvent::default_instance_ = new BattleActionInfo_SufferEvent();
  BattleActionInfo_CastAreaEvent::default_instance_ = new BattleActionInfo_CastAreaEvent();
  BattleActionInfo_ActionInfo::default_instance_ = new BattleActionInfo_ActionInfo();
  BattleProcess::default_instance_ = new BattleProcess();
  BattleProcess_AttackEvent::default_instance_ = new BattleProcess_AttackEvent();
  BattleProcess_AttrChangeEvent::default_instance_ = new BattleProcess_AttrChangeEvent();
  BattleProcess_ActionInfo::default_instance_ = new BattleProcess_ActionInfo();
  BattleManualSkill::default_instance_ = new BattleManualSkill();
  BattleOperation::default_instance_ = new BattleOperation();
  BattleOperationResult::default_instance_ = new BattleOperationResult();
  BattleResultInfo::default_instance_ = new BattleResultInfo();
  BattleRepeat::default_instance_ = new BattleRepeat();
  BattleQTEInfo::default_instance_ = new BattleQTEInfo();
  BattleReward::default_instance_ = new BattleReward();
  BattleRepeatReward::default_instance_ = new BattleRepeatReward();
  BattleRepeatReward_RewardInfo::default_instance_ = new BattleRepeatReward_RewardInfo();
  ExitBattle::default_instance_ = new ExitBattle();
  NPCTalk::default_instance_ = new NPCTalk();
  NPCTalkResult::default_instance_ = new NPCTalkResult();
  NPCFunction::default_instance_ = new NPCFunction();
  AddItem::default_instance_ = new AddItem();
  DeleteItem::default_instance_ = new DeleteItem();
  UpdateItem::default_instance_ = new UpdateItem();
  EquipItem::default_instance_ = new EquipItem();
  UseItem::default_instance_ = new UseItem();
  OtherEquipItem::default_instance_ = new OtherEquipItem();
  ChangeAttr::default_instance_ = new ChangeAttr();
  ChangeTask::default_instance_ = new ChangeTask();
  CheckTime::default_instance_ = new CheckTime();
  MercenaryGet::default_instance_ = new MercenaryGet();
  MercenaryCardGet::default_instance_ = new MercenaryCardGet();
  MercenaryCardGetResult::default_instance_ = new MercenaryCardGetResult();
  MercenaryAttrAdd::default_instance_ = new MercenaryAttrAdd();
  MercenaryToExp::default_instance_ = new MercenaryToExp();
  AddMercenary::default_instance_ = new AddMercenary();
  UpdateMercenary::default_instance_ = new UpdateMercenary();
  MercenaryDel::default_instance_ = new MercenaryDel();
  AddCharBuff::default_instance_ = new AddCharBuff();
  DelCharBuff::default_instance_ = new DelCharBuff();
  Chat::default_instance_ = new Chat();
  ChangeRemainVar::default_instance_ = new ChangeRemainVar();
  ChangeClientData::default_instance_ = new ChangeClientData();
  ReqFriendData::default_instance_ = new ReqFriendData();
  AckFriendData::default_instance_ = new AckFriendData();
  AckFriendData_DBFriendInfo::default_instance_ = new AckFriendData_DBFriendInfo();
  FriendData::default_instance_ = new FriendData();
  FriendData_FriendInfo::default_instance_ = new FriendData_FriendInfo();
  SocietyOperationData::default_instance_ = new SocietyOperationData();
  SocietyOperationData_SocietyOperationInfo::default_instance_ = new SocietyOperationData_SocietyOperationInfo();
  GetPvPData::default_instance_ = new GetPvPData();
  PvpOpeResult::default_instance_ = new PvpOpeResult();
  ReqPVPData::default_instance_ = new ReqPVPData();
  AckPVPData::default_instance_ = new AckPVPData();
  AckPVPData_DBPVPInfo::default_instance_ = new AckPVPData_DBPVPInfo();
  PVPData::default_instance_ = new PVPData();
  PVPData_MercInfo::default_instance_ = new PVPData_MercInfo();
  PVPData_PVPInfo::default_instance_ = new PVPData_PVPInfo();
  PVPBattle::default_instance_ = new PVPBattle();
  StartLadder::default_instance_ = new StartLadder();
  BuyLadderTimes::default_instance_ = new BuyLadderTimes();
  BuyPvPTimes::default_instance_ = new BuyPvPTimes();
  UpdateLadder::default_instance_ = new UpdateLadder();
  UpdateLadderReward::default_instance_ = new UpdateLadderReward();
  UpdateLadderReward_RewardInfo::default_instance_ = new UpdateLadderReward_RewardInfo();
  GetLadderReward::default_instance_ = new GetLadderReward();
  GetRoleData::default_instance_ = new GetRoleData();
  RoleData::default_instance_ = new RoleData();
  RoleData_MercInfo::default_instance_ = new RoleData_MercInfo();
  ReqRoleData::default_instance_ = new ReqRoleData();
  AckRoleData::default_instance_ = new AckRoleData();
  GetShopItemFromDB::default_instance_ = new GetShopItemFromDB();
  GetShopItemAck::default_instance_ = new GetShopItemAck();
  OpenShopUiReq::default_instance_ = new OpenShopUiReq();
  OpenShopUiAck::default_instance_ = new OpenShopUiAck();
  BuyItem::default_instance_ = new BuyItem();
  RefreshShopReq::default_instance_ = new RefreshShopReq();
  SellItem::default_instance_ = new SellItem();
  ChangeSkill::default_instance_ = new ChangeSkill();
  SkillLevelUp::default_instance_ = new SkillLevelUp();
  ReqLevelUpStar::default_instance_ = new ReqLevelUpStar();
  UpgradeItem::default_instance_ = new UpgradeItem();
  ReqRankList::default_instance_ = new ReqRankList();
  AckRankList::default_instance_ = new AckRankList();
  AckRankList_RankInfo::default_instance_ = new AckRankList_RankInfo();
  ReqServerRank::default_instance_ = new ReqServerRank();
  AckServerRank::default_instance_ = new AckServerRank();
  AckServerRank_RankInfo::default_instance_ = new AckServerRank_RankInfo();
  ReqChessData::default_instance_ = new ReqChessData();
  AckChessData::default_instance_ = new AckChessData();
  ReqRunChess::default_instance_ = new ReqRunChess();
  AckRunChess::default_instance_ = new AckRunChess();
  AckChessRank::default_instance_ = new AckChessRank();
  AckChessRank_RankInfo::default_instance_ = new AckChessRank_RankInfo();
  UnlockTrainMercenary::default_instance_ = new UnlockTrainMercenary();
  TrainMercenary::default_instance_ = new TrainMercenary();
  ReqTrainMercenaryTime::default_instance_ = new ReqTrainMercenaryTime();
  AckTrainMercenaryTime::default_instance_ = new AckTrainMercenaryTime();
  ReqFriendTrainMercenaryTime::default_instance_ = new ReqFriendTrainMercenaryTime();
  ReqAccelerateTrainMercenary::default_instance_ = new ReqAccelerateTrainMercenary();
  AckFriendTrainMercenaryTime::default_instance_ = new AckFriendTrainMercenaryTime();
  AckFriendTrainMercenaryTime_FriendTrainInfo::default_instance_ = new AckFriendTrainMercenaryTime_FriendTrainInfo();
  BuyMallItem::default_instance_ = new BuyMallItem();
  DailyWeekOnline::default_instance_ = new DailyWeekOnline();
  GetMonthSignInDataReq::default_instance_ = new GetMonthSignInDataReq();
  GetMonthSignInDataAck::default_instance_ = new GetMonthSignInDataAck();
  DailyMonthOnline::default_instance_ = new DailyMonthOnline();
  ReqDailyMonthOnlineData::default_instance_ = new ReqDailyMonthOnlineData();
  AckDailyMonthOnlineData::default_instance_ = new AckDailyMonthOnlineData();
  ReqSoulBag::default_instance_ = new ReqSoulBag();
  ReqQuickSoulBag::default_instance_ = new ReqQuickSoulBag();
  ReqChangeType::default_instance_ = new ReqChangeType();
  AckSoulBag::default_instance_ = new AckSoulBag();
  ReqSoulBagAction::default_instance_ = new ReqSoulBagAction();
  AckSoulBagAction::default_instance_ = new AckSoulBagAction();
  ReqSoulCombine::default_instance_ = new ReqSoulCombine();
  ReqPlatMoney::default_instance_ = new ReqPlatMoney();
  ReqPlatOrderID::default_instance_ = new ReqPlatOrderID();
  AckPlatOrderID::default_instance_ = new AckPlatOrderID();
  ReqAddStamina::default_instance_ = new ReqAddStamina();
  OfflineTrainMercenary::default_instance_ = new OfflineTrainMercenary();
  OfflineOper::default_instance_ = new OfflineOper();
  ReqOfflineOperList::default_instance_ = new ReqOfflineOperList();
  AckOfflineOperList::default_instance_ = new AckOfflineOperList();
  ReqActiveCode::default_instance_ = new ReqActiveCode();
  ReqServerActiveCode::default_instance_ = new ReqServerActiveCode();
  AckServerActiveCode::default_instance_ = new AckServerActiveCode();
  ReqRefreshGate::default_instance_ = new ReqRefreshGate();
  RefreshGateCost::default_instance_ = new RefreshGateCost();
  RefreshGate::default_instance_ = new RefreshGate();
  ReqGateLevelUp::default_instance_ = new ReqGateLevelUp();
  ReqChooseBigGate::default_instance_ = new ReqChooseBigGate();
  ReqMercenaryUpgrade::default_instance_ = new ReqMercenaryUpgrade();
  ReqLadderReward::default_instance_ = new ReqLadderReward();
  ReqGetLevelReward::default_instance_ = new ReqGetLevelReward();
  ReqGetActiveReward::default_instance_ = new ReqGetActiveReward();
  RechargeLogInfo::default_instance_ = new RechargeLogInfo();
  ResetByDay::default_instance_ = new ResetByDay();
  UserBehaviorLogInfo::default_instance_ = new UserBehaviorLogInfo();
  OnlineNumberInfo::default_instance_ = new OnlineNumberInfo();
  ReqVIPOperation::default_instance_ = new ReqVIPOperation();
  UserFeedback::default_instance_ = new UserFeedback();
  UserFeedback_UserFeedbackInfo::default_instance_ = new UserFeedback_UserFeedbackInfo();
  SystemReward::default_instance_ = new SystemReward();
  GMFreezeSystem::default_instance_ = new GMFreezeSystem();
  GMFreezeSystem_GMFreezeSystemInfo::default_instance_ = new GMFreezeSystem_GMFreezeSystemInfo();
  LoginSystemNotice::default_instance_ = new LoginSystemNotice();
  GMOperationResult::default_instance_ = new GMOperationResult();
  AckGetInviteCode::default_instance_ = new AckGetInviteCode();
  ReqDrawLottery::default_instance_ = new ReqDrawLottery();
  GetLotteryReward::default_instance_ = new GetLotteryReward();
  GiveUpHighGradeDrawLottery::default_instance_ = new GiveUpHighGradeDrawLottery();
  LotteryReward::default_instance_ = new LotteryReward();
  LotteryRewardData::default_instance_ = new LotteryRewardData();
  ReqQuickDrawLottery::default_instance_ = new ReqQuickDrawLottery();
  ReqGetInviteReward::default_instance_ = new ReqGetInviteReward();
  AckGetInviteNum::default_instance_ = new AckGetInviteNum();
  ReqGetInviteNum::default_instance_ = new ReqGetInviteNum();
  ReqAddMoney::default_instance_ = new ReqAddMoney();
  AddMoneyCost::default_instance_ = new AddMoneyCost();
  ChooseAddMoney::default_instance_ = new ChooseAddMoney();
  RightPosition::default_instance_ = new RightPosition();
  OpenBowl::default_instance_ = new OpenBowl();
  AddMoneyReward::default_instance_ = new AddMoneyReward();
  GetFirstRechargeGift::default_instance_ = new GetFirstRechargeGift();
  ReqAccelerateAction::default_instance_ = new ReqAccelerateAction();
  ReqBuyTimesAction::default_instance_ = new ReqBuyTimesAction();
  ReqIsMercTraining::default_instance_ = new ReqIsMercTraining();
  AckOtherLevelUp::default_instance_ = new AckOtherLevelUp();
  SendHeartBeatMsg::default_instance_ = new SendHeartBeatMsg();
  SendStoneMsg::default_instance_ = new SendStoneMsg();
  ReqWorldBossInfo::default_instance_ = new ReqWorldBossInfo();
  AckWorldBossInfo::default_instance_ = new AckWorldBossInfo();
  ExecuteSQL::default_instance_ = new ExecuteSQL();
  LoadAllActivityDataReq::default_instance_ = new LoadAllActivityDataReq();
  LoadAllActivityDataAck::default_instance_ = new LoadAllActivityDataAck();
  LoadAllActivityDataAck_ActivityData::default_instance_ = new LoadAllActivityDataAck_ActivityData();
  CanGetFirstRechargeReward::default_instance_ = new CanGetFirstRechargeReward();
  LoadAllSysBroadcastDataReq::default_instance_ = new LoadAllSysBroadcastDataReq();
  LoadAllSysBroadcastDataAck::default_instance_ = new LoadAllSysBroadcastDataAck();
  LoadAllSysBroadcastDataAck_SysBroadcastData::default_instance_ = new LoadAllSysBroadcastDataAck_SysBroadcastData();
  QueryAccidByAccnameReq::default_instance_ = new QueryAccidByAccnameReq();
  QueryAccidByAccnameAck::default_instance_ = new QueryAccidByAccnameAck();
  PkBattle::default_instance_ = new PkBattle();
  HorseData::default_instance_ = new HorseData();
  HorseData_HorseAttr::default_instance_ = new HorseData_HorseAttr();
  GetHorseDataReq::default_instance_ = new GetHorseDataReq();
  GetHorseDataAck::default_instance_ = new GetHorseDataAck();
  HorseGroomReq::default_instance_ = new HorseGroomReq();
  HorseGroomAck::default_instance_ = new HorseGroomAck();
  BuyHorseFeedCountReq::default_instance_ = new BuyHorseFeedCountReq();
  BuyHorseFeedCountAck::default_instance_ = new BuyHorseFeedCountAck();
  HorseShowChangeReq::default_instance_ = new HorseShowChangeReq();
  HorseShowChangeAck::default_instance_ = new HorseShowChangeAck();
  HorseChangeSys::default_instance_ = new HorseChangeSys();
  LoadAllHorseDataReq::default_instance_ = new LoadAllHorseDataReq();
  LoadAllHorseDataAck::default_instance_ = new LoadAllHorseDataAck();
  ReqStopQuickDestiny::default_instance_ = new ReqStopQuickDestiny();
  PlatScrollReq::default_instance_ = new PlatScrollReq();
  PlatScrollAck::default_instance_ = new PlatScrollAck();
  ReqGetVipLevelReward::default_instance_ = new ReqGetVipLevelReward();
  SaveBattleInfo::default_instance_ = new SaveBattleInfo();
  ReqViewBattleHistory::default_instance_ = new ReqViewBattleHistory();
  ReqGetBattleHistoryData::default_instance_ = new ReqGetBattleHistoryData();
  BattleHistoryInfo::default_instance_ = new BattleHistoryInfo();
  EnterActiveReq::default_instance_ = new EnterActiveReq();
  EnterActiveAck::default_instance_ = new EnterActiveAck();
  OpenTreasureUIReq::default_instance_ = new OpenTreasureUIReq();
  OpenTreasureUIAck::default_instance_ = new OpenTreasureUIAck();
  GetTreasureReq::default_instance_ = new GetTreasureReq();
  GetTreasureAck::default_instance_ = new GetTreasureAck();
  ResetAck::default_instance_ = new ResetAck();
  AddEquipStarReq::default_instance_ = new AddEquipStarReq();
  AddEquipStarAck::default_instance_ = new AddEquipStarAck();
  GetRoleMailInfoReq::default_instance_ = new GetRoleMailInfoReq();
  SelectMailInfoReq::default_instance_ = new SelectMailInfoReq();
  RoleMailInfo::default_instance_ = new RoleMailInfo();
  ReadMailReq::default_instance_ = new ReadMailReq();
  ReadMailAck::default_instance_ = new ReadMailAck();
  GetMailRewardReq::default_instance_ = new GetMailRewardReq();
  GetMailRewardAck::default_instance_ = new GetMailRewardAck();
  SendGMMailReq::default_instance_ = new SendGMMailReq();
  SendGMMailAck::default_instance_ = new SendGMMailAck();
  NewMailNotice::default_instance_ = new NewMailNotice();
  SelectMailInfoAck::default_instance_ = new SelectMailInfoAck();
  GetSkillInfoReq::default_instance_ = new GetSkillInfoReq();
  GetSkillInfoAck::default_instance_ = new GetSkillInfoAck();
  EquipUpgradeItemReq::default_instance_ = new EquipUpgradeItemReq();
  UnlockedSkill::default_instance_ = new UnlockedSkill();
  ReqGetLastPvpRewardTime::default_instance_ = new ReqGetLastPvpRewardTime();
  PvpRewardTimeAck::default_instance_ = new PvpRewardTimeAck();
  GetClimbTowerEnemyReq::default_instance_ = new GetClimbTowerEnemyReq();
  SelectClimbTowerEnemy::default_instance_ = new SelectClimbTowerEnemy();
  ClimbTowerEnemyData::default_instance_ = new ClimbTowerEnemyData();
  GetClimbTowerEnemyAck::default_instance_ = new GetClimbTowerEnemyAck();
  GetClimbTowerEnemyAck_MercInfo::default_instance_ = new GetClimbTowerEnemyAck_MercInfo();
  GetClimbTowerRewardReq::default_instance_ = new GetClimbTowerRewardReq();
  GetClimbTowerRewardAck::default_instance_ = new GetClimbTowerRewardAck();
  ReliveMercReq::default_instance_ = new ReliveMercReq();
  ReliveMercAck::default_instance_ = new ReliveMercAck();
  ResetClimbTowerReq::default_instance_ = new ResetClimbTowerReq();
  ClimbTowerBattleResult::default_instance_ = new ClimbTowerBattleResult();
  ClimbTowerBattleResult_SaveData::default_instance_ = new ClimbTowerBattleResult_SaveData();
  SaveCTEnemyInfo::default_instance_ = new SaveCTEnemyInfo();
  SendPvpRankRiseAwards::default_instance_ = new SendPvpRankRiseAwards();
  VipOperResult::default_instance_ = new VipOperResult();
  ItemCombineReq::default_instance_ = new ItemCombineReq();
  GateIpPortInfo::default_instance_->InitAsDefaultInstance();
  VersionInfoRequest::default_instance_->InitAsDefaultInstance();
  VersionInfoResponse::default_instance_->InitAsDefaultInstance();
  LoginAuthSys::default_instance_->InitAsDefaultInstance();
  LoginCenterAuthReq::default_instance_->InitAsDefaultInstance();
  CenterGateState::default_instance_->InitAsDefaultInstance();
  CenterGateState_CenterGateStateInfo::default_instance_->InitAsDefaultInstance();
  LoginCenterAuthAck::default_instance_->InitAsDefaultInstance();
  LoginCenterCharInfo::default_instance_->InitAsDefaultInstance();
  LoginCenterCharInfo_LoginServerCharInfo::default_instance_->InitAsDefaultInstance();
  LoginAuthAck::default_instance_->InitAsDefaultInstance();
  LoginAuthNack::default_instance_->InitAsDefaultInstance();
  LoginServerList::default_instance_->InitAsDefaultInstance();
  LoginServerList_LoginServerInfo::default_instance_->InitAsDefaultInstance();
  LoginServerChoose::default_instance_->InitAsDefaultInstance();
  CenterServerChoose::default_instance_->InitAsDefaultInstance();
  GateInfoSys::default_instance_->InitAsDefaultInstance();
  GateInfoNack::default_instance_->InitAsDefaultInstance();
  GateInfoAck::default_instance_->InitAsDefaultInstance();
  UserDisconnect::default_instance_->InitAsDefaultInstance();
  GateGetNonceSys::default_instance_->InitAsDefaultInstance();
  GateAuchNonce::default_instance_->InitAsDefaultInstance();
  GateAuthSys::default_instance_->InitAsDefaultInstance();
  CenterAuthSys::default_instance_->InitAsDefaultInstance();
  CenterAuthAck::default_instance_->InitAsDefaultInstance();
  CenterAuthNack::default_instance_->InitAsDefaultInstance();
  CenterAuthLogout::default_instance_->InitAsDefaultInstance();
  GetPlayerRoleList::default_instance_->InitAsDefaultInstance();
  PlayerRoleListData::default_instance_->InitAsDefaultInstance();
  EnterSceneSys::default_instance_->InitAsDefaultInstance();
  EnterSceneNack::default_instance_->InitAsDefaultInstance();
  ChooseSceneCmd::default_instance_->InitAsDefaultInstance();
  ServerInfoConnected::default_instance_->InitAsDefaultInstance();
  MapServerInfo::default_instance_->InitAsDefaultInstance();
  CreateUserInfo::default_instance_->InitAsDefaultInstance();
  CreateUserResult::default_instance_->InitAsDefaultInstance();
  SaveUserInfo::default_instance_->InitAsDefaultInstance();
  GetUserDetailInfo::default_instance_->InitAsDefaultInstance();
  UserDetailInfo::default_instance_->InitAsDefaultInstance();
  EnterSceneMapSys::default_instance_->InitAsDefaultInstance();
  EnterSceneMapNack::default_instance_->InitAsDefaultInstance();
  EnterSceneMapAck::default_instance_->InitAsDefaultInstance();
  ClientCreateSenceCmd::default_instance_->InitAsDefaultInstance();
  ClientEnterSenceSys::default_instance_->InitAsDefaultInstance();
  AddPlayerSys::default_instance_->InitAsDefaultInstance();
  AddNpcSys::default_instance_->InitAsDefaultInstance();
  DelPlayerSys::default_instance_->InitAsDefaultInstance();
  DelNpcSys::default_instance_->InitAsDefaultInstance();
  GateInfoID::default_instance_->InitAsDefaultInstance();
  GateLogoutCmd::default_instance_->InitAsDefaultInstance();
  Move::default_instance_->InitAsDefaultInstance();
  PlayerJumpMap::default_instance_->InitAsDefaultInstance();
  NPCTeleport::default_instance_->InitAsDefaultInstance();
  PlayerAttack::default_instance_->InitAsDefaultInstance();
  QTEResult::default_instance_->InitAsDefaultInstance();
  ClearSkill::default_instance_->InitAsDefaultInstance();
  AddSkill::default_instance_->InitAsDefaultInstance();
  SkillSequence::default_instance_->InitAsDefaultInstance();
  BattleCharInfo::default_instance_->InitAsDefaultInstance();
  BattleCharInfo_CharInfo::default_instance_->InitAsDefaultInstance();
  BattleActionInfo::default_instance_->InitAsDefaultInstance();
  BattleActionInfo_StartStopEvent::default_instance_->InitAsDefaultInstance();
  BattleActionInfo_TargetEvent::default_instance_->InitAsDefaultInstance();
  BattleActionInfo_AttackEvent::default_instance_->InitAsDefaultInstance();
  BattleActionInfo_AttrChangeEvent::default_instance_->InitAsDefaultInstance();
  BattleActionInfo_SummonEvent::default_instance_->InitAsDefaultInstance();
  BattleActionInfo_SufferEvent::default_instance_->InitAsDefaultInstance();
  BattleActionInfo_CastAreaEvent::default_instance_->InitAsDefaultInstance();
  BattleActionInfo_ActionInfo::default_instance_->InitAsDefaultInstance();
  BattleProcess::default_instance_->InitAsDefaultInstance();
  BattleProcess_AttackEvent::default_instance_->InitAsDefaultInstance();
  BattleProcess_AttrChangeEvent::default_instance_->InitAsDefaultInstance();
  BattleProcess_ActionInfo::default_instance_->InitAsDefaultInstance();
  BattleManualSkill::default_instance_->InitAsDefaultInstance();
  BattleOperation::default_instance_->InitAsDefaultInstance();
  BattleOperationResult::default_instance_->InitAsDefaultInstance();
  BattleResultInfo::default_instance_->InitAsDefaultInstance();
  BattleRepeat::default_instance_->InitAsDefaultInstance();
  BattleQTEInfo::default_instance_->InitAsDefaultInstance();
  BattleReward::default_instance_->InitAsDefaultInstance();
  BattleRepeatReward::default_instance_->InitAsDefaultInstance();
  BattleRepeatReward_RewardInfo::default_instance_->InitAsDefaultInstance();
  ExitBattle::default_instance_->InitAsDefaultInstance();
  NPCTalk::default_instance_->InitAsDefaultInstance();
  NPCTalkResult::default_instance_->InitAsDefaultInstance();
  NPCFunction::default_instance_->InitAsDefaultInstance();
  AddItem::default_instance_->InitAsDefaultInstance();
  DeleteItem::default_instance_->InitAsDefaultInstance();
  UpdateItem::default_instance_->InitAsDefaultInstance();
  EquipItem::default_instance_->InitAsDefaultInstance();
  UseItem::default_instance_->InitAsDefaultInstance();
  OtherEquipItem::default_instance_->InitAsDefaultInstance();
  ChangeAttr::default_instance_->InitAsDefaultInstance();
  ChangeTask::default_instance_->InitAsDefaultInstance();
  CheckTime::default_instance_->InitAsDefaultInstance();
  MercenaryGet::default_instance_->InitAsDefaultInstance();
  MercenaryCardGet::default_instance_->InitAsDefaultInstance();
  MercenaryCardGetResult::default_instance_->InitAsDefaultInstance();
  MercenaryAttrAdd::default_instance_->InitAsDefaultInstance();
  MercenaryToExp::default_instance_->InitAsDefaultInstance();
  AddMercenary::default_instance_->InitAsDefaultInstance();
  UpdateMercenary::default_instance_->InitAsDefaultInstance();
  MercenaryDel::default_instance_->InitAsDefaultInstance();
  AddCharBuff::default_instance_->InitAsDefaultInstance();
  DelCharBuff::default_instance_->InitAsDefaultInstance();
  Chat::default_instance_->InitAsDefaultInstance();
  ChangeRemainVar::default_instance_->InitAsDefaultInstance();
  ChangeClientData::default_instance_->InitAsDefaultInstance();
  ReqFriendData::default_instance_->InitAsDefaultInstance();
  AckFriendData::default_instance_->InitAsDefaultInstance();
  AckFriendData_DBFriendInfo::default_instance_->InitAsDefaultInstance();
  FriendData::default_instance_->InitAsDefaultInstance();
  FriendData_FriendInfo::default_instance_->InitAsDefaultInstance();
  SocietyOperationData::default_instance_->InitAsDefaultInstance();
  SocietyOperationData_SocietyOperationInfo::default_instance_->InitAsDefaultInstance();
  GetPvPData::default_instance_->InitAsDefaultInstance();
  PvpOpeResult::default_instance_->InitAsDefaultInstance();
  ReqPVPData::default_instance_->InitAsDefaultInstance();
  AckPVPData::default_instance_->InitAsDefaultInstance();
  AckPVPData_DBPVPInfo::default_instance_->InitAsDefaultInstance();
  PVPData::default_instance_->InitAsDefaultInstance();
  PVPData_MercInfo::default_instance_->InitAsDefaultInstance();
  PVPData_PVPInfo::default_instance_->InitAsDefaultInstance();
  PVPBattle::default_instance_->InitAsDefaultInstance();
  StartLadder::default_instance_->InitAsDefaultInstance();
  BuyLadderTimes::default_instance_->InitAsDefaultInstance();
  BuyPvPTimes::default_instance_->InitAsDefaultInstance();
  UpdateLadder::default_instance_->InitAsDefaultInstance();
  UpdateLadderReward::default_instance_->InitAsDefaultInstance();
  UpdateLadderReward_RewardInfo::default_instance_->InitAsDefaultInstance();
  GetLadderReward::default_instance_->InitAsDefaultInstance();
  GetRoleData::default_instance_->InitAsDefaultInstance();
  RoleData::default_instance_->InitAsDefaultInstance();
  RoleData_MercInfo::default_instance_->InitAsDefaultInstance();
  ReqRoleData::default_instance_->InitAsDefaultInstance();
  AckRoleData::default_instance_->InitAsDefaultInstance();
  GetShopItemFromDB::default_instance_->InitAsDefaultInstance();
  GetShopItemAck::default_instance_->InitAsDefaultInstance();
  OpenShopUiReq::default_instance_->InitAsDefaultInstance();
  OpenShopUiAck::default_instance_->InitAsDefaultInstance();
  BuyItem::default_instance_->InitAsDefaultInstance();
  RefreshShopReq::default_instance_->InitAsDefaultInstance();
  SellItem::default_instance_->InitAsDefaultInstance();
  ChangeSkill::default_instance_->InitAsDefaultInstance();
  SkillLevelUp::default_instance_->InitAsDefaultInstance();
  ReqLevelUpStar::default_instance_->InitAsDefaultInstance();
  UpgradeItem::default_instance_->InitAsDefaultInstance();
  ReqRankList::default_instance_->InitAsDefaultInstance();
  AckRankList::default_instance_->InitAsDefaultInstance();
  AckRankList_RankInfo::default_instance_->InitAsDefaultInstance();
  ReqServerRank::default_instance_->InitAsDefaultInstance();
  AckServerRank::default_instance_->InitAsDefaultInstance();
  AckServerRank_RankInfo::default_instance_->InitAsDefaultInstance();
  ReqChessData::default_instance_->InitAsDefaultInstance();
  AckChessData::default_instance_->InitAsDefaultInstance();
  ReqRunChess::default_instance_->InitAsDefaultInstance();
  AckRunChess::default_instance_->InitAsDefaultInstance();
  AckChessRank::default_instance_->InitAsDefaultInstance();
  AckChessRank_RankInfo::default_instance_->InitAsDefaultInstance();
  UnlockTrainMercenary::default_instance_->InitAsDefaultInstance();
  TrainMercenary::default_instance_->InitAsDefaultInstance();
  ReqTrainMercenaryTime::default_instance_->InitAsDefaultInstance();
  AckTrainMercenaryTime::default_instance_->InitAsDefaultInstance();
  ReqFriendTrainMercenaryTime::default_instance_->InitAsDefaultInstance();
  ReqAccelerateTrainMercenary::default_instance_->InitAsDefaultInstance();
  AckFriendTrainMercenaryTime::default_instance_->InitAsDefaultInstance();
  AckFriendTrainMercenaryTime_FriendTrainInfo::default_instance_->InitAsDefaultInstance();
  BuyMallItem::default_instance_->InitAsDefaultInstance();
  DailyWeekOnline::default_instance_->InitAsDefaultInstance();
  GetMonthSignInDataReq::default_instance_->InitAsDefaultInstance();
  GetMonthSignInDataAck::default_instance_->InitAsDefaultInstance();
  DailyMonthOnline::default_instance_->InitAsDefaultInstance();
  ReqDailyMonthOnlineData::default_instance_->InitAsDefaultInstance();
  AckDailyMonthOnlineData::default_instance_->InitAsDefaultInstance();
  ReqSoulBag::default_instance_->InitAsDefaultInstance();
  ReqQuickSoulBag::default_instance_->InitAsDefaultInstance();
  ReqChangeType::default_instance_->InitAsDefaultInstance();
  AckSoulBag::default_instance_->InitAsDefaultInstance();
  ReqSoulBagAction::default_instance_->InitAsDefaultInstance();
  AckSoulBagAction::default_instance_->InitAsDefaultInstance();
  ReqSoulCombine::default_instance_->InitAsDefaultInstance();
  ReqPlatMoney::default_instance_->InitAsDefaultInstance();
  ReqPlatOrderID::default_instance_->InitAsDefaultInstance();
  AckPlatOrderID::default_instance_->InitAsDefaultInstance();
  ReqAddStamina::default_instance_->InitAsDefaultInstance();
  OfflineTrainMercenary::default_instance_->InitAsDefaultInstance();
  OfflineOper::default_instance_->InitAsDefaultInstance();
  ReqOfflineOperList::default_instance_->InitAsDefaultInstance();
  AckOfflineOperList::default_instance_->InitAsDefaultInstance();
  ReqActiveCode::default_instance_->InitAsDefaultInstance();
  ReqServerActiveCode::default_instance_->InitAsDefaultInstance();
  AckServerActiveCode::default_instance_->InitAsDefaultInstance();
  ReqRefreshGate::default_instance_->InitAsDefaultInstance();
  RefreshGateCost::default_instance_->InitAsDefaultInstance();
  RefreshGate::default_instance_->InitAsDefaultInstance();
  ReqGateLevelUp::default_instance_->InitAsDefaultInstance();
  ReqChooseBigGate::default_instance_->InitAsDefaultInstance();
  ReqMercenaryUpgrade::default_instance_->InitAsDefaultInstance();
  ReqLadderReward::default_instance_->InitAsDefaultInstance();
  ReqGetLevelReward::default_instance_->InitAsDefaultInstance();
  ReqGetActiveReward::default_instance_->InitAsDefaultInstance();
  RechargeLogInfo::default_instance_->InitAsDefaultInstance();
  ResetByDay::default_instance_->InitAsDefaultInstance();
  UserBehaviorLogInfo::default_instance_->InitAsDefaultInstance();
  OnlineNumberInfo::default_instance_->InitAsDefaultInstance();
  ReqVIPOperation::default_instance_->InitAsDefaultInstance();
  UserFeedback::default_instance_->InitAsDefaultInstance();
  UserFeedback_UserFeedbackInfo::default_instance_->InitAsDefaultInstance();
  SystemReward::default_instance_->InitAsDefaultInstance();
  GMFreezeSystem::default_instance_->InitAsDefaultInstance();
  GMFreezeSystem_GMFreezeSystemInfo::default_instance_->InitAsDefaultInstance();
  LoginSystemNotice::default_instance_->InitAsDefaultInstance();
  GMOperationResult::default_instance_->InitAsDefaultInstance();
  AckGetInviteCode::default_instance_->InitAsDefaultInstance();
  ReqDrawLottery::default_instance_->InitAsDefaultInstance();
  GetLotteryReward::default_instance_->InitAsDefaultInstance();
  GiveUpHighGradeDrawLottery::default_instance_->InitAsDefaultInstance();
  LotteryReward::default_instance_->InitAsDefaultInstance();
  LotteryRewardData::default_instance_->InitAsDefaultInstance();
  ReqQuickDrawLottery::default_instance_->InitAsDefaultInstance();
  ReqGetInviteReward::default_instance_->InitAsDefaultInstance();
  AckGetInviteNum::default_instance_->InitAsDefaultInstance();
  ReqGetInviteNum::default_instance_->InitAsDefaultInstance();
  ReqAddMoney::default_instance_->InitAsDefaultInstance();
  AddMoneyCost::default_instance_->InitAsDefaultInstance();
  ChooseAddMoney::default_instance_->InitAsDefaultInstance();
  RightPosition::default_instance_->InitAsDefaultInstance();
  OpenBowl::default_instance_->InitAsDefaultInstance();
  AddMoneyReward::default_instance_->InitAsDefaultInstance();
  GetFirstRechargeGift::default_instance_->InitAsDefaultInstance();
  ReqAccelerateAction::default_instance_->InitAsDefaultInstance();
  ReqBuyTimesAction::default_instance_->InitAsDefaultInstance();
  ReqIsMercTraining::default_instance_->InitAsDefaultInstance();
  AckOtherLevelUp::default_instance_->InitAsDefaultInstance();
  SendHeartBeatMsg::default_instance_->InitAsDefaultInstance();
  SendStoneMsg::default_instance_->InitAsDefaultInstance();
  ReqWorldBossInfo::default_instance_->InitAsDefaultInstance();
  AckWorldBossInfo::default_instance_->InitAsDefaultInstance();
  ExecuteSQL::default_instance_->InitAsDefaultInstance();
  LoadAllActivityDataReq::default_instance_->InitAsDefaultInstance();
  LoadAllActivityDataAck::default_instance_->InitAsDefaultInstance();
  LoadAllActivityDataAck_ActivityData::default_instance_->InitAsDefaultInstance();
  CanGetFirstRechargeReward::default_instance_->InitAsDefaultInstance();
  LoadAllSysBroadcastDataReq::default_instance_->InitAsDefaultInstance();
  LoadAllSysBroadcastDataAck::default_instance_->InitAsDefaultInstance();
  LoadAllSysBroadcastDataAck_SysBroadcastData::default_instance_->InitAsDefaultInstance();
  QueryAccidByAccnameReq::default_instance_->InitAsDefaultInstance();
  QueryAccidByAccnameAck::default_instance_->InitAsDefaultInstance();
  PkBattle::default_instance_->InitAsDefaultInstance();
  HorseData::default_instance_->InitAsDefaultInstance();
  HorseData_HorseAttr::default_instance_->InitAsDefaultInstance();
  GetHorseDataReq::default_instance_->InitAsDefaultInstance();
  GetHorseDataAck::default_instance_->InitAsDefaultInstance();
  HorseGroomReq::default_instance_->InitAsDefaultInstance();
  HorseGroomAck::default_instance_->InitAsDefaultInstance();
  BuyHorseFeedCountReq::default_instance_->InitAsDefaultInstance();
  BuyHorseFeedCountAck::default_instance_->InitAsDefaultInstance();
  HorseShowChangeReq::default_instance_->InitAsDefaultInstance();
  HorseShowChangeAck::default_instance_->InitAsDefaultInstance();
  HorseChangeSys::default_instance_->InitAsDefaultInstance();
  LoadAllHorseDataReq::default_instance_->InitAsDefaultInstance();
  LoadAllHorseDataAck::default_instance_->InitAsDefaultInstance();
  ReqStopQuickDestiny::default_instance_->InitAsDefaultInstance();
  PlatScrollReq::default_instance_->InitAsDefaultInstance();
  PlatScrollAck::default_instance_->InitAsDefaultInstance();
  ReqGetVipLevelReward::default_instance_->InitAsDefaultInstance();
  SaveBattleInfo::default_instance_->InitAsDefaultInstance();
  ReqViewBattleHistory::default_instance_->InitAsDefaultInstance();
  ReqGetBattleHistoryData::default_instance_->InitAsDefaultInstance();
  BattleHistoryInfo::default_instance_->InitAsDefaultInstance();
  EnterActiveReq::default_instance_->InitAsDefaultInstance();
  EnterActiveAck::default_instance_->InitAsDefaultInstance();
  OpenTreasureUIReq::default_instance_->InitAsDefaultInstance();
  OpenTreasureUIAck::default_instance_->InitAsDefaultInstance();
  GetTreasureReq::default_instance_->InitAsDefaultInstance();
  GetTreasureAck::default_instance_->InitAsDefaultInstance();
  ResetAck::default_instance_->InitAsDefaultInstance();
  AddEquipStarReq::default_instance_->InitAsDefaultInstance();
  AddEquipStarAck::default_instance_->InitAsDefaultInstance();
  GetRoleMailInfoReq::default_instance_->InitAsDefaultInstance();
  SelectMailInfoReq::default_instance_->InitAsDefaultInstance();
  RoleMailInfo::default_instance_->InitAsDefaultInstance();
  ReadMailReq::default_instance_->InitAsDefaultInstance();
  ReadMailAck::default_instance_->InitAsDefaultInstance();
  GetMailRewardReq::default_instance_->InitAsDefaultInstance();
  GetMailRewardAck::default_instance_->InitAsDefaultInstance();
  SendGMMailReq::default_instance_->InitAsDefaultInstance();
  SendGMMailAck::default_instance_->InitAsDefaultInstance();
  NewMailNotice::default_instance_->InitAsDefaultInstance();
  SelectMailInfoAck::default_instance_->InitAsDefaultInstance();
  GetSkillInfoReq::default_instance_->InitAsDefaultInstance();
  GetSkillInfoAck::default_instance_->InitAsDefaultInstance();
  EquipUpgradeItemReq::default_instance_->InitAsDefaultInstance();
  UnlockedSkill::default_instance_->InitAsDefaultInstance();
  ReqGetLastPvpRewardTime::default_instance_->InitAsDefaultInstance();
  PvpRewardTimeAck::default_instance_->InitAsDefaultInstance();
  GetClimbTowerEnemyReq::default_instance_->InitAsDefaultInstance();
  SelectClimbTowerEnemy::default_instance_->InitAsDefaultInstance();
  ClimbTowerEnemyData::default_instance_->InitAsDefaultInstance();
  GetClimbTowerEnemyAck::default_instance_->InitAsDefaultInstance();
  GetClimbTowerEnemyAck_MercInfo::default_instance_->InitAsDefaultInstance();
  GetClimbTowerRewardReq::default_instance_->InitAsDefaultInstance();
  GetClimbTowerRewardAck::default_instance_->InitAsDefaultInstance();
  ReliveMercReq::default_instance_->InitAsDefaultInstance();
  ReliveMercAck::default_instance_->InitAsDefaultInstance();
  ResetClimbTowerReq::default_instance_->InitAsDefaultInstance();
  ClimbTowerBattleResult::default_instance_->InitAsDefaultInstance();
  ClimbTowerBattleResult_SaveData::default_instance_->InitAsDefaultInstance();
  SaveCTEnemyInfo::default_instance_->InitAsDefaultInstance();
  SendPvpRankRiseAwards::default_instance_->InitAsDefaultInstance();
  VipOperResult::default_instance_->InitAsDefaultInstance();
  ItemCombineReq::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Message_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Message_2eproto_once_);
void protobuf_AddDesc_Message_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Message_2eproto_once_,
                 &protobuf_AddDesc_Message_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Message_2eproto {
  StaticDescriptorInitializer_Message_2eproto() {
    protobuf_AddDesc_Message_2eproto();
  }
} static_descriptor_initializer_Message_2eproto_;
#endif
bool MessageNode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int GateIpPortInfo::kGateIdFieldNumber;
const int GateIpPortInfo::kGateIpFieldNumber;
const int GateIpPortInfo::kGatePortFieldNumber;
#endif  // !_MSC_VER

GateIpPortInfo::GateIpPortInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateIpPortInfo::InitAsDefaultInstance() {
}

GateIpPortInfo::GateIpPortInfo(const GateIpPortInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateIpPortInfo::SharedCtor() {
  _cached_size_ = 0;
  gate_id_ = 0u;
  gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gate_port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateIpPortInfo::~GateIpPortInfo() {
  SharedDtor();
}

void GateIpPortInfo::SharedDtor() {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete gate_ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateIpPortInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateIpPortInfo& GateIpPortInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateIpPortInfo* GateIpPortInfo::default_instance_ = NULL;

GateIpPortInfo* GateIpPortInfo::New() const {
  return new GateIpPortInfo;
}

void GateIpPortInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gate_id_ = 0u;
    if (has_gate_ip()) {
      if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
        gate_ip_->clear();
      }
    }
    gate_port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateIpPortInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 gate_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gate_id_)));
          set_has_gate_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_gate_ip;
        break;
      }

      // required string gate_ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gate_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gate_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_gate_port;
        break;
      }

      // required uint32 gate_port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gate_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gate_port_)));
          set_has_gate_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GateIpPortInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 gate_id = 1;
  if (has_gate_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->gate_id(), output);
  }

  // required string gate_ip = 2;
  if (has_gate_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->gate_ip(), output);
  }

  // required uint32 gate_port = 3;
  if (has_gate_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->gate_port(), output);
  }

}

int GateIpPortInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 gate_id = 1;
    if (has_gate_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gate_id());
    }

    // required string gate_ip = 2;
    if (has_gate_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gate_ip());
    }

    // required uint32 gate_port = 3;
    if (has_gate_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gate_port());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateIpPortInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateIpPortInfo*>(&from));
}

void GateIpPortInfo::MergeFrom(const GateIpPortInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gate_id()) {
      set_gate_id(from.gate_id());
    }
    if (from.has_gate_ip()) {
      set_gate_ip(from.gate_ip());
    }
    if (from.has_gate_port()) {
      set_gate_port(from.gate_port());
    }
  }
}

void GateIpPortInfo::CopyFrom(const GateIpPortInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateIpPortInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GateIpPortInfo::Swap(GateIpPortInfo* other) {
  if (other != this) {
    std::swap(gate_id_, other->gate_id_);
    std::swap(gate_ip_, other->gate_ip_);
    std::swap(gate_port_, other->gate_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateIpPortInfo::GetTypeName() const {
  return "message.GateIpPortInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int VersionInfoRequest::kVerReleaseFieldNumber;
const int VersionInfoRequest::kVerFreezeFieldNumber;
const int VersionInfoRequest::kVerDevelopmentFieldNumber;
const int VersionInfoRequest::kVerPatchFieldNumber;
const int VersionInfoRequest::kVerTypeFieldNumber;
const int VersionInfoRequest::kVerNoFieldNumber;
#endif  // !_MSC_VER

VersionInfoRequest::VersionInfoRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VersionInfoRequest::InitAsDefaultInstance() {
}

VersionInfoRequest::VersionInfoRequest(const VersionInfoRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VersionInfoRequest::SharedCtor() {
  _cached_size_ = 0;
  ver_release_ = 0u;
  ver_freeze_ = 0u;
  ver_development_ = 0u;
  ver_patch_ = 0u;
  ver_type_ = 0u;
  ver_no_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionInfoRequest::~VersionInfoRequest() {
  SharedDtor();
}

void VersionInfoRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VersionInfoRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VersionInfoRequest& VersionInfoRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

VersionInfoRequest* VersionInfoRequest::default_instance_ = NULL;

VersionInfoRequest* VersionInfoRequest::New() const {
  return new VersionInfoRequest;
}

void VersionInfoRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ver_release_ = 0u;
    ver_freeze_ = 0u;
    ver_development_ = 0u;
    ver_patch_ = 0u;
    ver_type_ = 0u;
    ver_no_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VersionInfoRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ver_release = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ver_release_)));
          set_has_ver_release();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ver_freeze;
        break;
      }

      // required uint32 ver_freeze = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ver_freeze:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ver_freeze_)));
          set_has_ver_freeze();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ver_development;
        break;
      }

      // required uint32 ver_development = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ver_development:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ver_development_)));
          set_has_ver_development();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ver_patch;
        break;
      }

      // required uint32 ver_patch = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ver_patch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ver_patch_)));
          set_has_ver_patch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ver_type;
        break;
      }

      // optional uint32 ver_type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ver_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ver_type_)));
          set_has_ver_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_ver_no;
        break;
      }

      // optional uint32 ver_no = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ver_no:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ver_no_)));
          set_has_ver_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VersionInfoRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ver_release = 1;
  if (has_ver_release()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ver_release(), output);
  }

  // required uint32 ver_freeze = 2;
  if (has_ver_freeze()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ver_freeze(), output);
  }

  // required uint32 ver_development = 3;
  if (has_ver_development()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->ver_development(), output);
  }

  // required uint32 ver_patch = 4;
  if (has_ver_patch()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->ver_patch(), output);
  }

  // optional uint32 ver_type = 5;
  if (has_ver_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->ver_type(), output);
  }

  // optional uint32 ver_no = 6;
  if (has_ver_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->ver_no(), output);
  }

}

int VersionInfoRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ver_release = 1;
    if (has_ver_release()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ver_release());
    }

    // required uint32 ver_freeze = 2;
    if (has_ver_freeze()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ver_freeze());
    }

    // required uint32 ver_development = 3;
    if (has_ver_development()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ver_development());
    }

    // required uint32 ver_patch = 4;
    if (has_ver_patch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ver_patch());
    }

    // optional uint32 ver_type = 5;
    if (has_ver_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ver_type());
    }

    // optional uint32 ver_no = 6;
    if (has_ver_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ver_no());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionInfoRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VersionInfoRequest*>(&from));
}

void VersionInfoRequest::MergeFrom(const VersionInfoRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ver_release()) {
      set_ver_release(from.ver_release());
    }
    if (from.has_ver_freeze()) {
      set_ver_freeze(from.ver_freeze());
    }
    if (from.has_ver_development()) {
      set_ver_development(from.ver_development());
    }
    if (from.has_ver_patch()) {
      set_ver_patch(from.ver_patch());
    }
    if (from.has_ver_type()) {
      set_ver_type(from.ver_type());
    }
    if (from.has_ver_no()) {
      set_ver_no(from.ver_no());
    }
  }
}

void VersionInfoRequest::CopyFrom(const VersionInfoRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionInfoRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void VersionInfoRequest::Swap(VersionInfoRequest* other) {
  if (other != this) {
    std::swap(ver_release_, other->ver_release_);
    std::swap(ver_freeze_, other->ver_freeze_);
    std::swap(ver_development_, other->ver_development_);
    std::swap(ver_patch_, other->ver_patch_);
    std::swap(ver_type_, other->ver_type_);
    std::swap(ver_no_, other->ver_no_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VersionInfoRequest::GetTypeName() const {
  return "message.VersionInfoRequest";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

VersionInfoResponse::VersionInfoResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VersionInfoResponse::InitAsDefaultInstance() {
}

VersionInfoResponse::VersionInfoResponse(const VersionInfoResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VersionInfoResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionInfoResponse::~VersionInfoResponse() {
  SharedDtor();
}

void VersionInfoResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VersionInfoResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VersionInfoResponse& VersionInfoResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

VersionInfoResponse* VersionInfoResponse::default_instance_ = NULL;

VersionInfoResponse* VersionInfoResponse::New() const {
  return new VersionInfoResponse;
}

void VersionInfoResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VersionInfoResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void VersionInfoResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int VersionInfoResponse::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionInfoResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VersionInfoResponse*>(&from));
}

void VersionInfoResponse::MergeFrom(const VersionInfoResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void VersionInfoResponse::CopyFrom(const VersionInfoResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionInfoResponse::IsInitialized() const {

  return true;
}

void VersionInfoResponse::Swap(VersionInfoResponse* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VersionInfoResponse::GetTypeName() const {
  return "message.VersionInfoResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginAuthSys::kAccIdFieldNumber;
const int LoginAuthSys::kSessionStrFieldNumber;
const int LoginAuthSys::kUserNameFieldNumber;
const int LoginAuthSys::kUserPassFieldNumber;
const int LoginAuthSys::kGmCheckFieldNumber;
#endif  // !_MSC_VER

LoginAuthSys::LoginAuthSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginAuthSys::InitAsDefaultInstance() {
}

LoginAuthSys::LoginAuthSys(const LoginAuthSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginAuthSys::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0;
  session_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gm_check_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginAuthSys::~LoginAuthSys() {
  SharedDtor();
}

void LoginAuthSys::SharedDtor() {
  if (session_str_ != &::google::protobuf::internal::kEmptyString) {
    delete session_str_;
  }
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
    delete user_pass_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginAuthSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginAuthSys& LoginAuthSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginAuthSys* LoginAuthSys::default_instance_ = NULL;

LoginAuthSys* LoginAuthSys::New() const {
  return new LoginAuthSys;
}

void LoginAuthSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0;
    if (has_session_str()) {
      if (session_str_ != &::google::protobuf::internal::kEmptyString) {
        session_str_->clear();
      }
    }
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    if (has_user_pass()) {
      if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
        user_pass_->clear();
      }
    }
    gm_check_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginAuthSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_session_str;
        break;
      }

      // required string session_str = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_session_str:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_session_str()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_name;
        break;
      }

      // optional bytes user_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_user_pass;
        break;
      }

      // optional bytes user_pass = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_pass:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_pass()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_gm_check;
        break;
      }

      // optional uint32 gm_check = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gm_check:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_check_)));
          set_has_gm_check();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginAuthSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->acc_id(), output);
  }

  // required string session_str = 2;
  if (has_session_str()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->session_str(), output);
  }

  // optional bytes user_name = 3;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->user_name(), output);
  }

  // optional bytes user_pass = 4;
  if (has_user_pass()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->user_pass(), output);
  }

  // optional uint32 gm_check = 5;
  if (has_gm_check()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->gm_check(), output);
  }

}

int LoginAuthSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->acc_id());
    }

    // required string session_str = 2;
    if (has_session_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->session_str());
    }

    // optional bytes user_name = 3;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_name());
    }

    // optional bytes user_pass = 4;
    if (has_user_pass()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_pass());
    }

    // optional uint32 gm_check = 5;
    if (has_gm_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_check());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginAuthSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginAuthSys*>(&from));
}

void LoginAuthSys::MergeFrom(const LoginAuthSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_session_str()) {
      set_session_str(from.session_str());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_user_pass()) {
      set_user_pass(from.user_pass());
    }
    if (from.has_gm_check()) {
      set_gm_check(from.gm_check());
    }
  }
}

void LoginAuthSys::CopyFrom(const LoginAuthSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginAuthSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void LoginAuthSys::Swap(LoginAuthSys* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(session_str_, other->session_str_);
    std::swap(user_name_, other->user_name_);
    std::swap(user_pass_, other->user_pass_);
    std::swap(gm_check_, other->gm_check_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginAuthSys::GetTypeName() const {
  return "message.LoginAuthSys";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginCenterAuthReq::kUserNameFieldNumber;
const int LoginCenterAuthReq::kUserPassFieldNumber;
const int LoginCenterAuthReq::kUserIpFieldNumber;
const int LoginCenterAuthReq::kGmCheckFieldNumber;
#endif  // !_MSC_VER

LoginCenterAuthReq::LoginCenterAuthReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginCenterAuthReq::InitAsDefaultInstance() {
}

LoginCenterAuthReq::LoginCenterAuthReq(const LoginCenterAuthReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginCenterAuthReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gm_check_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginCenterAuthReq::~LoginCenterAuthReq() {
  SharedDtor();
}

void LoginCenterAuthReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
    delete user_pass_;
  }
  if (user_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete user_ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginCenterAuthReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginCenterAuthReq& LoginCenterAuthReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginCenterAuthReq* LoginCenterAuthReq::default_instance_ = NULL;

LoginCenterAuthReq* LoginCenterAuthReq::New() const {
  return new LoginCenterAuthReq;
}

void LoginCenterAuthReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    if (has_user_pass()) {
      if (user_pass_ != &::google::protobuf::internal::kEmptyString) {
        user_pass_->clear();
      }
    }
    if (has_user_ip()) {
      if (user_ip_ != &::google::protobuf::internal::kEmptyString) {
        user_ip_->clear();
      }
    }
    gm_check_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginCenterAuthReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_pass;
        break;
      }

      // optional bytes user_pass = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_pass:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_pass()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_ip;
        break;
      }

      // optional bytes user_ip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_gm_check;
        break;
      }

      // optional uint32 gm_check = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gm_check:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_check_)));
          set_has_gm_check();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginCenterAuthReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->user_name(), output);
  }

  // optional bytes user_pass = 2;
  if (has_user_pass()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->user_pass(), output);
  }

  // optional bytes user_ip = 3;
  if (has_user_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->user_ip(), output);
  }

  // optional uint32 gm_check = 4;
  if (has_gm_check()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->gm_check(), output);
  }

}

int LoginCenterAuthReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_name());
    }

    // optional bytes user_pass = 2;
    if (has_user_pass()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_pass());
    }

    // optional bytes user_ip = 3;
    if (has_user_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_ip());
    }

    // optional uint32 gm_check = 4;
    if (has_gm_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_check());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginCenterAuthReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginCenterAuthReq*>(&from));
}

void LoginCenterAuthReq::MergeFrom(const LoginCenterAuthReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_user_pass()) {
      set_user_pass(from.user_pass());
    }
    if (from.has_user_ip()) {
      set_user_ip(from.user_ip());
    }
    if (from.has_gm_check()) {
      set_gm_check(from.gm_check());
    }
  }
}

void LoginCenterAuthReq::CopyFrom(const LoginCenterAuthReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginCenterAuthReq::IsInitialized() const {

  return true;
}

void LoginCenterAuthReq::Swap(LoginCenterAuthReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(user_pass_, other->user_pass_);
    std::swap(user_ip_, other->user_ip_);
    std::swap(gm_check_, other->gm_check_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginCenterAuthReq::GetTypeName() const {
  return "message.LoginCenterAuthReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CenterGateState_CenterGateStateInfo::kServerIdFieldNumber;
const int CenterGateState_CenterGateStateInfo::kServerStateFieldNumber;
#endif  // !_MSC_VER

CenterGateState_CenterGateStateInfo::CenterGateState_CenterGateStateInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CenterGateState_CenterGateStateInfo::InitAsDefaultInstance() {
}

CenterGateState_CenterGateStateInfo::CenterGateState_CenterGateStateInfo(const CenterGateState_CenterGateStateInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CenterGateState_CenterGateStateInfo::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0u;
  server_state_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CenterGateState_CenterGateStateInfo::~CenterGateState_CenterGateStateInfo() {
  SharedDtor();
}

void CenterGateState_CenterGateStateInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CenterGateState_CenterGateStateInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CenterGateState_CenterGateStateInfo& CenterGateState_CenterGateStateInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CenterGateState_CenterGateStateInfo* CenterGateState_CenterGateStateInfo::default_instance_ = NULL;

CenterGateState_CenterGateStateInfo* CenterGateState_CenterGateStateInfo::New() const {
  return new CenterGateState_CenterGateStateInfo;
}

void CenterGateState_CenterGateStateInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0u;
    server_state_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CenterGateState_CenterGateStateInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_server_state;
        break;
      }

      // required uint32 server_state = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_state_)));
          set_has_server_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CenterGateState_CenterGateStateInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->server_id(), output);
  }

  // required uint32 server_state = 2;
  if (has_server_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->server_state(), output);
  }

}

int CenterGateState_CenterGateStateInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // required uint32 server_state = 2;
    if (has_server_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_state());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CenterGateState_CenterGateStateInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CenterGateState_CenterGateStateInfo*>(&from));
}

void CenterGateState_CenterGateStateInfo::MergeFrom(const CenterGateState_CenterGateStateInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_server_state()) {
      set_server_state(from.server_state());
    }
  }
}

void CenterGateState_CenterGateStateInfo::CopyFrom(const CenterGateState_CenterGateStateInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CenterGateState_CenterGateStateInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CenterGateState_CenterGateStateInfo::Swap(CenterGateState_CenterGateStateInfo* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    std::swap(server_state_, other->server_state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CenterGateState_CenterGateStateInfo::GetTypeName() const {
  return "message.CenterGateState.CenterGateStateInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CenterGateState::kServerStateInfoFieldNumber;
#endif  // !_MSC_VER

CenterGateState::CenterGateState()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CenterGateState::InitAsDefaultInstance() {
}

CenterGateState::CenterGateState(const CenterGateState& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CenterGateState::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CenterGateState::~CenterGateState() {
  SharedDtor();
}

void CenterGateState::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CenterGateState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CenterGateState& CenterGateState::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CenterGateState* CenterGateState::default_instance_ = NULL;

CenterGateState* CenterGateState::New() const {
  return new CenterGateState;
}

void CenterGateState::Clear() {
  server_state_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CenterGateState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.CenterGateState.CenterGateStateInfo server_state_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server_state_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_server_state_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_server_state_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CenterGateState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.CenterGateState.CenterGateStateInfo server_state_info = 1;
  for (int i = 0; i < this->server_state_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->server_state_info(i), output);
  }

}

int CenterGateState::ByteSize() const {
  int total_size = 0;

  // repeated .message.CenterGateState.CenterGateStateInfo server_state_info = 1;
  total_size += 1 * this->server_state_info_size();
  for (int i = 0; i < this->server_state_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->server_state_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CenterGateState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CenterGateState*>(&from));
}

void CenterGateState::MergeFrom(const CenterGateState& from) {
  GOOGLE_CHECK_NE(&from, this);
  server_state_info_.MergeFrom(from.server_state_info_);
}

void CenterGateState::CopyFrom(const CenterGateState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CenterGateState::IsInitialized() const {

  for (int i = 0; i < server_state_info_size(); i++) {
    if (!this->server_state_info(i).IsInitialized()) return false;
  }
  return true;
}

void CenterGateState::Swap(CenterGateState* other) {
  if (other != this) {
    server_state_info_.Swap(&other->server_state_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CenterGateState::GetTypeName() const {
  return "message.CenterGateState";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginCenterAuthAck::kAccIdFieldNumber;
const int LoginCenterAuthAck::kUserNameFieldNumber;
const int LoginCenterAuthAck::kResultFieldNumber;
const int LoginCenterAuthAck::kLastServerFieldNumber;
#endif  // !_MSC_VER

LoginCenterAuthAck::LoginCenterAuthAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginCenterAuthAck::InitAsDefaultInstance() {
}

LoginCenterAuthAck::LoginCenterAuthAck(const LoginCenterAuthAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginCenterAuthAck::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  result_ = 0;
  last_server_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginCenterAuthAck::~LoginCenterAuthAck() {
  SharedDtor();
}

void LoginCenterAuthAck::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginCenterAuthAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginCenterAuthAck& LoginCenterAuthAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginCenterAuthAck* LoginCenterAuthAck::default_instance_ = NULL;

LoginCenterAuthAck* LoginCenterAuthAck::New() const {
  return new LoginCenterAuthAck;
}

void LoginCenterAuthAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0;
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    result_ = 0;
    last_server_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginCenterAuthAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // optional bytes user_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_result;
        break;
      }

      // required int32 result = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_last_server;
        break;
      }

      // required int32 last_server = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_last_server:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &last_server_)));
          set_has_last_server();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginCenterAuthAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->acc_id(), output);
  }

  // optional bytes user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->user_name(), output);
  }

  // required int32 result = 3;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->result(), output);
  }

  // required int32 last_server = 4;
  if (has_last_server()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->last_server(), output);
  }

}

int LoginCenterAuthAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->acc_id());
    }

    // optional bytes user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_name());
    }

    // required int32 result = 3;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // required int32 last_server = 4;
    if (has_last_server()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->last_server());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginCenterAuthAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginCenterAuthAck*>(&from));
}

void LoginCenterAuthAck::MergeFrom(const LoginCenterAuthAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_last_server()) {
      set_last_server(from.last_server());
    }
  }
}

void LoginCenterAuthAck::CopyFrom(const LoginCenterAuthAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginCenterAuthAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  return true;
}

void LoginCenterAuthAck::Swap(LoginCenterAuthAck* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(user_name_, other->user_name_);
    std::swap(result_, other->result_);
    std::swap(last_server_, other->last_server_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginCenterAuthAck::GetTypeName() const {
  return "message.LoginCenterAuthAck";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginCenterCharInfo_LoginServerCharInfo::kServerIdFieldNumber;
const int LoginCenterCharInfo_LoginServerCharInfo::kCharJobFieldNumber;
const int LoginCenterCharInfo_LoginServerCharInfo::kCharLevelFieldNumber;
const int LoginCenterCharInfo_LoginServerCharInfo::kCharSexFieldNumber;
const int LoginCenterCharInfo_LoginServerCharInfo::kGmTypeFieldNumber;
#endif  // !_MSC_VER

LoginCenterCharInfo_LoginServerCharInfo::LoginCenterCharInfo_LoginServerCharInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginCenterCharInfo_LoginServerCharInfo::InitAsDefaultInstance() {
}

LoginCenterCharInfo_LoginServerCharInfo::LoginCenterCharInfo_LoginServerCharInfo(const LoginCenterCharInfo_LoginServerCharInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginCenterCharInfo_LoginServerCharInfo::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0u;
  char_job_ = 0u;
  char_level_ = 0u;
  char_sex_ = 0u;
  gm_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginCenterCharInfo_LoginServerCharInfo::~LoginCenterCharInfo_LoginServerCharInfo() {
  SharedDtor();
}

void LoginCenterCharInfo_LoginServerCharInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginCenterCharInfo_LoginServerCharInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginCenterCharInfo_LoginServerCharInfo& LoginCenterCharInfo_LoginServerCharInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginCenterCharInfo_LoginServerCharInfo* LoginCenterCharInfo_LoginServerCharInfo::default_instance_ = NULL;

LoginCenterCharInfo_LoginServerCharInfo* LoginCenterCharInfo_LoginServerCharInfo::New() const {
  return new LoginCenterCharInfo_LoginServerCharInfo;
}

void LoginCenterCharInfo_LoginServerCharInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0u;
    char_job_ = 0u;
    char_level_ = 0u;
    char_sex_ = 0u;
    gm_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginCenterCharInfo_LoginServerCharInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_job;
        break;
      }

      // required uint32 char_job = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_job_)));
          set_has_char_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_char_level;
        break;
      }

      // required uint32 char_level = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_level_)));
          set_has_char_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_char_sex;
        break;
      }

      // required uint32 char_sex = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_sex_)));
          set_has_char_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_gm_type;
        break;
      }

      // required uint32 gm_type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gm_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_type_)));
          set_has_gm_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginCenterCharInfo_LoginServerCharInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->server_id(), output);
  }

  // required uint32 char_job = 2;
  if (has_char_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_job(), output);
  }

  // required uint32 char_level = 3;
  if (has_char_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->char_level(), output);
  }

  // required uint32 char_sex = 4;
  if (has_char_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->char_sex(), output);
  }

  // required uint32 gm_type = 5;
  if (has_gm_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->gm_type(), output);
  }

}

int LoginCenterCharInfo_LoginServerCharInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // required uint32 char_job = 2;
    if (has_char_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_job());
    }

    // required uint32 char_level = 3;
    if (has_char_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_level());
    }

    // required uint32 char_sex = 4;
    if (has_char_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_sex());
    }

    // required uint32 gm_type = 5;
    if (has_gm_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginCenterCharInfo_LoginServerCharInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginCenterCharInfo_LoginServerCharInfo*>(&from));
}

void LoginCenterCharInfo_LoginServerCharInfo::MergeFrom(const LoginCenterCharInfo_LoginServerCharInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_char_job()) {
      set_char_job(from.char_job());
    }
    if (from.has_char_level()) {
      set_char_level(from.char_level());
    }
    if (from.has_char_sex()) {
      set_char_sex(from.char_sex());
    }
    if (from.has_gm_type()) {
      set_gm_type(from.gm_type());
    }
  }
}

void LoginCenterCharInfo_LoginServerCharInfo::CopyFrom(const LoginCenterCharInfo_LoginServerCharInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginCenterCharInfo_LoginServerCharInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void LoginCenterCharInfo_LoginServerCharInfo::Swap(LoginCenterCharInfo_LoginServerCharInfo* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    std::swap(char_job_, other->char_job_);
    std::swap(char_level_, other->char_level_);
    std::swap(char_sex_, other->char_sex_);
    std::swap(gm_type_, other->gm_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginCenterCharInfo_LoginServerCharInfo::GetTypeName() const {
  return "message.LoginCenterCharInfo.LoginServerCharInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LoginCenterCharInfo::kAccIdFieldNumber;
const int LoginCenterCharInfo::kAccNameFieldNumber;
const int LoginCenterCharInfo::kServerCharInfoFieldNumber;
#endif  // !_MSC_VER

LoginCenterCharInfo::LoginCenterCharInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginCenterCharInfo::InitAsDefaultInstance() {
}

LoginCenterCharInfo::LoginCenterCharInfo(const LoginCenterCharInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginCenterCharInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  acc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginCenterCharInfo::~LoginCenterCharInfo() {
  SharedDtor();
}

void LoginCenterCharInfo::SharedDtor() {
  if (acc_name_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginCenterCharInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginCenterCharInfo& LoginCenterCharInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginCenterCharInfo* LoginCenterCharInfo::default_instance_ = NULL;

LoginCenterCharInfo* LoginCenterCharInfo::New() const {
  return new LoginCenterCharInfo;
}

void LoginCenterCharInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    if (has_acc_name()) {
      if (acc_name_ != &::google::protobuf::internal::kEmptyString) {
        acc_name_->clear();
      }
    }
  }
  server_char_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginCenterCharInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_acc_name;
        break;
      }

      // optional bytes acc_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_acc_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_acc_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_server_char_info;
        break;
      }

      // repeated .message.LoginCenterCharInfo.LoginServerCharInfo server_char_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server_char_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_server_char_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_server_char_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginCenterCharInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // optional bytes acc_name = 2;
  if (has_acc_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->acc_name(), output);
  }

  // repeated .message.LoginCenterCharInfo.LoginServerCharInfo server_char_info = 3;
  for (int i = 0; i < this->server_char_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->server_char_info(i), output);
  }

}

int LoginCenterCharInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional bytes acc_name = 2;
    if (has_acc_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->acc_name());
    }

  }
  // repeated .message.LoginCenterCharInfo.LoginServerCharInfo server_char_info = 3;
  total_size += 1 * this->server_char_info_size();
  for (int i = 0; i < this->server_char_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->server_char_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginCenterCharInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginCenterCharInfo*>(&from));
}

void LoginCenterCharInfo::MergeFrom(const LoginCenterCharInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  server_char_info_.MergeFrom(from.server_char_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_acc_name()) {
      set_acc_name(from.acc_name());
    }
  }
}

void LoginCenterCharInfo::CopyFrom(const LoginCenterCharInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginCenterCharInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < server_char_info_size(); i++) {
    if (!this->server_char_info(i).IsInitialized()) return false;
  }
  return true;
}

void LoginCenterCharInfo::Swap(LoginCenterCharInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(acc_name_, other->acc_name_);
    server_char_info_.Swap(&other->server_char_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginCenterCharInfo::GetTypeName() const {
  return "message.LoginCenterCharInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginAuthAck::kAccIdFieldNumber;
#endif  // !_MSC_VER

LoginAuthAck::LoginAuthAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginAuthAck::InitAsDefaultInstance() {
}

LoginAuthAck::LoginAuthAck(const LoginAuthAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginAuthAck::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginAuthAck::~LoginAuthAck() {
  SharedDtor();
}

void LoginAuthAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginAuthAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginAuthAck& LoginAuthAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginAuthAck* LoginAuthAck::default_instance_ = NULL;

LoginAuthAck* LoginAuthAck::New() const {
  return new LoginAuthAck;
}

void LoginAuthAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginAuthAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginAuthAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

}

int LoginAuthAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginAuthAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginAuthAck*>(&from));
}

void LoginAuthAck::MergeFrom(const LoginAuthAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void LoginAuthAck::CopyFrom(const LoginAuthAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginAuthAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginAuthAck::Swap(LoginAuthAck* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginAuthAck::GetTypeName() const {
  return "message.LoginAuthAck";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginAuthNack::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

LoginAuthNack::LoginAuthNack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginAuthNack::InitAsDefaultInstance() {
}

LoginAuthNack::LoginAuthNack(const LoginAuthNack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginAuthNack::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginAuthNack::~LoginAuthNack() {
  SharedDtor();
}

void LoginAuthNack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginAuthNack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginAuthNack& LoginAuthNack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginAuthNack* LoginAuthNack::default_instance_ = NULL;

LoginAuthNack* LoginAuthNack::New() const {
  return new LoginAuthNack;
}

void LoginAuthNack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginAuthNack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginAuthNack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

}

int LoginAuthNack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginAuthNack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginAuthNack*>(&from));
}

void LoginAuthNack::MergeFrom(const LoginAuthNack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void LoginAuthNack::CopyFrom(const LoginAuthNack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginAuthNack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginAuthNack::Swap(LoginAuthNack* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginAuthNack::GetTypeName() const {
  return "message.LoginAuthNack";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginServerList_LoginServerInfo::kServerIdFieldNumber;
const int LoginServerList_LoginServerInfo::kServerNameFieldNumber;
const int LoginServerList_LoginServerInfo::kServerStateFieldNumber;
const int LoginServerList_LoginServerInfo::kServerNewFieldNumber;
const int LoginServerList_LoginServerInfo::kCharJobFieldNumber;
const int LoginServerList_LoginServerInfo::kCharLevelFieldNumber;
const int LoginServerList_LoginServerInfo::kServerPlayerCountFieldNumber;
const int LoginServerList_LoginServerInfo::kCharSexFieldNumber;
const int LoginServerList_LoginServerInfo::kGmTypeFieldNumber;
#endif  // !_MSC_VER

LoginServerList_LoginServerInfo::LoginServerList_LoginServerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginServerList_LoginServerInfo::InitAsDefaultInstance() {
}

LoginServerList_LoginServerInfo::LoginServerList_LoginServerInfo(const LoginServerList_LoginServerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginServerList_LoginServerInfo::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0u;
  server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  server_state_ = 0u;
  server_new_ = 0u;
  char_job_ = 0u;
  char_level_ = 0u;
  server_player_count_ = 0u;
  char_sex_ = 0u;
  gm_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginServerList_LoginServerInfo::~LoginServerList_LoginServerInfo() {
  SharedDtor();
}

void LoginServerList_LoginServerInfo::SharedDtor() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginServerList_LoginServerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginServerList_LoginServerInfo& LoginServerList_LoginServerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginServerList_LoginServerInfo* LoginServerList_LoginServerInfo::default_instance_ = NULL;

LoginServerList_LoginServerInfo* LoginServerList_LoginServerInfo::New() const {
  return new LoginServerList_LoginServerInfo;
}

void LoginServerList_LoginServerInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0u;
    if (has_server_name()) {
      if (server_name_ != &::google::protobuf::internal::kEmptyString) {
        server_name_->clear();
      }
    }
    server_state_ = 0u;
    server_new_ = 0u;
    char_job_ = 0u;
    char_level_ = 0u;
    server_player_count_ = 0u;
    char_sex_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    gm_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginServerList_LoginServerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_server_name;
        break;
      }

      // optional bytes server_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_server_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_server_state;
        break;
      }

      // optional uint32 server_state = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_state_)));
          set_has_server_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_server_new;
        break;
      }

      // optional uint32 server_new = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_new:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_new_)));
          set_has_server_new();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_char_job;
        break;
      }

      // optional uint32 char_job = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_job_)));
          set_has_char_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_char_level;
        break;
      }

      // optional uint32 char_level = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_level_)));
          set_has_char_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_server_player_count;
        break;
      }

      // optional uint32 server_player_count = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_player_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_player_count_)));
          set_has_server_player_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_char_sex;
        break;
      }

      // optional uint32 char_sex = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_sex_)));
          set_has_char_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_gm_type;
        break;
      }

      // optional uint32 gm_type = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gm_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_type_)));
          set_has_gm_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginServerList_LoginServerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->server_id(), output);
  }

  // optional bytes server_name = 2;
  if (has_server_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->server_name(), output);
  }

  // optional uint32 server_state = 3;
  if (has_server_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->server_state(), output);
  }

  // optional uint32 server_new = 4;
  if (has_server_new()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->server_new(), output);
  }

  // optional uint32 char_job = 5;
  if (has_char_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->char_job(), output);
  }

  // optional uint32 char_level = 6;
  if (has_char_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->char_level(), output);
  }

  // optional uint32 server_player_count = 7;
  if (has_server_player_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->server_player_count(), output);
  }

  // optional uint32 char_sex = 8;
  if (has_char_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->char_sex(), output);
  }

  // optional uint32 gm_type = 9;
  if (has_gm_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->gm_type(), output);
  }

}

int LoginServerList_LoginServerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional bytes server_name = 2;
    if (has_server_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->server_name());
    }

    // optional uint32 server_state = 3;
    if (has_server_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_state());
    }

    // optional uint32 server_new = 4;
    if (has_server_new()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_new());
    }

    // optional uint32 char_job = 5;
    if (has_char_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_job());
    }

    // optional uint32 char_level = 6;
    if (has_char_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_level());
    }

    // optional uint32 server_player_count = 7;
    if (has_server_player_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_player_count());
    }

    // optional uint32 char_sex = 8;
    if (has_char_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_sex());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 gm_type = 9;
    if (has_gm_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginServerList_LoginServerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginServerList_LoginServerInfo*>(&from));
}

void LoginServerList_LoginServerInfo::MergeFrom(const LoginServerList_LoginServerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_server_name()) {
      set_server_name(from.server_name());
    }
    if (from.has_server_state()) {
      set_server_state(from.server_state());
    }
    if (from.has_server_new()) {
      set_server_new(from.server_new());
    }
    if (from.has_char_job()) {
      set_char_job(from.char_job());
    }
    if (from.has_char_level()) {
      set_char_level(from.char_level());
    }
    if (from.has_server_player_count()) {
      set_server_player_count(from.server_player_count());
    }
    if (from.has_char_sex()) {
      set_char_sex(from.char_sex());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_gm_type()) {
      set_gm_type(from.gm_type());
    }
  }
}

void LoginServerList_LoginServerInfo::CopyFrom(const LoginServerList_LoginServerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginServerList_LoginServerInfo::IsInitialized() const {

  return true;
}

void LoginServerList_LoginServerInfo::Swap(LoginServerList_LoginServerInfo* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    std::swap(server_name_, other->server_name_);
    std::swap(server_state_, other->server_state_);
    std::swap(server_new_, other->server_new_);
    std::swap(char_job_, other->char_job_);
    std::swap(char_level_, other->char_level_);
    std::swap(server_player_count_, other->server_player_count_);
    std::swap(char_sex_, other->char_sex_);
    std::swap(gm_type_, other->gm_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginServerList_LoginServerInfo::GetTypeName() const {
  return "message.LoginServerList.LoginServerInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LoginServerList::kServerInfoFieldNumber;
const int LoginServerList::kLastServerFieldNumber;
#endif  // !_MSC_VER

LoginServerList::LoginServerList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginServerList::InitAsDefaultInstance() {
}

LoginServerList::LoginServerList(const LoginServerList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginServerList::SharedCtor() {
  _cached_size_ = 0;
  last_server_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginServerList::~LoginServerList() {
  SharedDtor();
}

void LoginServerList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginServerList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginServerList& LoginServerList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginServerList* LoginServerList::default_instance_ = NULL;

LoginServerList* LoginServerList::New() const {
  return new LoginServerList;
}

void LoginServerList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    last_server_ = 0u;
  }
  server_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginServerList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.LoginServerList.LoginServerInfo server_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_server_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_server_info;
        if (input->ExpectTag(16)) goto parse_last_server;
        break;
      }

      // optional uint32 last_server = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_last_server:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &last_server_)));
          set_has_last_server();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginServerList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.LoginServerList.LoginServerInfo server_info = 1;
  for (int i = 0; i < this->server_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->server_info(i), output);
  }

  // optional uint32 last_server = 2;
  if (has_last_server()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->last_server(), output);
  }

}

int LoginServerList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 last_server = 2;
    if (has_last_server()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->last_server());
    }

  }
  // repeated .message.LoginServerList.LoginServerInfo server_info = 1;
  total_size += 1 * this->server_info_size();
  for (int i = 0; i < this->server_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->server_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginServerList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginServerList*>(&from));
}

void LoginServerList::MergeFrom(const LoginServerList& from) {
  GOOGLE_CHECK_NE(&from, this);
  server_info_.MergeFrom(from.server_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_last_server()) {
      set_last_server(from.last_server());
    }
  }
}

void LoginServerList::CopyFrom(const LoginServerList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginServerList::IsInitialized() const {

  return true;
}

void LoginServerList::Swap(LoginServerList* other) {
  if (other != this) {
    server_info_.Swap(&other->server_info_);
    std::swap(last_server_, other->last_server_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginServerList::GetTypeName() const {
  return "message.LoginServerList";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginServerChoose::kServerIdFieldNumber;
const int LoginServerChoose::kCharIdFieldNumber;
#endif  // !_MSC_VER

LoginServerChoose::LoginServerChoose()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginServerChoose::InitAsDefaultInstance() {
}

LoginServerChoose::LoginServerChoose(const LoginServerChoose& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginServerChoose::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0u;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginServerChoose::~LoginServerChoose() {
  SharedDtor();
}

void LoginServerChoose::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginServerChoose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginServerChoose& LoginServerChoose::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginServerChoose* LoginServerChoose::default_instance_ = NULL;

LoginServerChoose* LoginServerChoose::New() const {
  return new LoginServerChoose;
}

void LoginServerChoose::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0u;
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginServerChoose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // optional uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginServerChoose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->server_id(), output);
  }

  // optional uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

}

int LoginServerChoose::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginServerChoose::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginServerChoose*>(&from));
}

void LoginServerChoose::MergeFrom(const LoginServerChoose& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void LoginServerChoose::CopyFrom(const LoginServerChoose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginServerChoose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginServerChoose::Swap(LoginServerChoose* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginServerChoose::GetTypeName() const {
  return "message.LoginServerChoose";
}


// ===================================================================

#ifndef _MSC_VER
const int CenterServerChoose::kServerIdFieldNumber;
const int CenterServerChoose::kCharIdFieldNumber;
#endif  // !_MSC_VER

CenterServerChoose::CenterServerChoose()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CenterServerChoose::InitAsDefaultInstance() {
}

CenterServerChoose::CenterServerChoose(const CenterServerChoose& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CenterServerChoose::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0u;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CenterServerChoose::~CenterServerChoose() {
  SharedDtor();
}

void CenterServerChoose::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CenterServerChoose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CenterServerChoose& CenterServerChoose::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CenterServerChoose* CenterServerChoose::default_instance_ = NULL;

CenterServerChoose* CenterServerChoose::New() const {
  return new CenterServerChoose;
}

void CenterServerChoose::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0u;
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CenterServerChoose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // optional uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CenterServerChoose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->server_id(), output);
  }

  // optional uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

}

int CenterServerChoose::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CenterServerChoose::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CenterServerChoose*>(&from));
}

void CenterServerChoose::MergeFrom(const CenterServerChoose& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void CenterServerChoose::CopyFrom(const CenterServerChoose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CenterServerChoose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CenterServerChoose::Swap(CenterServerChoose* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CenterServerChoose::GetTypeName() const {
  return "message.CenterServerChoose";
}


// ===================================================================

#ifndef _MSC_VER
const int GateInfoSys::kAccIdFieldNumber;
const int GateInfoSys::kSessionIdFieldNumber;
const int GateInfoSys::kSeverIdFieldNumber;
#endif  // !_MSC_VER

GateInfoSys::GateInfoSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateInfoSys::InitAsDefaultInstance() {
}

GateInfoSys::GateInfoSys(const GateInfoSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateInfoSys::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  session_id_ = 0u;
  sever_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateInfoSys::~GateInfoSys() {
  SharedDtor();
}

void GateInfoSys::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateInfoSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateInfoSys& GateInfoSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateInfoSys* GateInfoSys::default_instance_ = NULL;

GateInfoSys* GateInfoSys::New() const {
  return new GateInfoSys;
}

void GateInfoSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    session_id_ = 0u;
    sever_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateInfoSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_session_id;
        break;
      }

      // required uint32 session_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sever_id;
        break;
      }

      // optional uint32 sever_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sever_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sever_id_)));
          set_has_sever_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GateInfoSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 session_id = 2;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->session_id(), output);
  }

  // optional uint32 sever_id = 3;
  if (has_sever_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sever_id(), output);
  }

}

int GateInfoSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 session_id = 2;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // optional uint32 sever_id = 3;
    if (has_sever_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sever_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateInfoSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateInfoSys*>(&from));
}

void GateInfoSys::MergeFrom(const GateInfoSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_sever_id()) {
      set_sever_id(from.sever_id());
    }
  }
}

void GateInfoSys::CopyFrom(const GateInfoSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateInfoSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GateInfoSys::Swap(GateInfoSys* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(session_id_, other->session_id_);
    std::swap(sever_id_, other->sever_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateInfoSys::GetTypeName() const {
  return "message.GateInfoSys";
}


// ===================================================================

#ifndef _MSC_VER
const int GateInfoNack::kSessionIdFieldNumber;
const int GateInfoNack::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

GateInfoNack::GateInfoNack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateInfoNack::InitAsDefaultInstance() {
}

GateInfoNack::GateInfoNack(const GateInfoNack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateInfoNack::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = 0u;
  error_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateInfoNack::~GateInfoNack() {
  SharedDtor();
}

void GateInfoNack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateInfoNack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateInfoNack& GateInfoNack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateInfoNack* GateInfoNack::default_instance_ = NULL;

GateInfoNack* GateInfoNack::New() const {
  return new GateInfoNack;
}

void GateInfoNack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    session_id_ = 0u;
    error_code_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateInfoNack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 session_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_error_code;
        break;
      }

      // required uint32 error_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GateInfoNack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->session_id(), output);
  }

  // required uint32 error_code = 2;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->error_code(), output);
  }

}

int GateInfoNack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // required uint32 error_code = 2;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateInfoNack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateInfoNack*>(&from));
}

void GateInfoNack::MergeFrom(const GateInfoNack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void GateInfoNack::CopyFrom(const GateInfoNack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateInfoNack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GateInfoNack::Swap(GateInfoNack* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateInfoNack::GetTypeName() const {
  return "message.GateInfoNack";
}


// ===================================================================

#ifndef _MSC_VER
const int GateInfoAck::kSessionIdFieldNumber;
const int GateInfoAck::kAccIdFieldNumber;
const int GateInfoAck::kNPortFieldNumber;
const int GateInfoAck::kSGateIpFieldNumber;
#endif  // !_MSC_VER

GateInfoAck::GateInfoAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateInfoAck::InitAsDefaultInstance() {
}

GateInfoAck::GateInfoAck(const GateInfoAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateInfoAck::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = 0u;
  acc_id_ = 0u;
  nport_ = 0u;
  sgateip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateInfoAck::~GateInfoAck() {
  SharedDtor();
}

void GateInfoAck::SharedDtor() {
  if (sgateip_ != &::google::protobuf::internal::kEmptyString) {
    delete sgateip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateInfoAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateInfoAck& GateInfoAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateInfoAck* GateInfoAck::default_instance_ = NULL;

GateInfoAck* GateInfoAck::New() const {
  return new GateInfoAck;
}

void GateInfoAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    session_id_ = 0u;
    acc_id_ = 0u;
    nport_ = 0u;
    if (has_sgateip()) {
      if (sgateip_ != &::google::protobuf::internal::kEmptyString) {
        sgateip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateInfoAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 session_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_acc_id;
        break;
      }

      // required uint32 acc_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_nPort;
        break;
      }

      // required uint32 nPort = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nport_)));
          set_has_nport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sGateIp;
        break;
      }

      // required string sGateIp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sGateIp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sgateip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GateInfoAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->session_id(), output);
  }

  // required uint32 acc_id = 2;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->acc_id(), output);
  }

  // required uint32 nPort = 3;
  if (has_nport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->nport(), output);
  }

  // required string sGateIp = 4;
  if (has_sgateip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->sgateip(), output);
  }

}

int GateInfoAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // required uint32 acc_id = 2;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 nPort = 3;
    if (has_nport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nport());
    }

    // required string sGateIp = 4;
    if (has_sgateip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sgateip());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateInfoAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateInfoAck*>(&from));
}

void GateInfoAck::MergeFrom(const GateInfoAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_nport()) {
      set_nport(from.nport());
    }
    if (from.has_sgateip()) {
      set_sgateip(from.sgateip());
    }
  }
}

void GateInfoAck::CopyFrom(const GateInfoAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateInfoAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void GateInfoAck::Swap(GateInfoAck* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(acc_id_, other->acc_id_);
    std::swap(nport_, other->nport_);
    std::swap(sgateip_, other->sgateip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateInfoAck::GetTypeName() const {
  return "message.GateInfoAck";
}


// ===================================================================

#ifndef _MSC_VER
const int UserDisconnect::kAccIdFieldNumber;
#endif  // !_MSC_VER

UserDisconnect::UserDisconnect()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserDisconnect::InitAsDefaultInstance() {
}

UserDisconnect::UserDisconnect(const UserDisconnect& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserDisconnect::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserDisconnect::~UserDisconnect() {
  SharedDtor();
}

void UserDisconnect::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserDisconnect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserDisconnect& UserDisconnect::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UserDisconnect* UserDisconnect::default_instance_ = NULL;

UserDisconnect* UserDisconnect::New() const {
  return new UserDisconnect;
}

void UserDisconnect::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserDisconnect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserDisconnect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

}

int UserDisconnect::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserDisconnect::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserDisconnect*>(&from));
}

void UserDisconnect::MergeFrom(const UserDisconnect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void UserDisconnect::CopyFrom(const UserDisconnect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserDisconnect::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UserDisconnect::Swap(UserDisconnect* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserDisconnect::GetTypeName() const {
  return "message.UserDisconnect";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GateGetNonceSys::GateGetNonceSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateGetNonceSys::InitAsDefaultInstance() {
}

GateGetNonceSys::GateGetNonceSys(const GateGetNonceSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateGetNonceSys::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateGetNonceSys::~GateGetNonceSys() {
  SharedDtor();
}

void GateGetNonceSys::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateGetNonceSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateGetNonceSys& GateGetNonceSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateGetNonceSys* GateGetNonceSys::default_instance_ = NULL;

GateGetNonceSys* GateGetNonceSys::New() const {
  return new GateGetNonceSys;
}

void GateGetNonceSys::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateGetNonceSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void GateGetNonceSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int GateGetNonceSys::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateGetNonceSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateGetNonceSys*>(&from));
}

void GateGetNonceSys::MergeFrom(const GateGetNonceSys& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void GateGetNonceSys::CopyFrom(const GateGetNonceSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateGetNonceSys::IsInitialized() const {

  return true;
}

void GateGetNonceSys::Swap(GateGetNonceSys* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateGetNonceSys::GetTypeName() const {
  return "message.GateGetNonceSys";
}


// ===================================================================

#ifndef _MSC_VER
const int GateAuchNonce::kNonceFieldNumber;
#endif  // !_MSC_VER

GateAuchNonce::GateAuchNonce()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateAuchNonce::InitAsDefaultInstance() {
}

GateAuchNonce::GateAuchNonce(const GateAuchNonce& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateAuchNonce::SharedCtor() {
  _cached_size_ = 0;
  nonce_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateAuchNonce::~GateAuchNonce() {
  SharedDtor();
}

void GateAuchNonce::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateAuchNonce::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateAuchNonce& GateAuchNonce::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateAuchNonce* GateAuchNonce::default_instance_ = NULL;

GateAuchNonce* GateAuchNonce::New() const {
  return new GateAuchNonce;
}

void GateAuchNonce::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    nonce_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateAuchNonce::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 nonce = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nonce_)));
          set_has_nonce();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GateAuchNonce::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 nonce = 1;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->nonce(), output);
  }

}

int GateAuchNonce::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 nonce = 1;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nonce());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateAuchNonce::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateAuchNonce*>(&from));
}

void GateAuchNonce::MergeFrom(const GateAuchNonce& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
  }
}

void GateAuchNonce::CopyFrom(const GateAuchNonce& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateAuchNonce::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GateAuchNonce::Swap(GateAuchNonce* other) {
  if (other != this) {
    std::swap(nonce_, other->nonce_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateAuchNonce::GetTypeName() const {
  return "message.GateAuchNonce";
}


// ===================================================================

#ifndef _MSC_VER
const int GateAuthSys::kAccIdFieldNumber;
const int GateAuthSys::kClientNonceFieldNumber;
const int GateAuthSys::kDigestFieldNumber;
#endif  // !_MSC_VER

GateAuthSys::GateAuthSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateAuthSys::InitAsDefaultInstance() {
}

GateAuthSys::GateAuthSys(const GateAuthSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateAuthSys::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  client_nonce_ = 0u;
  digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateAuthSys::~GateAuthSys() {
  SharedDtor();
}

void GateAuthSys::SharedDtor() {
  if (digest_ != &::google::protobuf::internal::kEmptyString) {
    delete digest_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateAuthSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateAuthSys& GateAuthSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateAuthSys* GateAuthSys::default_instance_ = NULL;

GateAuthSys* GateAuthSys::New() const {
  return new GateAuthSys;
}

void GateAuthSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    client_nonce_ = 0u;
    if (has_digest()) {
      if (digest_ != &::google::protobuf::internal::kEmptyString) {
        digest_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateAuthSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_client_nonce;
        break;
      }

      // required uint32 client_nonce = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_client_nonce:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &client_nonce_)));
          set_has_client_nonce();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_digest;
        break;
      }

      // required bytes digest = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_digest:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_digest()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GateAuthSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 client_nonce = 2;
  if (has_client_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->client_nonce(), output);
  }

  // required bytes digest = 3;
  if (has_digest()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->digest(), output);
  }

}

int GateAuthSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 client_nonce = 2;
    if (has_client_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->client_nonce());
    }

    // required bytes digest = 3;
    if (has_digest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->digest());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateAuthSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateAuthSys*>(&from));
}

void GateAuthSys::MergeFrom(const GateAuthSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_client_nonce()) {
      set_client_nonce(from.client_nonce());
    }
    if (from.has_digest()) {
      set_digest(from.digest());
    }
  }
}

void GateAuthSys::CopyFrom(const GateAuthSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateAuthSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GateAuthSys::Swap(GateAuthSys* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(client_nonce_, other->client_nonce_);
    std::swap(digest_, other->digest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateAuthSys::GetTypeName() const {
  return "message.GateAuthSys";
}


// ===================================================================

#ifndef _MSC_VER
const int CenterAuthSys::kAccIdFieldNumber;
const int CenterAuthSys::kClientNonceFieldNumber;
const int CenterAuthSys::kServerNonceFieldNumber;
const int CenterAuthSys::kDigestFieldNumber;
const int CenterAuthSys::kTempUserKeyFieldNumber;
#endif  // !_MSC_VER

CenterAuthSys::CenterAuthSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CenterAuthSys::InitAsDefaultInstance() {
}

CenterAuthSys::CenterAuthSys(const CenterAuthSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CenterAuthSys::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  client_nonce_ = 0u;
  server_nonce_ = 0u;
  digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  temp_user_key_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CenterAuthSys::~CenterAuthSys() {
  SharedDtor();
}

void CenterAuthSys::SharedDtor() {
  if (digest_ != &::google::protobuf::internal::kEmptyString) {
    delete digest_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CenterAuthSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CenterAuthSys& CenterAuthSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CenterAuthSys* CenterAuthSys::default_instance_ = NULL;

CenterAuthSys* CenterAuthSys::New() const {
  return new CenterAuthSys;
}

void CenterAuthSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    client_nonce_ = 0u;
    server_nonce_ = 0u;
    if (has_digest()) {
      if (digest_ != &::google::protobuf::internal::kEmptyString) {
        digest_->clear();
      }
    }
    temp_user_key_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CenterAuthSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_client_nonce;
        break;
      }

      // required uint32 client_nonce = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_client_nonce:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &client_nonce_)));
          set_has_client_nonce();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_server_nonce;
        break;
      }

      // required uint32 server_nonce = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_nonce:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_nonce_)));
          set_has_server_nonce();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_digest;
        break;
      }

      // required bytes digest = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_digest:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_digest()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_temp_user_key;
        break;
      }

      // required uint32 temp_user_key = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_temp_user_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &temp_user_key_)));
          set_has_temp_user_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CenterAuthSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 client_nonce = 2;
  if (has_client_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->client_nonce(), output);
  }

  // required uint32 server_nonce = 3;
  if (has_server_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->server_nonce(), output);
  }

  // required bytes digest = 4;
  if (has_digest()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->digest(), output);
  }

  // required uint32 temp_user_key = 5;
  if (has_temp_user_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->temp_user_key(), output);
  }

}

int CenterAuthSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 client_nonce = 2;
    if (has_client_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->client_nonce());
    }

    // required uint32 server_nonce = 3;
    if (has_server_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_nonce());
    }

    // required bytes digest = 4;
    if (has_digest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->digest());
    }

    // required uint32 temp_user_key = 5;
    if (has_temp_user_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->temp_user_key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CenterAuthSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CenterAuthSys*>(&from));
}

void CenterAuthSys::MergeFrom(const CenterAuthSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_client_nonce()) {
      set_client_nonce(from.client_nonce());
    }
    if (from.has_server_nonce()) {
      set_server_nonce(from.server_nonce());
    }
    if (from.has_digest()) {
      set_digest(from.digest());
    }
    if (from.has_temp_user_key()) {
      set_temp_user_key(from.temp_user_key());
    }
  }
}

void CenterAuthSys::CopyFrom(const CenterAuthSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CenterAuthSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void CenterAuthSys::Swap(CenterAuthSys* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(client_nonce_, other->client_nonce_);
    std::swap(server_nonce_, other->server_nonce_);
    std::swap(digest_, other->digest_);
    std::swap(temp_user_key_, other->temp_user_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CenterAuthSys::GetTypeName() const {
  return "message.CenterAuthSys";
}


// ===================================================================

#ifndef _MSC_VER
const int CenterAuthAck::kAccIdFieldNumber;
const int CenterAuthAck::kTempUserKeyFieldNumber;
#endif  // !_MSC_VER

CenterAuthAck::CenterAuthAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CenterAuthAck::InitAsDefaultInstance() {
}

CenterAuthAck::CenterAuthAck(const CenterAuthAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CenterAuthAck::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  temp_user_key_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CenterAuthAck::~CenterAuthAck() {
  SharedDtor();
}

void CenterAuthAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CenterAuthAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CenterAuthAck& CenterAuthAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CenterAuthAck* CenterAuthAck::default_instance_ = NULL;

CenterAuthAck* CenterAuthAck::New() const {
  return new CenterAuthAck;
}

void CenterAuthAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    temp_user_key_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CenterAuthAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_temp_user_key;
        break;
      }

      // required uint32 temp_user_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_temp_user_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &temp_user_key_)));
          set_has_temp_user_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CenterAuthAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 temp_user_key = 2;
  if (has_temp_user_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->temp_user_key(), output);
  }

}

int CenterAuthAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 temp_user_key = 2;
    if (has_temp_user_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->temp_user_key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CenterAuthAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CenterAuthAck*>(&from));
}

void CenterAuthAck::MergeFrom(const CenterAuthAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_temp_user_key()) {
      set_temp_user_key(from.temp_user_key());
    }
  }
}

void CenterAuthAck::CopyFrom(const CenterAuthAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CenterAuthAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CenterAuthAck::Swap(CenterAuthAck* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(temp_user_key_, other->temp_user_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CenterAuthAck::GetTypeName() const {
  return "message.CenterAuthAck";
}


// ===================================================================

#ifndef _MSC_VER
const int CenterAuthNack::kErrorCodeFieldNumber;
const int CenterAuthNack::kTempUserKeyFieldNumber;
#endif  // !_MSC_VER

CenterAuthNack::CenterAuthNack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CenterAuthNack::InitAsDefaultInstance() {
}

CenterAuthNack::CenterAuthNack(const CenterAuthNack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CenterAuthNack::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  temp_user_key_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CenterAuthNack::~CenterAuthNack() {
  SharedDtor();
}

void CenterAuthNack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CenterAuthNack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CenterAuthNack& CenterAuthNack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CenterAuthNack* CenterAuthNack::default_instance_ = NULL;

CenterAuthNack* CenterAuthNack::New() const {
  return new CenterAuthNack;
}

void CenterAuthNack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    temp_user_key_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CenterAuthNack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_temp_user_key;
        break;
      }

      // optional uint32 temp_user_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_temp_user_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &temp_user_key_)));
          set_has_temp_user_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CenterAuthNack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // optional uint32 temp_user_key = 2;
  if (has_temp_user_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->temp_user_key(), output);
  }

}

int CenterAuthNack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // optional uint32 temp_user_key = 2;
    if (has_temp_user_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->temp_user_key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CenterAuthNack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CenterAuthNack*>(&from));
}

void CenterAuthNack::MergeFrom(const CenterAuthNack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_temp_user_key()) {
      set_temp_user_key(from.temp_user_key());
    }
  }
}

void CenterAuthNack::CopyFrom(const CenterAuthNack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CenterAuthNack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CenterAuthNack::Swap(CenterAuthNack* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(temp_user_key_, other->temp_user_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CenterAuthNack::GetTypeName() const {
  return "message.CenterAuthNack";
}


// ===================================================================

#ifndef _MSC_VER
const int CenterAuthLogout::kAccIdFieldNumber;
#endif  // !_MSC_VER

CenterAuthLogout::CenterAuthLogout()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CenterAuthLogout::InitAsDefaultInstance() {
}

CenterAuthLogout::CenterAuthLogout(const CenterAuthLogout& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CenterAuthLogout::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CenterAuthLogout::~CenterAuthLogout() {
  SharedDtor();
}

void CenterAuthLogout::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CenterAuthLogout::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CenterAuthLogout& CenterAuthLogout::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CenterAuthLogout* CenterAuthLogout::default_instance_ = NULL;

CenterAuthLogout* CenterAuthLogout::New() const {
  return new CenterAuthLogout;
}

void CenterAuthLogout::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CenterAuthLogout::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CenterAuthLogout::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

}

int CenterAuthLogout::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CenterAuthLogout::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CenterAuthLogout*>(&from));
}

void CenterAuthLogout::MergeFrom(const CenterAuthLogout& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void CenterAuthLogout::CopyFrom(const CenterAuthLogout& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CenterAuthLogout::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CenterAuthLogout::Swap(CenterAuthLogout* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CenterAuthLogout::GetTypeName() const {
  return "message.CenterAuthLogout";
}


// ===================================================================

#ifndef _MSC_VER
const int GetPlayerRoleList::kAccIdFieldNumber;
#endif  // !_MSC_VER

GetPlayerRoleList::GetPlayerRoleList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetPlayerRoleList::InitAsDefaultInstance() {
}

GetPlayerRoleList::GetPlayerRoleList(const GetPlayerRoleList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetPlayerRoleList::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetPlayerRoleList::~GetPlayerRoleList() {
  SharedDtor();
}

void GetPlayerRoleList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetPlayerRoleList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetPlayerRoleList& GetPlayerRoleList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetPlayerRoleList* GetPlayerRoleList::default_instance_ = NULL;

GetPlayerRoleList* GetPlayerRoleList::New() const {
  return new GetPlayerRoleList;
}

void GetPlayerRoleList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetPlayerRoleList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetPlayerRoleList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

}

int GetPlayerRoleList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPlayerRoleList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetPlayerRoleList*>(&from));
}

void GetPlayerRoleList::MergeFrom(const GetPlayerRoleList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void GetPlayerRoleList::CopyFrom(const GetPlayerRoleList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPlayerRoleList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetPlayerRoleList::Swap(GetPlayerRoleList* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetPlayerRoleList::GetTypeName() const {
  return "message.GetPlayerRoleList";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerRoleListData::kRoleDataFieldNumber;
const int PlayerRoleListData::kAccIdFieldNumber;
#endif  // !_MSC_VER

PlayerRoleListData::PlayerRoleListData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerRoleListData::InitAsDefaultInstance() {
}

PlayerRoleListData::PlayerRoleListData(const PlayerRoleListData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerRoleListData::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerRoleListData::~PlayerRoleListData() {
  SharedDtor();
}

void PlayerRoleListData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerRoleListData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerRoleListData& PlayerRoleListData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PlayerRoleListData* PlayerRoleListData::default_instance_ = NULL;

PlayerRoleListData* PlayerRoleListData::New() const {
  return new PlayerRoleListData;
}

void PlayerRoleListData::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    acc_id_ = 0u;
  }
  role_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerRoleListData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes role_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_role_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_role_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_role_data;
        if (input->ExpectTag(16)) goto parse_acc_id;
        break;
      }

      // optional uint32 acc_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerRoleListData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes role_data = 1;
  for (int i = 0; i < this->role_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->role_data(i), output);
  }

  // optional uint32 acc_id = 2;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->acc_id(), output);
  }

}

int PlayerRoleListData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 acc_id = 2;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  // repeated bytes role_data = 1;
  total_size += 1 * this->role_data_size();
  for (int i = 0; i < this->role_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->role_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerRoleListData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerRoleListData*>(&from));
}

void PlayerRoleListData::MergeFrom(const PlayerRoleListData& from) {
  GOOGLE_CHECK_NE(&from, this);
  role_data_.MergeFrom(from.role_data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void PlayerRoleListData::CopyFrom(const PlayerRoleListData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerRoleListData::IsInitialized() const {

  return true;
}

void PlayerRoleListData::Swap(PlayerRoleListData* other) {
  if (other != this) {
    role_data_.Swap(&other->role_data_);
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerRoleListData::GetTypeName() const {
  return "message.PlayerRoleListData";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterSceneSys::kAvaterIndexFieldNumber;
#endif  // !_MSC_VER

EnterSceneSys::EnterSceneSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterSceneSys::InitAsDefaultInstance() {
}

EnterSceneSys::EnterSceneSys(const EnterSceneSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterSceneSys::SharedCtor() {
  _cached_size_ = 0;
  avater_index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterSceneSys::~EnterSceneSys() {
  SharedDtor();
}

void EnterSceneSys::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterSceneSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterSceneSys& EnterSceneSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EnterSceneSys* EnterSceneSys::default_instance_ = NULL;

EnterSceneSys* EnterSceneSys::New() const {
  return new EnterSceneSys;
}

void EnterSceneSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    avater_index_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterSceneSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 avater_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &avater_index_)));
          set_has_avater_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterSceneSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 avater_index = 1;
  if (has_avater_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->avater_index(), output);
  }

}

int EnterSceneSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 avater_index = 1;
    if (has_avater_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->avater_index());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterSceneSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterSceneSys*>(&from));
}

void EnterSceneSys::MergeFrom(const EnterSceneSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_avater_index()) {
      set_avater_index(from.avater_index());
    }
  }
}

void EnterSceneSys::CopyFrom(const EnterSceneSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterSceneSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EnterSceneSys::Swap(EnterSceneSys* other) {
  if (other != this) {
    std::swap(avater_index_, other->avater_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterSceneSys::GetTypeName() const {
  return "message.EnterSceneSys";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterSceneNack::kAccIdFieldNumber;
const int EnterSceneNack::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

EnterSceneNack::EnterSceneNack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterSceneNack::InitAsDefaultInstance() {
}

EnterSceneNack::EnterSceneNack(const EnterSceneNack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterSceneNack::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  error_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterSceneNack::~EnterSceneNack() {
  SharedDtor();
}

void EnterSceneNack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterSceneNack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterSceneNack& EnterSceneNack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EnterSceneNack* EnterSceneNack::default_instance_ = NULL;

EnterSceneNack* EnterSceneNack::New() const {
  return new EnterSceneNack;
}

void EnterSceneNack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    error_code_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterSceneNack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_error_code;
        break;
      }

      // required uint32 error_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterSceneNack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 error_code = 2;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->error_code(), output);
  }

}

int EnterSceneNack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 error_code = 2;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterSceneNack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterSceneNack*>(&from));
}

void EnterSceneNack::MergeFrom(const EnterSceneNack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void EnterSceneNack::CopyFrom(const EnterSceneNack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterSceneNack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void EnterSceneNack::Swap(EnterSceneNack* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterSceneNack::GetTypeName() const {
  return "message.EnterSceneNack";
}


// ===================================================================

#ifndef _MSC_VER
const int ChooseSceneCmd::kAccIdFieldNumber;
const int ChooseSceneCmd::kCharIdFieldNumber;
const int ChooseSceneCmd::kMapIdFieldNumber;
const int ChooseSceneCmd::kSlotIndexFieldNumber;
const int ChooseSceneCmd::kPosXFieldNumber;
const int ChooseSceneCmd::kPosYFieldNumber;
#endif  // !_MSC_VER

ChooseSceneCmd::ChooseSceneCmd()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChooseSceneCmd::InitAsDefaultInstance() {
}

ChooseSceneCmd::ChooseSceneCmd(const ChooseSceneCmd& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChooseSceneCmd::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  char_id_ = 0u;
  map_id_ = 0u;
  slot_index_ = 0u;
  pos_x_ = 0;
  pos_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChooseSceneCmd::~ChooseSceneCmd() {
  SharedDtor();
}

void ChooseSceneCmd::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChooseSceneCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChooseSceneCmd& ChooseSceneCmd::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ChooseSceneCmd* ChooseSceneCmd::default_instance_ = NULL;

ChooseSceneCmd* ChooseSceneCmd::New() const {
  return new ChooseSceneCmd;
}

void ChooseSceneCmd::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    char_id_ = 0u;
    map_id_ = 0u;
    slot_index_ = 0u;
    pos_x_ = 0;
    pos_y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChooseSceneCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // required uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_slot_index;
        break;
      }

      // required uint32 slot_index = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slot_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &slot_index_)));
          set_has_slot_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_pos_x;
        break;
      }

      // required float pos_x = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_pos_y;
        break;
      }

      // required float pos_y = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pos_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_y_)));
          set_has_pos_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChooseSceneCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

  // required uint32 map_id = 3;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->map_id(), output);
  }

  // required uint32 slot_index = 4;
  if (has_slot_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->slot_index(), output);
  }

  // required float pos_x = 5;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->pos_x(), output);
  }

  // required float pos_y = 6;
  if (has_pos_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->pos_y(), output);
  }

}

int ChooseSceneCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // required uint32 map_id = 3;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 slot_index = 4;
    if (has_slot_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->slot_index());
    }

    // required float pos_x = 5;
    if (has_pos_x()) {
      total_size += 1 + 4;
    }

    // required float pos_y = 6;
    if (has_pos_y()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChooseSceneCmd::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChooseSceneCmd*>(&from));
}

void ChooseSceneCmd::MergeFrom(const ChooseSceneCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_slot_index()) {
      set_slot_index(from.slot_index());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_pos_y()) {
      set_pos_y(from.pos_y());
    }
  }
}

void ChooseSceneCmd::CopyFrom(const ChooseSceneCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChooseSceneCmd::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void ChooseSceneCmd::Swap(ChooseSceneCmd* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(char_id_, other->char_id_);
    std::swap(map_id_, other->map_id_);
    std::swap(slot_index_, other->slot_index_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(pos_y_, other->pos_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChooseSceneCmd::GetTypeName() const {
  return "message.ChooseSceneCmd";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ServerInfoConnected::ServerInfoConnected()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServerInfoConnected::InitAsDefaultInstance() {
}

ServerInfoConnected::ServerInfoConnected(const ServerInfoConnected& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServerInfoConnected::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerInfoConnected::~ServerInfoConnected() {
  SharedDtor();
}

void ServerInfoConnected::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServerInfoConnected::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerInfoConnected& ServerInfoConnected::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ServerInfoConnected* ServerInfoConnected::default_instance_ = NULL;

ServerInfoConnected* ServerInfoConnected::New() const {
  return new ServerInfoConnected;
}

void ServerInfoConnected::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServerInfoConnected::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void ServerInfoConnected::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int ServerInfoConnected::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerInfoConnected::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerInfoConnected*>(&from));
}

void ServerInfoConnected::MergeFrom(const ServerInfoConnected& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void ServerInfoConnected::CopyFrom(const ServerInfoConnected& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerInfoConnected::IsInitialized() const {

  return true;
}

void ServerInfoConnected::Swap(ServerInfoConnected* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerInfoConnected::GetTypeName() const {
  return "message.ServerInfoConnected";
}


// ===================================================================

#ifndef _MSC_VER
const int MapServerInfo::kServerIdFieldNumber;
const int MapServerInfo::kMapinfoDataFieldNumber;
#endif  // !_MSC_VER

MapServerInfo::MapServerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MapServerInfo::InitAsDefaultInstance() {
}

MapServerInfo::MapServerInfo(const MapServerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MapServerInfo::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapServerInfo::~MapServerInfo() {
  SharedDtor();
}

void MapServerInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MapServerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MapServerInfo& MapServerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

MapServerInfo* MapServerInfo::default_instance_ = NULL;

MapServerInfo* MapServerInfo::New() const {
  return new MapServerInfo;
}

void MapServerInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0u;
  }
  mapinfo_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MapServerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_mapinfo_data;
        break;
      }

      // repeated bytes mapinfo_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mapinfo_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_mapinfo_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_mapinfo_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapServerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->server_id(), output);
  }

  // repeated bytes mapinfo_data = 2;
  for (int i = 0; i < this->mapinfo_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->mapinfo_data(i), output);
  }

}

int MapServerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

  }
  // repeated bytes mapinfo_data = 2;
  total_size += 1 * this->mapinfo_data_size();
  for (int i = 0; i < this->mapinfo_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->mapinfo_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapServerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MapServerInfo*>(&from));
}

void MapServerInfo::MergeFrom(const MapServerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  mapinfo_data_.MergeFrom(from.mapinfo_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
  }
}

void MapServerInfo::CopyFrom(const MapServerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapServerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MapServerInfo::Swap(MapServerInfo* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    mapinfo_data_.Swap(&other->mapinfo_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MapServerInfo::GetTypeName() const {
  return "message.MapServerInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateUserInfo::kCharIdFieldNumber;
const int CreateUserInfo::kUserDataFieldNumber;
const int CreateUserInfo::kServerIdFieldNumber;
const int CreateUserInfo::kIsRobotFieldNumber;
#endif  // !_MSC_VER

CreateUserInfo::CreateUserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateUserInfo::InitAsDefaultInstance() {
}

CreateUserInfo::CreateUserInfo(const CreateUserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateUserInfo::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  server_id_ = 0u;
  is_robot_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateUserInfo::~CreateUserInfo() {
  SharedDtor();
}

void CreateUserInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateUserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateUserInfo& CreateUserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CreateUserInfo* CreateUserInfo::default_instance_ = NULL;

CreateUserInfo* CreateUserInfo::New() const {
  return new CreateUserInfo;
}

void CreateUserInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
    server_id_ = 0u;
    is_robot_ = 0u;
  }
  user_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateUserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_data;
        break;
      }

      // repeated bytes user_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_user_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_data;
        if (input->ExpectTag(24)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_robot;
        break;
      }

      // optional uint32 is_robot = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_robot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_robot_)));
          set_has_is_robot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateUserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

  // repeated bytes user_data = 2;
  for (int i = 0; i < this->user_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->user_data(i), output);
  }

  // optional uint32 server_id = 3;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->server_id(), output);
  }

  // optional uint32 is_robot = 4;
  if (has_is_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->is_robot(), output);
  }

}

int CreateUserInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // optional uint32 server_id = 3;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 is_robot = 4;
    if (has_is_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_robot());
    }

  }
  // repeated bytes user_data = 2;
  total_size += 1 * this->user_data_size();
  for (int i = 0; i < this->user_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->user_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateUserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateUserInfo*>(&from));
}

void CreateUserInfo::MergeFrom(const CreateUserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_data_.MergeFrom(from.user_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_is_robot()) {
      set_is_robot(from.is_robot());
    }
  }
}

void CreateUserInfo::CopyFrom(const CreateUserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateUserInfo::IsInitialized() const {

  return true;
}

void CreateUserInfo::Swap(CreateUserInfo* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    user_data_.Swap(&other->user_data_);
    std::swap(server_id_, other->server_id_);
    std::swap(is_robot_, other->is_robot_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateUserInfo::GetTypeName() const {
  return "message.CreateUserInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateUserResult::kCharIdFieldNumber;
const int CreateUserResult::kResultFieldNumber;
#endif  // !_MSC_VER

CreateUserResult::CreateUserResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateUserResult::InitAsDefaultInstance() {
}

CreateUserResult::CreateUserResult(const CreateUserResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateUserResult::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateUserResult::~CreateUserResult() {
  SharedDtor();
}

void CreateUserResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateUserResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateUserResult& CreateUserResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CreateUserResult* CreateUserResult::default_instance_ = NULL;

CreateUserResult* CreateUserResult::New() const {
  return new CreateUserResult;
}

void CreateUserResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
    result_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateUserResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // required uint32 result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateUserResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

  // required uint32 result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result(), output);
  }

}

int CreateUserResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // required uint32 result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateUserResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateUserResult*>(&from));
}

void CreateUserResult::MergeFrom(const CreateUserResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void CreateUserResult::CopyFrom(const CreateUserResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateUserResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CreateUserResult::Swap(CreateUserResult* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateUserResult::GetTypeName() const {
  return "message.CreateUserResult";
}


// ===================================================================

#ifndef _MSC_VER
const int SaveUserInfo::kAccIdFieldNumber;
const int SaveUserInfo::kUserDataFieldNumber;
const int SaveUserInfo::kSequenceIdFieldNumber;
#endif  // !_MSC_VER

SaveUserInfo::SaveUserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SaveUserInfo::InitAsDefaultInstance() {
}

SaveUserInfo::SaveUserInfo(const SaveUserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SaveUserInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  sequence_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaveUserInfo::~SaveUserInfo() {
  SharedDtor();
}

void SaveUserInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SaveUserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SaveUserInfo& SaveUserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SaveUserInfo* SaveUserInfo::default_instance_ = NULL;

SaveUserInfo* SaveUserInfo::New() const {
  return new SaveUserInfo;
}

void SaveUserInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    sequence_id_ = 0u;
  }
  user_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SaveUserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_data;
        break;
      }

      // repeated bytes user_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_user_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_data;
        if (input->ExpectTag(24)) goto parse_sequence_id;
        break;
      }

      // optional uint32 sequence_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_id_)));
          set_has_sequence_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SaveUserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // repeated bytes user_data = 2;
  for (int i = 0; i < this->user_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->user_data(i), output);
  }

  // optional uint32 sequence_id = 3;
  if (has_sequence_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sequence_id(), output);
  }

}

int SaveUserInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional uint32 sequence_id = 3;
    if (has_sequence_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence_id());
    }

  }
  // repeated bytes user_data = 2;
  total_size += 1 * this->user_data_size();
  for (int i = 0; i < this->user_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->user_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaveUserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SaveUserInfo*>(&from));
}

void SaveUserInfo::MergeFrom(const SaveUserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_data_.MergeFrom(from.user_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_sequence_id()) {
      set_sequence_id(from.sequence_id());
    }
  }
}

void SaveUserInfo::CopyFrom(const SaveUserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveUserInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SaveUserInfo::Swap(SaveUserInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    user_data_.Swap(&other->user_data_);
    std::swap(sequence_id_, other->sequence_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SaveUserInfo::GetTypeName() const {
  return "message.SaveUserInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int GetUserDetailInfo::kAccIdFieldNumber;
const int GetUserDetailInfo::kCharIdFieldNumber;
#endif  // !_MSC_VER

GetUserDetailInfo::GetUserDetailInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetUserDetailInfo::InitAsDefaultInstance() {
}

GetUserDetailInfo::GetUserDetailInfo(const GetUserDetailInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetUserDetailInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetUserDetailInfo::~GetUserDetailInfo() {
  SharedDtor();
}

void GetUserDetailInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetUserDetailInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetUserDetailInfo& GetUserDetailInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetUserDetailInfo* GetUserDetailInfo::default_instance_ = NULL;

GetUserDetailInfo* GetUserDetailInfo::New() const {
  return new GetUserDetailInfo;
}

void GetUserDetailInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetUserDetailInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // required uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetUserDetailInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

}

int GetUserDetailInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetUserDetailInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetUserDetailInfo*>(&from));
}

void GetUserDetailInfo::MergeFrom(const GetUserDetailInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void GetUserDetailInfo::CopyFrom(const GetUserDetailInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserDetailInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GetUserDetailInfo::Swap(GetUserDetailInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetUserDetailInfo::GetTypeName() const {
  return "message.GetUserDetailInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int UserDetailInfo::kAccIdFieldNumber;
const int UserDetailInfo::kSequenceIdFieldNumber;
const int UserDetailInfo::kUserDataFieldNumber;
#endif  // !_MSC_VER

UserDetailInfo::UserDetailInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserDetailInfo::InitAsDefaultInstance() {
}

UserDetailInfo::UserDetailInfo(const UserDetailInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserDetailInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  sequence_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserDetailInfo::~UserDetailInfo() {
  SharedDtor();
}

void UserDetailInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserDetailInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserDetailInfo& UserDetailInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UserDetailInfo* UserDetailInfo::default_instance_ = NULL;

UserDetailInfo* UserDetailInfo::New() const {
  return new UserDetailInfo;
}

void UserDetailInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    sequence_id_ = 0u;
  }
  user_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserDetailInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sequence_id;
        break;
      }

      // required uint32 sequence_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_id_)));
          set_has_sequence_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_data;
        break;
      }

      // repeated bytes user_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_user_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserDetailInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 sequence_id = 2;
  if (has_sequence_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sequence_id(), output);
  }

  // repeated bytes user_data = 3;
  for (int i = 0; i < this->user_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->user_data(i), output);
  }

}

int UserDetailInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 sequence_id = 2;
    if (has_sequence_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence_id());
    }

  }
  // repeated bytes user_data = 3;
  total_size += 1 * this->user_data_size();
  for (int i = 0; i < this->user_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->user_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserDetailInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserDetailInfo*>(&from));
}

void UserDetailInfo::MergeFrom(const UserDetailInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_data_.MergeFrom(from.user_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_sequence_id()) {
      set_sequence_id(from.sequence_id());
    }
  }
}

void UserDetailInfo::CopyFrom(const UserDetailInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserDetailInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UserDetailInfo::Swap(UserDetailInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(sequence_id_, other->sequence_id_);
    user_data_.Swap(&other->user_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserDetailInfo::GetTypeName() const {
  return "message.UserDetailInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterSceneMapSys::kGateIdFieldNumber;
const int EnterSceneMapSys::kCharIdFieldNumber;
const int EnterSceneMapSys::kAccIdFieldNumber;
const int EnterSceneMapSys::kMapIdFieldNumber;
const int EnterSceneMapSys::kSlotIndexFieldNumber;
const int EnterSceneMapSys::kInstanceIdFieldNumber;
const int EnterSceneMapSys::kPosXFieldNumber;
const int EnterSceneMapSys::kPosYFieldNumber;
const int EnterSceneMapSys::kBchangeSceneFieldNumber;
#endif  // !_MSC_VER

EnterSceneMapSys::EnterSceneMapSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterSceneMapSys::InitAsDefaultInstance() {
}

EnterSceneMapSys::EnterSceneMapSys(const EnterSceneMapSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterSceneMapSys::SharedCtor() {
  _cached_size_ = 0;
  gate_id_ = 0u;
  char_id_ = 0u;
  acc_id_ = 0u;
  map_id_ = 0u;
  slot_index_ = 0u;
  instance_id_ = 0u;
  pos_x_ = 0;
  pos_y_ = 0;
  bchange_scene_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterSceneMapSys::~EnterSceneMapSys() {
  SharedDtor();
}

void EnterSceneMapSys::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterSceneMapSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterSceneMapSys& EnterSceneMapSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EnterSceneMapSys* EnterSceneMapSys::default_instance_ = NULL;

EnterSceneMapSys* EnterSceneMapSys::New() const {
  return new EnterSceneMapSys;
}

void EnterSceneMapSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gate_id_ = 0u;
    char_id_ = 0u;
    acc_id_ = 0u;
    map_id_ = 0u;
    slot_index_ = 0u;
    instance_id_ = 0u;
    pos_x_ = 0;
    pos_y_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    bchange_scene_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterSceneMapSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 gate_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gate_id_)));
          set_has_gate_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // required uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_acc_id;
        break;
      }

      // required uint32 acc_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_slot_index;
        break;
      }

      // required uint32 slot_index = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slot_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &slot_index_)));
          set_has_slot_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_instance_id;
        break;
      }

      // required uint32 instance_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_instance_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &instance_id_)));
          set_has_instance_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_pos_x;
        break;
      }

      // required float pos_x = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_pos_y;
        break;
      }

      // required float pos_y = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pos_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_y_)));
          set_has_pos_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_bchange_scene;
        break;
      }

      // required uint32 bchange_scene = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bchange_scene:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bchange_scene_)));
          set_has_bchange_scene();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterSceneMapSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 gate_id = 1;
  if (has_gate_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->gate_id(), output);
  }

  // required uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

  // required uint32 acc_id = 3;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->acc_id(), output);
  }

  // required uint32 map_id = 4;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->map_id(), output);
  }

  // required uint32 slot_index = 5;
  if (has_slot_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->slot_index(), output);
  }

  // required uint32 instance_id = 6;
  if (has_instance_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->instance_id(), output);
  }

  // required float pos_x = 7;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->pos_x(), output);
  }

  // required float pos_y = 8;
  if (has_pos_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->pos_y(), output);
  }

  // required uint32 bchange_scene = 9;
  if (has_bchange_scene()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->bchange_scene(), output);
  }

}

int EnterSceneMapSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 gate_id = 1;
    if (has_gate_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gate_id());
    }

    // required uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // required uint32 acc_id = 3;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 map_id = 4;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 slot_index = 5;
    if (has_slot_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->slot_index());
    }

    // required uint32 instance_id = 6;
    if (has_instance_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->instance_id());
    }

    // required float pos_x = 7;
    if (has_pos_x()) {
      total_size += 1 + 4;
    }

    // required float pos_y = 8;
    if (has_pos_y()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 bchange_scene = 9;
    if (has_bchange_scene()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bchange_scene());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterSceneMapSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterSceneMapSys*>(&from));
}

void EnterSceneMapSys::MergeFrom(const EnterSceneMapSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gate_id()) {
      set_gate_id(from.gate_id());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_slot_index()) {
      set_slot_index(from.slot_index());
    }
    if (from.has_instance_id()) {
      set_instance_id(from.instance_id());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_pos_y()) {
      set_pos_y(from.pos_y());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_bchange_scene()) {
      set_bchange_scene(from.bchange_scene());
    }
  }
}

void EnterSceneMapSys::CopyFrom(const EnterSceneMapSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterSceneMapSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void EnterSceneMapSys::Swap(EnterSceneMapSys* other) {
  if (other != this) {
    std::swap(gate_id_, other->gate_id_);
    std::swap(char_id_, other->char_id_);
    std::swap(acc_id_, other->acc_id_);
    std::swap(map_id_, other->map_id_);
    std::swap(slot_index_, other->slot_index_);
    std::swap(instance_id_, other->instance_id_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(pos_y_, other->pos_y_);
    std::swap(bchange_scene_, other->bchange_scene_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterSceneMapSys::GetTypeName() const {
  return "message.EnterSceneMapSys";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterSceneMapNack::kAccIdFieldNumber;
#endif  // !_MSC_VER

EnterSceneMapNack::EnterSceneMapNack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterSceneMapNack::InitAsDefaultInstance() {
}

EnterSceneMapNack::EnterSceneMapNack(const EnterSceneMapNack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterSceneMapNack::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterSceneMapNack::~EnterSceneMapNack() {
  SharedDtor();
}

void EnterSceneMapNack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterSceneMapNack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterSceneMapNack& EnterSceneMapNack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EnterSceneMapNack* EnterSceneMapNack::default_instance_ = NULL;

EnterSceneMapNack* EnterSceneMapNack::New() const {
  return new EnterSceneMapNack;
}

void EnterSceneMapNack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterSceneMapNack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterSceneMapNack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

}

int EnterSceneMapNack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterSceneMapNack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterSceneMapNack*>(&from));
}

void EnterSceneMapNack::MergeFrom(const EnterSceneMapNack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void EnterSceneMapNack::CopyFrom(const EnterSceneMapNack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterSceneMapNack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EnterSceneMapNack::Swap(EnterSceneMapNack* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterSceneMapNack::GetTypeName() const {
  return "message.EnterSceneMapNack";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterSceneMapAck::kAccIdFieldNumber;
#endif  // !_MSC_VER

EnterSceneMapAck::EnterSceneMapAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterSceneMapAck::InitAsDefaultInstance() {
}

EnterSceneMapAck::EnterSceneMapAck(const EnterSceneMapAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterSceneMapAck::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterSceneMapAck::~EnterSceneMapAck() {
  SharedDtor();
}

void EnterSceneMapAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterSceneMapAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterSceneMapAck& EnterSceneMapAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EnterSceneMapAck* EnterSceneMapAck::default_instance_ = NULL;

EnterSceneMapAck* EnterSceneMapAck::New() const {
  return new EnterSceneMapAck;
}

void EnterSceneMapAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterSceneMapAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterSceneMapAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

}

int EnterSceneMapAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterSceneMapAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterSceneMapAck*>(&from));
}

void EnterSceneMapAck::MergeFrom(const EnterSceneMapAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void EnterSceneMapAck::CopyFrom(const EnterSceneMapAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterSceneMapAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EnterSceneMapAck::Swap(EnterSceneMapAck* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterSceneMapAck::GetTypeName() const {
  return "message.EnterSceneMapAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ClientCreateSenceCmd::kMapIdFieldNumber;
const int ClientCreateSenceCmd::kPosXFieldNumber;
const int ClientCreateSenceCmd::kPosYFieldNumber;
#endif  // !_MSC_VER

ClientCreateSenceCmd::ClientCreateSenceCmd()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ClientCreateSenceCmd::InitAsDefaultInstance() {
}

ClientCreateSenceCmd::ClientCreateSenceCmd(const ClientCreateSenceCmd& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ClientCreateSenceCmd::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  pos_x_ = 0;
  pos_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientCreateSenceCmd::~ClientCreateSenceCmd() {
  SharedDtor();
}

void ClientCreateSenceCmd::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClientCreateSenceCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientCreateSenceCmd& ClientCreateSenceCmd::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ClientCreateSenceCmd* ClientCreateSenceCmd::default_instance_ = NULL;

ClientCreateSenceCmd* ClientCreateSenceCmd::New() const {
  return new ClientCreateSenceCmd;
}

void ClientCreateSenceCmd::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0u;
    pos_x_ = 0;
    pos_y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClientCreateSenceCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_pos_x;
        break;
      }

      // required float pos_x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_pos_y;
        break;
      }

      // required float pos_y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pos_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pos_y_)));
          set_has_pos_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientCreateSenceCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required float pos_x = 2;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->pos_x(), output);
  }

  // required float pos_y = 3;
  if (has_pos_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->pos_y(), output);
  }

}

int ClientCreateSenceCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required float pos_x = 2;
    if (has_pos_x()) {
      total_size += 1 + 4;
    }

    // required float pos_y = 3;
    if (has_pos_y()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientCreateSenceCmd::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientCreateSenceCmd*>(&from));
}

void ClientCreateSenceCmd::MergeFrom(const ClientCreateSenceCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_pos_y()) {
      set_pos_y(from.pos_y());
    }
  }
}

void ClientCreateSenceCmd::CopyFrom(const ClientCreateSenceCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientCreateSenceCmd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ClientCreateSenceCmd::Swap(ClientCreateSenceCmd* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(pos_y_, other->pos_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ClientCreateSenceCmd::GetTypeName() const {
  return "message.ClientCreateSenceCmd";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ClientEnterSenceSys::ClientEnterSenceSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ClientEnterSenceSys::InitAsDefaultInstance() {
}

ClientEnterSenceSys::ClientEnterSenceSys(const ClientEnterSenceSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ClientEnterSenceSys::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientEnterSenceSys::~ClientEnterSenceSys() {
  SharedDtor();
}

void ClientEnterSenceSys::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClientEnterSenceSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientEnterSenceSys& ClientEnterSenceSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ClientEnterSenceSys* ClientEnterSenceSys::default_instance_ = NULL;

ClientEnterSenceSys* ClientEnterSenceSys::New() const {
  return new ClientEnterSenceSys;
}

void ClientEnterSenceSys::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClientEnterSenceSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void ClientEnterSenceSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int ClientEnterSenceSys::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientEnterSenceSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientEnterSenceSys*>(&from));
}

void ClientEnterSenceSys::MergeFrom(const ClientEnterSenceSys& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void ClientEnterSenceSys::CopyFrom(const ClientEnterSenceSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientEnterSenceSys::IsInitialized() const {

  return true;
}

void ClientEnterSenceSys::Swap(ClientEnterSenceSys* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ClientEnterSenceSys::GetTypeName() const {
  return "message.ClientEnterSenceSys";
}


// ===================================================================

#ifndef _MSC_VER
const int AddPlayerSys::kCharIdFieldNumber;
const int AddPlayerSys::kPosXFieldNumber;
const int AddPlayerSys::kPosYFieldNumber;
const int AddPlayerSys::kPosOFieldNumber;
const int AddPlayerSys::kCharJobFieldNumber;
const int AddPlayerSys::kCharSexFieldNumber;
const int AddPlayerSys::kCharNameFieldNumber;
const int AddPlayerSys::kCharWeaponFieldNumber;
const int AddPlayerSys::kCharLevelFieldNumber;
const int AddPlayerSys::kHorseIdFieldNumber;
const int AddPlayerSys::kHorseImageFieldNumber;
const int AddPlayerSys::kHorseNameFieldNumber;
#endif  // !_MSC_VER

AddPlayerSys::AddPlayerSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddPlayerSys::InitAsDefaultInstance() {
}

AddPlayerSys::AddPlayerSys(const AddPlayerSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddPlayerSys::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  pos_x_ = 0u;
  pos_y_ = 0u;
  pos_o_ = 0u;
  char_job_ = 0u;
  char_sex_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  char_weapon_ = 0u;
  char_level_ = 0u;
  horse_id_ = 0u;
  horse_image_ = 0u;
  horse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddPlayerSys::~AddPlayerSys() {
  SharedDtor();
}

void AddPlayerSys::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (horse_name_ != &::google::protobuf::internal::kEmptyString) {
    delete horse_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddPlayerSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddPlayerSys& AddPlayerSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddPlayerSys* AddPlayerSys::default_instance_ = NULL;

AddPlayerSys* AddPlayerSys::New() const {
  return new AddPlayerSys;
}

void AddPlayerSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
    pos_x_ = 0u;
    pos_y_ = 0u;
    pos_o_ = 0u;
    char_job_ = 0u;
    char_sex_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    char_weapon_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    char_level_ = 0u;
    horse_id_ = 0u;
    horse_image_ = 0u;
    if (has_horse_name()) {
      if (horse_name_ != &::google::protobuf::internal::kEmptyString) {
        horse_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddPlayerSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pos_x;
        break;
      }

      // required uint32 pos_x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pos_y;
        break;
      }

      // required uint32 pos_y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_y_)));
          set_has_pos_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_pos_o;
        break;
      }

      // required uint32 pos_o = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_o:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_o_)));
          set_has_pos_o();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_char_job;
        break;
      }

      // required uint32 char_job = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_job_)));
          set_has_char_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_char_sex;
        break;
      }

      // required uint32 char_sex = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_sex_)));
          set_has_char_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_char_name;
        break;
      }

      // required bytes char_name = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_char_weapon;
        break;
      }

      // required uint32 char_weapon = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_weapon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_weapon_)));
          set_has_char_weapon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_char_level;
        break;
      }

      // required uint32 char_level = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_level_)));
          set_has_char_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_horse_id;
        break;
      }

      // optional uint32 horse_id = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_horse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &horse_id_)));
          set_has_horse_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_horse_image;
        break;
      }

      // optional uint32 horse_image = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_horse_image:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &horse_image_)));
          set_has_horse_image();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_horse_name;
        break;
      }

      // optional bytes horse_name = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_horse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_horse_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddPlayerSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

  // required uint32 pos_x = 2;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->pos_x(), output);
  }

  // required uint32 pos_y = 3;
  if (has_pos_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->pos_y(), output);
  }

  // required uint32 pos_o = 4;
  if (has_pos_o()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->pos_o(), output);
  }

  // required uint32 char_job = 5;
  if (has_char_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->char_job(), output);
  }

  // required uint32 char_sex = 6;
  if (has_char_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->char_sex(), output);
  }

  // required bytes char_name = 7;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->char_name(), output);
  }

  // required uint32 char_weapon = 8;
  if (has_char_weapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->char_weapon(), output);
  }

  // required uint32 char_level = 9;
  if (has_char_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->char_level(), output);
  }

  // optional uint32 horse_id = 10;
  if (has_horse_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->horse_id(), output);
  }

  // optional uint32 horse_image = 11;
  if (has_horse_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->horse_image(), output);
  }

  // optional bytes horse_name = 12;
  if (has_horse_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      12, this->horse_name(), output);
  }

}

int AddPlayerSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // required uint32 pos_x = 2;
    if (has_pos_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos_x());
    }

    // required uint32 pos_y = 3;
    if (has_pos_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos_y());
    }

    // required uint32 pos_o = 4;
    if (has_pos_o()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos_o());
    }

    // required uint32 char_job = 5;
    if (has_char_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_job());
    }

    // required uint32 char_sex = 6;
    if (has_char_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_sex());
    }

    // required bytes char_name = 7;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // required uint32 char_weapon = 8;
    if (has_char_weapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_weapon());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 char_level = 9;
    if (has_char_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_level());
    }

    // optional uint32 horse_id = 10;
    if (has_horse_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->horse_id());
    }

    // optional uint32 horse_image = 11;
    if (has_horse_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->horse_image());
    }

    // optional bytes horse_name = 12;
    if (has_horse_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->horse_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddPlayerSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddPlayerSys*>(&from));
}

void AddPlayerSys::MergeFrom(const AddPlayerSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_pos_y()) {
      set_pos_y(from.pos_y());
    }
    if (from.has_pos_o()) {
      set_pos_o(from.pos_o());
    }
    if (from.has_char_job()) {
      set_char_job(from.char_job());
    }
    if (from.has_char_sex()) {
      set_char_sex(from.char_sex());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_char_weapon()) {
      set_char_weapon(from.char_weapon());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_char_level()) {
      set_char_level(from.char_level());
    }
    if (from.has_horse_id()) {
      set_horse_id(from.horse_id());
    }
    if (from.has_horse_image()) {
      set_horse_image(from.horse_image());
    }
    if (from.has_horse_name()) {
      set_horse_name(from.horse_name());
    }
  }
}

void AddPlayerSys::CopyFrom(const AddPlayerSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddPlayerSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void AddPlayerSys::Swap(AddPlayerSys* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(pos_y_, other->pos_y_);
    std::swap(pos_o_, other->pos_o_);
    std::swap(char_job_, other->char_job_);
    std::swap(char_sex_, other->char_sex_);
    std::swap(char_name_, other->char_name_);
    std::swap(char_weapon_, other->char_weapon_);
    std::swap(char_level_, other->char_level_);
    std::swap(horse_id_, other->horse_id_);
    std::swap(horse_image_, other->horse_image_);
    std::swap(horse_name_, other->horse_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddPlayerSys::GetTypeName() const {
  return "message.AddPlayerSys";
}


// ===================================================================

#ifndef _MSC_VER
const int AddNpcSys::kNpcIdFieldNumber;
const int AddNpcSys::kNpcOnlyIdFieldNumber;
const int AddNpcSys::kNpcModeIdFieldNumber;
const int AddNpcSys::kNpcTypeIdFieldNumber;
const int AddNpcSys::kPosXFieldNumber;
const int AddNpcSys::kPosYFieldNumber;
const int AddNpcSys::kPosOFieldNumber;
#endif  // !_MSC_VER

AddNpcSys::AddNpcSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddNpcSys::InitAsDefaultInstance() {
}

AddNpcSys::AddNpcSys(const AddNpcSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddNpcSys::SharedCtor() {
  _cached_size_ = 0;
  npc_id_ = 0u;
  npc_only_id_ = 0u;
  npc_mode_id_ = 0u;
  npc_type_id_ = 0u;
  pos_x_ = 0u;
  pos_y_ = 0u;
  pos_o_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddNpcSys::~AddNpcSys() {
  SharedDtor();
}

void AddNpcSys::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddNpcSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddNpcSys& AddNpcSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddNpcSys* AddNpcSys::default_instance_ = NULL;

AddNpcSys* AddNpcSys::New() const {
  return new AddNpcSys;
}

void AddNpcSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    npc_id_ = 0u;
    npc_only_id_ = 0u;
    npc_mode_id_ = 0u;
    npc_type_id_ = 0u;
    pos_x_ = 0u;
    pos_y_ = 0u;
    pos_o_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddNpcSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 npc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &npc_id_)));
          set_has_npc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_npc_only_id;
        break;
      }

      // required uint32 npc_only_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_npc_only_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &npc_only_id_)));
          set_has_npc_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_npc_mode_id;
        break;
      }

      // required uint32 npc_mode_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_npc_mode_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &npc_mode_id_)));
          set_has_npc_mode_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_npc_type_id;
        break;
      }

      // required uint32 npc_type_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_npc_type_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &npc_type_id_)));
          set_has_npc_type_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_pos_x;
        break;
      }

      // required uint32 pos_x = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_pos_y;
        break;
      }

      // required uint32 pos_y = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_y_)));
          set_has_pos_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_pos_o;
        break;
      }

      // required uint32 pos_o = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_o:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_o_)));
          set_has_pos_o();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddNpcSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 npc_id = 1;
  if (has_npc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->npc_id(), output);
  }

  // required uint32 npc_only_id = 2;
  if (has_npc_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->npc_only_id(), output);
  }

  // required uint32 npc_mode_id = 3;
  if (has_npc_mode_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->npc_mode_id(), output);
  }

  // required uint32 npc_type_id = 4;
  if (has_npc_type_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->npc_type_id(), output);
  }

  // required uint32 pos_x = 5;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->pos_x(), output);
  }

  // required uint32 pos_y = 6;
  if (has_pos_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->pos_y(), output);
  }

  // required uint32 pos_o = 7;
  if (has_pos_o()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->pos_o(), output);
  }

}

int AddNpcSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 npc_id = 1;
    if (has_npc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->npc_id());
    }

    // required uint32 npc_only_id = 2;
    if (has_npc_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->npc_only_id());
    }

    // required uint32 npc_mode_id = 3;
    if (has_npc_mode_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->npc_mode_id());
    }

    // required uint32 npc_type_id = 4;
    if (has_npc_type_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->npc_type_id());
    }

    // required uint32 pos_x = 5;
    if (has_pos_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos_x());
    }

    // required uint32 pos_y = 6;
    if (has_pos_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos_y());
    }

    // required uint32 pos_o = 7;
    if (has_pos_o()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos_o());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddNpcSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddNpcSys*>(&from));
}

void AddNpcSys::MergeFrom(const AddNpcSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_npc_id()) {
      set_npc_id(from.npc_id());
    }
    if (from.has_npc_only_id()) {
      set_npc_only_id(from.npc_only_id());
    }
    if (from.has_npc_mode_id()) {
      set_npc_mode_id(from.npc_mode_id());
    }
    if (from.has_npc_type_id()) {
      set_npc_type_id(from.npc_type_id());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_pos_y()) {
      set_pos_y(from.pos_y());
    }
    if (from.has_pos_o()) {
      set_pos_o(from.pos_o());
    }
  }
}

void AddNpcSys::CopyFrom(const AddNpcSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddNpcSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void AddNpcSys::Swap(AddNpcSys* other) {
  if (other != this) {
    std::swap(npc_id_, other->npc_id_);
    std::swap(npc_only_id_, other->npc_only_id_);
    std::swap(npc_mode_id_, other->npc_mode_id_);
    std::swap(npc_type_id_, other->npc_type_id_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(pos_y_, other->pos_y_);
    std::swap(pos_o_, other->pos_o_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddNpcSys::GetTypeName() const {
  return "message.AddNpcSys";
}


// ===================================================================

#ifndef _MSC_VER
const int DelPlayerSys::kCharIdFieldNumber;
#endif  // !_MSC_VER

DelPlayerSys::DelPlayerSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DelPlayerSys::InitAsDefaultInstance() {
}

DelPlayerSys::DelPlayerSys(const DelPlayerSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DelPlayerSys::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DelPlayerSys::~DelPlayerSys() {
  SharedDtor();
}

void DelPlayerSys::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DelPlayerSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DelPlayerSys& DelPlayerSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

DelPlayerSys* DelPlayerSys::default_instance_ = NULL;

DelPlayerSys* DelPlayerSys::New() const {
  return new DelPlayerSys;
}

void DelPlayerSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DelPlayerSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DelPlayerSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

}

int DelPlayerSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DelPlayerSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DelPlayerSys*>(&from));
}

void DelPlayerSys::MergeFrom(const DelPlayerSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void DelPlayerSys::CopyFrom(const DelPlayerSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelPlayerSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DelPlayerSys::Swap(DelPlayerSys* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DelPlayerSys::GetTypeName() const {
  return "message.DelPlayerSys";
}


// ===================================================================

#ifndef _MSC_VER
const int DelNpcSys::kNpcIdFieldNumber;
#endif  // !_MSC_VER

DelNpcSys::DelNpcSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DelNpcSys::InitAsDefaultInstance() {
}

DelNpcSys::DelNpcSys(const DelNpcSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DelNpcSys::SharedCtor() {
  _cached_size_ = 0;
  npc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DelNpcSys::~DelNpcSys() {
  SharedDtor();
}

void DelNpcSys::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DelNpcSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DelNpcSys& DelNpcSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

DelNpcSys* DelNpcSys::default_instance_ = NULL;

DelNpcSys* DelNpcSys::New() const {
  return new DelNpcSys;
}

void DelNpcSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    npc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DelNpcSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 npc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &npc_id_)));
          set_has_npc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DelNpcSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 npc_id = 1;
  if (has_npc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->npc_id(), output);
  }

}

int DelNpcSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 npc_id = 1;
    if (has_npc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->npc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DelNpcSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DelNpcSys*>(&from));
}

void DelNpcSys::MergeFrom(const DelNpcSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_npc_id()) {
      set_npc_id(from.npc_id());
    }
  }
}

void DelNpcSys::CopyFrom(const DelNpcSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelNpcSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DelNpcSys::Swap(DelNpcSys* other) {
  if (other != this) {
    std::swap(npc_id_, other->npc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DelNpcSys::GetTypeName() const {
  return "message.DelNpcSys";
}


// ===================================================================

#ifndef _MSC_VER
const int GateInfoID::kGateIdFieldNumber;
#endif  // !_MSC_VER

GateInfoID::GateInfoID()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateInfoID::InitAsDefaultInstance() {
}

GateInfoID::GateInfoID(const GateInfoID& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateInfoID::SharedCtor() {
  _cached_size_ = 0;
  gate_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateInfoID::~GateInfoID() {
  SharedDtor();
}

void GateInfoID::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateInfoID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateInfoID& GateInfoID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateInfoID* GateInfoID::default_instance_ = NULL;

GateInfoID* GateInfoID::New() const {
  return new GateInfoID;
}

void GateInfoID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gate_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateInfoID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 gate_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gate_id_)));
          set_has_gate_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GateInfoID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 gate_id = 1;
  if (has_gate_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->gate_id(), output);
  }

}

int GateInfoID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 gate_id = 1;
    if (has_gate_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gate_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateInfoID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateInfoID*>(&from));
}

void GateInfoID::MergeFrom(const GateInfoID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gate_id()) {
      set_gate_id(from.gate_id());
    }
  }
}

void GateInfoID::CopyFrom(const GateInfoID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateInfoID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GateInfoID::Swap(GateInfoID* other) {
  if (other != this) {
    std::swap(gate_id_, other->gate_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateInfoID::GetTypeName() const {
  return "message.GateInfoID";
}


// ===================================================================

#ifndef _MSC_VER
const int GateLogoutCmd::kAccIdFieldNumber;
#endif  // !_MSC_VER

GateLogoutCmd::GateLogoutCmd()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GateLogoutCmd::InitAsDefaultInstance() {
}

GateLogoutCmd::GateLogoutCmd(const GateLogoutCmd& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GateLogoutCmd::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GateLogoutCmd::~GateLogoutCmd() {
  SharedDtor();
}

void GateLogoutCmd::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GateLogoutCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GateLogoutCmd& GateLogoutCmd::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GateLogoutCmd* GateLogoutCmd::default_instance_ = NULL;

GateLogoutCmd* GateLogoutCmd::New() const {
  return new GateLogoutCmd;
}

void GateLogoutCmd::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GateLogoutCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GateLogoutCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->acc_id(), output);
  }

}

int GateLogoutCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GateLogoutCmd::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GateLogoutCmd*>(&from));
}

void GateLogoutCmd::MergeFrom(const GateLogoutCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void GateLogoutCmd::CopyFrom(const GateLogoutCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GateLogoutCmd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GateLogoutCmd::Swap(GateLogoutCmd* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GateLogoutCmd::GetTypeName() const {
  return "message.GateLogoutCmd";
}


// ===================================================================

#ifndef _MSC_VER
const int Move::kCharIdFieldNumber;
const int Move::kOrientFieldNumber;
const int Move::kXFieldNumber;
const int Move::kYFieldNumber;
#endif  // !_MSC_VER

Move::Move()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Move::InitAsDefaultInstance() {
}

Move::Move(const Move& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Move::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  orient_ = 0u;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Move::~Move() {
  SharedDtor();
}

void Move::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Move::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Move& Move::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

Move* Move::default_instance_ = NULL;

Move* Move::New() const {
  return new Move;
}

void Move::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
    orient_ = 0u;
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Move::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_orient;
        break;
      }

      // required uint32 orient = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_orient:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &orient_)));
          set_has_orient();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_x;
        break;
      }

      // required float x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_y;
        break;
      }

      // required float y = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Move::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

  // required uint32 orient = 2;
  if (has_orient()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->orient(), output);
  }

  // required float x = 3;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->x(), output);
  }

  // required float y = 4;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->y(), output);
  }

}

int Move::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // required uint32 orient = 2;
    if (has_orient()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->orient());
    }

    // required float x = 3;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 4;
    if (has_y()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Move::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Move*>(&from));
}

void Move::MergeFrom(const Move& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_orient()) {
      set_orient(from.orient());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void Move::CopyFrom(const Move& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Move::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Move::Swap(Move* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(orient_, other->orient_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Move::GetTypeName() const {
  return "message.Move";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerJumpMap::kPlayerIdFieldNumber;
const int PlayerJumpMap::kJumpIdFieldNumber;
#endif  // !_MSC_VER

PlayerJumpMap::PlayerJumpMap()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerJumpMap::InitAsDefaultInstance() {
}

PlayerJumpMap::PlayerJumpMap(const PlayerJumpMap& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerJumpMap::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  jump_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerJumpMap::~PlayerJumpMap() {
  SharedDtor();
}

void PlayerJumpMap::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerJumpMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerJumpMap& PlayerJumpMap::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PlayerJumpMap* PlayerJumpMap::default_instance_ = NULL;

PlayerJumpMap* PlayerJumpMap::New() const {
  return new PlayerJumpMap;
}

void PlayerJumpMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_id_ = 0u;
    jump_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerJumpMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_jump_id;
        break;
      }

      // required uint32 jump_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_jump_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &jump_id_)));
          set_has_jump_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerJumpMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 jump_id = 2;
  if (has_jump_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->jump_id(), output);
  }

}

int PlayerJumpMap::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 jump_id = 2;
    if (has_jump_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->jump_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerJumpMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerJumpMap*>(&from));
}

void PlayerJumpMap::MergeFrom(const PlayerJumpMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_jump_id()) {
      set_jump_id(from.jump_id());
    }
  }
}

void PlayerJumpMap::CopyFrom(const PlayerJumpMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerJumpMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PlayerJumpMap::Swap(PlayerJumpMap* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(jump_id_, other->jump_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerJumpMap::GetTypeName() const {
  return "message.PlayerJumpMap";
}


// ===================================================================

#ifndef _MSC_VER
const int NPCTeleport::kNpcIdFieldNumber;
const int NPCTeleport::kBigStageIdFieldNumber;
const int NPCTeleport::kSmallStageIdFieldNumber;
#endif  // !_MSC_VER

NPCTeleport::NPCTeleport()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NPCTeleport::InitAsDefaultInstance() {
}

NPCTeleport::NPCTeleport(const NPCTeleport& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NPCTeleport::SharedCtor() {
  _cached_size_ = 0;
  npc_id_ = 0u;
  big_stage_id_ = 0u;
  small_stage_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NPCTeleport::~NPCTeleport() {
  SharedDtor();
}

void NPCTeleport::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NPCTeleport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NPCTeleport& NPCTeleport::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

NPCTeleport* NPCTeleport::default_instance_ = NULL;

NPCTeleport* NPCTeleport::New() const {
  return new NPCTeleport;
}

void NPCTeleport::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    npc_id_ = 0u;
    big_stage_id_ = 0u;
    small_stage_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NPCTeleport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 npc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &npc_id_)));
          set_has_npc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_big_stage_id;
        break;
      }

      // required uint32 big_stage_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_big_stage_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &big_stage_id_)));
          set_has_big_stage_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_small_stage_id;
        break;
      }

      // required uint32 small_stage_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_small_stage_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &small_stage_id_)));
          set_has_small_stage_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NPCTeleport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 npc_id = 1;
  if (has_npc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->npc_id(), output);
  }

  // required uint32 big_stage_id = 2;
  if (has_big_stage_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->big_stage_id(), output);
  }

  // required uint32 small_stage_id = 3;
  if (has_small_stage_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->small_stage_id(), output);
  }

}

int NPCTeleport::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 npc_id = 1;
    if (has_npc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->npc_id());
    }

    // required uint32 big_stage_id = 2;
    if (has_big_stage_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->big_stage_id());
    }

    // required uint32 small_stage_id = 3;
    if (has_small_stage_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->small_stage_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NPCTeleport::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NPCTeleport*>(&from));
}

void NPCTeleport::MergeFrom(const NPCTeleport& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_npc_id()) {
      set_npc_id(from.npc_id());
    }
    if (from.has_big_stage_id()) {
      set_big_stage_id(from.big_stage_id());
    }
    if (from.has_small_stage_id()) {
      set_small_stage_id(from.small_stage_id());
    }
  }
}

void NPCTeleport::CopyFrom(const NPCTeleport& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NPCTeleport::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void NPCTeleport::Swap(NPCTeleport* other) {
  if (other != this) {
    std::swap(npc_id_, other->npc_id_);
    std::swap(big_stage_id_, other->big_stage_id_);
    std::swap(small_stage_id_, other->small_stage_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NPCTeleport::GetTypeName() const {
  return "message.NPCTeleport";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerAttack::kPlayerIdFieldNumber;
const int PlayerAttack::kAttackIdFieldNumber;
const int PlayerAttack::kBattleTypeFieldNumber;
#endif  // !_MSC_VER

PlayerAttack::PlayerAttack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerAttack::InitAsDefaultInstance() {
}

PlayerAttack::PlayerAttack(const PlayerAttack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerAttack::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  attack_id_ = 0u;
  battle_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerAttack::~PlayerAttack() {
  SharedDtor();
}

void PlayerAttack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerAttack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerAttack& PlayerAttack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PlayerAttack* PlayerAttack::default_instance_ = NULL;

PlayerAttack* PlayerAttack::New() const {
  return new PlayerAttack;
}

void PlayerAttack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_id_ = 0u;
    attack_id_ = 0u;
    battle_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerAttack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_attack_id;
        break;
      }

      // required uint32 attack_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attack_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attack_id_)));
          set_has_attack_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_battle_type;
        break;
      }

      // optional uint32 battle_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_battle_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_type_)));
          set_has_battle_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerAttack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 attack_id = 2;
  if (has_attack_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->attack_id(), output);
  }

  // optional uint32 battle_type = 3;
  if (has_battle_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->battle_type(), output);
  }

}

int PlayerAttack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 attack_id = 2;
    if (has_attack_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->attack_id());
    }

    // optional uint32 battle_type = 3;
    if (has_battle_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerAttack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerAttack*>(&from));
}

void PlayerAttack::MergeFrom(const PlayerAttack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_attack_id()) {
      set_attack_id(from.attack_id());
    }
    if (from.has_battle_type()) {
      set_battle_type(from.battle_type());
    }
  }
}

void PlayerAttack::CopyFrom(const PlayerAttack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerAttack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PlayerAttack::Swap(PlayerAttack* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(attack_id_, other->attack_id_);
    std::swap(battle_type_, other->battle_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerAttack::GetTypeName() const {
  return "message.PlayerAttack";
}


// ===================================================================

#ifndef _MSC_VER
const int QTEResult::kPlayerIdFieldNumber;
const int QTEResult::kQTEIdFieldNumber;
const int QTEResult::kQTEResultFieldNumber;
#endif  // !_MSC_VER

QTEResult::QTEResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void QTEResult::InitAsDefaultInstance() {
}

QTEResult::QTEResult(const QTEResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void QTEResult::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  qte_id_ = 0u;
  qte_result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QTEResult::~QTEResult() {
  SharedDtor();
}

void QTEResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QTEResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QTEResult& QTEResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

QTEResult* QTEResult::default_instance_ = NULL;

QTEResult* QTEResult::New() const {
  return new QTEResult;
}

void QTEResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_id_ = 0u;
    qte_id_ = 0u;
    qte_result_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool QTEResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_QTE_id;
        break;
      }

      // required uint32 QTE_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_QTE_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &qte_id_)));
          set_has_qte_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_QTE_result;
        break;
      }

      // required uint32 QTE_result = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_QTE_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &qte_result_)));
          set_has_qte_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QTEResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 QTE_id = 2;
  if (has_qte_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->qte_id(), output);
  }

  // required uint32 QTE_result = 3;
  if (has_qte_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->qte_result(), output);
  }

}

int QTEResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 QTE_id = 2;
    if (has_qte_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->qte_id());
    }

    // required uint32 QTE_result = 3;
    if (has_qte_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->qte_result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QTEResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QTEResult*>(&from));
}

void QTEResult::MergeFrom(const QTEResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_qte_id()) {
      set_qte_id(from.qte_id());
    }
    if (from.has_qte_result()) {
      set_qte_result(from.qte_result());
    }
  }
}

void QTEResult::CopyFrom(const QTEResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QTEResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void QTEResult::Swap(QTEResult* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(qte_id_, other->qte_id_);
    std::swap(qte_result_, other->qte_result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QTEResult::GetTypeName() const {
  return "message.QTEResult";
}


// ===================================================================

#ifndef _MSC_VER
const int ClearSkill::kPlayerIdFieldNumber;
#endif  // !_MSC_VER

ClearSkill::ClearSkill()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ClearSkill::InitAsDefaultInstance() {
}

ClearSkill::ClearSkill(const ClearSkill& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ClearSkill::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClearSkill::~ClearSkill() {
  SharedDtor();
}

void ClearSkill::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClearSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClearSkill& ClearSkill::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ClearSkill* ClearSkill::default_instance_ = NULL;

ClearSkill* ClearSkill::New() const {
  return new ClearSkill;
}

void ClearSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClearSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClearSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

}

int ClearSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClearSkill::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClearSkill*>(&from));
}

void ClearSkill::MergeFrom(const ClearSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
  }
}

void ClearSkill::CopyFrom(const ClearSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearSkill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClearSkill::Swap(ClearSkill* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ClearSkill::GetTypeName() const {
  return "message.ClearSkill";
}


// ===================================================================

#ifndef _MSC_VER
const int AddSkill::kPlayerIdFieldNumber;
const int AddSkill::kSkillIdFieldNumber;
#endif  // !_MSC_VER

AddSkill::AddSkill()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddSkill::InitAsDefaultInstance() {
}

AddSkill::AddSkill(const AddSkill& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddSkill::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  skill_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddSkill::~AddSkill() {
  SharedDtor();
}

void AddSkill::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddSkill& AddSkill::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddSkill* AddSkill::default_instance_ = NULL;

AddSkill* AddSkill::New() const {
  return new AddSkill;
}

void AddSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_id_ = 0u;
    skill_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_id;
        break;
      }

      // required uint32 skill_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_id_)));
          set_has_skill_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 skill_id = 2;
  if (has_skill_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->skill_id(), output);
  }

}

int AddSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 skill_id = 2;
    if (has_skill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddSkill::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddSkill*>(&from));
}

void AddSkill::MergeFrom(const AddSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_skill_id()) {
      set_skill_id(from.skill_id());
    }
  }
}

void AddSkill::CopyFrom(const AddSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddSkill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AddSkill::Swap(AddSkill* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(skill_id_, other->skill_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddSkill::GetTypeName() const {
  return "message.AddSkill";
}


// ===================================================================

#ifndef _MSC_VER
const int SkillSequence::kPlayerIdFieldNumber;
const int SkillSequence::kSkillId1FieldNumber;
const int SkillSequence::kSkillId2FieldNumber;
const int SkillSequence::kSkillId3FieldNumber;
#endif  // !_MSC_VER

SkillSequence::SkillSequence()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SkillSequence::InitAsDefaultInstance() {
}

SkillSequence::SkillSequence(const SkillSequence& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SkillSequence::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  skill_id1_ = 0u;
  skill_id2_ = 0u;
  skill_id3_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SkillSequence::~SkillSequence() {
  SharedDtor();
}

void SkillSequence::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SkillSequence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SkillSequence& SkillSequence::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SkillSequence* SkillSequence::default_instance_ = NULL;

SkillSequence* SkillSequence::New() const {
  return new SkillSequence;
}

void SkillSequence::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_id_ = 0u;
    skill_id1_ = 0u;
    skill_id2_ = 0u;
    skill_id3_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SkillSequence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_id1;
        break;
      }

      // required uint32 skill_id1 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_id1_)));
          set_has_skill_id1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skill_id2;
        break;
      }

      // required uint32 skill_id2 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_id2_)));
          set_has_skill_id2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_skill_id3;
        break;
      }

      // required uint32 skill_id3 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_id3_)));
          set_has_skill_id3();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SkillSequence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 skill_id1 = 2;
  if (has_skill_id1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->skill_id1(), output);
  }

  // required uint32 skill_id2 = 3;
  if (has_skill_id2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->skill_id2(), output);
  }

  // required uint32 skill_id3 = 4;
  if (has_skill_id3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->skill_id3(), output);
  }

}

int SkillSequence::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 skill_id1 = 2;
    if (has_skill_id1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_id1());
    }

    // required uint32 skill_id2 = 3;
    if (has_skill_id2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_id2());
    }

    // required uint32 skill_id3 = 4;
    if (has_skill_id3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_id3());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SkillSequence::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SkillSequence*>(&from));
}

void SkillSequence::MergeFrom(const SkillSequence& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_skill_id1()) {
      set_skill_id1(from.skill_id1());
    }
    if (from.has_skill_id2()) {
      set_skill_id2(from.skill_id2());
    }
    if (from.has_skill_id3()) {
      set_skill_id3(from.skill_id3());
    }
  }
}

void SkillSequence::CopyFrom(const SkillSequence& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SkillSequence::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void SkillSequence::Swap(SkillSequence* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(skill_id1_, other->skill_id1_);
    std::swap(skill_id2_, other->skill_id2_);
    std::swap(skill_id3_, other->skill_id3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SkillSequence::GetTypeName() const {
  return "message.SkillSequence";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleCharInfo_CharInfo::kCharIdFieldNumber;
const int BattleCharInfo_CharInfo::kModeIdFieldNumber;
const int BattleCharInfo_CharInfo::kPosXFieldNumber;
const int BattleCharInfo_CharInfo::kHpFieldNumber;
const int BattleCharInfo_CharInfo::kMoveSpeedFieldNumber;
const int BattleCharInfo_CharInfo::kSexFieldNumber;
const int BattleCharInfo_CharInfo::kWeaponFieldNumber;
const int BattleCharInfo_CharInfo::kMpFieldNumber;
const int BattleCharInfo_CharInfo::kIsBossFieldNumber;
const int BattleCharInfo_CharInfo::kBossNameFieldNumber;
#endif  // !_MSC_VER

BattleCharInfo_CharInfo::BattleCharInfo_CharInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleCharInfo_CharInfo::InitAsDefaultInstance() {
}

BattleCharInfo_CharInfo::BattleCharInfo_CharInfo(const BattleCharInfo_CharInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleCharInfo_CharInfo::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  mode_id_ = 0;
  pos_x_ = 0;
  hp_ = 0;
  move_speed_ = 0;
  sex_ = 0;
  weapon_ = 0;
  mp_ = 0;
  is_boss_ = 0;
  boss_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleCharInfo_CharInfo::~BattleCharInfo_CharInfo() {
  SharedDtor();
}

void BattleCharInfo_CharInfo::SharedDtor() {
  if (boss_name_ != &::google::protobuf::internal::kEmptyString) {
    delete boss_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleCharInfo_CharInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleCharInfo_CharInfo& BattleCharInfo_CharInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleCharInfo_CharInfo* BattleCharInfo_CharInfo::default_instance_ = NULL;

BattleCharInfo_CharInfo* BattleCharInfo_CharInfo::New() const {
  return new BattleCharInfo_CharInfo;
}

void BattleCharInfo_CharInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    mode_id_ = 0;
    pos_x_ = 0;
    hp_ = 0;
    move_speed_ = 0;
    sex_ = 0;
    weapon_ = 0;
    mp_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    is_boss_ = 0;
    if (has_boss_name()) {
      if (boss_name_ != &::google::protobuf::internal::kEmptyString) {
        boss_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleCharInfo_CharInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mode_id;
        break;
      }

      // required int32 mode_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mode_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mode_id_)));
          set_has_mode_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pos_x;
        break;
      }

      // required int32 pos_x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_hp;
        break;
      }

      // required int32 hp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hp_)));
          set_has_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_move_speed;
        break;
      }

      // required int32 move_speed = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_move_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &move_speed_)));
          set_has_move_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_sex;
        break;
      }

      // optional int32 sex = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_weapon;
        break;
      }

      // optional int32 weapon = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weapon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weapon_)));
          set_has_weapon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_mp;
        break;
      }

      // optional int32 mp = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mp_)));
          set_has_mp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_is_boss;
        break;
      }

      // optional int32 is_boss = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_boss:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_boss_)));
          set_has_is_boss();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_boss_name;
        break;
      }

      // optional bytes boss_name = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_boss_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_boss_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleCharInfo_CharInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 mode_id = 2;
  if (has_mode_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->mode_id(), output);
  }

  // required int32 pos_x = 3;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->pos_x(), output);
  }

  // required int32 hp = 4;
  if (has_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->hp(), output);
  }

  // required int32 move_speed = 5;
  if (has_move_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->move_speed(), output);
  }

  // optional int32 sex = 6;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->sex(), output);
  }

  // optional int32 weapon = 7;
  if (has_weapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->weapon(), output);
  }

  // optional int32 mp = 8;
  if (has_mp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->mp(), output);
  }

  // optional int32 is_boss = 9;
  if (has_is_boss()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->is_boss(), output);
  }

  // optional bytes boss_name = 10;
  if (has_boss_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->boss_name(), output);
  }

}

int BattleCharInfo_CharInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 mode_id = 2;
    if (has_mode_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mode_id());
    }

    // required int32 pos_x = 3;
    if (has_pos_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos_x());
    }

    // required int32 hp = 4;
    if (has_hp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hp());
    }

    // required int32 move_speed = 5;
    if (has_move_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->move_speed());
    }

    // optional int32 sex = 6;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sex());
    }

    // optional int32 weapon = 7;
    if (has_weapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->weapon());
    }

    // optional int32 mp = 8;
    if (has_mp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mp());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 is_boss = 9;
    if (has_is_boss()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_boss());
    }

    // optional bytes boss_name = 10;
    if (has_boss_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->boss_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleCharInfo_CharInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleCharInfo_CharInfo*>(&from));
}

void BattleCharInfo_CharInfo::MergeFrom(const BattleCharInfo_CharInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_mode_id()) {
      set_mode_id(from.mode_id());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_hp()) {
      set_hp(from.hp());
    }
    if (from.has_move_speed()) {
      set_move_speed(from.move_speed());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_weapon()) {
      set_weapon(from.weapon());
    }
    if (from.has_mp()) {
      set_mp(from.mp());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_is_boss()) {
      set_is_boss(from.is_boss());
    }
    if (from.has_boss_name()) {
      set_boss_name(from.boss_name());
    }
  }
}

void BattleCharInfo_CharInfo::CopyFrom(const BattleCharInfo_CharInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleCharInfo_CharInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void BattleCharInfo_CharInfo::Swap(BattleCharInfo_CharInfo* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(mode_id_, other->mode_id_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(hp_, other->hp_);
    std::swap(move_speed_, other->move_speed_);
    std::swap(sex_, other->sex_);
    std::swap(weapon_, other->weapon_);
    std::swap(mp_, other->mp_);
    std::swap(is_boss_, other->is_boss_);
    std::swap(boss_name_, other->boss_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleCharInfo_CharInfo::GetTypeName() const {
  return "message.BattleCharInfo.CharInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleCharInfo::kCharinfoFieldNumber;
#endif  // !_MSC_VER

BattleCharInfo::BattleCharInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleCharInfo::InitAsDefaultInstance() {
}

BattleCharInfo::BattleCharInfo(const BattleCharInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleCharInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleCharInfo::~BattleCharInfo() {
  SharedDtor();
}

void BattleCharInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleCharInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleCharInfo& BattleCharInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleCharInfo* BattleCharInfo::default_instance_ = NULL;

BattleCharInfo* BattleCharInfo::New() const {
  return new BattleCharInfo;
}

void BattleCharInfo::Clear() {
  charinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleCharInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.BattleCharInfo.CharInfo charinfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_charinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_charinfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleCharInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.BattleCharInfo.CharInfo charinfo = 1;
  for (int i = 0; i < this->charinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->charinfo(i), output);
  }

}

int BattleCharInfo::ByteSize() const {
  int total_size = 0;

  // repeated .message.BattleCharInfo.CharInfo charinfo = 1;
  total_size += 1 * this->charinfo_size();
  for (int i = 0; i < this->charinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->charinfo(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleCharInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleCharInfo*>(&from));
}

void BattleCharInfo::MergeFrom(const BattleCharInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  charinfo_.MergeFrom(from.charinfo_);
}

void BattleCharInfo::CopyFrom(const BattleCharInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleCharInfo::IsInitialized() const {

  for (int i = 0; i < charinfo_size(); i++) {
    if (!this->charinfo(i).IsInitialized()) return false;
  }
  return true;
}

void BattleCharInfo::Swap(BattleCharInfo* other) {
  if (other != this) {
    charinfo_.Swap(&other->charinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleCharInfo::GetTypeName() const {
  return "message.BattleCharInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleActionInfo_StartStopEvent::kCharIdFieldNumber;
const int BattleActionInfo_StartStopEvent::kEventTypeIdFieldNumber;
const int BattleActionInfo_StartStopEvent::kEventStartEndFieldNumber;
const int BattleActionInfo_StartStopEvent::kEventValueFieldNumber;
const int BattleActionInfo_StartStopEvent::kMoveToXFieldNumber;
const int BattleActionInfo_StartStopEvent::kTargetIdFieldNumber;
const int BattleActionInfo_StartStopEvent::kNextXFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo_StartStopEvent::BattleActionInfo_StartStopEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo_StartStopEvent::InitAsDefaultInstance() {
}

BattleActionInfo_StartStopEvent::BattleActionInfo_StartStopEvent(const BattleActionInfo_StartStopEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo_StartStopEvent::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  event_type_id_ = 0;
  event_start_end_ = 0;
  event_value_ = 0;
  move_to_x_ = 0;
  target_id_ = 0;
  next_x_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo_StartStopEvent::~BattleActionInfo_StartStopEvent() {
  SharedDtor();
}

void BattleActionInfo_StartStopEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleActionInfo_StartStopEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo_StartStopEvent& BattleActionInfo_StartStopEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo_StartStopEvent* BattleActionInfo_StartStopEvent::default_instance_ = NULL;

BattleActionInfo_StartStopEvent* BattleActionInfo_StartStopEvent::New() const {
  return new BattleActionInfo_StartStopEvent;
}

void BattleActionInfo_StartStopEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    event_type_id_ = 0;
    event_start_end_ = 0;
    event_value_ = 0;
    move_to_x_ = 0;
    target_id_ = 0;
    next_x_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo_StartStopEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_event_type_id;
        break;
      }

      // required int32 event_type_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_event_type_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &event_type_id_)));
          set_has_event_type_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_event_start_end;
        break;
      }

      // required int32 event_start_end = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_event_start_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &event_start_end_)));
          set_has_event_start_end();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_event_value;
        break;
      }

      // optional int32 event_value = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_event_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &event_value_)));
          set_has_event_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_move_to_x;
        break;
      }

      // optional int32 move_to_x = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_move_to_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &move_to_x_)));
          set_has_move_to_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_target_id;
        break;
      }

      // optional int32 target_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_id_)));
          set_has_target_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_next_x;
        break;
      }

      // optional int32 next_x = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_next_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &next_x_)));
          set_has_next_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo_StartStopEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 event_type_id = 2;
  if (has_event_type_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->event_type_id(), output);
  }

  // required int32 event_start_end = 3;
  if (has_event_start_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->event_start_end(), output);
  }

  // optional int32 event_value = 4;
  if (has_event_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->event_value(), output);
  }

  // optional int32 move_to_x = 5;
  if (has_move_to_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->move_to_x(), output);
  }

  // optional int32 target_id = 6;
  if (has_target_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->target_id(), output);
  }

  // optional int32 next_x = 7;
  if (has_next_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->next_x(), output);
  }

}

int BattleActionInfo_StartStopEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 event_type_id = 2;
    if (has_event_type_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->event_type_id());
    }

    // required int32 event_start_end = 3;
    if (has_event_start_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->event_start_end());
    }

    // optional int32 event_value = 4;
    if (has_event_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->event_value());
    }

    // optional int32 move_to_x = 5;
    if (has_move_to_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->move_to_x());
    }

    // optional int32 target_id = 6;
    if (has_target_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->target_id());
    }

    // optional int32 next_x = 7;
    if (has_next_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->next_x());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo_StartStopEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo_StartStopEvent*>(&from));
}

void BattleActionInfo_StartStopEvent::MergeFrom(const BattleActionInfo_StartStopEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_event_type_id()) {
      set_event_type_id(from.event_type_id());
    }
    if (from.has_event_start_end()) {
      set_event_start_end(from.event_start_end());
    }
    if (from.has_event_value()) {
      set_event_value(from.event_value());
    }
    if (from.has_move_to_x()) {
      set_move_to_x(from.move_to_x());
    }
    if (from.has_target_id()) {
      set_target_id(from.target_id());
    }
    if (from.has_next_x()) {
      set_next_x(from.next_x());
    }
  }
}

void BattleActionInfo_StartStopEvent::CopyFrom(const BattleActionInfo_StartStopEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo_StartStopEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BattleActionInfo_StartStopEvent::Swap(BattleActionInfo_StartStopEvent* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(event_type_id_, other->event_type_id_);
    std::swap(event_start_end_, other->event_start_end_);
    std::swap(event_value_, other->event_value_);
    std::swap(move_to_x_, other->move_to_x_);
    std::swap(target_id_, other->target_id_);
    std::swap(next_x_, other->next_x_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo_StartStopEvent::GetTypeName() const {
  return "message.BattleActionInfo.StartStopEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleActionInfo_TargetEvent::kTargetCharIdFieldNumber;
const int BattleActionInfo_TargetEvent::kDamageFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo_TargetEvent::BattleActionInfo_TargetEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo_TargetEvent::InitAsDefaultInstance() {
}

BattleActionInfo_TargetEvent::BattleActionInfo_TargetEvent(const BattleActionInfo_TargetEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo_TargetEvent::SharedCtor() {
  _cached_size_ = 0;
  target_char_id_ = 0;
  damage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo_TargetEvent::~BattleActionInfo_TargetEvent() {
  SharedDtor();
}

void BattleActionInfo_TargetEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleActionInfo_TargetEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo_TargetEvent& BattleActionInfo_TargetEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo_TargetEvent* BattleActionInfo_TargetEvent::default_instance_ = NULL;

BattleActionInfo_TargetEvent* BattleActionInfo_TargetEvent::New() const {
  return new BattleActionInfo_TargetEvent;
}

void BattleActionInfo_TargetEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    target_char_id_ = 0;
    damage_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo_TargetEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 target_char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_char_id_)));
          set_has_target_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_damage;
        break;
      }

      // required int32 damage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &damage_)));
          set_has_damage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo_TargetEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 target_char_id = 1;
  if (has_target_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->target_char_id(), output);
  }

  // required int32 damage = 2;
  if (has_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->damage(), output);
  }

}

int BattleActionInfo_TargetEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 target_char_id = 1;
    if (has_target_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->target_char_id());
    }

    // required int32 damage = 2;
    if (has_damage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->damage());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo_TargetEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo_TargetEvent*>(&from));
}

void BattleActionInfo_TargetEvent::MergeFrom(const BattleActionInfo_TargetEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_char_id()) {
      set_target_char_id(from.target_char_id());
    }
    if (from.has_damage()) {
      set_damage(from.damage());
    }
  }
}

void BattleActionInfo_TargetEvent::CopyFrom(const BattleActionInfo_TargetEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo_TargetEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BattleActionInfo_TargetEvent::Swap(BattleActionInfo_TargetEvent* other) {
  if (other != this) {
    std::swap(target_char_id_, other->target_char_id_);
    std::swap(damage_, other->damage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo_TargetEvent::GetTypeName() const {
  return "message.BattleActionInfo.TargetEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleActionInfo_AttackEvent::kCharIdFieldNumber;
const int BattleActionInfo_AttackEvent::kSkillIdFieldNumber;
const int BattleActionInfo_AttackEvent::kTargetCharIdFieldNumber;
const int BattleActionInfo_AttackEvent::kChangeValueFieldNumber;
const int BattleActionInfo_AttackEvent::kIsCriticalFieldNumber;
const int BattleActionInfo_AttackEvent::kTimeInfoFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo_AttackEvent::BattleActionInfo_AttackEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo_AttackEvent::InitAsDefaultInstance() {
}

BattleActionInfo_AttackEvent::BattleActionInfo_AttackEvent(const BattleActionInfo_AttackEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo_AttackEvent::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  skill_id_ = 0;
  change_value_ = 0;
  is_critical_ = 0;
  time_info_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo_AttackEvent::~BattleActionInfo_AttackEvent() {
  SharedDtor();
}

void BattleActionInfo_AttackEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleActionInfo_AttackEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo_AttackEvent& BattleActionInfo_AttackEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo_AttackEvent* BattleActionInfo_AttackEvent::default_instance_ = NULL;

BattleActionInfo_AttackEvent* BattleActionInfo_AttackEvent::New() const {
  return new BattleActionInfo_AttackEvent;
}

void BattleActionInfo_AttackEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    skill_id_ = 0;
    change_value_ = 0;
    is_critical_ = 0;
    time_info_ = 0;
  }
  target_char_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo_AttackEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_id;
        break;
      }

      // required int32 skill_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skill_id_)));
          set_has_skill_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_char_id;
        break;
      }

      // repeated int32 target_char_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_target_char_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_target_char_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_char_id;
        if (input->ExpectTag(32)) goto parse_change_value;
        break;
      }

      // optional int32 change_value = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_change_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &change_value_)));
          set_has_change_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_is_critical;
        break;
      }

      // optional int32 is_critical = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_critical:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_critical_)));
          set_has_is_critical();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_time_info;
        break;
      }

      // optional int32 time_info = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_info_)));
          set_has_time_info();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo_AttackEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 skill_id = 2;
  if (has_skill_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->skill_id(), output);
  }

  // repeated int32 target_char_id = 3;
  for (int i = 0; i < this->target_char_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->target_char_id(i), output);
  }

  // optional int32 change_value = 4;
  if (has_change_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->change_value(), output);
  }

  // optional int32 is_critical = 5;
  if (has_is_critical()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->is_critical(), output);
  }

  // optional int32 time_info = 6;
  if (has_time_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->time_info(), output);
  }

}

int BattleActionInfo_AttackEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 skill_id = 2;
    if (has_skill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skill_id());
    }

    // optional int32 change_value = 4;
    if (has_change_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->change_value());
    }

    // optional int32 is_critical = 5;
    if (has_is_critical()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_critical());
    }

    // optional int32 time_info = 6;
    if (has_time_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time_info());
    }

  }
  // repeated int32 target_char_id = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->target_char_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->target_char_id(i));
    }
    total_size += 1 * this->target_char_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo_AttackEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo_AttackEvent*>(&from));
}

void BattleActionInfo_AttackEvent::MergeFrom(const BattleActionInfo_AttackEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_char_id_.MergeFrom(from.target_char_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_skill_id()) {
      set_skill_id(from.skill_id());
    }
    if (from.has_change_value()) {
      set_change_value(from.change_value());
    }
    if (from.has_is_critical()) {
      set_is_critical(from.is_critical());
    }
    if (from.has_time_info()) {
      set_time_info(from.time_info());
    }
  }
}

void BattleActionInfo_AttackEvent::CopyFrom(const BattleActionInfo_AttackEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo_AttackEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BattleActionInfo_AttackEvent::Swap(BattleActionInfo_AttackEvent* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(skill_id_, other->skill_id_);
    target_char_id_.Swap(&other->target_char_id_);
    std::swap(change_value_, other->change_value_);
    std::swap(is_critical_, other->is_critical_);
    std::swap(time_info_, other->time_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo_AttackEvent::GetTypeName() const {
  return "message.BattleActionInfo.AttackEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleActionInfo_AttrChangeEvent::kCharIdFieldNumber;
const int BattleActionInfo_AttrChangeEvent::kChangeTypeFieldNumber;
const int BattleActionInfo_AttrChangeEvent::kChangeValueFieldNumber;
const int BattleActionInfo_AttrChangeEvent::kSkillDamageFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo_AttrChangeEvent::BattleActionInfo_AttrChangeEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo_AttrChangeEvent::InitAsDefaultInstance() {
}

BattleActionInfo_AttrChangeEvent::BattleActionInfo_AttrChangeEvent(const BattleActionInfo_AttrChangeEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo_AttrChangeEvent::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  change_type_ = 0;
  change_value_ = 0;
  skill_damage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo_AttrChangeEvent::~BattleActionInfo_AttrChangeEvent() {
  SharedDtor();
}

void BattleActionInfo_AttrChangeEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleActionInfo_AttrChangeEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo_AttrChangeEvent& BattleActionInfo_AttrChangeEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo_AttrChangeEvent* BattleActionInfo_AttrChangeEvent::default_instance_ = NULL;

BattleActionInfo_AttrChangeEvent* BattleActionInfo_AttrChangeEvent::New() const {
  return new BattleActionInfo_AttrChangeEvent;
}

void BattleActionInfo_AttrChangeEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    change_type_ = 0;
    change_value_ = 0;
    skill_damage_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo_AttrChangeEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_change_type;
        break;
      }

      // required int32 change_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_change_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &change_type_)));
          set_has_change_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_change_value;
        break;
      }

      // required int32 change_value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_change_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &change_value_)));
          set_has_change_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_skill_damage;
        break;
      }

      // optional int32 skill_damage = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skill_damage_)));
          set_has_skill_damage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo_AttrChangeEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 change_type = 2;
  if (has_change_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->change_type(), output);
  }

  // required int32 change_value = 3;
  if (has_change_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->change_value(), output);
  }

  // optional int32 skill_damage = 4;
  if (has_skill_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->skill_damage(), output);
  }

}

int BattleActionInfo_AttrChangeEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 change_type = 2;
    if (has_change_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->change_type());
    }

    // required int32 change_value = 3;
    if (has_change_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->change_value());
    }

    // optional int32 skill_damage = 4;
    if (has_skill_damage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skill_damage());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo_AttrChangeEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo_AttrChangeEvent*>(&from));
}

void BattleActionInfo_AttrChangeEvent::MergeFrom(const BattleActionInfo_AttrChangeEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_change_type()) {
      set_change_type(from.change_type());
    }
    if (from.has_change_value()) {
      set_change_value(from.change_value());
    }
    if (from.has_skill_damage()) {
      set_skill_damage(from.skill_damage());
    }
  }
}

void BattleActionInfo_AttrChangeEvent::CopyFrom(const BattleActionInfo_AttrChangeEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo_AttrChangeEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BattleActionInfo_AttrChangeEvent::Swap(BattleActionInfo_AttrChangeEvent* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(change_type_, other->change_type_);
    std::swap(change_value_, other->change_value_);
    std::swap(skill_damage_, other->skill_damage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo_AttrChangeEvent::GetTypeName() const {
  return "message.BattleActionInfo.AttrChangeEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleActionInfo_SummonEvent::kCharIdFieldNumber;
const int BattleActionInfo_SummonEvent::kModeIdFieldNumber;
const int BattleActionInfo_SummonEvent::kPosXFieldNumber;
const int BattleActionInfo_SummonEvent::kHpFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo_SummonEvent::BattleActionInfo_SummonEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo_SummonEvent::InitAsDefaultInstance() {
}

BattleActionInfo_SummonEvent::BattleActionInfo_SummonEvent(const BattleActionInfo_SummonEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo_SummonEvent::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  mode_id_ = 0;
  pos_x_ = 0;
  hp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo_SummonEvent::~BattleActionInfo_SummonEvent() {
  SharedDtor();
}

void BattleActionInfo_SummonEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleActionInfo_SummonEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo_SummonEvent& BattleActionInfo_SummonEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo_SummonEvent* BattleActionInfo_SummonEvent::default_instance_ = NULL;

BattleActionInfo_SummonEvent* BattleActionInfo_SummonEvent::New() const {
  return new BattleActionInfo_SummonEvent;
}

void BattleActionInfo_SummonEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    mode_id_ = 0;
    pos_x_ = 0;
    hp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo_SummonEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mode_id;
        break;
      }

      // required int32 mode_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mode_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mode_id_)));
          set_has_mode_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pos_x;
        break;
      }

      // required int32 pos_x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_hp;
        break;
      }

      // required int32 hp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hp_)));
          set_has_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo_SummonEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 mode_id = 2;
  if (has_mode_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->mode_id(), output);
  }

  // required int32 pos_x = 3;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->pos_x(), output);
  }

  // required int32 hp = 4;
  if (has_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->hp(), output);
  }

}

int BattleActionInfo_SummonEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 mode_id = 2;
    if (has_mode_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mode_id());
    }

    // required int32 pos_x = 3;
    if (has_pos_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos_x());
    }

    // required int32 hp = 4;
    if (has_hp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo_SummonEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo_SummonEvent*>(&from));
}

void BattleActionInfo_SummonEvent::MergeFrom(const BattleActionInfo_SummonEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_mode_id()) {
      set_mode_id(from.mode_id());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_hp()) {
      set_hp(from.hp());
    }
  }
}

void BattleActionInfo_SummonEvent::CopyFrom(const BattleActionInfo_SummonEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo_SummonEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void BattleActionInfo_SummonEvent::Swap(BattleActionInfo_SummonEvent* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(mode_id_, other->mode_id_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(hp_, other->hp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo_SummonEvent::GetTypeName() const {
  return "message.BattleActionInfo.SummonEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleActionInfo_SufferEvent::kCharIdFieldNumber;
const int BattleActionInfo_SufferEvent::kSkillIdFieldNumber;
const int BattleActionInfo_SufferEvent::kTargetCharIdFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo_SufferEvent::BattleActionInfo_SufferEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo_SufferEvent::InitAsDefaultInstance() {
}

BattleActionInfo_SufferEvent::BattleActionInfo_SufferEvent(const BattleActionInfo_SufferEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo_SufferEvent::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  skill_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo_SufferEvent::~BattleActionInfo_SufferEvent() {
  SharedDtor();
}

void BattleActionInfo_SufferEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleActionInfo_SufferEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo_SufferEvent& BattleActionInfo_SufferEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo_SufferEvent* BattleActionInfo_SufferEvent::default_instance_ = NULL;

BattleActionInfo_SufferEvent* BattleActionInfo_SufferEvent::New() const {
  return new BattleActionInfo_SufferEvent;
}

void BattleActionInfo_SufferEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    skill_id_ = 0;
  }
  target_char_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo_SufferEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_id;
        break;
      }

      // required int32 skill_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skill_id_)));
          set_has_skill_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_char_id;
        break;
      }

      // repeated int32 target_char_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_target_char_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_target_char_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_char_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo_SufferEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 skill_id = 2;
  if (has_skill_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->skill_id(), output);
  }

  // repeated int32 target_char_id = 3;
  for (int i = 0; i < this->target_char_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->target_char_id(i), output);
  }

}

int BattleActionInfo_SufferEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 skill_id = 2;
    if (has_skill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skill_id());
    }

  }
  // repeated int32 target_char_id = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->target_char_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->target_char_id(i));
    }
    total_size += 1 * this->target_char_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo_SufferEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo_SufferEvent*>(&from));
}

void BattleActionInfo_SufferEvent::MergeFrom(const BattleActionInfo_SufferEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_char_id_.MergeFrom(from.target_char_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_skill_id()) {
      set_skill_id(from.skill_id());
    }
  }
}

void BattleActionInfo_SufferEvent::CopyFrom(const BattleActionInfo_SufferEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo_SufferEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BattleActionInfo_SufferEvent::Swap(BattleActionInfo_SufferEvent* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(skill_id_, other->skill_id_);
    target_char_id_.Swap(&other->target_char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo_SufferEvent::GetTypeName() const {
  return "message.BattleActionInfo.SufferEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleActionInfo_CastAreaEvent::kEventStartEndFieldNumber;
const int BattleActionInfo_CastAreaEvent::kPosXFieldNumber;
const int BattleActionInfo_CastAreaEvent::kAreaFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo_CastAreaEvent::BattleActionInfo_CastAreaEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo_CastAreaEvent::InitAsDefaultInstance() {
}

BattleActionInfo_CastAreaEvent::BattleActionInfo_CastAreaEvent(const BattleActionInfo_CastAreaEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo_CastAreaEvent::SharedCtor() {
  _cached_size_ = 0;
  event_start_end_ = 0;
  pos_x_ = 0;
  area_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo_CastAreaEvent::~BattleActionInfo_CastAreaEvent() {
  SharedDtor();
}

void BattleActionInfo_CastAreaEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleActionInfo_CastAreaEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo_CastAreaEvent& BattleActionInfo_CastAreaEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo_CastAreaEvent* BattleActionInfo_CastAreaEvent::default_instance_ = NULL;

BattleActionInfo_CastAreaEvent* BattleActionInfo_CastAreaEvent::New() const {
  return new BattleActionInfo_CastAreaEvent;
}

void BattleActionInfo_CastAreaEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    event_start_end_ = 0;
    pos_x_ = 0;
    area_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo_CastAreaEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 event_start_end = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &event_start_end_)));
          set_has_event_start_end();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pos_x;
        break;
      }

      // required int32 pos_x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_area;
        break;
      }

      // required int32 area = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_area:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &area_)));
          set_has_area();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo_CastAreaEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 event_start_end = 1;
  if (has_event_start_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->event_start_end(), output);
  }

  // required int32 pos_x = 2;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->pos_x(), output);
  }

  // required int32 area = 3;
  if (has_area()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->area(), output);
  }

}

int BattleActionInfo_CastAreaEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 event_start_end = 1;
    if (has_event_start_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->event_start_end());
    }

    // required int32 pos_x = 2;
    if (has_pos_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos_x());
    }

    // required int32 area = 3;
    if (has_area()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->area());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo_CastAreaEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo_CastAreaEvent*>(&from));
}

void BattleActionInfo_CastAreaEvent::MergeFrom(const BattleActionInfo_CastAreaEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_event_start_end()) {
      set_event_start_end(from.event_start_end());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_area()) {
      set_area(from.area());
    }
  }
}

void BattleActionInfo_CastAreaEvent::CopyFrom(const BattleActionInfo_CastAreaEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo_CastAreaEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BattleActionInfo_CastAreaEvent::Swap(BattleActionInfo_CastAreaEvent* other) {
  if (other != this) {
    std::swap(event_start_end_, other->event_start_end_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(area_, other->area_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo_CastAreaEvent::GetTypeName() const {
  return "message.BattleActionInfo.CastAreaEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleActionInfo_ActionInfo::kStartStopEventFieldNumber;
const int BattleActionInfo_ActionInfo::kAttackEventFieldNumber;
const int BattleActionInfo_ActionInfo::kAttrChangeEventFieldNumber;
const int BattleActionInfo_ActionInfo::kSummonEventFieldNumber;
const int BattleActionInfo_ActionInfo::kSufferEventFieldNumber;
const int BattleActionInfo_ActionInfo::kCastAreaEventFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo_ActionInfo::BattleActionInfo_ActionInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo_ActionInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  start_stop_event_ = const_cast< ::message::BattleActionInfo_StartStopEvent*>(
      ::message::BattleActionInfo_StartStopEvent::internal_default_instance());
#else
  start_stop_event_ = const_cast< ::message::BattleActionInfo_StartStopEvent*>(&::message::BattleActionInfo_StartStopEvent::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  attack_event_ = const_cast< ::message::BattleActionInfo_AttackEvent*>(
      ::message::BattleActionInfo_AttackEvent::internal_default_instance());
#else
  attack_event_ = const_cast< ::message::BattleActionInfo_AttackEvent*>(&::message::BattleActionInfo_AttackEvent::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  attr_change_event_ = const_cast< ::message::BattleActionInfo_AttrChangeEvent*>(
      ::message::BattleActionInfo_AttrChangeEvent::internal_default_instance());
#else
  attr_change_event_ = const_cast< ::message::BattleActionInfo_AttrChangeEvent*>(&::message::BattleActionInfo_AttrChangeEvent::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  summon_event_ = const_cast< ::message::BattleActionInfo_SummonEvent*>(
      ::message::BattleActionInfo_SummonEvent::internal_default_instance());
#else
  summon_event_ = const_cast< ::message::BattleActionInfo_SummonEvent*>(&::message::BattleActionInfo_SummonEvent::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  suffer_event_ = const_cast< ::message::BattleActionInfo_SufferEvent*>(
      ::message::BattleActionInfo_SufferEvent::internal_default_instance());
#else
  suffer_event_ = const_cast< ::message::BattleActionInfo_SufferEvent*>(&::message::BattleActionInfo_SufferEvent::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cast_area_event_ = const_cast< ::message::BattleActionInfo_CastAreaEvent*>(
      ::message::BattleActionInfo_CastAreaEvent::internal_default_instance());
#else
  cast_area_event_ = const_cast< ::message::BattleActionInfo_CastAreaEvent*>(&::message::BattleActionInfo_CastAreaEvent::default_instance());
#endif
}

BattleActionInfo_ActionInfo::BattleActionInfo_ActionInfo(const BattleActionInfo_ActionInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo_ActionInfo::SharedCtor() {
  _cached_size_ = 0;
  start_stop_event_ = NULL;
  attack_event_ = NULL;
  attr_change_event_ = NULL;
  summon_event_ = NULL;
  suffer_event_ = NULL;
  cast_area_event_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo_ActionInfo::~BattleActionInfo_ActionInfo() {
  SharedDtor();
}

void BattleActionInfo_ActionInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete start_stop_event_;
    delete attack_event_;
    delete attr_change_event_;
    delete summon_event_;
    delete suffer_event_;
    delete cast_area_event_;
  }
}

void BattleActionInfo_ActionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo_ActionInfo& BattleActionInfo_ActionInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo_ActionInfo* BattleActionInfo_ActionInfo::default_instance_ = NULL;

BattleActionInfo_ActionInfo* BattleActionInfo_ActionInfo::New() const {
  return new BattleActionInfo_ActionInfo;
}

void BattleActionInfo_ActionInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_start_stop_event()) {
      if (start_stop_event_ != NULL) start_stop_event_->::message::BattleActionInfo_StartStopEvent::Clear();
    }
    if (has_attack_event()) {
      if (attack_event_ != NULL) attack_event_->::message::BattleActionInfo_AttackEvent::Clear();
    }
    if (has_attr_change_event()) {
      if (attr_change_event_ != NULL) attr_change_event_->::message::BattleActionInfo_AttrChangeEvent::Clear();
    }
    if (has_summon_event()) {
      if (summon_event_ != NULL) summon_event_->::message::BattleActionInfo_SummonEvent::Clear();
    }
    if (has_suffer_event()) {
      if (suffer_event_ != NULL) suffer_event_->::message::BattleActionInfo_SufferEvent::Clear();
    }
    if (has_cast_area_event()) {
      if (cast_area_event_ != NULL) cast_area_event_->::message::BattleActionInfo_CastAreaEvent::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo_ActionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .message.BattleActionInfo.StartStopEvent start_stop_event = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start_stop_event()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attack_event;
        break;
      }

      // optional .message.BattleActionInfo.AttackEvent attack_event = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attack_event:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attack_event()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_attr_change_event;
        break;
      }

      // optional .message.BattleActionInfo.AttrChangeEvent attr_change_event = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attr_change_event:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attr_change_event()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_summon_event;
        break;
      }

      // optional .message.BattleActionInfo.SummonEvent summon_event = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_summon_event:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_summon_event()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_suffer_event;
        break;
      }

      // optional .message.BattleActionInfo.SufferEvent suffer_event = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_suffer_event:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_suffer_event()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_cast_area_event;
        break;
      }

      // optional .message.BattleActionInfo.CastAreaEvent cast_area_event = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cast_area_event:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cast_area_event()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo_ActionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .message.BattleActionInfo.StartStopEvent start_stop_event = 1;
  if (has_start_stop_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->start_stop_event(), output);
  }

  // optional .message.BattleActionInfo.AttackEvent attack_event = 2;
  if (has_attack_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->attack_event(), output);
  }

  // optional .message.BattleActionInfo.AttrChangeEvent attr_change_event = 3;
  if (has_attr_change_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->attr_change_event(), output);
  }

  // optional .message.BattleActionInfo.SummonEvent summon_event = 4;
  if (has_summon_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->summon_event(), output);
  }

  // optional .message.BattleActionInfo.SufferEvent suffer_event = 5;
  if (has_suffer_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->suffer_event(), output);
  }

  // optional .message.BattleActionInfo.CastAreaEvent cast_area_event = 6;
  if (has_cast_area_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->cast_area_event(), output);
  }

}

int BattleActionInfo_ActionInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .message.BattleActionInfo.StartStopEvent start_stop_event = 1;
    if (has_start_stop_event()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->start_stop_event());
    }

    // optional .message.BattleActionInfo.AttackEvent attack_event = 2;
    if (has_attack_event()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attack_event());
    }

    // optional .message.BattleActionInfo.AttrChangeEvent attr_change_event = 3;
    if (has_attr_change_event()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attr_change_event());
    }

    // optional .message.BattleActionInfo.SummonEvent summon_event = 4;
    if (has_summon_event()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->summon_event());
    }

    // optional .message.BattleActionInfo.SufferEvent suffer_event = 5;
    if (has_suffer_event()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->suffer_event());
    }

    // optional .message.BattleActionInfo.CastAreaEvent cast_area_event = 6;
    if (has_cast_area_event()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cast_area_event());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo_ActionInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo_ActionInfo*>(&from));
}

void BattleActionInfo_ActionInfo::MergeFrom(const BattleActionInfo_ActionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_stop_event()) {
      mutable_start_stop_event()->::message::BattleActionInfo_StartStopEvent::MergeFrom(from.start_stop_event());
    }
    if (from.has_attack_event()) {
      mutable_attack_event()->::message::BattleActionInfo_AttackEvent::MergeFrom(from.attack_event());
    }
    if (from.has_attr_change_event()) {
      mutable_attr_change_event()->::message::BattleActionInfo_AttrChangeEvent::MergeFrom(from.attr_change_event());
    }
    if (from.has_summon_event()) {
      mutable_summon_event()->::message::BattleActionInfo_SummonEvent::MergeFrom(from.summon_event());
    }
    if (from.has_suffer_event()) {
      mutable_suffer_event()->::message::BattleActionInfo_SufferEvent::MergeFrom(from.suffer_event());
    }
    if (from.has_cast_area_event()) {
      mutable_cast_area_event()->::message::BattleActionInfo_CastAreaEvent::MergeFrom(from.cast_area_event());
    }
  }
}

void BattleActionInfo_ActionInfo::CopyFrom(const BattleActionInfo_ActionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo_ActionInfo::IsInitialized() const {

  if (has_start_stop_event()) {
    if (!this->start_stop_event().IsInitialized()) return false;
  }
  if (has_attack_event()) {
    if (!this->attack_event().IsInitialized()) return false;
  }
  if (has_attr_change_event()) {
    if (!this->attr_change_event().IsInitialized()) return false;
  }
  if (has_summon_event()) {
    if (!this->summon_event().IsInitialized()) return false;
  }
  if (has_suffer_event()) {
    if (!this->suffer_event().IsInitialized()) return false;
  }
  if (has_cast_area_event()) {
    if (!this->cast_area_event().IsInitialized()) return false;
  }
  return true;
}

void BattleActionInfo_ActionInfo::Swap(BattleActionInfo_ActionInfo* other) {
  if (other != this) {
    std::swap(start_stop_event_, other->start_stop_event_);
    std::swap(attack_event_, other->attack_event_);
    std::swap(attr_change_event_, other->attr_change_event_);
    std::swap(summon_event_, other->summon_event_);
    std::swap(suffer_event_, other->suffer_event_);
    std::swap(cast_area_event_, other->cast_area_event_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo_ActionInfo::GetTypeName() const {
  return "message.BattleActionInfo.ActionInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleActionInfo::kActionInfoFieldNumber;
#endif  // !_MSC_VER

BattleActionInfo::BattleActionInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleActionInfo::InitAsDefaultInstance() {
}

BattleActionInfo::BattleActionInfo(const BattleActionInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleActionInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleActionInfo::~BattleActionInfo() {
  SharedDtor();
}

void BattleActionInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleActionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleActionInfo& BattleActionInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleActionInfo* BattleActionInfo::default_instance_ = NULL;

BattleActionInfo* BattleActionInfo::New() const {
  return new BattleActionInfo;
}

void BattleActionInfo::Clear() {
  action_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleActionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.BattleActionInfo.ActionInfo action_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_action_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_action_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_action_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleActionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.BattleActionInfo.ActionInfo action_info = 1;
  for (int i = 0; i < this->action_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->action_info(i), output);
  }

}

int BattleActionInfo::ByteSize() const {
  int total_size = 0;

  // repeated .message.BattleActionInfo.ActionInfo action_info = 1;
  total_size += 1 * this->action_info_size();
  for (int i = 0; i < this->action_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->action_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleActionInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleActionInfo*>(&from));
}

void BattleActionInfo::MergeFrom(const BattleActionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  action_info_.MergeFrom(from.action_info_);
}

void BattleActionInfo::CopyFrom(const BattleActionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleActionInfo::IsInitialized() const {

  for (int i = 0; i < action_info_size(); i++) {
    if (!this->action_info(i).IsInitialized()) return false;
  }
  return true;
}

void BattleActionInfo::Swap(BattleActionInfo* other) {
  if (other != this) {
    action_info_.Swap(&other->action_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleActionInfo::GetTypeName() const {
  return "message.BattleActionInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleProcess_AttackEvent::kCharIdFieldNumber;
const int BattleProcess_AttackEvent::kSkillIdFieldNumber;
const int BattleProcess_AttackEvent::kTargetCharIdFieldNumber;
const int BattleProcess_AttackEvent::kChangeValueFieldNumber;
const int BattleProcess_AttackEvent::kIsCriticalFieldNumber;
#endif  // !_MSC_VER

BattleProcess_AttackEvent::BattleProcess_AttackEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleProcess_AttackEvent::InitAsDefaultInstance() {
}

BattleProcess_AttackEvent::BattleProcess_AttackEvent(const BattleProcess_AttackEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleProcess_AttackEvent::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  skill_id_ = 0;
  change_value_ = 0;
  is_critical_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleProcess_AttackEvent::~BattleProcess_AttackEvent() {
  SharedDtor();
}

void BattleProcess_AttackEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleProcess_AttackEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleProcess_AttackEvent& BattleProcess_AttackEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleProcess_AttackEvent* BattleProcess_AttackEvent::default_instance_ = NULL;

BattleProcess_AttackEvent* BattleProcess_AttackEvent::New() const {
  return new BattleProcess_AttackEvent;
}

void BattleProcess_AttackEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    skill_id_ = 0;
    change_value_ = 0;
    is_critical_ = 0;
  }
  target_char_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleProcess_AttackEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_id;
        break;
      }

      // required int32 skill_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skill_id_)));
          set_has_skill_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_char_id;
        break;
      }

      // repeated int32 target_char_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_target_char_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_target_char_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_char_id;
        if (input->ExpectTag(32)) goto parse_change_value;
        break;
      }

      // optional int32 change_value = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_change_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &change_value_)));
          set_has_change_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_is_critical;
        break;
      }

      // optional int32 is_critical = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_critical:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_critical_)));
          set_has_is_critical();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleProcess_AttackEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 skill_id = 2;
  if (has_skill_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->skill_id(), output);
  }

  // repeated int32 target_char_id = 3;
  for (int i = 0; i < this->target_char_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->target_char_id(i), output);
  }

  // optional int32 change_value = 4;
  if (has_change_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->change_value(), output);
  }

  // optional int32 is_critical = 5;
  if (has_is_critical()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->is_critical(), output);
  }

}

int BattleProcess_AttackEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 skill_id = 2;
    if (has_skill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skill_id());
    }

    // optional int32 change_value = 4;
    if (has_change_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->change_value());
    }

    // optional int32 is_critical = 5;
    if (has_is_critical()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_critical());
    }

  }
  // repeated int32 target_char_id = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->target_char_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->target_char_id(i));
    }
    total_size += 1 * this->target_char_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleProcess_AttackEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleProcess_AttackEvent*>(&from));
}

void BattleProcess_AttackEvent::MergeFrom(const BattleProcess_AttackEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_char_id_.MergeFrom(from.target_char_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_skill_id()) {
      set_skill_id(from.skill_id());
    }
    if (from.has_change_value()) {
      set_change_value(from.change_value());
    }
    if (from.has_is_critical()) {
      set_is_critical(from.is_critical());
    }
  }
}

void BattleProcess_AttackEvent::CopyFrom(const BattleProcess_AttackEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleProcess_AttackEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BattleProcess_AttackEvent::Swap(BattleProcess_AttackEvent* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(skill_id_, other->skill_id_);
    target_char_id_.Swap(&other->target_char_id_);
    std::swap(change_value_, other->change_value_);
    std::swap(is_critical_, other->is_critical_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleProcess_AttackEvent::GetTypeName() const {
  return "message.BattleProcess.AttackEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleProcess_AttrChangeEvent::kCharIdFieldNumber;
const int BattleProcess_AttrChangeEvent::kChangeTypeFieldNumber;
const int BattleProcess_AttrChangeEvent::kChangeValueFieldNumber;
const int BattleProcess_AttrChangeEvent::kSkillDamageFieldNumber;
#endif  // !_MSC_VER

BattleProcess_AttrChangeEvent::BattleProcess_AttrChangeEvent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleProcess_AttrChangeEvent::InitAsDefaultInstance() {
}

BattleProcess_AttrChangeEvent::BattleProcess_AttrChangeEvent(const BattleProcess_AttrChangeEvent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleProcess_AttrChangeEvent::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  change_type_ = 0;
  change_value_ = 0;
  skill_damage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleProcess_AttrChangeEvent::~BattleProcess_AttrChangeEvent() {
  SharedDtor();
}

void BattleProcess_AttrChangeEvent::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleProcess_AttrChangeEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleProcess_AttrChangeEvent& BattleProcess_AttrChangeEvent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleProcess_AttrChangeEvent* BattleProcess_AttrChangeEvent::default_instance_ = NULL;

BattleProcess_AttrChangeEvent* BattleProcess_AttrChangeEvent::New() const {
  return new BattleProcess_AttrChangeEvent;
}

void BattleProcess_AttrChangeEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    change_type_ = 0;
    change_value_ = 0;
    skill_damage_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleProcess_AttrChangeEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_change_type;
        break;
      }

      // required int32 change_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_change_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &change_type_)));
          set_has_change_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_change_value;
        break;
      }

      // required int32 change_value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_change_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &change_value_)));
          set_has_change_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_skill_damage;
        break;
      }

      // optional int32 skill_damage = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skill_damage_)));
          set_has_skill_damage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleProcess_AttrChangeEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 change_type = 2;
  if (has_change_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->change_type(), output);
  }

  // required int32 change_value = 3;
  if (has_change_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->change_value(), output);
  }

  // optional int32 skill_damage = 4;
  if (has_skill_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->skill_damage(), output);
  }

}

int BattleProcess_AttrChangeEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 change_type = 2;
    if (has_change_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->change_type());
    }

    // required int32 change_value = 3;
    if (has_change_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->change_value());
    }

    // optional int32 skill_damage = 4;
    if (has_skill_damage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skill_damage());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleProcess_AttrChangeEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleProcess_AttrChangeEvent*>(&from));
}

void BattleProcess_AttrChangeEvent::MergeFrom(const BattleProcess_AttrChangeEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_change_type()) {
      set_change_type(from.change_type());
    }
    if (from.has_change_value()) {
      set_change_value(from.change_value());
    }
    if (from.has_skill_damage()) {
      set_skill_damage(from.skill_damage());
    }
  }
}

void BattleProcess_AttrChangeEvent::CopyFrom(const BattleProcess_AttrChangeEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleProcess_AttrChangeEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BattleProcess_AttrChangeEvent::Swap(BattleProcess_AttrChangeEvent* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(change_type_, other->change_type_);
    std::swap(change_value_, other->change_value_);
    std::swap(skill_damage_, other->skill_damage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleProcess_AttrChangeEvent::GetTypeName() const {
  return "message.BattleProcess.AttrChangeEvent";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleProcess_ActionInfo::kAttackEventFieldNumber;
const int BattleProcess_ActionInfo::kAttrChangeEventFieldNumber;
#endif  // !_MSC_VER

BattleProcess_ActionInfo::BattleProcess_ActionInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleProcess_ActionInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  attack_event_ = const_cast< ::message::BattleProcess_AttackEvent*>(
      ::message::BattleProcess_AttackEvent::internal_default_instance());
#else
  attack_event_ = const_cast< ::message::BattleProcess_AttackEvent*>(&::message::BattleProcess_AttackEvent::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  attr_change_event_ = const_cast< ::message::BattleProcess_AttrChangeEvent*>(
      ::message::BattleProcess_AttrChangeEvent::internal_default_instance());
#else
  attr_change_event_ = const_cast< ::message::BattleProcess_AttrChangeEvent*>(&::message::BattleProcess_AttrChangeEvent::default_instance());
#endif
}

BattleProcess_ActionInfo::BattleProcess_ActionInfo(const BattleProcess_ActionInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleProcess_ActionInfo::SharedCtor() {
  _cached_size_ = 0;
  attack_event_ = NULL;
  attr_change_event_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleProcess_ActionInfo::~BattleProcess_ActionInfo() {
  SharedDtor();
}

void BattleProcess_ActionInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete attack_event_;
    delete attr_change_event_;
  }
}

void BattleProcess_ActionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleProcess_ActionInfo& BattleProcess_ActionInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleProcess_ActionInfo* BattleProcess_ActionInfo::default_instance_ = NULL;

BattleProcess_ActionInfo* BattleProcess_ActionInfo::New() const {
  return new BattleProcess_ActionInfo;
}

void BattleProcess_ActionInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_attack_event()) {
      if (attack_event_ != NULL) attack_event_->::message::BattleProcess_AttackEvent::Clear();
    }
    if (has_attr_change_event()) {
      if (attr_change_event_ != NULL) attr_change_event_->::message::BattleProcess_AttrChangeEvent::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleProcess_ActionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .message.BattleProcess.AttackEvent attack_event = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attack_event()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attr_change_event;
        break;
      }

      // optional .message.BattleProcess.AttrChangeEvent attr_change_event = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attr_change_event:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attr_change_event()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleProcess_ActionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .message.BattleProcess.AttackEvent attack_event = 1;
  if (has_attack_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->attack_event(), output);
  }

  // optional .message.BattleProcess.AttrChangeEvent attr_change_event = 2;
  if (has_attr_change_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->attr_change_event(), output);
  }

}

int BattleProcess_ActionInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .message.BattleProcess.AttackEvent attack_event = 1;
    if (has_attack_event()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attack_event());
    }

    // optional .message.BattleProcess.AttrChangeEvent attr_change_event = 2;
    if (has_attr_change_event()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attr_change_event());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleProcess_ActionInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleProcess_ActionInfo*>(&from));
}

void BattleProcess_ActionInfo::MergeFrom(const BattleProcess_ActionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_attack_event()) {
      mutable_attack_event()->::message::BattleProcess_AttackEvent::MergeFrom(from.attack_event());
    }
    if (from.has_attr_change_event()) {
      mutable_attr_change_event()->::message::BattleProcess_AttrChangeEvent::MergeFrom(from.attr_change_event());
    }
  }
}

void BattleProcess_ActionInfo::CopyFrom(const BattleProcess_ActionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleProcess_ActionInfo::IsInitialized() const {

  if (has_attack_event()) {
    if (!this->attack_event().IsInitialized()) return false;
  }
  if (has_attr_change_event()) {
    if (!this->attr_change_event().IsInitialized()) return false;
  }
  return true;
}

void BattleProcess_ActionInfo::Swap(BattleProcess_ActionInfo* other) {
  if (other != this) {
    std::swap(attack_event_, other->attack_event_);
    std::swap(attr_change_event_, other->attr_change_event_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleProcess_ActionInfo::GetTypeName() const {
  return "message.BattleProcess.ActionInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleProcess::kActionInfoFieldNumber;
#endif  // !_MSC_VER

BattleProcess::BattleProcess()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleProcess::InitAsDefaultInstance() {
}

BattleProcess::BattleProcess(const BattleProcess& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleProcess::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleProcess::~BattleProcess() {
  SharedDtor();
}

void BattleProcess::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleProcess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleProcess& BattleProcess::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleProcess* BattleProcess::default_instance_ = NULL;

BattleProcess* BattleProcess::New() const {
  return new BattleProcess;
}

void BattleProcess::Clear() {
  action_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleProcess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.BattleProcess.ActionInfo action_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_action_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_action_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_action_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleProcess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.BattleProcess.ActionInfo action_info = 1;
  for (int i = 0; i < this->action_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->action_info(i), output);
  }

}

int BattleProcess::ByteSize() const {
  int total_size = 0;

  // repeated .message.BattleProcess.ActionInfo action_info = 1;
  total_size += 1 * this->action_info_size();
  for (int i = 0; i < this->action_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->action_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleProcess::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleProcess*>(&from));
}

void BattleProcess::MergeFrom(const BattleProcess& from) {
  GOOGLE_CHECK_NE(&from, this);
  action_info_.MergeFrom(from.action_info_);
}

void BattleProcess::CopyFrom(const BattleProcess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleProcess::IsInitialized() const {

  for (int i = 0; i < action_info_size(); i++) {
    if (!this->action_info(i).IsInitialized()) return false;
  }
  return true;
}

void BattleProcess::Swap(BattleProcess* other) {
  if (other != this) {
    action_info_.Swap(&other->action_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleProcess::GetTypeName() const {
  return "message.BattleProcess";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleManualSkill::kCharIdFieldNumber;
const int BattleManualSkill::kManualSkillFieldNumber;
#endif  // !_MSC_VER

BattleManualSkill::BattleManualSkill()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleManualSkill::InitAsDefaultInstance() {
}

BattleManualSkill::BattleManualSkill(const BattleManualSkill& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleManualSkill::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  manual_skill_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleManualSkill::~BattleManualSkill() {
  SharedDtor();
}

void BattleManualSkill::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleManualSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleManualSkill& BattleManualSkill::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleManualSkill* BattleManualSkill::default_instance_ = NULL;

BattleManualSkill* BattleManualSkill::New() const {
  return new BattleManualSkill;
}

void BattleManualSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    manual_skill_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleManualSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_manual_skill;
        break;
      }

      // required int32 manual_skill = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_manual_skill:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &manual_skill_)));
          set_has_manual_skill();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleManualSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 manual_skill = 2;
  if (has_manual_skill()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->manual_skill(), output);
  }

}

int BattleManualSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 manual_skill = 2;
    if (has_manual_skill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->manual_skill());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleManualSkill::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleManualSkill*>(&from));
}

void BattleManualSkill::MergeFrom(const BattleManualSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_manual_skill()) {
      set_manual_skill(from.manual_skill());
    }
  }
}

void BattleManualSkill::CopyFrom(const BattleManualSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleManualSkill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BattleManualSkill::Swap(BattleManualSkill* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(manual_skill_, other->manual_skill_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleManualSkill::GetTypeName() const {
  return "message.BattleManualSkill";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleOperation::kCharIdFieldNumber;
const int BattleOperation::kOperationIdFieldNumber;
const int BattleOperation::kPosXFieldNumber;
#endif  // !_MSC_VER

BattleOperation::BattleOperation()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleOperation::InitAsDefaultInstance() {
}

BattleOperation::BattleOperation(const BattleOperation& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleOperation::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  operation_id_ = 0;
  pos_x_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleOperation::~BattleOperation() {
  SharedDtor();
}

void BattleOperation::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleOperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleOperation& BattleOperation::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleOperation* BattleOperation::default_instance_ = NULL;

BattleOperation* BattleOperation::New() const {
  return new BattleOperation;
}

void BattleOperation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    operation_id_ = 0;
    pos_x_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_operation_id;
        break;
      }

      // required int32 operation_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_operation_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &operation_id_)));
          set_has_operation_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pos_x;
        break;
      }

      // optional int32 pos_x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 operation_id = 2;
  if (has_operation_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->operation_id(), output);
  }

  // optional int32 pos_x = 3;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->pos_x(), output);
  }

}

int BattleOperation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 operation_id = 2;
    if (has_operation_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->operation_id());
    }

    // optional int32 pos_x = 3;
    if (has_pos_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos_x());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleOperation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleOperation*>(&from));
}

void BattleOperation::MergeFrom(const BattleOperation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_operation_id()) {
      set_operation_id(from.operation_id());
    }
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
  }
}

void BattleOperation::CopyFrom(const BattleOperation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BattleOperation::Swap(BattleOperation* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(operation_id_, other->operation_id_);
    std::swap(pos_x_, other->pos_x_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleOperation::GetTypeName() const {
  return "message.BattleOperation";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleOperationResult::kCharIdFieldNumber;
const int BattleOperationResult::kOperationIdFieldNumber;
const int BattleOperationResult::kOperationResultFieldNumber;
#endif  // !_MSC_VER

BattleOperationResult::BattleOperationResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleOperationResult::InitAsDefaultInstance() {
}

BattleOperationResult::BattleOperationResult(const BattleOperationResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleOperationResult::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  operation_id_ = 0;
  operation_result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleOperationResult::~BattleOperationResult() {
  SharedDtor();
}

void BattleOperationResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleOperationResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleOperationResult& BattleOperationResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleOperationResult* BattleOperationResult::default_instance_ = NULL;

BattleOperationResult* BattleOperationResult::New() const {
  return new BattleOperationResult;
}

void BattleOperationResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    operation_id_ = 0;
    operation_result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleOperationResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_operation_id;
        break;
      }

      // required int32 operation_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_operation_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &operation_id_)));
          set_has_operation_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_operation_result;
        break;
      }

      // required int32 operation_result = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_operation_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &operation_result_)));
          set_has_operation_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleOperationResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // required int32 operation_id = 2;
  if (has_operation_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->operation_id(), output);
  }

  // required int32 operation_result = 3;
  if (has_operation_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->operation_result(), output);
  }

}

int BattleOperationResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // required int32 operation_id = 2;
    if (has_operation_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->operation_id());
    }

    // required int32 operation_result = 3;
    if (has_operation_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->operation_result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleOperationResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleOperationResult*>(&from));
}

void BattleOperationResult::MergeFrom(const BattleOperationResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_operation_id()) {
      set_operation_id(from.operation_id());
    }
    if (from.has_operation_result()) {
      set_operation_result(from.operation_result());
    }
  }
}

void BattleOperationResult::CopyFrom(const BattleOperationResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleOperationResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BattleOperationResult::Swap(BattleOperationResult* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(operation_id_, other->operation_id_);
    std::swap(operation_result_, other->operation_result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleOperationResult::GetTypeName() const {
  return "message.BattleOperationResult";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleResultInfo::kBattleResultFieldNumber;
const int BattleResultInfo::kBattleStarFieldNumber;
const int BattleResultInfo::kPvpCharIdFieldNumber;
const int BattleResultInfo::kSkillExpFieldNumber;
const int BattleResultInfo::kMapIdFieldNumber;
const int BattleResultInfo::kTypeFieldNumber;
const int BattleResultInfo::kIsPkFieldNumber;
#endif  // !_MSC_VER

BattleResultInfo::BattleResultInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleResultInfo::InitAsDefaultInstance() {
}

BattleResultInfo::BattleResultInfo(const BattleResultInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleResultInfo::SharedCtor() {
  _cached_size_ = 0;
  battle_result_ = 0u;
  battle_star_ = 0u;
  pvp_char_id_ = 0u;
  skill_exp_ = 0u;
  map_id_ = 0u;
  type_ = 0u;
  is_pk_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleResultInfo::~BattleResultInfo() {
  SharedDtor();
}

void BattleResultInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleResultInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleResultInfo& BattleResultInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleResultInfo* BattleResultInfo::default_instance_ = NULL;

BattleResultInfo* BattleResultInfo::New() const {
  return new BattleResultInfo;
}

void BattleResultInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    battle_result_ = 0u;
    battle_star_ = 0u;
    pvp_char_id_ = 0u;
    skill_exp_ = 0u;
    map_id_ = 0u;
    type_ = 0u;
    is_pk_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleResultInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 battle_result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_result_)));
          set_has_battle_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_battle_star;
        break;
      }

      // optional uint32 battle_star = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_battle_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_star_)));
          set_has_battle_star();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pvp_char_id;
        break;
      }

      // optional uint32 pvp_char_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pvp_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pvp_char_id_)));
          set_has_pvp_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_skill_exp;
        break;
      }

      // optional uint32 skill_exp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_exp_)));
          set_has_skill_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_map_id;
        break;
      }

      // optional uint32 map_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }

      // optional uint32 type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_is_pk;
        break;
      }

      // optional uint32 is_pk = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_pk:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_pk_)));
          set_has_is_pk();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleResultInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 battle_result = 1;
  if (has_battle_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->battle_result(), output);
  }

  // optional uint32 battle_star = 2;
  if (has_battle_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->battle_star(), output);
  }

  // optional uint32 pvp_char_id = 3;
  if (has_pvp_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->pvp_char_id(), output);
  }

  // optional uint32 skill_exp = 4;
  if (has_skill_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->skill_exp(), output);
  }

  // optional uint32 map_id = 5;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->map_id(), output);
  }

  // optional uint32 type = 6;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->type(), output);
  }

  // optional uint32 is_pk = 7;
  if (has_is_pk()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->is_pk(), output);
  }

}

int BattleResultInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 battle_result = 1;
    if (has_battle_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_result());
    }

    // optional uint32 battle_star = 2;
    if (has_battle_star()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_star());
    }

    // optional uint32 pvp_char_id = 3;
    if (has_pvp_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pvp_char_id());
    }

    // optional uint32 skill_exp = 4;
    if (has_skill_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_exp());
    }

    // optional uint32 map_id = 5;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // optional uint32 type = 6;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 is_pk = 7;
    if (has_is_pk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_pk());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleResultInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleResultInfo*>(&from));
}

void BattleResultInfo::MergeFrom(const BattleResultInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_battle_result()) {
      set_battle_result(from.battle_result());
    }
    if (from.has_battle_star()) {
      set_battle_star(from.battle_star());
    }
    if (from.has_pvp_char_id()) {
      set_pvp_char_id(from.pvp_char_id());
    }
    if (from.has_skill_exp()) {
      set_skill_exp(from.skill_exp());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_is_pk()) {
      set_is_pk(from.is_pk());
    }
  }
}

void BattleResultInfo::CopyFrom(const BattleResultInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleResultInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BattleResultInfo::Swap(BattleResultInfo* other) {
  if (other != this) {
    std::swap(battle_result_, other->battle_result_);
    std::swap(battle_star_, other->battle_star_);
    std::swap(pvp_char_id_, other->pvp_char_id_);
    std::swap(skill_exp_, other->skill_exp_);
    std::swap(map_id_, other->map_id_);
    std::swap(type_, other->type_);
    std::swap(is_pk_, other->is_pk_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleResultInfo::GetTypeName() const {
  return "message.BattleResultInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleRepeat::kMapIdFieldNumber;
const int BattleRepeat::kBattleTimesFieldNumber;
const int BattleRepeat::kTypeFieldNumber;
const int BattleRepeat::kAutoSellMaterialFieldNumber;
const int BattleRepeat::kAutoSellEquipFieldNumber;
#endif  // !_MSC_VER

BattleRepeat::BattleRepeat()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleRepeat::InitAsDefaultInstance() {
}

BattleRepeat::BattleRepeat(const BattleRepeat& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleRepeat::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  battle_times_ = 0u;
  type_ = 0u;
  auto_sell_material_ = 0u;
  auto_sell_equip_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleRepeat::~BattleRepeat() {
  SharedDtor();
}

void BattleRepeat::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleRepeat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleRepeat& BattleRepeat::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleRepeat* BattleRepeat::default_instance_ = NULL;

BattleRepeat* BattleRepeat::New() const {
  return new BattleRepeat;
}

void BattleRepeat::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0u;
    battle_times_ = 0u;
    type_ = 0u;
    auto_sell_material_ = 0u;
    auto_sell_equip_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleRepeat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_battle_times;
        break;
      }

      // required uint32 battle_times = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_battle_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_times_)));
          set_has_battle_times();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional uint32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_auto_sell_material;
        break;
      }

      // optional uint32 auto_sell_material = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_auto_sell_material:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &auto_sell_material_)));
          set_has_auto_sell_material();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_auto_sell_equip;
        break;
      }

      // optional uint32 auto_sell_equip = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_auto_sell_equip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &auto_sell_equip_)));
          set_has_auto_sell_equip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleRepeat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 battle_times = 2;
  if (has_battle_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->battle_times(), output);
  }

  // optional uint32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  // optional uint32 auto_sell_material = 4;
  if (has_auto_sell_material()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->auto_sell_material(), output);
  }

  // optional uint32 auto_sell_equip = 5;
  if (has_auto_sell_equip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->auto_sell_equip(), output);
  }

}

int BattleRepeat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 battle_times = 2;
    if (has_battle_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_times());
    }

    // optional uint32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 auto_sell_material = 4;
    if (has_auto_sell_material()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->auto_sell_material());
    }

    // optional uint32 auto_sell_equip = 5;
    if (has_auto_sell_equip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->auto_sell_equip());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleRepeat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleRepeat*>(&from));
}

void BattleRepeat::MergeFrom(const BattleRepeat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_battle_times()) {
      set_battle_times(from.battle_times());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_auto_sell_material()) {
      set_auto_sell_material(from.auto_sell_material());
    }
    if (from.has_auto_sell_equip()) {
      set_auto_sell_equip(from.auto_sell_equip());
    }
  }
}

void BattleRepeat::CopyFrom(const BattleRepeat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleRepeat::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BattleRepeat::Swap(BattleRepeat* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(battle_times_, other->battle_times_);
    std::swap(type_, other->type_);
    std::swap(auto_sell_material_, other->auto_sell_material_);
    std::swap(auto_sell_equip_, other->auto_sell_equip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleRepeat::GetTypeName() const {
  return "message.BattleRepeat";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleQTEInfo::kQTEIdFieldNumber;
#endif  // !_MSC_VER

BattleQTEInfo::BattleQTEInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleQTEInfo::InitAsDefaultInstance() {
}

BattleQTEInfo::BattleQTEInfo(const BattleQTEInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleQTEInfo::SharedCtor() {
  _cached_size_ = 0;
  qte_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleQTEInfo::~BattleQTEInfo() {
  SharedDtor();
}

void BattleQTEInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleQTEInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleQTEInfo& BattleQTEInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleQTEInfo* BattleQTEInfo::default_instance_ = NULL;

BattleQTEInfo* BattleQTEInfo::New() const {
  return new BattleQTEInfo;
}

void BattleQTEInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    qte_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleQTEInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 QTE_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &qte_id_)));
          set_has_qte_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleQTEInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 QTE_id = 1;
  if (has_qte_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->qte_id(), output);
  }

}

int BattleQTEInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 QTE_id = 1;
    if (has_qte_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->qte_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleQTEInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleQTEInfo*>(&from));
}

void BattleQTEInfo::MergeFrom(const BattleQTEInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_qte_id()) {
      set_qte_id(from.qte_id());
    }
  }
}

void BattleQTEInfo::CopyFrom(const BattleQTEInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleQTEInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BattleQTEInfo::Swap(BattleQTEInfo* other) {
  if (other != this) {
    std::swap(qte_id_, other->qte_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleQTEInfo::GetTypeName() const {
  return "message.BattleQTEInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleReward::kBattleMapFieldNumber;
const int BattleReward::kExpFieldNumber;
const int BattleReward::kExpAdditionalFieldNumber;
const int BattleReward::kTeamExpFieldNumber;
const int BattleReward::kTeamExpAdditionalFieldNumber;
const int BattleReward::kMoneyFieldNumber;
const int BattleReward::kMoneyAdditionalFieldNumber;
const int BattleReward::kRewardItemFieldNumber;
const int BattleReward::kRewardItemNumFieldNumber;
const int BattleReward::kIsRepeatFieldNumber;
#endif  // !_MSC_VER

BattleReward::BattleReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleReward::InitAsDefaultInstance() {
}

BattleReward::BattleReward(const BattleReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleReward::SharedCtor() {
  _cached_size_ = 0;
  battle_map_ = 0u;
  exp_ = 0u;
  exp_additional_ = 0u;
  team_exp_ = 0u;
  team_exp_additional_ = 0u;
  money_ = 0u;
  money_additional_ = 0u;
  is_repeat_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleReward::~BattleReward() {
  SharedDtor();
}

void BattleReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleReward& BattleReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleReward* BattleReward::default_instance_ = NULL;

BattleReward* BattleReward::New() const {
  return new BattleReward;
}

void BattleReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    battle_map_ = 0u;
    exp_ = 0u;
    exp_additional_ = 0u;
    team_exp_ = 0u;
    team_exp_additional_ = 0u;
    money_ = 0u;
    money_additional_ = 0u;
  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    is_repeat_ = 0u;
  }
  reward_item_.Clear();
  reward_item_num_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 battle_map = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_map_)));
          set_has_battle_map();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_exp;
        break;
      }

      // optional uint32 exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_exp_additional;
        break;
      }

      // optional uint32 exp_additional = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp_additional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_additional_)));
          set_has_exp_additional();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_team_exp;
        break;
      }

      // optional uint32 team_exp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_team_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &team_exp_)));
          set_has_team_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_team_exp_additional;
        break;
      }

      // optional uint32 team_exp_additional = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_team_exp_additional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &team_exp_additional_)));
          set_has_team_exp_additional();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_money;
        break;
      }

      // optional uint32 money = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_money_additional;
        break;
      }

      // optional uint32 money_additional = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money_additional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &money_additional_)));
          set_has_money_additional();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_reward_item;
        break;
      }

      // repeated uint32 reward_item = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_item:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_reward_item())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_reward_item())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_reward_item;
        if (input->ExpectTag(72)) goto parse_reward_item_num;
        break;
      }

      // repeated uint32 reward_item_num = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 72, input, this->mutable_reward_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_reward_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_reward_item_num;
        if (input->ExpectTag(80)) goto parse_is_repeat;
        break;
      }

      // optional uint32 is_repeat = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_repeat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_repeat_)));
          set_has_is_repeat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 battle_map = 1;
  if (has_battle_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->battle_map(), output);
  }

  // optional uint32 exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->exp(), output);
  }

  // optional uint32 exp_additional = 3;
  if (has_exp_additional()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->exp_additional(), output);
  }

  // optional uint32 team_exp = 4;
  if (has_team_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->team_exp(), output);
  }

  // optional uint32 team_exp_additional = 5;
  if (has_team_exp_additional()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->team_exp_additional(), output);
  }

  // optional uint32 money = 6;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->money(), output);
  }

  // optional uint32 money_additional = 7;
  if (has_money_additional()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->money_additional(), output);
  }

  // repeated uint32 reward_item = 8;
  for (int i = 0; i < this->reward_item_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->reward_item(i), output);
  }

  // repeated uint32 reward_item_num = 9;
  for (int i = 0; i < this->reward_item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      9, this->reward_item_num(i), output);
  }

  // optional uint32 is_repeat = 10;
  if (has_is_repeat()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->is_repeat(), output);
  }

}

int BattleReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 battle_map = 1;
    if (has_battle_map()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_map());
    }

    // optional uint32 exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp());
    }

    // optional uint32 exp_additional = 3;
    if (has_exp_additional()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp_additional());
    }

    // optional uint32 team_exp = 4;
    if (has_team_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->team_exp());
    }

    // optional uint32 team_exp_additional = 5;
    if (has_team_exp_additional()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->team_exp_additional());
    }

    // optional uint32 money = 6;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->money());
    }

    // optional uint32 money_additional = 7;
    if (has_money_additional()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->money_additional());
    }

  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // optional uint32 is_repeat = 10;
    if (has_is_repeat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_repeat());
    }

  }
  // repeated uint32 reward_item = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->reward_item_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->reward_item(i));
    }
    total_size += 1 * this->reward_item_size() + data_size;
  }

  // repeated uint32 reward_item_num = 9;
  {
    int data_size = 0;
    for (int i = 0; i < this->reward_item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->reward_item_num(i));
    }
    total_size += 1 * this->reward_item_num_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleReward*>(&from));
}

void BattleReward::MergeFrom(const BattleReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  reward_item_.MergeFrom(from.reward_item_);
  reward_item_num_.MergeFrom(from.reward_item_num_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_battle_map()) {
      set_battle_map(from.battle_map());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_exp_additional()) {
      set_exp_additional(from.exp_additional());
    }
    if (from.has_team_exp()) {
      set_team_exp(from.team_exp());
    }
    if (from.has_team_exp_additional()) {
      set_team_exp_additional(from.team_exp_additional());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_money_additional()) {
      set_money_additional(from.money_additional());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_is_repeat()) {
      set_is_repeat(from.is_repeat());
    }
  }
}

void BattleReward::CopyFrom(const BattleReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BattleReward::Swap(BattleReward* other) {
  if (other != this) {
    std::swap(battle_map_, other->battle_map_);
    std::swap(exp_, other->exp_);
    std::swap(exp_additional_, other->exp_additional_);
    std::swap(team_exp_, other->team_exp_);
    std::swap(team_exp_additional_, other->team_exp_additional_);
    std::swap(money_, other->money_);
    std::swap(money_additional_, other->money_additional_);
    reward_item_.Swap(&other->reward_item_);
    reward_item_num_.Swap(&other->reward_item_num_);
    std::swap(is_repeat_, other->is_repeat_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleReward::GetTypeName() const {
  return "message.BattleReward";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleRepeatReward_RewardInfo::kExpFieldNumber;
const int BattleRepeatReward_RewardInfo::kTeamExpFieldNumber;
const int BattleRepeatReward_RewardInfo::kMoneyFieldNumber;
const int BattleRepeatReward_RewardInfo::kItemIdFieldNumber;
const int BattleRepeatReward_RewardInfo::kItemNumFieldNumber;
#endif  // !_MSC_VER

BattleRepeatReward_RewardInfo::BattleRepeatReward_RewardInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleRepeatReward_RewardInfo::InitAsDefaultInstance() {
}

BattleRepeatReward_RewardInfo::BattleRepeatReward_RewardInfo(const BattleRepeatReward_RewardInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleRepeatReward_RewardInfo::SharedCtor() {
  _cached_size_ = 0;
  exp_ = 0u;
  team_exp_ = 0u;
  money_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleRepeatReward_RewardInfo::~BattleRepeatReward_RewardInfo() {
  SharedDtor();
}

void BattleRepeatReward_RewardInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleRepeatReward_RewardInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleRepeatReward_RewardInfo& BattleRepeatReward_RewardInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleRepeatReward_RewardInfo* BattleRepeatReward_RewardInfo::default_instance_ = NULL;

BattleRepeatReward_RewardInfo* BattleRepeatReward_RewardInfo::New() const {
  return new BattleRepeatReward_RewardInfo;
}

void BattleRepeatReward_RewardInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    exp_ = 0u;
    team_exp_ = 0u;
    money_ = 0u;
  }
  item_id_.Clear();
  item_num_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleRepeatReward_RewardInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 exp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_team_exp;
        break;
      }

      // optional uint32 team_exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_team_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &team_exp_)));
          set_has_team_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional uint32 money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_id;
        break;
      }

      // repeated uint32 item_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_item_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_id;
        if (input->ExpectTag(40)) goto parse_item_num;
        break;
      }

      // repeated uint32 item_num = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_num;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleRepeatReward_RewardInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 exp = 1;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->exp(), output);
  }

  // optional uint32 team_exp = 2;
  if (has_team_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->team_exp(), output);
  }

  // optional uint32 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->money(), output);
  }

  // repeated uint32 item_id = 4;
  for (int i = 0; i < this->item_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->item_id(i), output);
  }

  // repeated uint32 item_num = 5;
  for (int i = 0; i < this->item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->item_num(i), output);
  }

}

int BattleRepeatReward_RewardInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 exp = 1;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp());
    }

    // optional uint32 team_exp = 2;
    if (has_team_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->team_exp());
    }

    // optional uint32 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->money());
    }

  }
  // repeated uint32 item_id = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_id(i));
    }
    total_size += 1 * this->item_id_size() + data_size;
  }

  // repeated uint32 item_num = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_num(i));
    }
    total_size += 1 * this->item_num_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleRepeatReward_RewardInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleRepeatReward_RewardInfo*>(&from));
}

void BattleRepeatReward_RewardInfo::MergeFrom(const BattleRepeatReward_RewardInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_id_.MergeFrom(from.item_id_);
  item_num_.MergeFrom(from.item_num_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_team_exp()) {
      set_team_exp(from.team_exp());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
}

void BattleRepeatReward_RewardInfo::CopyFrom(const BattleRepeatReward_RewardInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleRepeatReward_RewardInfo::IsInitialized() const {

  return true;
}

void BattleRepeatReward_RewardInfo::Swap(BattleRepeatReward_RewardInfo* other) {
  if (other != this) {
    std::swap(exp_, other->exp_);
    std::swap(team_exp_, other->team_exp_);
    std::swap(money_, other->money_);
    item_id_.Swap(&other->item_id_);
    item_num_.Swap(&other->item_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleRepeatReward_RewardInfo::GetTypeName() const {
  return "message.BattleRepeatReward.RewardInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BattleRepeatReward::kBattleMapFieldNumber;
const int BattleRepeatReward::kRewardDataFieldNumber;
const int BattleRepeatReward::kExpAdditionalFieldNumber;
const int BattleRepeatReward::kTeamExpAdditionalFieldNumber;
const int BattleRepeatReward::kMoneyAdditionalFieldNumber;
const int BattleRepeatReward::kItemIdAdditionalFieldNumber;
const int BattleRepeatReward::kItemNumAdditionalFieldNumber;
const int BattleRepeatReward::kTicketNumFieldNumber;
#endif  // !_MSC_VER

BattleRepeatReward::BattleRepeatReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleRepeatReward::InitAsDefaultInstance() {
}

BattleRepeatReward::BattleRepeatReward(const BattleRepeatReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleRepeatReward::SharedCtor() {
  _cached_size_ = 0;
  battle_map_ = 0u;
  exp_additional_ = 0u;
  team_exp_additional_ = 0u;
  money_additional_ = 0u;
  ticket_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleRepeatReward::~BattleRepeatReward() {
  SharedDtor();
}

void BattleRepeatReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleRepeatReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleRepeatReward& BattleRepeatReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleRepeatReward* BattleRepeatReward::default_instance_ = NULL;

BattleRepeatReward* BattleRepeatReward::New() const {
  return new BattleRepeatReward;
}

void BattleRepeatReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    battle_map_ = 0u;
    exp_additional_ = 0u;
    team_exp_additional_ = 0u;
    money_additional_ = 0u;
    ticket_num_ = 0u;
  }
  reward_data_.Clear();
  item_id_additional_.Clear();
  item_num_additional_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleRepeatReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 battle_map = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_map_)));
          set_has_battle_map();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reward_data;
        break;
      }

      // repeated .message.BattleRepeatReward.RewardInfo reward_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reward_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reward_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reward_data;
        if (input->ExpectTag(24)) goto parse_exp_additional;
        break;
      }

      // optional uint32 exp_additional = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp_additional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_additional_)));
          set_has_exp_additional();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_team_exp_additional;
        break;
      }

      // optional uint32 team_exp_additional = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_team_exp_additional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &team_exp_additional_)));
          set_has_team_exp_additional();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_money_additional;
        break;
      }

      // optional uint32 money_additional = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money_additional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &money_additional_)));
          set_has_money_additional();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_item_id_additional;
        break;
      }

      // repeated uint32 item_id_additional = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id_additional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_item_id_additional())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_id_additional())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_item_id_additional;
        if (input->ExpectTag(56)) goto parse_item_num_additional;
        break;
      }

      // repeated uint32 item_num_additional = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num_additional:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56, input, this->mutable_item_num_additional())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_num_additional())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_item_num_additional;
        if (input->ExpectTag(64)) goto parse_ticket_num;
        break;
      }

      // optional uint32 ticket_num = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ticket_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ticket_num_)));
          set_has_ticket_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleRepeatReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 battle_map = 1;
  if (has_battle_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->battle_map(), output);
  }

  // repeated .message.BattleRepeatReward.RewardInfo reward_data = 2;
  for (int i = 0; i < this->reward_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->reward_data(i), output);
  }

  // optional uint32 exp_additional = 3;
  if (has_exp_additional()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->exp_additional(), output);
  }

  // optional uint32 team_exp_additional = 4;
  if (has_team_exp_additional()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->team_exp_additional(), output);
  }

  // optional uint32 money_additional = 5;
  if (has_money_additional()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->money_additional(), output);
  }

  // repeated uint32 item_id_additional = 6;
  for (int i = 0; i < this->item_id_additional_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->item_id_additional(i), output);
  }

  // repeated uint32 item_num_additional = 7;
  for (int i = 0; i < this->item_num_additional_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->item_num_additional(i), output);
  }

  // optional uint32 ticket_num = 8;
  if (has_ticket_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->ticket_num(), output);
  }

}

int BattleRepeatReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 battle_map = 1;
    if (has_battle_map()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_map());
    }

    // optional uint32 exp_additional = 3;
    if (has_exp_additional()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp_additional());
    }

    // optional uint32 team_exp_additional = 4;
    if (has_team_exp_additional()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->team_exp_additional());
    }

    // optional uint32 money_additional = 5;
    if (has_money_additional()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->money_additional());
    }

    // optional uint32 ticket_num = 8;
    if (has_ticket_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ticket_num());
    }

  }
  // repeated .message.BattleRepeatReward.RewardInfo reward_data = 2;
  total_size += 1 * this->reward_data_size();
  for (int i = 0; i < this->reward_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reward_data(i));
  }

  // repeated uint32 item_id_additional = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_additional_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_id_additional(i));
    }
    total_size += 1 * this->item_id_additional_size() + data_size;
  }

  // repeated uint32 item_num_additional = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_num_additional_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_num_additional(i));
    }
    total_size += 1 * this->item_num_additional_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleRepeatReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleRepeatReward*>(&from));
}

void BattleRepeatReward::MergeFrom(const BattleRepeatReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  reward_data_.MergeFrom(from.reward_data_);
  item_id_additional_.MergeFrom(from.item_id_additional_);
  item_num_additional_.MergeFrom(from.item_num_additional_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_battle_map()) {
      set_battle_map(from.battle_map());
    }
    if (from.has_exp_additional()) {
      set_exp_additional(from.exp_additional());
    }
    if (from.has_team_exp_additional()) {
      set_team_exp_additional(from.team_exp_additional());
    }
    if (from.has_money_additional()) {
      set_money_additional(from.money_additional());
    }
    if (from.has_ticket_num()) {
      set_ticket_num(from.ticket_num());
    }
  }
}

void BattleRepeatReward::CopyFrom(const BattleRepeatReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleRepeatReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BattleRepeatReward::Swap(BattleRepeatReward* other) {
  if (other != this) {
    std::swap(battle_map_, other->battle_map_);
    reward_data_.Swap(&other->reward_data_);
    std::swap(exp_additional_, other->exp_additional_);
    std::swap(team_exp_additional_, other->team_exp_additional_);
    std::swap(money_additional_, other->money_additional_);
    item_id_additional_.Swap(&other->item_id_additional_);
    item_num_additional_.Swap(&other->item_num_additional_);
    std::swap(ticket_num_, other->ticket_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleRepeatReward::GetTypeName() const {
  return "message.BattleRepeatReward";
}


// ===================================================================

#ifndef _MSC_VER
const int ExitBattle::kPlayerIdFieldNumber;
#endif  // !_MSC_VER

ExitBattle::ExitBattle()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ExitBattle::InitAsDefaultInstance() {
}

ExitBattle::ExitBattle(const ExitBattle& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ExitBattle::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitBattle::~ExitBattle() {
  SharedDtor();
}

void ExitBattle::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExitBattle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExitBattle& ExitBattle::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ExitBattle* ExitBattle::default_instance_ = NULL;

ExitBattle* ExitBattle::New() const {
  return new ExitBattle;
}

void ExitBattle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ExitBattle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExitBattle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

}

int ExitBattle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitBattle::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExitBattle*>(&from));
}

void ExitBattle::MergeFrom(const ExitBattle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
  }
}

void ExitBattle::CopyFrom(const ExitBattle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitBattle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExitBattle::Swap(ExitBattle* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExitBattle::GetTypeName() const {
  return "message.ExitBattle";
}


// ===================================================================

#ifndef _MSC_VER
const int NPCTalk::kNpcIdFieldNumber;
#endif  // !_MSC_VER

NPCTalk::NPCTalk()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NPCTalk::InitAsDefaultInstance() {
}

NPCTalk::NPCTalk(const NPCTalk& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NPCTalk::SharedCtor() {
  _cached_size_ = 0;
  npc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NPCTalk::~NPCTalk() {
  SharedDtor();
}

void NPCTalk::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NPCTalk::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NPCTalk& NPCTalk::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

NPCTalk* NPCTalk::default_instance_ = NULL;

NPCTalk* NPCTalk::New() const {
  return new NPCTalk;
}

void NPCTalk::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    npc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NPCTalk::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 npc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &npc_id_)));
          set_has_npc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NPCTalk::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 npc_id = 1;
  if (has_npc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->npc_id(), output);
  }

}

int NPCTalk::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 npc_id = 1;
    if (has_npc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->npc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NPCTalk::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NPCTalk*>(&from));
}

void NPCTalk::MergeFrom(const NPCTalk& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_npc_id()) {
      set_npc_id(from.npc_id());
    }
  }
}

void NPCTalk::CopyFrom(const NPCTalk& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NPCTalk::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void NPCTalk::Swap(NPCTalk* other) {
  if (other != this) {
    std::swap(npc_id_, other->npc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NPCTalk::GetTypeName() const {
  return "message.NPCTalk";
}


// ===================================================================

#ifndef _MSC_VER
const int NPCTalkResult::kFuncTypeFieldNumber;
const int NPCTalkResult::kFuncValueFieldNumber;
#endif  // !_MSC_VER

NPCTalkResult::NPCTalkResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NPCTalkResult::InitAsDefaultInstance() {
}

NPCTalkResult::NPCTalkResult(const NPCTalkResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NPCTalkResult::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NPCTalkResult::~NPCTalkResult() {
  SharedDtor();
}

void NPCTalkResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NPCTalkResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NPCTalkResult& NPCTalkResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

NPCTalkResult* NPCTalkResult::default_instance_ = NULL;

NPCTalkResult* NPCTalkResult::New() const {
  return new NPCTalkResult;
}

void NPCTalkResult::Clear() {
  func_type_.Clear();
  func_value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NPCTalkResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 func_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_func_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_func_type())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_func_type())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_func_type;
        if (input->ExpectTag(16)) goto parse_func_value;
        break;
      }

      // repeated uint32 func_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_func_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_func_value())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_func_value())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_func_value;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NPCTalkResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 func_type = 1;
  for (int i = 0; i < this->func_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->func_type(i), output);
  }

  // repeated uint32 func_value = 2;
  for (int i = 0; i < this->func_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->func_value(i), output);
  }

}

int NPCTalkResult::ByteSize() const {
  int total_size = 0;

  // repeated uint32 func_type = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->func_type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->func_type(i));
    }
    total_size += 1 * this->func_type_size() + data_size;
  }

  // repeated uint32 func_value = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->func_value_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->func_value(i));
    }
    total_size += 1 * this->func_value_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NPCTalkResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NPCTalkResult*>(&from));
}

void NPCTalkResult::MergeFrom(const NPCTalkResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  func_type_.MergeFrom(from.func_type_);
  func_value_.MergeFrom(from.func_value_);
}

void NPCTalkResult::CopyFrom(const NPCTalkResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NPCTalkResult::IsInitialized() const {

  return true;
}

void NPCTalkResult::Swap(NPCTalkResult* other) {
  if (other != this) {
    func_type_.Swap(&other->func_type_);
    func_value_.Swap(&other->func_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NPCTalkResult::GetTypeName() const {
  return "message.NPCTalkResult";
}


// ===================================================================

#ifndef _MSC_VER
const int NPCFunction::kFuncTypeFieldNumber;
const int NPCFunction::kFuncValueFieldNumber;
#endif  // !_MSC_VER

NPCFunction::NPCFunction()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NPCFunction::InitAsDefaultInstance() {
}

NPCFunction::NPCFunction(const NPCFunction& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NPCFunction::SharedCtor() {
  _cached_size_ = 0;
  func_type_ = 0u;
  func_value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NPCFunction::~NPCFunction() {
  SharedDtor();
}

void NPCFunction::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NPCFunction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NPCFunction& NPCFunction::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

NPCFunction* NPCFunction::default_instance_ = NULL;

NPCFunction* NPCFunction::New() const {
  return new NPCFunction;
}

void NPCFunction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    func_type_ = 0u;
    func_value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NPCFunction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 func_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &func_type_)));
          set_has_func_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_func_value;
        break;
      }

      // required uint32 func_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_func_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &func_value_)));
          set_has_func_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NPCFunction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 func_type = 1;
  if (has_func_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->func_type(), output);
  }

  // required uint32 func_value = 2;
  if (has_func_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->func_value(), output);
  }

}

int NPCFunction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 func_type = 1;
    if (has_func_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->func_type());
    }

    // required uint32 func_value = 2;
    if (has_func_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->func_value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NPCFunction::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NPCFunction*>(&from));
}

void NPCFunction::MergeFrom(const NPCFunction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_func_type()) {
      set_func_type(from.func_type());
    }
    if (from.has_func_value()) {
      set_func_value(from.func_value());
    }
  }
}

void NPCFunction::CopyFrom(const NPCFunction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NPCFunction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NPCFunction::Swap(NPCFunction* other) {
  if (other != this) {
    std::swap(func_type_, other->func_type_);
    std::swap(func_value_, other->func_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NPCFunction::GetTypeName() const {
  return "message.NPCFunction";
}


// ===================================================================

#ifndef _MSC_VER
const int AddItem::kItemOnlyIdFieldNumber;
const int AddItem::kItemTypeFieldNumber;
const int AddItem::kItemNumFieldNumber;
const int AddItem::kItemUpgradeFieldNumber;
const int AddItem::kItemHoleFieldNumber;
const int AddItem::kIsBattleFieldNumber;
const int AddItem::kIsEquipFieldNumber;
#endif  // !_MSC_VER

AddItem::AddItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddItem::InitAsDefaultInstance() {
}

AddItem::AddItem(const AddItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddItem::SharedCtor() {
  _cached_size_ = 0;
  item_only_id_ = GOOGLE_ULONGLONG(0);
  item_type_ = 0u;
  item_num_ = 0u;
  item_upgrade_ = 0u;
  is_battle_ = 0u;
  is_equip_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddItem::~AddItem() {
  SharedDtor();
}

void AddItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddItem& AddItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddItem* AddItem::default_instance_ = NULL;

AddItem* AddItem::New() const {
  return new AddItem;
}

void AddItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_only_id_ = GOOGLE_ULONGLONG(0);
    item_type_ = 0u;
    item_num_ = 0u;
    item_upgrade_ = 0u;
    is_battle_ = 0u;
    is_equip_ = 0u;
  }
  item_hole_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 item_only_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &item_only_id_)));
          set_has_item_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_type;
        break;
      }

      // required uint32 item_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_type_)));
          set_has_item_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_num;
        break;
      }

      // required uint32 item_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_upgrade;
        break;
      }

      // optional uint32 item_upgrade = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_upgrade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_upgrade_)));
          set_has_item_upgrade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_hole;
        break;
      }

      // repeated uint32 item_hole = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_hole:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_item_hole())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_hole())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_hole;
        if (input->ExpectTag(48)) goto parse_is_battle;
        break;
      }

      // optional uint32 is_battle = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_battle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_battle_)));
          set_has_is_battle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_is_equip;
        break;
      }

      // optional uint32 is_equip = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_equip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_equip_)));
          set_has_is_equip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 item_only_id = 1;
  if (has_item_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->item_only_id(), output);
  }

  // required uint32 item_type = 2;
  if (has_item_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_type(), output);
  }

  // required uint32 item_num = 3;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->item_num(), output);
  }

  // optional uint32 item_upgrade = 4;
  if (has_item_upgrade()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->item_upgrade(), output);
  }

  // repeated uint32 item_hole = 5;
  for (int i = 0; i < this->item_hole_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->item_hole(i), output);
  }

  // optional uint32 is_battle = 6;
  if (has_is_battle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->is_battle(), output);
  }

  // optional uint32 is_equip = 7;
  if (has_is_equip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->is_equip(), output);
  }

}

int AddItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 item_only_id = 1;
    if (has_item_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->item_only_id());
    }

    // required uint32 item_type = 2;
    if (has_item_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_type());
    }

    // required uint32 item_num = 3;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_num());
    }

    // optional uint32 item_upgrade = 4;
    if (has_item_upgrade()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_upgrade());
    }

    // optional uint32 is_battle = 6;
    if (has_is_battle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_battle());
    }

    // optional uint32 is_equip = 7;
    if (has_is_equip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_equip());
    }

  }
  // repeated uint32 item_hole = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_hole_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_hole(i));
    }
    total_size += 1 * this->item_hole_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddItem*>(&from));
}

void AddItem::MergeFrom(const AddItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_hole_.MergeFrom(from.item_hole_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_only_id()) {
      set_item_only_id(from.item_only_id());
    }
    if (from.has_item_type()) {
      set_item_type(from.item_type());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
    if (from.has_item_upgrade()) {
      set_item_upgrade(from.item_upgrade());
    }
    if (from.has_is_battle()) {
      set_is_battle(from.is_battle());
    }
    if (from.has_is_equip()) {
      set_is_equip(from.is_equip());
    }
  }
}

void AddItem::CopyFrom(const AddItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void AddItem::Swap(AddItem* other) {
  if (other != this) {
    std::swap(item_only_id_, other->item_only_id_);
    std::swap(item_type_, other->item_type_);
    std::swap(item_num_, other->item_num_);
    std::swap(item_upgrade_, other->item_upgrade_);
    item_hole_.Swap(&other->item_hole_);
    std::swap(is_battle_, other->is_battle_);
    std::swap(is_equip_, other->is_equip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddItem::GetTypeName() const {
  return "message.AddItem";
}


// ===================================================================

#ifndef _MSC_VER
const int DeleteItem::kItemOnlyIdFieldNumber;
const int DeleteItem::kItemNumFieldNumber;
const int DeleteItem::kIsEquipFieldNumber;
#endif  // !_MSC_VER

DeleteItem::DeleteItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DeleteItem::InitAsDefaultInstance() {
}

DeleteItem::DeleteItem(const DeleteItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DeleteItem::SharedCtor() {
  _cached_size_ = 0;
  item_only_id_ = GOOGLE_ULONGLONG(0);
  item_num_ = 0u;
  is_equip_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteItem::~DeleteItem() {
  SharedDtor();
}

void DeleteItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DeleteItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeleteItem& DeleteItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

DeleteItem* DeleteItem::default_instance_ = NULL;

DeleteItem* DeleteItem::New() const {
  return new DeleteItem;
}

void DeleteItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_only_id_ = GOOGLE_ULONGLONG(0);
    item_num_ = 0u;
    is_equip_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DeleteItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 item_only_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &item_only_id_)));
          set_has_item_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_num;
        break;
      }

      // required uint32 item_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_equip;
        break;
      }

      // optional uint32 is_equip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_equip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_equip_)));
          set_has_is_equip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DeleteItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 item_only_id = 1;
  if (has_item_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->item_only_id(), output);
  }

  // required uint32 item_num = 2;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_num(), output);
  }

  // optional uint32 is_equip = 3;
  if (has_is_equip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->is_equip(), output);
  }

}

int DeleteItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 item_only_id = 1;
    if (has_item_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->item_only_id());
    }

    // required uint32 item_num = 2;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_num());
    }

    // optional uint32 is_equip = 3;
    if (has_is_equip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_equip());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeleteItem*>(&from));
}

void DeleteItem::MergeFrom(const DeleteItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_only_id()) {
      set_item_only_id(from.item_only_id());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
    if (from.has_is_equip()) {
      set_is_equip(from.is_equip());
    }
  }
}

void DeleteItem::CopyFrom(const DeleteItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DeleteItem::Swap(DeleteItem* other) {
  if (other != this) {
    std::swap(item_only_id_, other->item_only_id_);
    std::swap(item_num_, other->item_num_);
    std::swap(is_equip_, other->is_equip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DeleteItem::GetTypeName() const {
  return "message.DeleteItem";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateItem::kItemOnlyIdFieldNumber;
const int UpdateItem::kItemTypeFieldNumber;
const int UpdateItem::kItemNumFieldNumber;
const int UpdateItem::kItemUpgradeFieldNumber;
const int UpdateItem::kItemHoleFieldNumber;
const int UpdateItem::kIsEquipFieldNumber;
#endif  // !_MSC_VER

UpdateItem::UpdateItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateItem::InitAsDefaultInstance() {
}

UpdateItem::UpdateItem(const UpdateItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateItem::SharedCtor() {
  _cached_size_ = 0;
  item_only_id_ = GOOGLE_ULONGLONG(0);
  item_type_ = 0u;
  item_num_ = 0u;
  item_upgrade_ = 0u;
  is_equip_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateItem::~UpdateItem() {
  SharedDtor();
}

void UpdateItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateItem& UpdateItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UpdateItem* UpdateItem::default_instance_ = NULL;

UpdateItem* UpdateItem::New() const {
  return new UpdateItem;
}

void UpdateItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_only_id_ = GOOGLE_ULONGLONG(0);
    item_type_ = 0u;
    item_num_ = 0u;
    item_upgrade_ = 0u;
    is_equip_ = 0u;
  }
  item_hole_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 item_only_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &item_only_id_)));
          set_has_item_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_type;
        break;
      }

      // optional uint32 item_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_type_)));
          set_has_item_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_num;
        break;
      }

      // optional uint32 item_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_upgrade;
        break;
      }

      // optional uint32 item_upgrade = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_upgrade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_upgrade_)));
          set_has_item_upgrade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_hole;
        break;
      }

      // repeated uint32 item_hole = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_hole:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_item_hole())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_hole())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_hole;
        if (input->ExpectTag(48)) goto parse_is_equip;
        break;
      }

      // optional uint32 is_equip = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_equip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_equip_)));
          set_has_is_equip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 item_only_id = 1;
  if (has_item_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->item_only_id(), output);
  }

  // optional uint32 item_type = 2;
  if (has_item_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_type(), output);
  }

  // optional uint32 item_num = 3;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->item_num(), output);
  }

  // optional uint32 item_upgrade = 4;
  if (has_item_upgrade()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->item_upgrade(), output);
  }

  // repeated uint32 item_hole = 5;
  for (int i = 0; i < this->item_hole_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->item_hole(i), output);
  }

  // optional uint32 is_equip = 6;
  if (has_is_equip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->is_equip(), output);
  }

}

int UpdateItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 item_only_id = 1;
    if (has_item_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->item_only_id());
    }

    // optional uint32 item_type = 2;
    if (has_item_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_type());
    }

    // optional uint32 item_num = 3;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_num());
    }

    // optional uint32 item_upgrade = 4;
    if (has_item_upgrade()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_upgrade());
    }

    // optional uint32 is_equip = 6;
    if (has_is_equip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_equip());
    }

  }
  // repeated uint32 item_hole = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_hole_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_hole(i));
    }
    total_size += 1 * this->item_hole_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateItem*>(&from));
}

void UpdateItem::MergeFrom(const UpdateItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_hole_.MergeFrom(from.item_hole_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_only_id()) {
      set_item_only_id(from.item_only_id());
    }
    if (from.has_item_type()) {
      set_item_type(from.item_type());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
    if (from.has_item_upgrade()) {
      set_item_upgrade(from.item_upgrade());
    }
    if (from.has_is_equip()) {
      set_is_equip(from.is_equip());
    }
  }
}

void UpdateItem::CopyFrom(const UpdateItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UpdateItem::Swap(UpdateItem* other) {
  if (other != this) {
    std::swap(item_only_id_, other->item_only_id_);
    std::swap(item_type_, other->item_type_);
    std::swap(item_num_, other->item_num_);
    std::swap(item_upgrade_, other->item_upgrade_);
    item_hole_.Swap(&other->item_hole_);
    std::swap(is_equip_, other->is_equip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateItem::GetTypeName() const {
  return "message.UpdateItem";
}


// ===================================================================

#ifndef _MSC_VER
const int EquipItem::kItemOnlyIdFieldNumber;
const int EquipItem::kMercPosFieldNumber;
const int EquipItem::kIsUnequipFieldNumber;
const int EquipItem::kIsDestFieldNumber;
const int EquipItem::kPosFieldNumber;
#endif  // !_MSC_VER

EquipItem::EquipItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EquipItem::InitAsDefaultInstance() {
}

EquipItem::EquipItem(const EquipItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EquipItem::SharedCtor() {
  _cached_size_ = 0;
  item_only_id_ = GOOGLE_ULONGLONG(0);
  merc_pos_ = 0u;
  is_unequip_ = false;
  is_dest_ = false;
  pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EquipItem::~EquipItem() {
  SharedDtor();
}

void EquipItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EquipItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EquipItem& EquipItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EquipItem* EquipItem::default_instance_ = NULL;

EquipItem* EquipItem::New() const {
  return new EquipItem;
}

void EquipItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_only_id_ = GOOGLE_ULONGLONG(0);
    merc_pos_ = 0u;
    is_unequip_ = false;
    is_dest_ = false;
    pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EquipItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 item_only_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &item_only_id_)));
          set_has_item_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_merc_pos;
        break;
      }

      // optional uint32 merc_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_unequip;
        break;
      }

      // optional bool is_unequip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_unequip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_unequip_)));
          set_has_is_unequip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_dest;
        break;
      }

      // optional bool is_dest = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_dest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_dest_)));
          set_has_is_dest();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_pos;
        break;
      }

      // optional uint32 pos = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EquipItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 item_only_id = 1;
  if (has_item_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->item_only_id(), output);
  }

  // optional uint32 merc_pos = 2;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->merc_pos(), output);
  }

  // optional bool is_unequip = 3;
  if (has_is_unequip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_unequip(), output);
  }

  // optional bool is_dest = 4;
  if (has_is_dest()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_dest(), output);
  }

  // optional uint32 pos = 5;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->pos(), output);
  }

}

int EquipItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 item_only_id = 1;
    if (has_item_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->item_only_id());
    }

    // optional uint32 merc_pos = 2;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // optional bool is_unequip = 3;
    if (has_is_unequip()) {
      total_size += 1 + 1;
    }

    // optional bool is_dest = 4;
    if (has_is_dest()) {
      total_size += 1 + 1;
    }

    // optional uint32 pos = 5;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EquipItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EquipItem*>(&from));
}

void EquipItem::MergeFrom(const EquipItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_only_id()) {
      set_item_only_id(from.item_only_id());
    }
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_is_unequip()) {
      set_is_unequip(from.is_unequip());
    }
    if (from.has_is_dest()) {
      set_is_dest(from.is_dest());
    }
    if (from.has_pos()) {
      set_pos(from.pos());
    }
  }
}

void EquipItem::CopyFrom(const EquipItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EquipItem::Swap(EquipItem* other) {
  if (other != this) {
    std::swap(item_only_id_, other->item_only_id_);
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(is_unequip_, other->is_unequip_);
    std::swap(is_dest_, other->is_dest_);
    std::swap(pos_, other->pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EquipItem::GetTypeName() const {
  return "message.EquipItem";
}


// ===================================================================

#ifndef _MSC_VER
const int UseItem::kItemOnlyIdFieldNumber;
const int UseItem::kMercPosFieldNumber;
const int UseItem::kItemNumFieldNumber;
#endif  // !_MSC_VER

UseItem::UseItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UseItem::InitAsDefaultInstance() {
}

UseItem::UseItem(const UseItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UseItem::SharedCtor() {
  _cached_size_ = 0;
  item_only_id_ = GOOGLE_ULONGLONG(0);
  merc_pos_ = 0u;
  item_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseItem::~UseItem() {
  SharedDtor();
}

void UseItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UseItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseItem& UseItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UseItem* UseItem::default_instance_ = NULL;

UseItem* UseItem::New() const {
  return new UseItem;
}

void UseItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_only_id_ = GOOGLE_ULONGLONG(0);
    merc_pos_ = 0u;
    item_num_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UseItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 item_only_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &item_only_id_)));
          set_has_item_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_merc_pos;
        break;
      }

      // optional uint32 merc_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_num;
        break;
      }

      // optional uint32 item_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UseItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 item_only_id = 1;
  if (has_item_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->item_only_id(), output);
  }

  // optional uint32 merc_pos = 2;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->merc_pos(), output);
  }

  // optional uint32 item_num = 3;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->item_num(), output);
  }

}

int UseItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 item_only_id = 1;
    if (has_item_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->item_only_id());
    }

    // optional uint32 merc_pos = 2;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // optional uint32 item_num = 3;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseItem*>(&from));
}

void UseItem::MergeFrom(const UseItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_only_id()) {
      set_item_only_id(from.item_only_id());
    }
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
  }
}

void UseItem::CopyFrom(const UseItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UseItem::Swap(UseItem* other) {
  if (other != this) {
    std::swap(item_only_id_, other->item_only_id_);
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(item_num_, other->item_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseItem::GetTypeName() const {
  return "message.UseItem";
}


// ===================================================================

#ifndef _MSC_VER
const int OtherEquipItem::kPlayerIdFieldNumber;
const int OtherEquipItem::kItemTypeFieldNumber;
const int OtherEquipItem::kIsUnequipFieldNumber;
#endif  // !_MSC_VER

OtherEquipItem::OtherEquipItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OtherEquipItem::InitAsDefaultInstance() {
}

OtherEquipItem::OtherEquipItem(const OtherEquipItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OtherEquipItem::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  item_type_ = 0u;
  is_unequip_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OtherEquipItem::~OtherEquipItem() {
  SharedDtor();
}

void OtherEquipItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OtherEquipItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OtherEquipItem& OtherEquipItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OtherEquipItem* OtherEquipItem::default_instance_ = NULL;

OtherEquipItem* OtherEquipItem::New() const {
  return new OtherEquipItem;
}

void OtherEquipItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_id_ = 0u;
    item_type_ = 0u;
    is_unequip_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OtherEquipItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_type;
        break;
      }

      // required uint32 item_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_type_)));
          set_has_item_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_unequip;
        break;
      }

      // optional bool is_unequip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_unequip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_unequip_)));
          set_has_is_unequip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OtherEquipItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 item_type = 2;
  if (has_item_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_type(), output);
  }

  // optional bool is_unequip = 3;
  if (has_is_unequip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_unequip(), output);
  }

}

int OtherEquipItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 item_type = 2;
    if (has_item_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_type());
    }

    // optional bool is_unequip = 3;
    if (has_is_unequip()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OtherEquipItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OtherEquipItem*>(&from));
}

void OtherEquipItem::MergeFrom(const OtherEquipItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_item_type()) {
      set_item_type(from.item_type());
    }
    if (from.has_is_unequip()) {
      set_is_unequip(from.is_unequip());
    }
  }
}

void OtherEquipItem::CopyFrom(const OtherEquipItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OtherEquipItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void OtherEquipItem::Swap(OtherEquipItem* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(item_type_, other->item_type_);
    std::swap(is_unequip_, other->is_unequip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OtherEquipItem::GetTypeName() const {
  return "message.OtherEquipItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeAttr::kAttrTypeFieldNumber;
const int ChangeAttr::kAttrValueFieldNumber;
const int ChangeAttr::kAttrValueTypeFieldNumber;
const int ChangeAttr::kMercPosFieldNumber;
const int ChangeAttr::kIsBattleFieldNumber;
const int ChangeAttr::kCostChannelFieldNumber;
#endif  // !_MSC_VER

ChangeAttr::ChangeAttr()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeAttr::InitAsDefaultInstance() {
}

ChangeAttr::ChangeAttr(const ChangeAttr& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeAttr::SharedCtor() {
  _cached_size_ = 0;
  attr_value_type_ = 0u;
  merc_pos_ = 0u;
  is_battle_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeAttr::~ChangeAttr() {
  SharedDtor();
}

void ChangeAttr::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeAttr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeAttr& ChangeAttr::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ChangeAttr* ChangeAttr::default_instance_ = NULL;

ChangeAttr* ChangeAttr::New() const {
  return new ChangeAttr;
}

void ChangeAttr::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    attr_value_type_ = 0u;
    merc_pos_ = 0u;
    is_battle_ = 0u;
  }
  attr_type_.Clear();
  attr_value_.Clear();
  cost_channel_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeAttr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 attr_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attr_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_attr_type())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_attr_type())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_attr_type;
        if (input->ExpectTag(16)) goto parse_attr_value;
        break;
      }

      // repeated uint32 attr_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attr_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_attr_value())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_attr_value())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_attr_value;
        if (input->ExpectTag(24)) goto parse_attr_value_type;
        break;
      }

      // optional uint32 attr_value_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attr_value_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attr_value_type_)));
          set_has_attr_value_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_merc_pos;
        break;
      }

      // optional uint32 merc_pos = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_is_battle;
        break;
      }

      // optional uint32 is_battle = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_battle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_battle_)));
          set_has_is_battle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_cost_channel;
        break;
      }

      // repeated uint32 cost_channel = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cost_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_cost_channel())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_cost_channel())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_cost_channel;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeAttr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 attr_type = 1;
  for (int i = 0; i < this->attr_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->attr_type(i), output);
  }

  // repeated uint32 attr_value = 2;
  for (int i = 0; i < this->attr_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->attr_value(i), output);
  }

  // optional uint32 attr_value_type = 3;
  if (has_attr_value_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->attr_value_type(), output);
  }

  // optional uint32 merc_pos = 4;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->merc_pos(), output);
  }

  // optional uint32 is_battle = 5;
  if (has_is_battle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->is_battle(), output);
  }

  // repeated uint32 cost_channel = 6;
  for (int i = 0; i < this->cost_channel_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->cost_channel(i), output);
  }

}

int ChangeAttr::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional uint32 attr_value_type = 3;
    if (has_attr_value_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->attr_value_type());
    }

    // optional uint32 merc_pos = 4;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // optional uint32 is_battle = 5;
    if (has_is_battle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_battle());
    }

  }
  // repeated uint32 attr_type = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->attr_type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->attr_type(i));
    }
    total_size += 1 * this->attr_type_size() + data_size;
  }

  // repeated uint32 attr_value = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->attr_value_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->attr_value(i));
    }
    total_size += 1 * this->attr_value_size() + data_size;
  }

  // repeated uint32 cost_channel = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->cost_channel_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->cost_channel(i));
    }
    total_size += 1 * this->cost_channel_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeAttr::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeAttr*>(&from));
}

void ChangeAttr::MergeFrom(const ChangeAttr& from) {
  GOOGLE_CHECK_NE(&from, this);
  attr_type_.MergeFrom(from.attr_type_);
  attr_value_.MergeFrom(from.attr_value_);
  cost_channel_.MergeFrom(from.cost_channel_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_attr_value_type()) {
      set_attr_value_type(from.attr_value_type());
    }
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_is_battle()) {
      set_is_battle(from.is_battle());
    }
  }
}

void ChangeAttr::CopyFrom(const ChangeAttr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeAttr::IsInitialized() const {

  return true;
}

void ChangeAttr::Swap(ChangeAttr* other) {
  if (other != this) {
    attr_type_.Swap(&other->attr_type_);
    attr_value_.Swap(&other->attr_value_);
    std::swap(attr_value_type_, other->attr_value_type_);
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(is_battle_, other->is_battle_);
    cost_channel_.Swap(&other->cost_channel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeAttr::GetTypeName() const {
  return "message.ChangeAttr";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeTask::kTaskVarFieldNumber;
const int ChangeTask::kTaskValueFieldNumber;
#endif  // !_MSC_VER

ChangeTask::ChangeTask()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeTask::InitAsDefaultInstance() {
}

ChangeTask::ChangeTask(const ChangeTask& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeTask::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeTask::~ChangeTask() {
  SharedDtor();
}

void ChangeTask::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeTask::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeTask& ChangeTask::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ChangeTask* ChangeTask::default_instance_ = NULL;

ChangeTask* ChangeTask::New() const {
  return new ChangeTask;
}

void ChangeTask::Clear() {
  task_var_.Clear();
  task_value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeTask::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 task_var = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_task_var:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_task_var())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_task_var())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_task_var;
        if (input->ExpectTag(16)) goto parse_task_value;
        break;
      }

      // repeated uint32 task_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_task_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_task_value())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_task_value())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_task_value;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeTask::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 task_var = 1;
  for (int i = 0; i < this->task_var_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->task_var(i), output);
  }

  // repeated uint32 task_value = 2;
  for (int i = 0; i < this->task_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->task_value(i), output);
  }

}

int ChangeTask::ByteSize() const {
  int total_size = 0;

  // repeated uint32 task_var = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->task_var_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->task_var(i));
    }
    total_size += 1 * this->task_var_size() + data_size;
  }

  // repeated uint32 task_value = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->task_value_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->task_value(i));
    }
    total_size += 1 * this->task_value_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeTask::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeTask*>(&from));
}

void ChangeTask::MergeFrom(const ChangeTask& from) {
  GOOGLE_CHECK_NE(&from, this);
  task_var_.MergeFrom(from.task_var_);
  task_value_.MergeFrom(from.task_value_);
}

void ChangeTask::CopyFrom(const ChangeTask& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeTask::IsInitialized() const {

  return true;
}

void ChangeTask::Swap(ChangeTask* other) {
  if (other != this) {
    task_var_.Swap(&other->task_var_);
    task_value_.Swap(&other->task_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeTask::GetTypeName() const {
  return "message.ChangeTask";
}


// ===================================================================

#ifndef _MSC_VER
const int CheckTime::kMonthFieldNumber;
const int CheckTime::kDayFieldNumber;
const int CheckTime::kHourFieldNumber;
const int CheckTime::kMinuteFieldNumber;
const int CheckTime::kSecondFieldNumber;
#endif  // !_MSC_VER

CheckTime::CheckTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CheckTime::InitAsDefaultInstance() {
}

CheckTime::CheckTime(const CheckTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CheckTime::SharedCtor() {
  _cached_size_ = 0;
  month_ = 0u;
  day_ = 0u;
  hour_ = 0u;
  minute_ = 0u;
  second_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckTime::~CheckTime() {
  SharedDtor();
}

void CheckTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CheckTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CheckTime& CheckTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CheckTime* CheckTime::default_instance_ = NULL;

CheckTime* CheckTime::New() const {
  return new CheckTime;
}

void CheckTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    month_ = 0u;
    day_ = 0u;
    hour_ = 0u;
    minute_ = 0u;
    second_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CheckTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 month = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &month_)));
          set_has_month();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_day;
        break;
      }

      // required uint32 day = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &day_)));
          set_has_day();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_hour;
        break;
      }

      // required uint32 hour = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hour_)));
          set_has_hour();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_minute;
        break;
      }

      // required uint32 minute = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minute:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minute_)));
          set_has_minute();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_second;
        break;
      }

      // required uint32 second = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &second_)));
          set_has_second();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 month = 1;
  if (has_month()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->month(), output);
  }

  // required uint32 day = 2;
  if (has_day()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->day(), output);
  }

  // required uint32 hour = 3;
  if (has_hour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->hour(), output);
  }

  // required uint32 minute = 4;
  if (has_minute()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->minute(), output);
  }

  // required uint32 second = 5;
  if (has_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->second(), output);
  }

}

int CheckTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 month = 1;
    if (has_month()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->month());
    }

    // required uint32 day = 2;
    if (has_day()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->day());
    }

    // required uint32 hour = 3;
    if (has_hour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hour());
    }

    // required uint32 minute = 4;
    if (has_minute()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->minute());
    }

    // required uint32 second = 5;
    if (has_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->second());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CheckTime*>(&from));
}

void CheckTime::MergeFrom(const CheckTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_month()) {
      set_month(from.month());
    }
    if (from.has_day()) {
      set_day(from.day());
    }
    if (from.has_hour()) {
      set_hour(from.hour());
    }
    if (from.has_minute()) {
      set_minute(from.minute());
    }
    if (from.has_second()) {
      set_second(from.second());
    }
  }
}

void CheckTime::CopyFrom(const CheckTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckTime::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void CheckTime::Swap(CheckTime* other) {
  if (other != this) {
    std::swap(month_, other->month_);
    std::swap(day_, other->day_);
    std::swap(hour_, other->hour_);
    std::swap(minute_, other->minute_);
    std::swap(second_, other->second_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CheckTime::GetTypeName() const {
  return "message.CheckTime";
}


// ===================================================================

#ifndef _MSC_VER
const int MercenaryGet::kMercCardFieldNumber;
#endif  // !_MSC_VER

MercenaryGet::MercenaryGet()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MercenaryGet::InitAsDefaultInstance() {
}

MercenaryGet::MercenaryGet(const MercenaryGet& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MercenaryGet::SharedCtor() {
  _cached_size_ = 0;
  merc_card_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MercenaryGet::~MercenaryGet() {
  SharedDtor();
}

void MercenaryGet::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MercenaryGet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MercenaryGet& MercenaryGet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

MercenaryGet* MercenaryGet::default_instance_ = NULL;

MercenaryGet* MercenaryGet::New() const {
  return new MercenaryGet;
}

void MercenaryGet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_card_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MercenaryGet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_card = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_card_)));
          set_has_merc_card();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MercenaryGet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_card = 1;
  if (has_merc_card()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_card(), output);
  }

}

int MercenaryGet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_card = 1;
    if (has_merc_card()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_card());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MercenaryGet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MercenaryGet*>(&from));
}

void MercenaryGet::MergeFrom(const MercenaryGet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_card()) {
      set_merc_card(from.merc_card());
    }
  }
}

void MercenaryGet::CopyFrom(const MercenaryGet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MercenaryGet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MercenaryGet::Swap(MercenaryGet* other) {
  if (other != this) {
    std::swap(merc_card_, other->merc_card_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MercenaryGet::GetTypeName() const {
  return "message.MercenaryGet";
}


// ===================================================================

#ifndef _MSC_VER
const int MercenaryCardGet::kMercCardFieldNumber;
#endif  // !_MSC_VER

MercenaryCardGet::MercenaryCardGet()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MercenaryCardGet::InitAsDefaultInstance() {
}

MercenaryCardGet::MercenaryCardGet(const MercenaryCardGet& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MercenaryCardGet::SharedCtor() {
  _cached_size_ = 0;
  merc_card_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MercenaryCardGet::~MercenaryCardGet() {
  SharedDtor();
}

void MercenaryCardGet::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MercenaryCardGet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MercenaryCardGet& MercenaryCardGet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

MercenaryCardGet* MercenaryCardGet::default_instance_ = NULL;

MercenaryCardGet* MercenaryCardGet::New() const {
  return new MercenaryCardGet;
}

void MercenaryCardGet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_card_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MercenaryCardGet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_card = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_card_)));
          set_has_merc_card();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MercenaryCardGet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_card = 1;
  if (has_merc_card()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_card(), output);
  }

}

int MercenaryCardGet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_card = 1;
    if (has_merc_card()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_card());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MercenaryCardGet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MercenaryCardGet*>(&from));
}

void MercenaryCardGet::MergeFrom(const MercenaryCardGet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_card()) {
      set_merc_card(from.merc_card());
    }
  }
}

void MercenaryCardGet::CopyFrom(const MercenaryCardGet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MercenaryCardGet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MercenaryCardGet::Swap(MercenaryCardGet* other) {
  if (other != this) {
    std::swap(merc_card_, other->merc_card_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MercenaryCardGet::GetTypeName() const {
  return "message.MercenaryCardGet";
}


// ===================================================================

#ifndef _MSC_VER
const int MercenaryCardGetResult::kOperResultFieldNumber;
const int MercenaryCardGetResult::kMercCardFieldNumber;
const int MercenaryCardGetResult::kMercIdFieldNumber;
const int MercenaryCardGetResult::kMercChipNowFieldNumber;
const int MercenaryCardGetResult::kMercChipMaxFieldNumber;
const int MercenaryCardGetResult::kFreeMercFieldNumber;
const int MercenaryCardGetResult::kFreeChipFieldNumber;
#endif  // !_MSC_VER

MercenaryCardGetResult::MercenaryCardGetResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MercenaryCardGetResult::InitAsDefaultInstance() {
}

MercenaryCardGetResult::MercenaryCardGetResult(const MercenaryCardGetResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MercenaryCardGetResult::SharedCtor() {
  _cached_size_ = 0;
  oper_result_ = 0u;
  merc_card_ = 0u;
  merc_id_ = 0u;
  merc_chip_now_ = 0u;
  merc_chip_max_ = 0u;
  free_merc_ = 0u;
  free_chip_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MercenaryCardGetResult::~MercenaryCardGetResult() {
  SharedDtor();
}

void MercenaryCardGetResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MercenaryCardGetResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MercenaryCardGetResult& MercenaryCardGetResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

MercenaryCardGetResult* MercenaryCardGetResult::default_instance_ = NULL;

MercenaryCardGetResult* MercenaryCardGetResult::New() const {
  return new MercenaryCardGetResult;
}

void MercenaryCardGetResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    oper_result_ = 0u;
    merc_card_ = 0u;
    merc_id_ = 0u;
    merc_chip_now_ = 0u;
    merc_chip_max_ = 0u;
    free_merc_ = 0u;
    free_chip_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MercenaryCardGetResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 oper_result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_result_)));
          set_has_oper_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_merc_card;
        break;
      }

      // required uint32 merc_card = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_card:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_card_)));
          set_has_merc_card();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_merc_id;
        break;
      }

      // required uint32 merc_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_id_)));
          set_has_merc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_merc_chip_now;
        break;
      }

      // required uint32 merc_chip_now = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_chip_now:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_chip_now_)));
          set_has_merc_chip_now();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_merc_chip_max;
        break;
      }

      // required uint32 merc_chip_max = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_chip_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_chip_max_)));
          set_has_merc_chip_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_free_merc;
        break;
      }

      // required uint32 free_merc = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_free_merc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &free_merc_)));
          set_has_free_merc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_free_chip;
        break;
      }

      // required uint32 free_chip = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_free_chip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &free_chip_)));
          set_has_free_chip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MercenaryCardGetResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 oper_result = 1;
  if (has_oper_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->oper_result(), output);
  }

  // required uint32 merc_card = 2;
  if (has_merc_card()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->merc_card(), output);
  }

  // required uint32 merc_id = 3;
  if (has_merc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->merc_id(), output);
  }

  // required uint32 merc_chip_now = 4;
  if (has_merc_chip_now()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->merc_chip_now(), output);
  }

  // required uint32 merc_chip_max = 5;
  if (has_merc_chip_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->merc_chip_max(), output);
  }

  // required uint32 free_merc = 6;
  if (has_free_merc()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->free_merc(), output);
  }

  // required uint32 free_chip = 7;
  if (has_free_chip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->free_chip(), output);
  }

}

int MercenaryCardGetResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 oper_result = 1;
    if (has_oper_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_result());
    }

    // required uint32 merc_card = 2;
    if (has_merc_card()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_card());
    }

    // required uint32 merc_id = 3;
    if (has_merc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_id());
    }

    // required uint32 merc_chip_now = 4;
    if (has_merc_chip_now()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_chip_now());
    }

    // required uint32 merc_chip_max = 5;
    if (has_merc_chip_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_chip_max());
    }

    // required uint32 free_merc = 6;
    if (has_free_merc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->free_merc());
    }

    // required uint32 free_chip = 7;
    if (has_free_chip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->free_chip());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MercenaryCardGetResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MercenaryCardGetResult*>(&from));
}

void MercenaryCardGetResult::MergeFrom(const MercenaryCardGetResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_oper_result()) {
      set_oper_result(from.oper_result());
    }
    if (from.has_merc_card()) {
      set_merc_card(from.merc_card());
    }
    if (from.has_merc_id()) {
      set_merc_id(from.merc_id());
    }
    if (from.has_merc_chip_now()) {
      set_merc_chip_now(from.merc_chip_now());
    }
    if (from.has_merc_chip_max()) {
      set_merc_chip_max(from.merc_chip_max());
    }
    if (from.has_free_merc()) {
      set_free_merc(from.free_merc());
    }
    if (from.has_free_chip()) {
      set_free_chip(from.free_chip());
    }
  }
}

void MercenaryCardGetResult::CopyFrom(const MercenaryCardGetResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MercenaryCardGetResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void MercenaryCardGetResult::Swap(MercenaryCardGetResult* other) {
  if (other != this) {
    std::swap(oper_result_, other->oper_result_);
    std::swap(merc_card_, other->merc_card_);
    std::swap(merc_id_, other->merc_id_);
    std::swap(merc_chip_now_, other->merc_chip_now_);
    std::swap(merc_chip_max_, other->merc_chip_max_);
    std::swap(free_merc_, other->free_merc_);
    std::swap(free_chip_, other->free_chip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MercenaryCardGetResult::GetTypeName() const {
  return "message.MercenaryCardGetResult";
}


// ===================================================================

#ifndef _MSC_VER
const int MercenaryAttrAdd::kMercPosFieldNumber;
const int MercenaryAttrAdd::kAttrTypeFieldNumber;
const int MercenaryAttrAdd::kAttrValueFieldNumber;
#endif  // !_MSC_VER

MercenaryAttrAdd::MercenaryAttrAdd()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MercenaryAttrAdd::InitAsDefaultInstance() {
}

MercenaryAttrAdd::MercenaryAttrAdd(const MercenaryAttrAdd& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MercenaryAttrAdd::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  attr_type_ = 0u;
  attr_value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MercenaryAttrAdd::~MercenaryAttrAdd() {
  SharedDtor();
}

void MercenaryAttrAdd::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MercenaryAttrAdd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MercenaryAttrAdd& MercenaryAttrAdd::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

MercenaryAttrAdd* MercenaryAttrAdd::default_instance_ = NULL;

MercenaryAttrAdd* MercenaryAttrAdd::New() const {
  return new MercenaryAttrAdd;
}

void MercenaryAttrAdd::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
    attr_type_ = 0u;
    attr_value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MercenaryAttrAdd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_attr_type;
        break;
      }

      // required uint32 attr_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attr_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attr_type_)));
          set_has_attr_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_attr_value;
        break;
      }

      // required uint32 attr_value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attr_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attr_value_)));
          set_has_attr_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MercenaryAttrAdd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

  // required uint32 attr_type = 2;
  if (has_attr_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->attr_type(), output);
  }

  // required uint32 attr_value = 3;
  if (has_attr_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->attr_value(), output);
  }

}

int MercenaryAttrAdd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // required uint32 attr_type = 2;
    if (has_attr_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->attr_type());
    }

    // required uint32 attr_value = 3;
    if (has_attr_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->attr_value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MercenaryAttrAdd::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MercenaryAttrAdd*>(&from));
}

void MercenaryAttrAdd::MergeFrom(const MercenaryAttrAdd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_attr_type()) {
      set_attr_type(from.attr_type());
    }
    if (from.has_attr_value()) {
      set_attr_value(from.attr_value());
    }
  }
}

void MercenaryAttrAdd::CopyFrom(const MercenaryAttrAdd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MercenaryAttrAdd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MercenaryAttrAdd::Swap(MercenaryAttrAdd* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(attr_type_, other->attr_type_);
    std::swap(attr_value_, other->attr_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MercenaryAttrAdd::GetTypeName() const {
  return "message.MercenaryAttrAdd";
}


// ===================================================================

#ifndef _MSC_VER
const int MercenaryToExp::kMercFromPosFieldNumber;
const int MercenaryToExp::kMercToPosFieldNumber;
const int MercenaryToExp::kIsCostMoneyFieldNumber;
#endif  // !_MSC_VER

MercenaryToExp::MercenaryToExp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MercenaryToExp::InitAsDefaultInstance() {
}

MercenaryToExp::MercenaryToExp(const MercenaryToExp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MercenaryToExp::SharedCtor() {
  _cached_size_ = 0;
  merc_from_pos_ = 0u;
  merc_to_pos_ = 0u;
  is_cost_money_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MercenaryToExp::~MercenaryToExp() {
  SharedDtor();
}

void MercenaryToExp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MercenaryToExp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MercenaryToExp& MercenaryToExp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

MercenaryToExp* MercenaryToExp::default_instance_ = NULL;

MercenaryToExp* MercenaryToExp::New() const {
  return new MercenaryToExp;
}

void MercenaryToExp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_from_pos_ = 0u;
    merc_to_pos_ = 0u;
    is_cost_money_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MercenaryToExp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_from_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_from_pos_)));
          set_has_merc_from_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_merc_to_pos;
        break;
      }

      // required uint32 merc_to_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_to_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_to_pos_)));
          set_has_merc_to_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_cost_money;
        break;
      }

      // optional uint32 is_cost_money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_cost_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_cost_money_)));
          set_has_is_cost_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MercenaryToExp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_from_pos = 1;
  if (has_merc_from_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_from_pos(), output);
  }

  // required uint32 merc_to_pos = 2;
  if (has_merc_to_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->merc_to_pos(), output);
  }

  // optional uint32 is_cost_money = 3;
  if (has_is_cost_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->is_cost_money(), output);
  }

}

int MercenaryToExp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_from_pos = 1;
    if (has_merc_from_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_from_pos());
    }

    // required uint32 merc_to_pos = 2;
    if (has_merc_to_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_to_pos());
    }

    // optional uint32 is_cost_money = 3;
    if (has_is_cost_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_cost_money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MercenaryToExp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MercenaryToExp*>(&from));
}

void MercenaryToExp::MergeFrom(const MercenaryToExp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_from_pos()) {
      set_merc_from_pos(from.merc_from_pos());
    }
    if (from.has_merc_to_pos()) {
      set_merc_to_pos(from.merc_to_pos());
    }
    if (from.has_is_cost_money()) {
      set_is_cost_money(from.is_cost_money());
    }
  }
}

void MercenaryToExp::CopyFrom(const MercenaryToExp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MercenaryToExp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MercenaryToExp::Swap(MercenaryToExp* other) {
  if (other != this) {
    std::swap(merc_from_pos_, other->merc_from_pos_);
    std::swap(merc_to_pos_, other->merc_to_pos_);
    std::swap(is_cost_money_, other->is_cost_money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MercenaryToExp::GetTypeName() const {
  return "message.MercenaryToExp";
}


// ===================================================================

#ifndef _MSC_VER
const int AddMercenary::kMercPosFieldNumber;
const int AddMercenary::kMercDataFieldNumber;
#endif  // !_MSC_VER

AddMercenary::AddMercenary()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddMercenary::InitAsDefaultInstance() {
}

AddMercenary::AddMercenary(const AddMercenary& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddMercenary::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddMercenary::~AddMercenary() {
  SharedDtor();
}

void AddMercenary::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddMercenary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddMercenary& AddMercenary::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddMercenary* AddMercenary::default_instance_ = NULL;

AddMercenary* AddMercenary::New() const {
  return new AddMercenary;
}

void AddMercenary::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
  }
  merc_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddMercenary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_merc_data;
        break;
      }

      // repeated bytes merc_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_merc_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_merc_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_merc_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddMercenary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

  // repeated bytes merc_data = 2;
  for (int i = 0; i < this->merc_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->merc_data(i), output);
  }

}

int AddMercenary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

  }
  // repeated bytes merc_data = 2;
  total_size += 1 * this->merc_data_size();
  for (int i = 0; i < this->merc_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->merc_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddMercenary::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddMercenary*>(&from));
}

void AddMercenary::MergeFrom(const AddMercenary& from) {
  GOOGLE_CHECK_NE(&from, this);
  merc_data_.MergeFrom(from.merc_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
  }
}

void AddMercenary::CopyFrom(const AddMercenary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddMercenary::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AddMercenary::Swap(AddMercenary* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    merc_data_.Swap(&other->merc_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddMercenary::GetTypeName() const {
  return "message.AddMercenary";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateMercenary::kMercPosFieldNumber;
const int UpdateMercenary::kMercDataFieldNumber;
#endif  // !_MSC_VER

UpdateMercenary::UpdateMercenary()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateMercenary::InitAsDefaultInstance() {
}

UpdateMercenary::UpdateMercenary(const UpdateMercenary& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateMercenary::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateMercenary::~UpdateMercenary() {
  SharedDtor();
}

void UpdateMercenary::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateMercenary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateMercenary& UpdateMercenary::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UpdateMercenary* UpdateMercenary::default_instance_ = NULL;

UpdateMercenary* UpdateMercenary::New() const {
  return new UpdateMercenary;
}

void UpdateMercenary::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
  }
  merc_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateMercenary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_merc_data;
        break;
      }

      // repeated bytes merc_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_merc_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_merc_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_merc_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateMercenary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

  // repeated bytes merc_data = 2;
  for (int i = 0; i < this->merc_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->merc_data(i), output);
  }

}

int UpdateMercenary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

  }
  // repeated bytes merc_data = 2;
  total_size += 1 * this->merc_data_size();
  for (int i = 0; i < this->merc_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->merc_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateMercenary::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateMercenary*>(&from));
}

void UpdateMercenary::MergeFrom(const UpdateMercenary& from) {
  GOOGLE_CHECK_NE(&from, this);
  merc_data_.MergeFrom(from.merc_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
  }
}

void UpdateMercenary::CopyFrom(const UpdateMercenary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateMercenary::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UpdateMercenary::Swap(UpdateMercenary* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    merc_data_.Swap(&other->merc_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateMercenary::GetTypeName() const {
  return "message.UpdateMercenary";
}


// ===================================================================

#ifndef _MSC_VER
const int MercenaryDel::kMercPosFieldNumber;
#endif  // !_MSC_VER

MercenaryDel::MercenaryDel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MercenaryDel::InitAsDefaultInstance() {
}

MercenaryDel::MercenaryDel(const MercenaryDel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MercenaryDel::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MercenaryDel::~MercenaryDel() {
  SharedDtor();
}

void MercenaryDel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MercenaryDel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MercenaryDel& MercenaryDel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

MercenaryDel* MercenaryDel::default_instance_ = NULL;

MercenaryDel* MercenaryDel::New() const {
  return new MercenaryDel;
}

void MercenaryDel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MercenaryDel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MercenaryDel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

}

int MercenaryDel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MercenaryDel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MercenaryDel*>(&from));
}

void MercenaryDel::MergeFrom(const MercenaryDel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
  }
}

void MercenaryDel::CopyFrom(const MercenaryDel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MercenaryDel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MercenaryDel::Swap(MercenaryDel* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MercenaryDel::GetTypeName() const {
  return "message.MercenaryDel";
}


// ===================================================================

#ifndef _MSC_VER
const int AddCharBuff::kBuffIdFieldNumber;
const int AddCharBuff::kBuffValueFieldNumber;
#endif  // !_MSC_VER

AddCharBuff::AddCharBuff()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddCharBuff::InitAsDefaultInstance() {
}

AddCharBuff::AddCharBuff(const AddCharBuff& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddCharBuff::SharedCtor() {
  _cached_size_ = 0;
  buff_id_ = 0u;
  buff_value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddCharBuff::~AddCharBuff() {
  SharedDtor();
}

void AddCharBuff::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddCharBuff::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddCharBuff& AddCharBuff::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddCharBuff* AddCharBuff::default_instance_ = NULL;

AddCharBuff* AddCharBuff::New() const {
  return new AddCharBuff;
}

void AddCharBuff::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    buff_id_ = 0u;
    buff_value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddCharBuff::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 buff_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buff_id_)));
          set_has_buff_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_buff_value;
        break;
      }

      // optional uint32 buff_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buff_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buff_value_)));
          set_has_buff_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddCharBuff::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 buff_id = 1;
  if (has_buff_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->buff_id(), output);
  }

  // optional uint32 buff_value = 2;
  if (has_buff_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->buff_value(), output);
  }

}

int AddCharBuff::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 buff_id = 1;
    if (has_buff_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buff_id());
    }

    // optional uint32 buff_value = 2;
    if (has_buff_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buff_value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddCharBuff::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddCharBuff*>(&from));
}

void AddCharBuff::MergeFrom(const AddCharBuff& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buff_id()) {
      set_buff_id(from.buff_id());
    }
    if (from.has_buff_value()) {
      set_buff_value(from.buff_value());
    }
  }
}

void AddCharBuff::CopyFrom(const AddCharBuff& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddCharBuff::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AddCharBuff::Swap(AddCharBuff* other) {
  if (other != this) {
    std::swap(buff_id_, other->buff_id_);
    std::swap(buff_value_, other->buff_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddCharBuff::GetTypeName() const {
  return "message.AddCharBuff";
}


// ===================================================================

#ifndef _MSC_VER
const int DelCharBuff::kBuffIdFieldNumber;
#endif  // !_MSC_VER

DelCharBuff::DelCharBuff()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DelCharBuff::InitAsDefaultInstance() {
}

DelCharBuff::DelCharBuff(const DelCharBuff& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DelCharBuff::SharedCtor() {
  _cached_size_ = 0;
  buff_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DelCharBuff::~DelCharBuff() {
  SharedDtor();
}

void DelCharBuff::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DelCharBuff::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DelCharBuff& DelCharBuff::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

DelCharBuff* DelCharBuff::default_instance_ = NULL;

DelCharBuff* DelCharBuff::New() const {
  return new DelCharBuff;
}

void DelCharBuff::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    buff_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DelCharBuff::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 buff_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buff_id_)));
          set_has_buff_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DelCharBuff::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 buff_id = 1;
  if (has_buff_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->buff_id(), output);
  }

}

int DelCharBuff::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 buff_id = 1;
    if (has_buff_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buff_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DelCharBuff::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DelCharBuff*>(&from));
}

void DelCharBuff::MergeFrom(const DelCharBuff& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buff_id()) {
      set_buff_id(from.buff_id());
    }
  }
}

void DelCharBuff::CopyFrom(const DelCharBuff& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelCharBuff::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DelCharBuff::Swap(DelCharBuff* other) {
  if (other != this) {
    std::swap(buff_id_, other->buff_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DelCharBuff::GetTypeName() const {
  return "message.DelCharBuff";
}


// ===================================================================

#ifndef _MSC_VER
const int Chat::kChatTypeFieldNumber;
const int Chat::kChatDataFieldNumber;
const int Chat::kFromNameFieldNumber;
const int Chat::kToNameFieldNumber;
const int Chat::kItemInfoFieldNumber;
const int Chat::kEquipInfoFieldNumber;
const int Chat::kRoleInfoFieldNumber;
const int Chat::kMercInfoFieldNumber;
const int Chat::kSexFieldNumber;
const int Chat::kVipLvFieldNumber;
const int Chat::kNoticeTypeFieldNumber;
const int Chat::kServerIdFieldNumber;
#endif  // !_MSC_VER

Chat::Chat()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Chat::InitAsDefaultInstance() {
}

Chat::Chat(const Chat& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Chat::SharedCtor() {
  _cached_size_ = 0;
  chat_type_ = 0u;
  sex_ = 0u;
  vip_lv_ = 0u;
  notice_type_ = 0u;
  server_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Chat::~Chat() {
  SharedDtor();
}

void Chat::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Chat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Chat& Chat::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

Chat* Chat::default_instance_ = NULL;

Chat* Chat::New() const {
  return new Chat;
}

void Chat::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    chat_type_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    sex_ = 0u;
    vip_lv_ = 0u;
    notice_type_ = 0u;
    server_id_ = 0u;
  }
  chat_data_.Clear();
  from_name_.Clear();
  to_name_.Clear();
  item_info_.Clear();
  equip_info_.Clear();
  role_info_.Clear();
  merc_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Chat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 chat_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chat_type_)));
          set_has_chat_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_chat_data;
        break;
      }

      // repeated bytes chat_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chat_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_chat_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_chat_data;
        if (input->ExpectTag(26)) goto parse_from_name;
        break;
      }

      // repeated bytes from_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_from_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_from_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_from_name;
        if (input->ExpectTag(34)) goto parse_to_name;
        break;
      }

      // repeated bytes to_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_to_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_to_name;
        if (input->ExpectTag(42)) goto parse_item_info;
        break;
      }

      // repeated bytes item_info = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_item_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_item_info;
        if (input->ExpectTag(50)) goto parse_equip_info;
        break;
      }

      // repeated bytes equip_info = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_equip_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_equip_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_equip_info;
        if (input->ExpectTag(58)) goto parse_role_info;
        break;
      }

      // repeated bytes role_info = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_role_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_role_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_role_info;
        if (input->ExpectTag(66)) goto parse_merc_info;
        break;
      }

      // repeated bytes merc_info = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_merc_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_merc_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_merc_info;
        if (input->ExpectTag(72)) goto parse_sex;
        break;
      }

      // optional uint32 sex = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_vip_lv;
        break;
      }

      // optional uint32 vip_lv = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_vip_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vip_lv_)));
          set_has_vip_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_notice_type;
        break;
      }

      // optional uint32 notice_type = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_notice_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &notice_type_)));
          set_has_notice_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Chat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 chat_type = 1;
  if (has_chat_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chat_type(), output);
  }

  // repeated bytes chat_data = 2;
  for (int i = 0; i < this->chat_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->chat_data(i), output);
  }

  // repeated bytes from_name = 3;
  for (int i = 0; i < this->from_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->from_name(i), output);
  }

  // repeated bytes to_name = 4;
  for (int i = 0; i < this->to_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->to_name(i), output);
  }

  // repeated bytes item_info = 5;
  for (int i = 0; i < this->item_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->item_info(i), output);
  }

  // repeated bytes equip_info = 6;
  for (int i = 0; i < this->equip_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->equip_info(i), output);
  }

  // repeated bytes role_info = 7;
  for (int i = 0; i < this->role_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->role_info(i), output);
  }

  // repeated bytes merc_info = 8;
  for (int i = 0; i < this->merc_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->merc_info(i), output);
  }

  // optional uint32 sex = 9;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->sex(), output);
  }

  // optional uint32 vip_lv = 10;
  if (has_vip_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->vip_lv(), output);
  }

  // optional uint32 notice_type = 11;
  if (has_notice_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->notice_type(), output);
  }

  // optional uint32 server_id = 12;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->server_id(), output);
  }

}

int Chat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 chat_type = 1;
    if (has_chat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chat_type());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 sex = 9;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sex());
    }

    // optional uint32 vip_lv = 10;
    if (has_vip_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->vip_lv());
    }

    // optional uint32 notice_type = 11;
    if (has_notice_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->notice_type());
    }

    // optional uint32 server_id = 12;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

  }
  // repeated bytes chat_data = 2;
  total_size += 1 * this->chat_data_size();
  for (int i = 0; i < this->chat_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->chat_data(i));
  }

  // repeated bytes from_name = 3;
  total_size += 1 * this->from_name_size();
  for (int i = 0; i < this->from_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->from_name(i));
  }

  // repeated bytes to_name = 4;
  total_size += 1 * this->to_name_size();
  for (int i = 0; i < this->to_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->to_name(i));
  }

  // repeated bytes item_info = 5;
  total_size += 1 * this->item_info_size();
  for (int i = 0; i < this->item_info_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->item_info(i));
  }

  // repeated bytes equip_info = 6;
  total_size += 1 * this->equip_info_size();
  for (int i = 0; i < this->equip_info_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->equip_info(i));
  }

  // repeated bytes role_info = 7;
  total_size += 1 * this->role_info_size();
  for (int i = 0; i < this->role_info_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->role_info(i));
  }

  // repeated bytes merc_info = 8;
  total_size += 1 * this->merc_info_size();
  for (int i = 0; i < this->merc_info_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->merc_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Chat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Chat*>(&from));
}

void Chat::MergeFrom(const Chat& from) {
  GOOGLE_CHECK_NE(&from, this);
  chat_data_.MergeFrom(from.chat_data_);
  from_name_.MergeFrom(from.from_name_);
  to_name_.MergeFrom(from.to_name_);
  item_info_.MergeFrom(from.item_info_);
  equip_info_.MergeFrom(from.equip_info_);
  role_info_.MergeFrom(from.role_info_);
  merc_info_.MergeFrom(from.merc_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chat_type()) {
      set_chat_type(from.chat_type());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_vip_lv()) {
      set_vip_lv(from.vip_lv());
    }
    if (from.has_notice_type()) {
      set_notice_type(from.notice_type());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
  }
}

void Chat::CopyFrom(const Chat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chat::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Chat::Swap(Chat* other) {
  if (other != this) {
    std::swap(chat_type_, other->chat_type_);
    chat_data_.Swap(&other->chat_data_);
    from_name_.Swap(&other->from_name_);
    to_name_.Swap(&other->to_name_);
    item_info_.Swap(&other->item_info_);
    equip_info_.Swap(&other->equip_info_);
    role_info_.Swap(&other->role_info_);
    merc_info_.Swap(&other->merc_info_);
    std::swap(sex_, other->sex_);
    std::swap(vip_lv_, other->vip_lv_);
    std::swap(notice_type_, other->notice_type_);
    std::swap(server_id_, other->server_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Chat::GetTypeName() const {
  return "message.Chat";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeRemainVar::kRemainTypeFieldNumber;
const int ChangeRemainVar::kRemainValueFieldNumber;
#endif  // !_MSC_VER

ChangeRemainVar::ChangeRemainVar()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeRemainVar::InitAsDefaultInstance() {
}

ChangeRemainVar::ChangeRemainVar(const ChangeRemainVar& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeRemainVar::SharedCtor() {
  _cached_size_ = 0;
  remain_type_ = 0u;
  remain_value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeRemainVar::~ChangeRemainVar() {
  SharedDtor();
}

void ChangeRemainVar::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeRemainVar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeRemainVar& ChangeRemainVar::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ChangeRemainVar* ChangeRemainVar::default_instance_ = NULL;

ChangeRemainVar* ChangeRemainVar::New() const {
  return new ChangeRemainVar;
}

void ChangeRemainVar::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    remain_type_ = 0u;
    remain_value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeRemainVar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 remain_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remain_type_)));
          set_has_remain_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_remain_value;
        break;
      }

      // required uint32 remain_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remain_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remain_value_)));
          set_has_remain_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeRemainVar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 remain_type = 1;
  if (has_remain_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->remain_type(), output);
  }

  // required uint32 remain_value = 2;
  if (has_remain_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->remain_value(), output);
  }

}

int ChangeRemainVar::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 remain_type = 1;
    if (has_remain_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remain_type());
    }

    // required uint32 remain_value = 2;
    if (has_remain_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remain_value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeRemainVar::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeRemainVar*>(&from));
}

void ChangeRemainVar::MergeFrom(const ChangeRemainVar& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_remain_type()) {
      set_remain_type(from.remain_type());
    }
    if (from.has_remain_value()) {
      set_remain_value(from.remain_value());
    }
  }
}

void ChangeRemainVar::CopyFrom(const ChangeRemainVar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeRemainVar::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ChangeRemainVar::Swap(ChangeRemainVar* other) {
  if (other != this) {
    std::swap(remain_type_, other->remain_type_);
    std::swap(remain_value_, other->remain_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeRemainVar::GetTypeName() const {
  return "message.ChangeRemainVar";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeClientData::kClieDataFieldNumber;
#endif  // !_MSC_VER

ChangeClientData::ChangeClientData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeClientData::InitAsDefaultInstance() {
}

ChangeClientData::ChangeClientData(const ChangeClientData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeClientData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeClientData::~ChangeClientData() {
  SharedDtor();
}

void ChangeClientData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeClientData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeClientData& ChangeClientData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ChangeClientData* ChangeClientData::default_instance_ = NULL;

ChangeClientData* ChangeClientData::New() const {
  return new ChangeClientData;
}

void ChangeClientData::Clear() {
  clie_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeClientData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes clie_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clie_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_clie_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_clie_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeClientData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes clie_data = 1;
  for (int i = 0; i < this->clie_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->clie_data(i), output);
  }

}

int ChangeClientData::ByteSize() const {
  int total_size = 0;

  // repeated bytes clie_data = 1;
  total_size += 1 * this->clie_data_size();
  for (int i = 0; i < this->clie_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->clie_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeClientData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeClientData*>(&from));
}

void ChangeClientData::MergeFrom(const ChangeClientData& from) {
  GOOGLE_CHECK_NE(&from, this);
  clie_data_.MergeFrom(from.clie_data_);
}

void ChangeClientData::CopyFrom(const ChangeClientData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeClientData::IsInitialized() const {

  return true;
}

void ChangeClientData::Swap(ChangeClientData* other) {
  if (other != this) {
    clie_data_.Swap(&other->clie_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeClientData::GetTypeName() const {
  return "message.ChangeClientData";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqFriendData::kCharIdFieldNumber;
#endif  // !_MSC_VER

ReqFriendData::ReqFriendData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqFriendData::InitAsDefaultInstance() {
}

ReqFriendData::ReqFriendData(const ReqFriendData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqFriendData::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqFriendData::~ReqFriendData() {
  SharedDtor();
}

void ReqFriendData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqFriendData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqFriendData& ReqFriendData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqFriendData* ReqFriendData::default_instance_ = NULL;

ReqFriendData* ReqFriendData::New() const {
  return new ReqFriendData;
}

void ReqFriendData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqFriendData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqFriendData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

}

int ReqFriendData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqFriendData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqFriendData*>(&from));
}

void ReqFriendData::MergeFrom(const ReqFriendData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void ReqFriendData::CopyFrom(const ReqFriendData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqFriendData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqFriendData::Swap(ReqFriendData* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqFriendData::GetTypeName() const {
  return "message.ReqFriendData";
}


// ===================================================================

#ifndef _MSC_VER
const int AckFriendData_DBFriendInfo::kCharIdFieldNumber;
const int AckFriendData_DBFriendInfo::kTargetCharIdFieldNumber;
const int AckFriendData_DBFriendInfo::kTargetCharNameFieldNumber;
const int AckFriendData_DBFriendInfo::kFriendTypeFieldNumber;
const int AckFriendData_DBFriendInfo::kLoveFieldNumber;
const int AckFriendData_DBFriendInfo::kLastLoveDateFieldNumber;
const int AckFriendData_DBFriendInfo::kFightDataFieldNumber;
const int AckFriendData_DBFriendInfo::kMercenaryDataFieldNumber;
const int AckFriendData_DBFriendInfo::kOtherDataFieldNumber;
const int AckFriendData_DBFriendInfo::kJobFieldNumber;
const int AckFriendData_DBFriendInfo::kSexFieldNumber;
const int AckFriendData_DBFriendInfo::kLevelFieldNumber;
#endif  // !_MSC_VER

AckFriendData_DBFriendInfo::AckFriendData_DBFriendInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckFriendData_DBFriendInfo::InitAsDefaultInstance() {
}

AckFriendData_DBFriendInfo::AckFriendData_DBFriendInfo(const AckFriendData_DBFriendInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckFriendData_DBFriendInfo::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  target_char_id_ = 0u;
  target_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  friend_type_ = 0u;
  love_ = 0u;
  last_love_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fight_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mercenary_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  other_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  job_ = 0u;
  sex_ = 0u;
  level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckFriendData_DBFriendInfo::~AckFriendData_DBFriendInfo() {
  SharedDtor();
}

void AckFriendData_DBFriendInfo::SharedDtor() {
  if (target_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_char_name_;
  }
  if (last_love_date_ != &::google::protobuf::internal::kEmptyString) {
    delete last_love_date_;
  }
  if (fight_data_ != &::google::protobuf::internal::kEmptyString) {
    delete fight_data_;
  }
  if (mercenary_data_ != &::google::protobuf::internal::kEmptyString) {
    delete mercenary_data_;
  }
  if (other_data_ != &::google::protobuf::internal::kEmptyString) {
    delete other_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckFriendData_DBFriendInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckFriendData_DBFriendInfo& AckFriendData_DBFriendInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckFriendData_DBFriendInfo* AckFriendData_DBFriendInfo::default_instance_ = NULL;

AckFriendData_DBFriendInfo* AckFriendData_DBFriendInfo::New() const {
  return new AckFriendData_DBFriendInfo;
}

void AckFriendData_DBFriendInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
    target_char_id_ = 0u;
    if (has_target_char_name()) {
      if (target_char_name_ != &::google::protobuf::internal::kEmptyString) {
        target_char_name_->clear();
      }
    }
    friend_type_ = 0u;
    love_ = 0u;
    if (has_last_love_date()) {
      if (last_love_date_ != &::google::protobuf::internal::kEmptyString) {
        last_love_date_->clear();
      }
    }
    if (has_fight_data()) {
      if (fight_data_ != &::google::protobuf::internal::kEmptyString) {
        fight_data_->clear();
      }
    }
    if (has_mercenary_data()) {
      if (mercenary_data_ != &::google::protobuf::internal::kEmptyString) {
        mercenary_data_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_other_data()) {
      if (other_data_ != &::google::protobuf::internal::kEmptyString) {
        other_data_->clear();
      }
    }
    job_ = 0u;
    sex_ = 0u;
    level_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckFriendData_DBFriendInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_target_char_id;
        break;
      }

      // required uint32 target_char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_char_id_)));
          set_has_target_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_target_char_name;
        break;
      }

      // required bytes target_char_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_friend_type;
        break;
      }

      // required uint32 friend_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_type_)));
          set_has_friend_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_love;
        break;
      }

      // required uint32 love = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_love:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &love_)));
          set_has_love();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_last_love_date;
        break;
      }

      // required bytes last_love_date = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_last_love_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_last_love_date()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_fight_data;
        break;
      }

      // optional bytes fight_data = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fight_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fight_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_mercenary_data;
        break;
      }

      // optional bytes mercenary_data = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mercenary_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mercenary_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_other_data;
        break;
      }

      // optional bytes other_data = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_other_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_other_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_job;
        break;
      }

      // optional uint32 job = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_sex;
        break;
      }

      // optional uint32 sex = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_level;
        break;
      }

      // optional uint32 level = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckFriendData_DBFriendInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

  // required uint32 target_char_id = 2;
  if (has_target_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_char_id(), output);
  }

  // required bytes target_char_name = 3;
  if (has_target_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->target_char_name(), output);
  }

  // required uint32 friend_type = 4;
  if (has_friend_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->friend_type(), output);
  }

  // required uint32 love = 5;
  if (has_love()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->love(), output);
  }

  // required bytes last_love_date = 6;
  if (has_last_love_date()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->last_love_date(), output);
  }

  // optional bytes fight_data = 7;
  if (has_fight_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->fight_data(), output);
  }

  // optional bytes mercenary_data = 8;
  if (has_mercenary_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->mercenary_data(), output);
  }

  // optional bytes other_data = 9;
  if (has_other_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->other_data(), output);
  }

  // optional uint32 job = 10;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->job(), output);
  }

  // optional uint32 sex = 11;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->sex(), output);
  }

  // optional uint32 level = 12;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->level(), output);
  }

}

int AckFriendData_DBFriendInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // required uint32 target_char_id = 2;
    if (has_target_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_char_id());
    }

    // required bytes target_char_name = 3;
    if (has_target_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target_char_name());
    }

    // required uint32 friend_type = 4;
    if (has_friend_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_type());
    }

    // required uint32 love = 5;
    if (has_love()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->love());
    }

    // required bytes last_love_date = 6;
    if (has_last_love_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->last_love_date());
    }

    // optional bytes fight_data = 7;
    if (has_fight_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->fight_data());
    }

    // optional bytes mercenary_data = 8;
    if (has_mercenary_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mercenary_data());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes other_data = 9;
    if (has_other_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->other_data());
    }

    // optional uint32 job = 10;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->job());
    }

    // optional uint32 sex = 11;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sex());
    }

    // optional uint32 level = 12;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckFriendData_DBFriendInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckFriendData_DBFriendInfo*>(&from));
}

void AckFriendData_DBFriendInfo::MergeFrom(const AckFriendData_DBFriendInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_target_char_id()) {
      set_target_char_id(from.target_char_id());
    }
    if (from.has_target_char_name()) {
      set_target_char_name(from.target_char_name());
    }
    if (from.has_friend_type()) {
      set_friend_type(from.friend_type());
    }
    if (from.has_love()) {
      set_love(from.love());
    }
    if (from.has_last_love_date()) {
      set_last_love_date(from.last_love_date());
    }
    if (from.has_fight_data()) {
      set_fight_data(from.fight_data());
    }
    if (from.has_mercenary_data()) {
      set_mercenary_data(from.mercenary_data());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_other_data()) {
      set_other_data(from.other_data());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
  }
}

void AckFriendData_DBFriendInfo::CopyFrom(const AckFriendData_DBFriendInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckFriendData_DBFriendInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void AckFriendData_DBFriendInfo::Swap(AckFriendData_DBFriendInfo* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(target_char_id_, other->target_char_id_);
    std::swap(target_char_name_, other->target_char_name_);
    std::swap(friend_type_, other->friend_type_);
    std::swap(love_, other->love_);
    std::swap(last_love_date_, other->last_love_date_);
    std::swap(fight_data_, other->fight_data_);
    std::swap(mercenary_data_, other->mercenary_data_);
    std::swap(other_data_, other->other_data_);
    std::swap(job_, other->job_);
    std::swap(sex_, other->sex_);
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckFriendData_DBFriendInfo::GetTypeName() const {
  return "message.AckFriendData.DBFriendInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AckFriendData::kFriendInfoFieldNumber;
#endif  // !_MSC_VER

AckFriendData::AckFriendData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckFriendData::InitAsDefaultInstance() {
}

AckFriendData::AckFriendData(const AckFriendData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckFriendData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckFriendData::~AckFriendData() {
  SharedDtor();
}

void AckFriendData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckFriendData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckFriendData& AckFriendData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckFriendData* AckFriendData::default_instance_ = NULL;

AckFriendData* AckFriendData::New() const {
  return new AckFriendData;
}

void AckFriendData::Clear() {
  friend_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckFriendData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.AckFriendData.DBFriendInfo friend_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_friend_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_friend_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_friend_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckFriendData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.AckFriendData.DBFriendInfo friend_info = 1;
  for (int i = 0; i < this->friend_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->friend_info(i), output);
  }

}

int AckFriendData::ByteSize() const {
  int total_size = 0;

  // repeated .message.AckFriendData.DBFriendInfo friend_info = 1;
  total_size += 1 * this->friend_info_size();
  for (int i = 0; i < this->friend_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->friend_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckFriendData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckFriendData*>(&from));
}

void AckFriendData::MergeFrom(const AckFriendData& from) {
  GOOGLE_CHECK_NE(&from, this);
  friend_info_.MergeFrom(from.friend_info_);
}

void AckFriendData::CopyFrom(const AckFriendData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckFriendData::IsInitialized() const {

  for (int i = 0; i < friend_info_size(); i++) {
    if (!this->friend_info(i).IsInitialized()) return false;
  }
  return true;
}

void AckFriendData::Swap(AckFriendData* other) {
  if (other != this) {
    friend_info_.Swap(&other->friend_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckFriendData::GetTypeName() const {
  return "message.AckFriendData";
}


// ===================================================================

#ifndef _MSC_VER
const int FriendData_FriendInfo::kFriendIdFieldNumber;
const int FriendData_FriendInfo::kFriendNameFieldNumber;
const int FriendData_FriendInfo::kFriendTypeFieldNumber;
const int FriendData_FriendInfo::kFriendLvFieldNumber;
const int FriendData_FriendInfo::kFriendJobFieldNumber;
const int FriendData_FriendInfo::kFriendSexFieldNumber;
const int FriendData_FriendInfo::kFriendLoveFieldNumber;
const int FriendData_FriendInfo::kFriendOnlineFieldNumber;
#endif  // !_MSC_VER

FriendData_FriendInfo::FriendData_FriendInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FriendData_FriendInfo::InitAsDefaultInstance() {
}

FriendData_FriendInfo::FriendData_FriendInfo(const FriendData_FriendInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FriendData_FriendInfo::SharedCtor() {
  _cached_size_ = 0;
  friend_id_ = 0u;
  friend_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  friend_type_ = 0u;
  friend_lv_ = 0u;
  friend_job_ = 0u;
  friend_sex_ = 0u;
  friend_love_ = 0u;
  friend_online_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendData_FriendInfo::~FriendData_FriendInfo() {
  SharedDtor();
}

void FriendData_FriendInfo::SharedDtor() {
  if (friend_name_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FriendData_FriendInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FriendData_FriendInfo& FriendData_FriendInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

FriendData_FriendInfo* FriendData_FriendInfo::default_instance_ = NULL;

FriendData_FriendInfo* FriendData_FriendInfo::New() const {
  return new FriendData_FriendInfo;
}

void FriendData_FriendInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    friend_id_ = 0u;
    if (has_friend_name()) {
      if (friend_name_ != &::google::protobuf::internal::kEmptyString) {
        friend_name_->clear();
      }
    }
    friend_type_ = 0u;
    friend_lv_ = 0u;
    friend_job_ = 0u;
    friend_sex_ = 0u;
    friend_love_ = 0u;
    friend_online_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FriendData_FriendInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 friend_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_id_)));
          set_has_friend_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_friend_name;
        break;
      }

      // optional bytes friend_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_friend_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_friend_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_friend_type;
        break;
      }

      // optional uint32 friend_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_type_)));
          set_has_friend_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_friend_lv;
        break;
      }

      // optional uint32 friend_lv = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_lv_)));
          set_has_friend_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_friend_job;
        break;
      }

      // optional uint32 friend_job = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_job_)));
          set_has_friend_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_friend_sex;
        break;
      }

      // optional uint32 friend_sex = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_sex_)));
          set_has_friend_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_friend_love;
        break;
      }

      // optional uint32 friend_love = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_love:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_love_)));
          set_has_friend_love();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_friend_online;
        break;
      }

      // optional uint32 friend_online = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_online:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_online_)));
          set_has_friend_online();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FriendData_FriendInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 friend_id = 1;
  if (has_friend_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->friend_id(), output);
  }

  // optional bytes friend_name = 2;
  if (has_friend_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->friend_name(), output);
  }

  // optional uint32 friend_type = 3;
  if (has_friend_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->friend_type(), output);
  }

  // optional uint32 friend_lv = 4;
  if (has_friend_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->friend_lv(), output);
  }

  // optional uint32 friend_job = 5;
  if (has_friend_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->friend_job(), output);
  }

  // optional uint32 friend_sex = 6;
  if (has_friend_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->friend_sex(), output);
  }

  // optional uint32 friend_love = 7;
  if (has_friend_love()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->friend_love(), output);
  }

  // optional uint32 friend_online = 8;
  if (has_friend_online()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->friend_online(), output);
  }

}

int FriendData_FriendInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 friend_id = 1;
    if (has_friend_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_id());
    }

    // optional bytes friend_name = 2;
    if (has_friend_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->friend_name());
    }

    // optional uint32 friend_type = 3;
    if (has_friend_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_type());
    }

    // optional uint32 friend_lv = 4;
    if (has_friend_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_lv());
    }

    // optional uint32 friend_job = 5;
    if (has_friend_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_job());
    }

    // optional uint32 friend_sex = 6;
    if (has_friend_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_sex());
    }

    // optional uint32 friend_love = 7;
    if (has_friend_love()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_love());
    }

    // optional uint32 friend_online = 8;
    if (has_friend_online()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_online());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendData_FriendInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FriendData_FriendInfo*>(&from));
}

void FriendData_FriendInfo::MergeFrom(const FriendData_FriendInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_friend_id()) {
      set_friend_id(from.friend_id());
    }
    if (from.has_friend_name()) {
      set_friend_name(from.friend_name());
    }
    if (from.has_friend_type()) {
      set_friend_type(from.friend_type());
    }
    if (from.has_friend_lv()) {
      set_friend_lv(from.friend_lv());
    }
    if (from.has_friend_job()) {
      set_friend_job(from.friend_job());
    }
    if (from.has_friend_sex()) {
      set_friend_sex(from.friend_sex());
    }
    if (from.has_friend_love()) {
      set_friend_love(from.friend_love());
    }
    if (from.has_friend_online()) {
      set_friend_online(from.friend_online());
    }
  }
}

void FriendData_FriendInfo::CopyFrom(const FriendData_FriendInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendData_FriendInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FriendData_FriendInfo::Swap(FriendData_FriendInfo* other) {
  if (other != this) {
    std::swap(friend_id_, other->friend_id_);
    std::swap(friend_name_, other->friend_name_);
    std::swap(friend_type_, other->friend_type_);
    std::swap(friend_lv_, other->friend_lv_);
    std::swap(friend_job_, other->friend_job_);
    std::swap(friend_sex_, other->friend_sex_);
    std::swap(friend_love_, other->friend_love_);
    std::swap(friend_online_, other->friend_online_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FriendData_FriendInfo::GetTypeName() const {
  return "message.FriendData.FriendInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int FriendData::kFriendInfoFieldNumber;
const int FriendData::kFriendOperationFieldNumber;
#endif  // !_MSC_VER

FriendData::FriendData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FriendData::InitAsDefaultInstance() {
}

FriendData::FriendData(const FriendData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FriendData::SharedCtor() {
  _cached_size_ = 0;
  friend_operation_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendData::~FriendData() {
  SharedDtor();
}

void FriendData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FriendData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FriendData& FriendData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

FriendData* FriendData::default_instance_ = NULL;

FriendData* FriendData::New() const {
  return new FriendData;
}

void FriendData::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    friend_operation_ = 0u;
  }
  friend_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FriendData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.FriendData.FriendInfo friend_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_friend_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_friend_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_friend_info;
        if (input->ExpectTag(16)) goto parse_friend_operation;
        break;
      }

      // optional uint32 friend_operation = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_operation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_operation_)));
          set_has_friend_operation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FriendData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.FriendData.FriendInfo friend_info = 1;
  for (int i = 0; i < this->friend_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->friend_info(i), output);
  }

  // optional uint32 friend_operation = 2;
  if (has_friend_operation()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->friend_operation(), output);
  }

}

int FriendData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 friend_operation = 2;
    if (has_friend_operation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_operation());
    }

  }
  // repeated .message.FriendData.FriendInfo friend_info = 1;
  total_size += 1 * this->friend_info_size();
  for (int i = 0; i < this->friend_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->friend_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FriendData*>(&from));
}

void FriendData::MergeFrom(const FriendData& from) {
  GOOGLE_CHECK_NE(&from, this);
  friend_info_.MergeFrom(from.friend_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_friend_operation()) {
      set_friend_operation(from.friend_operation());
    }
  }
}

void FriendData::CopyFrom(const FriendData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendData::IsInitialized() const {

  for (int i = 0; i < friend_info_size(); i++) {
    if (!this->friend_info(i).IsInitialized()) return false;
  }
  return true;
}

void FriendData::Swap(FriendData* other) {
  if (other != this) {
    friend_info_.Swap(&other->friend_info_);
    std::swap(friend_operation_, other->friend_operation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FriendData::GetTypeName() const {
  return "message.FriendData";
}


// ===================================================================

#ifndef _MSC_VER
const int SocietyOperationData_SocietyOperationInfo::kTimeFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kSourceIdFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kSourceNameFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kTargetIdFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kTargetNameFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kOperationTypeFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kOperationResultFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kOperationValueFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kJobFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kSexFieldNumber;
const int SocietyOperationData_SocietyOperationInfo::kLevelFieldNumber;
#endif  // !_MSC_VER

SocietyOperationData_SocietyOperationInfo::SocietyOperationData_SocietyOperationInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SocietyOperationData_SocietyOperationInfo::InitAsDefaultInstance() {
}

SocietyOperationData_SocietyOperationInfo::SocietyOperationData_SocietyOperationInfo(const SocietyOperationData_SocietyOperationInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SocietyOperationData_SocietyOperationInfo::SharedCtor() {
  _cached_size_ = 0;
  time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  source_id_ = 0u;
  source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_id_ = 0u;
  target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  operation_type_ = 0u;
  operation_result_ = 0u;
  job_ = 0u;
  sex_ = 0u;
  level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SocietyOperationData_SocietyOperationInfo::~SocietyOperationData_SocietyOperationInfo() {
  SharedDtor();
}

void SocietyOperationData_SocietyOperationInfo::SharedDtor() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (source_name_ != &::google::protobuf::internal::kEmptyString) {
    delete source_name_;
  }
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SocietyOperationData_SocietyOperationInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SocietyOperationData_SocietyOperationInfo& SocietyOperationData_SocietyOperationInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SocietyOperationData_SocietyOperationInfo* SocietyOperationData_SocietyOperationInfo::default_instance_ = NULL;

SocietyOperationData_SocietyOperationInfo* SocietyOperationData_SocietyOperationInfo::New() const {
  return new SocietyOperationData_SocietyOperationInfo;
}

void SocietyOperationData_SocietyOperationInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_time()) {
      if (time_ != &::google::protobuf::internal::kEmptyString) {
        time_->clear();
      }
    }
    source_id_ = 0u;
    if (has_source_name()) {
      if (source_name_ != &::google::protobuf::internal::kEmptyString) {
        source_name_->clear();
      }
    }
    target_id_ = 0u;
    if (has_target_name()) {
      if (target_name_ != &::google::protobuf::internal::kEmptyString) {
        target_name_->clear();
      }
    }
    operation_type_ = 0u;
    operation_result_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    job_ = 0u;
    sex_ = 0u;
    level_ = 0u;
  }
  operation_value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SocietyOperationData_SocietyOperationInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_source_id;
        break;
      }

      // optional uint32 source_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_source_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_id_)));
          set_has_source_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_source_name;
        break;
      }

      // optional bytes source_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_source_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_source_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_target_id;
        break;
      }

      // optional uint32 target_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_id_)));
          set_has_target_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_target_name;
        break;
      }

      // optional bytes target_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_operation_type;
        break;
      }

      // optional uint32 operation_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_operation_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &operation_type_)));
          set_has_operation_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_operation_result;
        break;
      }

      // optional uint32 operation_result = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_operation_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &operation_result_)));
          set_has_operation_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_operation_value;
        break;
      }

      // repeated uint32 operation_value = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_operation_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_operation_value())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_operation_value())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_operation_value;
        if (input->ExpectTag(72)) goto parse_job;
        break;
      }

      // optional uint32 job = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_sex;
        break;
      }

      // optional uint32 sex = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_level;
        break;
      }

      // optional uint32 level = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SocietyOperationData_SocietyOperationInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->time(), output);
  }

  // optional uint32 source_id = 2;
  if (has_source_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->source_id(), output);
  }

  // optional bytes source_name = 3;
  if (has_source_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->source_name(), output);
  }

  // optional uint32 target_id = 4;
  if (has_target_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->target_id(), output);
  }

  // optional bytes target_name = 5;
  if (has_target_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->target_name(), output);
  }

  // optional uint32 operation_type = 6;
  if (has_operation_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->operation_type(), output);
  }

  // optional uint32 operation_result = 7;
  if (has_operation_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->operation_result(), output);
  }

  // repeated uint32 operation_value = 8;
  for (int i = 0; i < this->operation_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->operation_value(i), output);
  }

  // optional uint32 job = 9;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->job(), output);
  }

  // optional uint32 sex = 10;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->sex(), output);
  }

  // optional uint32 level = 11;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->level(), output);
  }

}

int SocietyOperationData_SocietyOperationInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes time = 1;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->time());
    }

    // optional uint32 source_id = 2;
    if (has_source_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->source_id());
    }

    // optional bytes source_name = 3;
    if (has_source_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->source_name());
    }

    // optional uint32 target_id = 4;
    if (has_target_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_id());
    }

    // optional bytes target_name = 5;
    if (has_target_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target_name());
    }

    // optional uint32 operation_type = 6;
    if (has_operation_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->operation_type());
    }

    // optional uint32 operation_result = 7;
    if (has_operation_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->operation_result());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 job = 9;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->job());
    }

    // optional uint32 sex = 10;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sex());
    }

    // optional uint32 level = 11;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

  }
  // repeated uint32 operation_value = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->operation_value_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->operation_value(i));
    }
    total_size += 1 * this->operation_value_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SocietyOperationData_SocietyOperationInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SocietyOperationData_SocietyOperationInfo*>(&from));
}

void SocietyOperationData_SocietyOperationInfo::MergeFrom(const SocietyOperationData_SocietyOperationInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  operation_value_.MergeFrom(from.operation_value_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_source_id()) {
      set_source_id(from.source_id());
    }
    if (from.has_source_name()) {
      set_source_name(from.source_name());
    }
    if (from.has_target_id()) {
      set_target_id(from.target_id());
    }
    if (from.has_target_name()) {
      set_target_name(from.target_name());
    }
    if (from.has_operation_type()) {
      set_operation_type(from.operation_type());
    }
    if (from.has_operation_result()) {
      set_operation_result(from.operation_result());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_job()) {
      set_job(from.job());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
  }
}

void SocietyOperationData_SocietyOperationInfo::CopyFrom(const SocietyOperationData_SocietyOperationInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SocietyOperationData_SocietyOperationInfo::IsInitialized() const {

  return true;
}

void SocietyOperationData_SocietyOperationInfo::Swap(SocietyOperationData_SocietyOperationInfo* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(source_id_, other->source_id_);
    std::swap(source_name_, other->source_name_);
    std::swap(target_id_, other->target_id_);
    std::swap(target_name_, other->target_name_);
    std::swap(operation_type_, other->operation_type_);
    std::swap(operation_result_, other->operation_result_);
    operation_value_.Swap(&other->operation_value_);
    std::swap(job_, other->job_);
    std::swap(sex_, other->sex_);
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SocietyOperationData_SocietyOperationInfo::GetTypeName() const {
  return "message.SocietyOperationData.SocietyOperationInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SocietyOperationData::kSocietyInfoFieldNumber;
#endif  // !_MSC_VER

SocietyOperationData::SocietyOperationData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SocietyOperationData::InitAsDefaultInstance() {
}

SocietyOperationData::SocietyOperationData(const SocietyOperationData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SocietyOperationData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SocietyOperationData::~SocietyOperationData() {
  SharedDtor();
}

void SocietyOperationData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SocietyOperationData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SocietyOperationData& SocietyOperationData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SocietyOperationData* SocietyOperationData::default_instance_ = NULL;

SocietyOperationData* SocietyOperationData::New() const {
  return new SocietyOperationData;
}

void SocietyOperationData::Clear() {
  society_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SocietyOperationData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.SocietyOperationData.SocietyOperationInfo society_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_society_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_society_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_society_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SocietyOperationData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.SocietyOperationData.SocietyOperationInfo society_info = 1;
  for (int i = 0; i < this->society_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->society_info(i), output);
  }

}

int SocietyOperationData::ByteSize() const {
  int total_size = 0;

  // repeated .message.SocietyOperationData.SocietyOperationInfo society_info = 1;
  total_size += 1 * this->society_info_size();
  for (int i = 0; i < this->society_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->society_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SocietyOperationData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SocietyOperationData*>(&from));
}

void SocietyOperationData::MergeFrom(const SocietyOperationData& from) {
  GOOGLE_CHECK_NE(&from, this);
  society_info_.MergeFrom(from.society_info_);
}

void SocietyOperationData::CopyFrom(const SocietyOperationData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SocietyOperationData::IsInitialized() const {

  return true;
}

void SocietyOperationData::Swap(SocietyOperationData* other) {
  if (other != this) {
    society_info_.Swap(&other->society_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SocietyOperationData::GetTypeName() const {
  return "message.SocietyOperationData";
}


// ===================================================================

#ifndef _MSC_VER
const int GetPvPData::kPvpTypeFieldNumber;
const int GetPvPData::kIsLadderFieldNumber;
#endif  // !_MSC_VER

GetPvPData::GetPvPData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetPvPData::InitAsDefaultInstance() {
}

GetPvPData::GetPvPData(const GetPvPData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetPvPData::SharedCtor() {
  _cached_size_ = 0;
  pvp_type_ = 0u;
  is_ladder_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetPvPData::~GetPvPData() {
  SharedDtor();
}

void GetPvPData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetPvPData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetPvPData& GetPvPData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetPvPData* GetPvPData::default_instance_ = NULL;

GetPvPData* GetPvPData::New() const {
  return new GetPvPData;
}

void GetPvPData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pvp_type_ = 0u;
    is_ladder_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetPvPData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pvp_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pvp_type_)));
          set_has_pvp_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_ladder;
        break;
      }

      // optional uint32 is_ladder = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_ladder:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_ladder_)));
          set_has_is_ladder();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetPvPData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 pvp_type = 1;
  if (has_pvp_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pvp_type(), output);
  }

  // optional uint32 is_ladder = 2;
  if (has_is_ladder()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->is_ladder(), output);
  }

}

int GetPvPData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pvp_type = 1;
    if (has_pvp_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pvp_type());
    }

    // optional uint32 is_ladder = 2;
    if (has_is_ladder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_ladder());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPvPData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetPvPData*>(&from));
}

void GetPvPData::MergeFrom(const GetPvPData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pvp_type()) {
      set_pvp_type(from.pvp_type());
    }
    if (from.has_is_ladder()) {
      set_is_ladder(from.is_ladder());
    }
  }
}

void GetPvPData::CopyFrom(const GetPvPData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPvPData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetPvPData::Swap(GetPvPData* other) {
  if (other != this) {
    std::swap(pvp_type_, other->pvp_type_);
    std::swap(is_ladder_, other->is_ladder_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetPvPData::GetTypeName() const {
  return "message.GetPvPData";
}


// ===================================================================

#ifndef _MSC_VER
const int PvpOpeResult::kOpeTypeFieldNumber;
const int PvpOpeResult::kOpeResultFieldNumber;
const int PvpOpeResult::kRemainTimeFieldNumber;
const int PvpOpeResult::kLeftTimesFieldNumber;
#endif  // !_MSC_VER

PvpOpeResult::PvpOpeResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PvpOpeResult::InitAsDefaultInstance() {
}

PvpOpeResult::PvpOpeResult(const PvpOpeResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PvpOpeResult::SharedCtor() {
  _cached_size_ = 0;
  ope_type_ = 0u;
  ope_result_ = 0u;
  remain_time_ = 0u;
  left_times_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PvpOpeResult::~PvpOpeResult() {
  SharedDtor();
}

void PvpOpeResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PvpOpeResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PvpOpeResult& PvpOpeResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PvpOpeResult* PvpOpeResult::default_instance_ = NULL;

PvpOpeResult* PvpOpeResult::New() const {
  return new PvpOpeResult;
}

void PvpOpeResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ope_type_ = 0u;
    ope_result_ = 0u;
    remain_time_ = 0u;
    left_times_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PvpOpeResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ope_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ope_type_)));
          set_has_ope_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ope_result;
        break;
      }

      // optional uint32 ope_result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ope_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ope_result_)));
          set_has_ope_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_remain_time;
        break;
      }

      // optional uint32 remain_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remain_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remain_time_)));
          set_has_remain_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_left_times;
        break;
      }

      // optional uint32 left_times = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_left_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &left_times_)));
          set_has_left_times();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PvpOpeResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 ope_type = 1;
  if (has_ope_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ope_type(), output);
  }

  // optional uint32 ope_result = 2;
  if (has_ope_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ope_result(), output);
  }

  // optional uint32 remain_time = 3;
  if (has_remain_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->remain_time(), output);
  }

  // optional uint32 left_times = 4;
  if (has_left_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->left_times(), output);
  }

}

int PvpOpeResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ope_type = 1;
    if (has_ope_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ope_type());
    }

    // optional uint32 ope_result = 2;
    if (has_ope_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ope_result());
    }

    // optional uint32 remain_time = 3;
    if (has_remain_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remain_time());
    }

    // optional uint32 left_times = 4;
    if (has_left_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->left_times());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PvpOpeResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PvpOpeResult*>(&from));
}

void PvpOpeResult::MergeFrom(const PvpOpeResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ope_type()) {
      set_ope_type(from.ope_type());
    }
    if (from.has_ope_result()) {
      set_ope_result(from.ope_result());
    }
    if (from.has_remain_time()) {
      set_remain_time(from.remain_time());
    }
    if (from.has_left_times()) {
      set_left_times(from.left_times());
    }
  }
}

void PvpOpeResult::CopyFrom(const PvpOpeResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PvpOpeResult::IsInitialized() const {

  return true;
}

void PvpOpeResult::Swap(PvpOpeResult* other) {
  if (other != this) {
    std::swap(ope_type_, other->ope_type_);
    std::swap(ope_result_, other->ope_result_);
    std::swap(remain_time_, other->remain_time_);
    std::swap(left_times_, other->left_times_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PvpOpeResult::GetTypeName() const {
  return "message.PvpOpeResult";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqPVPData::kTargetIdFieldNumber;
#endif  // !_MSC_VER

ReqPVPData::ReqPVPData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqPVPData::InitAsDefaultInstance() {
}

ReqPVPData::ReqPVPData(const ReqPVPData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqPVPData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqPVPData::~ReqPVPData() {
  SharedDtor();
}

void ReqPVPData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqPVPData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqPVPData& ReqPVPData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqPVPData* ReqPVPData::default_instance_ = NULL;

ReqPVPData* ReqPVPData::New() const {
  return new ReqPVPData;
}

void ReqPVPData::Clear() {
  target_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqPVPData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 target_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_target_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_target_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_target_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqPVPData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 target_id = 1;
  for (int i = 0; i < this->target_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->target_id(i), output);
  }

}

int ReqPVPData::ByteSize() const {
  int total_size = 0;

  // repeated uint32 target_id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->target_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->target_id(i));
    }
    total_size += 1 * this->target_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqPVPData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqPVPData*>(&from));
}

void ReqPVPData::MergeFrom(const ReqPVPData& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_id_.MergeFrom(from.target_id_);
}

void ReqPVPData::CopyFrom(const ReqPVPData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqPVPData::IsInitialized() const {

  return true;
}

void ReqPVPData::Swap(ReqPVPData* other) {
  if (other != this) {
    target_id_.Swap(&other->target_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqPVPData::GetTypeName() const {
  return "message.ReqPVPData";
}


// ===================================================================

#ifndef _MSC_VER
const int AckPVPData_DBPVPInfo::kTargetCharIdFieldNumber;
const int AckPVPData_DBPVPInfo::kTargetJobFieldNumber;
const int AckPVPData_DBPVPInfo::kTargetSexFieldNumber;
const int AckPVPData_DBPVPInfo::kTargetCharNameFieldNumber;
const int AckPVPData_DBPVPInfo::kTargetLvFieldNumber;
const int AckPVPData_DBPVPInfo::kSuccessNumFieldNumber;
const int AckPVPData_DBPVPInfo::kTargetRankFieldNumber;
const int AckPVPData_DBPVPInfo::kFightScoreFieldNumber;
const int AckPVPData_DBPVPInfo::kMercBagFieldNumber;
const int AckPVPData_DBPVPInfo::kEquipPosFieldNumber;
#endif  // !_MSC_VER

AckPVPData_DBPVPInfo::AckPVPData_DBPVPInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckPVPData_DBPVPInfo::InitAsDefaultInstance() {
}

AckPVPData_DBPVPInfo::AckPVPData_DBPVPInfo(const AckPVPData_DBPVPInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckPVPData_DBPVPInfo::SharedCtor() {
  _cached_size_ = 0;
  target_char_id_ = 0u;
  target_job_ = 0u;
  target_sex_ = 0u;
  target_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_lv_ = 0u;
  success_num_ = 0u;
  target_rank_ = 0u;
  fight_score_ = 0u;
  merc_bag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  equip_pos_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckPVPData_DBPVPInfo::~AckPVPData_DBPVPInfo() {
  SharedDtor();
}

void AckPVPData_DBPVPInfo::SharedDtor() {
  if (target_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_char_name_;
  }
  if (merc_bag_ != &::google::protobuf::internal::kEmptyString) {
    delete merc_bag_;
  }
  if (equip_pos_ != &::google::protobuf::internal::kEmptyString) {
    delete equip_pos_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckPVPData_DBPVPInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckPVPData_DBPVPInfo& AckPVPData_DBPVPInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckPVPData_DBPVPInfo* AckPVPData_DBPVPInfo::default_instance_ = NULL;

AckPVPData_DBPVPInfo* AckPVPData_DBPVPInfo::New() const {
  return new AckPVPData_DBPVPInfo;
}

void AckPVPData_DBPVPInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    target_char_id_ = 0u;
    target_job_ = 0u;
    target_sex_ = 0u;
    if (has_target_char_name()) {
      if (target_char_name_ != &::google::protobuf::internal::kEmptyString) {
        target_char_name_->clear();
      }
    }
    target_lv_ = 0u;
    success_num_ = 0u;
    target_rank_ = 0u;
    fight_score_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_merc_bag()) {
      if (merc_bag_ != &::google::protobuf::internal::kEmptyString) {
        merc_bag_->clear();
      }
    }
    if (has_equip_pos()) {
      if (equip_pos_ != &::google::protobuf::internal::kEmptyString) {
        equip_pos_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckPVPData_DBPVPInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 target_char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_char_id_)));
          set_has_target_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_target_job;
        break;
      }

      // optional uint32 target_job = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_job_)));
          set_has_target_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_sex;
        break;
      }

      // optional uint32 target_sex = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_sex_)));
          set_has_target_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_target_char_name;
        break;
      }

      // optional bytes target_char_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_target_lv;
        break;
      }

      // optional uint32 target_lv = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_lv_)));
          set_has_target_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_success_num;
        break;
      }

      // optional uint32 success_num = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_success_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &success_num_)));
          set_has_success_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_target_rank;
        break;
      }

      // optional uint32 target_rank = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_rank_)));
          set_has_target_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_fight_score;
        break;
      }

      // optional uint32 fight_score = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fight_score_)));
          set_has_fight_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_merc_bag;
        break;
      }

      // optional bytes merc_bag = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_merc_bag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_merc_bag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_equip_pos;
        break;
      }

      // optional bytes equip_pos = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_equip_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_equip_pos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckPVPData_DBPVPInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 target_char_id = 1;
  if (has_target_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->target_char_id(), output);
  }

  // optional uint32 target_job = 2;
  if (has_target_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_job(), output);
  }

  // optional uint32 target_sex = 3;
  if (has_target_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->target_sex(), output);
  }

  // optional bytes target_char_name = 4;
  if (has_target_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->target_char_name(), output);
  }

  // optional uint32 target_lv = 5;
  if (has_target_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->target_lv(), output);
  }

  // optional uint32 success_num = 6;
  if (has_success_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->success_num(), output);
  }

  // optional uint32 target_rank = 7;
  if (has_target_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->target_rank(), output);
  }

  // optional uint32 fight_score = 8;
  if (has_fight_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->fight_score(), output);
  }

  // optional bytes merc_bag = 9;
  if (has_merc_bag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->merc_bag(), output);
  }

  // optional bytes equip_pos = 10;
  if (has_equip_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->equip_pos(), output);
  }

}

int AckPVPData_DBPVPInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 target_char_id = 1;
    if (has_target_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_char_id());
    }

    // optional uint32 target_job = 2;
    if (has_target_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_job());
    }

    // optional uint32 target_sex = 3;
    if (has_target_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_sex());
    }

    // optional bytes target_char_name = 4;
    if (has_target_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target_char_name());
    }

    // optional uint32 target_lv = 5;
    if (has_target_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_lv());
    }

    // optional uint32 success_num = 6;
    if (has_success_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->success_num());
    }

    // optional uint32 target_rank = 7;
    if (has_target_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_rank());
    }

    // optional uint32 fight_score = 8;
    if (has_fight_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fight_score());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes merc_bag = 9;
    if (has_merc_bag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->merc_bag());
    }

    // optional bytes equip_pos = 10;
    if (has_equip_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->equip_pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckPVPData_DBPVPInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckPVPData_DBPVPInfo*>(&from));
}

void AckPVPData_DBPVPInfo::MergeFrom(const AckPVPData_DBPVPInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_char_id()) {
      set_target_char_id(from.target_char_id());
    }
    if (from.has_target_job()) {
      set_target_job(from.target_job());
    }
    if (from.has_target_sex()) {
      set_target_sex(from.target_sex());
    }
    if (from.has_target_char_name()) {
      set_target_char_name(from.target_char_name());
    }
    if (from.has_target_lv()) {
      set_target_lv(from.target_lv());
    }
    if (from.has_success_num()) {
      set_success_num(from.success_num());
    }
    if (from.has_target_rank()) {
      set_target_rank(from.target_rank());
    }
    if (from.has_fight_score()) {
      set_fight_score(from.fight_score());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_merc_bag()) {
      set_merc_bag(from.merc_bag());
    }
    if (from.has_equip_pos()) {
      set_equip_pos(from.equip_pos());
    }
  }
}

void AckPVPData_DBPVPInfo::CopyFrom(const AckPVPData_DBPVPInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckPVPData_DBPVPInfo::IsInitialized() const {

  return true;
}

void AckPVPData_DBPVPInfo::Swap(AckPVPData_DBPVPInfo* other) {
  if (other != this) {
    std::swap(target_char_id_, other->target_char_id_);
    std::swap(target_job_, other->target_job_);
    std::swap(target_sex_, other->target_sex_);
    std::swap(target_char_name_, other->target_char_name_);
    std::swap(target_lv_, other->target_lv_);
    std::swap(success_num_, other->success_num_);
    std::swap(target_rank_, other->target_rank_);
    std::swap(fight_score_, other->fight_score_);
    std::swap(merc_bag_, other->merc_bag_);
    std::swap(equip_pos_, other->equip_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckPVPData_DBPVPInfo::GetTypeName() const {
  return "message.AckPVPData.DBPVPInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AckPVPData::kPvpInfoFieldNumber;
const int AckPVPData::kMyLadderFieldNumber;
#endif  // !_MSC_VER

AckPVPData::AckPVPData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckPVPData::InitAsDefaultInstance() {
}

AckPVPData::AckPVPData(const AckPVPData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckPVPData::SharedCtor() {
  _cached_size_ = 0;
  my_ladder_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckPVPData::~AckPVPData() {
  SharedDtor();
}

void AckPVPData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckPVPData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckPVPData& AckPVPData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckPVPData* AckPVPData::default_instance_ = NULL;

AckPVPData* AckPVPData::New() const {
  return new AckPVPData;
}

void AckPVPData::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    my_ladder_ = 0u;
  }
  pvp_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckPVPData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.AckPVPData.DBPVPInfo pvp_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pvp_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pvp_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_pvp_info;
        if (input->ExpectTag(16)) goto parse_my_ladder;
        break;
      }

      // optional uint32 my_ladder = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_my_ladder:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &my_ladder_)));
          set_has_my_ladder();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckPVPData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.AckPVPData.DBPVPInfo pvp_info = 1;
  for (int i = 0; i < this->pvp_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->pvp_info(i), output);
  }

  // optional uint32 my_ladder = 2;
  if (has_my_ladder()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->my_ladder(), output);
  }

}

int AckPVPData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 my_ladder = 2;
    if (has_my_ladder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->my_ladder());
    }

  }
  // repeated .message.AckPVPData.DBPVPInfo pvp_info = 1;
  total_size += 1 * this->pvp_info_size();
  for (int i = 0; i < this->pvp_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pvp_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckPVPData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckPVPData*>(&from));
}

void AckPVPData::MergeFrom(const AckPVPData& from) {
  GOOGLE_CHECK_NE(&from, this);
  pvp_info_.MergeFrom(from.pvp_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_my_ladder()) {
      set_my_ladder(from.my_ladder());
    }
  }
}

void AckPVPData::CopyFrom(const AckPVPData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckPVPData::IsInitialized() const {

  return true;
}

void AckPVPData::Swap(AckPVPData* other) {
  if (other != this) {
    pvp_info_.Swap(&other->pvp_info_);
    std::swap(my_ladder_, other->my_ladder_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckPVPData::GetTypeName() const {
  return "message.AckPVPData";
}


// ===================================================================

#ifndef _MSC_VER
const int PVPData_MercInfo::kMercIdFieldNumber;
const int PVPData_MercInfo::kMercLvFieldNumber;
const int PVPData_MercInfo::kMercColorFieldNumber;
const int PVPData_MercInfo::kMercStarFieldNumber;
#endif  // !_MSC_VER

PVPData_MercInfo::PVPData_MercInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PVPData_MercInfo::InitAsDefaultInstance() {
}

PVPData_MercInfo::PVPData_MercInfo(const PVPData_MercInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PVPData_MercInfo::SharedCtor() {
  _cached_size_ = 0;
  merc_id_ = 0u;
  merc_lv_ = 0u;
  merc_color_ = 0u;
  merc_star_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PVPData_MercInfo::~PVPData_MercInfo() {
  SharedDtor();
}

void PVPData_MercInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PVPData_MercInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PVPData_MercInfo& PVPData_MercInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PVPData_MercInfo* PVPData_MercInfo::default_instance_ = NULL;

PVPData_MercInfo* PVPData_MercInfo::New() const {
  return new PVPData_MercInfo;
}

void PVPData_MercInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_id_ = 0u;
    merc_lv_ = 0u;
    merc_color_ = 0u;
    merc_star_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PVPData_MercInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_id_)));
          set_has_merc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_merc_lv;
        break;
      }

      // required uint32 merc_lv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_lv_)));
          set_has_merc_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_merc_color;
        break;
      }

      // required uint32 merc_color = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_color_)));
          set_has_merc_color();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_merc_star;
        break;
      }

      // required uint32 merc_star = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_star_)));
          set_has_merc_star();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PVPData_MercInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_id = 1;
  if (has_merc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_id(), output);
  }

  // required uint32 merc_lv = 2;
  if (has_merc_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->merc_lv(), output);
  }

  // required uint32 merc_color = 3;
  if (has_merc_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->merc_color(), output);
  }

  // required uint32 merc_star = 4;
  if (has_merc_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->merc_star(), output);
  }

}

int PVPData_MercInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_id = 1;
    if (has_merc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_id());
    }

    // required uint32 merc_lv = 2;
    if (has_merc_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_lv());
    }

    // required uint32 merc_color = 3;
    if (has_merc_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_color());
    }

    // required uint32 merc_star = 4;
    if (has_merc_star()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_star());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PVPData_MercInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PVPData_MercInfo*>(&from));
}

void PVPData_MercInfo::MergeFrom(const PVPData_MercInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_id()) {
      set_merc_id(from.merc_id());
    }
    if (from.has_merc_lv()) {
      set_merc_lv(from.merc_lv());
    }
    if (from.has_merc_color()) {
      set_merc_color(from.merc_color());
    }
    if (from.has_merc_star()) {
      set_merc_star(from.merc_star());
    }
  }
}

void PVPData_MercInfo::CopyFrom(const PVPData_MercInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PVPData_MercInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void PVPData_MercInfo::Swap(PVPData_MercInfo* other) {
  if (other != this) {
    std::swap(merc_id_, other->merc_id_);
    std::swap(merc_lv_, other->merc_lv_);
    std::swap(merc_color_, other->merc_color_);
    std::swap(merc_star_, other->merc_star_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PVPData_MercInfo::GetTypeName() const {
  return "message.PVPData.MercInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int PVPData_PVPInfo::kTargetCharIdFieldNumber;
const int PVPData_PVPInfo::kTargetJobFieldNumber;
const int PVPData_PVPInfo::kTargetSexFieldNumber;
const int PVPData_PVPInfo::kTargetLevelFieldNumber;
const int PVPData_PVPInfo::kTargetNameFieldNumber;
const int PVPData_PVPInfo::kTargetPvpRankFieldNumber;
const int PVPData_PVPInfo::kTargetFightScoreFieldNumber;
const int PVPData_PVPInfo::kTargetSuccessTimesFieldNumber;
const int PVPData_PVPInfo::kTargetMercDataFieldNumber;
#endif  // !_MSC_VER

PVPData_PVPInfo::PVPData_PVPInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PVPData_PVPInfo::InitAsDefaultInstance() {
}

PVPData_PVPInfo::PVPData_PVPInfo(const PVPData_PVPInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PVPData_PVPInfo::SharedCtor() {
  _cached_size_ = 0;
  target_char_id_ = 0u;
  target_job_ = 0u;
  target_sex_ = 0u;
  target_level_ = 0u;
  target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_pvp_rank_ = 0u;
  target_fight_score_ = 0u;
  target_success_times_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PVPData_PVPInfo::~PVPData_PVPInfo() {
  SharedDtor();
}

void PVPData_PVPInfo::SharedDtor() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PVPData_PVPInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PVPData_PVPInfo& PVPData_PVPInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PVPData_PVPInfo* PVPData_PVPInfo::default_instance_ = NULL;

PVPData_PVPInfo* PVPData_PVPInfo::New() const {
  return new PVPData_PVPInfo;
}

void PVPData_PVPInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    target_char_id_ = 0u;
    target_job_ = 0u;
    target_sex_ = 0u;
    target_level_ = 0u;
    if (has_target_name()) {
      if (target_name_ != &::google::protobuf::internal::kEmptyString) {
        target_name_->clear();
      }
    }
    target_pvp_rank_ = 0u;
    target_fight_score_ = 0u;
    target_success_times_ = 0u;
  }
  target_merc_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PVPData_PVPInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 target_char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_char_id_)));
          set_has_target_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_target_job;
        break;
      }

      // optional uint32 target_job = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_job_)));
          set_has_target_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_sex;
        break;
      }

      // optional uint32 target_sex = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_sex_)));
          set_has_target_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_target_level;
        break;
      }

      // optional uint32 target_level = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_level_)));
          set_has_target_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_target_name;
        break;
      }

      // optional bytes target_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_target_pvp_rank;
        break;
      }

      // optional uint32 target_pvp_rank = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_pvp_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_pvp_rank_)));
          set_has_target_pvp_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_target_fight_score;
        break;
      }

      // optional uint32 target_fight_score = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_fight_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_fight_score_)));
          set_has_target_fight_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_target_success_times;
        break;
      }

      // optional uint32 target_success_times = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_success_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_success_times_)));
          set_has_target_success_times();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_target_merc_data;
        break;
      }

      // repeated .message.PVPData.MercInfo target_merc_data = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_merc_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_target_merc_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_target_merc_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PVPData_PVPInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 target_char_id = 1;
  if (has_target_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->target_char_id(), output);
  }

  // optional uint32 target_job = 2;
  if (has_target_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_job(), output);
  }

  // optional uint32 target_sex = 3;
  if (has_target_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->target_sex(), output);
  }

  // optional uint32 target_level = 4;
  if (has_target_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->target_level(), output);
  }

  // optional bytes target_name = 5;
  if (has_target_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->target_name(), output);
  }

  // optional uint32 target_pvp_rank = 6;
  if (has_target_pvp_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->target_pvp_rank(), output);
  }

  // optional uint32 target_fight_score = 7;
  if (has_target_fight_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->target_fight_score(), output);
  }

  // optional uint32 target_success_times = 8;
  if (has_target_success_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->target_success_times(), output);
  }

  // repeated .message.PVPData.MercInfo target_merc_data = 9;
  for (int i = 0; i < this->target_merc_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->target_merc_data(i), output);
  }

}

int PVPData_PVPInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 target_char_id = 1;
    if (has_target_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_char_id());
    }

    // optional uint32 target_job = 2;
    if (has_target_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_job());
    }

    // optional uint32 target_sex = 3;
    if (has_target_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_sex());
    }

    // optional uint32 target_level = 4;
    if (has_target_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_level());
    }

    // optional bytes target_name = 5;
    if (has_target_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target_name());
    }

    // optional uint32 target_pvp_rank = 6;
    if (has_target_pvp_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_pvp_rank());
    }

    // optional uint32 target_fight_score = 7;
    if (has_target_fight_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_fight_score());
    }

    // optional uint32 target_success_times = 8;
    if (has_target_success_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_success_times());
    }

  }
  // repeated .message.PVPData.MercInfo target_merc_data = 9;
  total_size += 1 * this->target_merc_data_size();
  for (int i = 0; i < this->target_merc_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->target_merc_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PVPData_PVPInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PVPData_PVPInfo*>(&from));
}

void PVPData_PVPInfo::MergeFrom(const PVPData_PVPInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_merc_data_.MergeFrom(from.target_merc_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_char_id()) {
      set_target_char_id(from.target_char_id());
    }
    if (from.has_target_job()) {
      set_target_job(from.target_job());
    }
    if (from.has_target_sex()) {
      set_target_sex(from.target_sex());
    }
    if (from.has_target_level()) {
      set_target_level(from.target_level());
    }
    if (from.has_target_name()) {
      set_target_name(from.target_name());
    }
    if (from.has_target_pvp_rank()) {
      set_target_pvp_rank(from.target_pvp_rank());
    }
    if (from.has_target_fight_score()) {
      set_target_fight_score(from.target_fight_score());
    }
    if (from.has_target_success_times()) {
      set_target_success_times(from.target_success_times());
    }
  }
}

void PVPData_PVPInfo::CopyFrom(const PVPData_PVPInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PVPData_PVPInfo::IsInitialized() const {

  for (int i = 0; i < target_merc_data_size(); i++) {
    if (!this->target_merc_data(i).IsInitialized()) return false;
  }
  return true;
}

void PVPData_PVPInfo::Swap(PVPData_PVPInfo* other) {
  if (other != this) {
    std::swap(target_char_id_, other->target_char_id_);
    std::swap(target_job_, other->target_job_);
    std::swap(target_sex_, other->target_sex_);
    std::swap(target_level_, other->target_level_);
    std::swap(target_name_, other->target_name_);
    std::swap(target_pvp_rank_, other->target_pvp_rank_);
    std::swap(target_fight_score_, other->target_fight_score_);
    std::swap(target_success_times_, other->target_success_times_);
    target_merc_data_.Swap(&other->target_merc_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PVPData_PVPInfo::GetTypeName() const {
  return "message.PVPData.PVPInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int PVPData::kPvpInfoFieldNumber;
const int PVPData::kRemainTimeFieldNumber;
const int PVPData::kLeftPvpTimesFieldNumber;
const int PVPData::kMyRankFieldNumber;
const int PVPData::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

PVPData::PVPData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PVPData::InitAsDefaultInstance() {
}

PVPData::PVPData(const PVPData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PVPData::SharedCtor() {
  _cached_size_ = 0;
  remain_time_ = 0u;
  left_pvp_times_ = 0u;
  my_rank_ = 0u;
  error_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PVPData::~PVPData() {
  SharedDtor();
}

void PVPData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PVPData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PVPData& PVPData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PVPData* PVPData::default_instance_ = NULL;

PVPData* PVPData::New() const {
  return new PVPData;
}

void PVPData::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    remain_time_ = 0u;
    left_pvp_times_ = 0u;
    my_rank_ = 0u;
    error_code_ = 0u;
  }
  pvp_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PVPData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.PVPData.PVPInfo pvp_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pvp_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pvp_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_pvp_info;
        if (input->ExpectTag(16)) goto parse_remain_time;
        break;
      }

      // optional uint32 remain_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remain_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remain_time_)));
          set_has_remain_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_left_pvp_times;
        break;
      }

      // optional uint32 left_pvp_times = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_left_pvp_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &left_pvp_times_)));
          set_has_left_pvp_times();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_my_rank;
        break;
      }

      // optional uint32 my_rank = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_my_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &my_rank_)));
          set_has_my_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_error_code;
        break;
      }

      // optional uint32 error_code = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PVPData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.PVPData.PVPInfo pvp_info = 1;
  for (int i = 0; i < this->pvp_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->pvp_info(i), output);
  }

  // optional uint32 remain_time = 2;
  if (has_remain_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->remain_time(), output);
  }

  // optional uint32 left_pvp_times = 3;
  if (has_left_pvp_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->left_pvp_times(), output);
  }

  // optional uint32 my_rank = 4;
  if (has_my_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->my_rank(), output);
  }

  // optional uint32 error_code = 5;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->error_code(), output);
  }

}

int PVPData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 remain_time = 2;
    if (has_remain_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remain_time());
    }

    // optional uint32 left_pvp_times = 3;
    if (has_left_pvp_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->left_pvp_times());
    }

    // optional uint32 my_rank = 4;
    if (has_my_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->my_rank());
    }

    // optional uint32 error_code = 5;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

  }
  // repeated .message.PVPData.PVPInfo pvp_info = 1;
  total_size += 1 * this->pvp_info_size();
  for (int i = 0; i < this->pvp_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pvp_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PVPData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PVPData*>(&from));
}

void PVPData::MergeFrom(const PVPData& from) {
  GOOGLE_CHECK_NE(&from, this);
  pvp_info_.MergeFrom(from.pvp_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_remain_time()) {
      set_remain_time(from.remain_time());
    }
    if (from.has_left_pvp_times()) {
      set_left_pvp_times(from.left_pvp_times());
    }
    if (from.has_my_rank()) {
      set_my_rank(from.my_rank());
    }
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void PVPData::CopyFrom(const PVPData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PVPData::IsInitialized() const {

  for (int i = 0; i < pvp_info_size(); i++) {
    if (!this->pvp_info(i).IsInitialized()) return false;
  }
  return true;
}

void PVPData::Swap(PVPData* other) {
  if (other != this) {
    pvp_info_.Swap(&other->pvp_info_);
    std::swap(remain_time_, other->remain_time_);
    std::swap(left_pvp_times_, other->left_pvp_times_);
    std::swap(my_rank_, other->my_rank_);
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PVPData::GetTypeName() const {
  return "message.PVPData";
}


// ===================================================================

#ifndef _MSC_VER
const int PVPBattle::kTargetIdFieldNumber;
const int PVPBattle::kIsLadderFieldNumber;
#endif  // !_MSC_VER

PVPBattle::PVPBattle()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PVPBattle::InitAsDefaultInstance() {
}

PVPBattle::PVPBattle(const PVPBattle& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PVPBattle::SharedCtor() {
  _cached_size_ = 0;
  target_id_ = 0u;
  is_ladder_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PVPBattle::~PVPBattle() {
  SharedDtor();
}

void PVPBattle::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PVPBattle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PVPBattle& PVPBattle::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PVPBattle* PVPBattle::default_instance_ = NULL;

PVPBattle* PVPBattle::New() const {
  return new PVPBattle;
}

void PVPBattle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    target_id_ = 0u;
    is_ladder_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PVPBattle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 target_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_id_)));
          set_has_target_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_ladder;
        break;
      }

      // optional uint32 is_ladder = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_ladder:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_ladder_)));
          set_has_is_ladder();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PVPBattle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 target_id = 1;
  if (has_target_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->target_id(), output);
  }

  // optional uint32 is_ladder = 2;
  if (has_is_ladder()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->is_ladder(), output);
  }

}

int PVPBattle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 target_id = 1;
    if (has_target_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_id());
    }

    // optional uint32 is_ladder = 2;
    if (has_is_ladder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_ladder());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PVPBattle::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PVPBattle*>(&from));
}

void PVPBattle::MergeFrom(const PVPBattle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_id()) {
      set_target_id(from.target_id());
    }
    if (from.has_is_ladder()) {
      set_is_ladder(from.is_ladder());
    }
  }
}

void PVPBattle::CopyFrom(const PVPBattle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PVPBattle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PVPBattle::Swap(PVPBattle* other) {
  if (other != this) {
    std::swap(target_id_, other->target_id_);
    std::swap(is_ladder_, other->is_ladder_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PVPBattle::GetTypeName() const {
  return "message.PVPBattle";
}


// ===================================================================

#ifndef _MSC_VER
const int StartLadder::kCharIdFieldNumber;
#endif  // !_MSC_VER

StartLadder::StartLadder()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartLadder::InitAsDefaultInstance() {
}

StartLadder::StartLadder(const StartLadder& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartLadder::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartLadder::~StartLadder() {
  SharedDtor();
}

void StartLadder::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartLadder::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartLadder& StartLadder::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

StartLadder* StartLadder::default_instance_ = NULL;

StartLadder* StartLadder::New() const {
  return new StartLadder;
}

void StartLadder::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartLadder::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartLadder::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

}

int StartLadder::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartLadder::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartLadder*>(&from));
}

void StartLadder::MergeFrom(const StartLadder& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void StartLadder::CopyFrom(const StartLadder& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartLadder::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartLadder::Swap(StartLadder* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartLadder::GetTypeName() const {
  return "message.StartLadder";
}


// ===================================================================

#ifndef _MSC_VER
const int BuyLadderTimes::kCharIdFieldNumber;
#endif  // !_MSC_VER

BuyLadderTimes::BuyLadderTimes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BuyLadderTimes::InitAsDefaultInstance() {
}

BuyLadderTimes::BuyLadderTimes(const BuyLadderTimes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BuyLadderTimes::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuyLadderTimes::~BuyLadderTimes() {
  SharedDtor();
}

void BuyLadderTimes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BuyLadderTimes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BuyLadderTimes& BuyLadderTimes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BuyLadderTimes* BuyLadderTimes::default_instance_ = NULL;

BuyLadderTimes* BuyLadderTimes::New() const {
  return new BuyLadderTimes;
}

void BuyLadderTimes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BuyLadderTimes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuyLadderTimes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

}

int BuyLadderTimes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuyLadderTimes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BuyLadderTimes*>(&from));
}

void BuyLadderTimes::MergeFrom(const BuyLadderTimes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void BuyLadderTimes::CopyFrom(const BuyLadderTimes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuyLadderTimes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BuyLadderTimes::Swap(BuyLadderTimes* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BuyLadderTimes::GetTypeName() const {
  return "message.BuyLadderTimes";
}


// ===================================================================

#ifndef _MSC_VER
const int BuyPvPTimes::kCharIdFieldNumber;
#endif  // !_MSC_VER

BuyPvPTimes::BuyPvPTimes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BuyPvPTimes::InitAsDefaultInstance() {
}

BuyPvPTimes::BuyPvPTimes(const BuyPvPTimes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BuyPvPTimes::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuyPvPTimes::~BuyPvPTimes() {
  SharedDtor();
}

void BuyPvPTimes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BuyPvPTimes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BuyPvPTimes& BuyPvPTimes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BuyPvPTimes* BuyPvPTimes::default_instance_ = NULL;

BuyPvPTimes* BuyPvPTimes::New() const {
  return new BuyPvPTimes;
}

void BuyPvPTimes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BuyPvPTimes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuyPvPTimes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

}

int BuyPvPTimes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuyPvPTimes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BuyPvPTimes*>(&from));
}

void BuyPvPTimes::MergeFrom(const BuyPvPTimes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void BuyPvPTimes::CopyFrom(const BuyPvPTimes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuyPvPTimes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BuyPvPTimes::Swap(BuyPvPTimes* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BuyPvPTimes::GetTypeName() const {
  return "message.BuyPvPTimes";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateLadder::kCharIdFieldNumber;
const int UpdateLadder::kTargetCharIdFieldNumber;
#endif  // !_MSC_VER

UpdateLadder::UpdateLadder()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateLadder::InitAsDefaultInstance() {
}

UpdateLadder::UpdateLadder(const UpdateLadder& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateLadder::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  target_char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateLadder::~UpdateLadder() {
  SharedDtor();
}

void UpdateLadder::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateLadder::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateLadder& UpdateLadder::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UpdateLadder* UpdateLadder::default_instance_ = NULL;

UpdateLadder* UpdateLadder::New() const {
  return new UpdateLadder;
}

void UpdateLadder::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
    target_char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateLadder::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_target_char_id;
        break;
      }

      // optional uint32 target_char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_char_id_)));
          set_has_target_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateLadder::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

  // optional uint32 target_char_id = 2;
  if (has_target_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_char_id(), output);
  }

}

int UpdateLadder::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // optional uint32 target_char_id = 2;
    if (has_target_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateLadder::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateLadder*>(&from));
}

void UpdateLadder::MergeFrom(const UpdateLadder& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_target_char_id()) {
      set_target_char_id(from.target_char_id());
    }
  }
}

void UpdateLadder::CopyFrom(const UpdateLadder& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateLadder::IsInitialized() const {

  return true;
}

void UpdateLadder::Swap(UpdateLadder* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(target_char_id_, other->target_char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateLadder::GetTypeName() const {
  return "message.UpdateLadder";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateLadderReward_RewardInfo::kFromLadderFieldNumber;
const int UpdateLadderReward_RewardInfo::kToLadderFieldNumber;
const int UpdateLadderReward_RewardInfo::kRewardLadderFieldNumber;
#endif  // !_MSC_VER

UpdateLadderReward_RewardInfo::UpdateLadderReward_RewardInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateLadderReward_RewardInfo::InitAsDefaultInstance() {
}

UpdateLadderReward_RewardInfo::UpdateLadderReward_RewardInfo(const UpdateLadderReward_RewardInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateLadderReward_RewardInfo::SharedCtor() {
  _cached_size_ = 0;
  from_ladder_ = 0u;
  to_ladder_ = 0u;
  reward_ladder_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateLadderReward_RewardInfo::~UpdateLadderReward_RewardInfo() {
  SharedDtor();
}

void UpdateLadderReward_RewardInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateLadderReward_RewardInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateLadderReward_RewardInfo& UpdateLadderReward_RewardInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UpdateLadderReward_RewardInfo* UpdateLadderReward_RewardInfo::default_instance_ = NULL;

UpdateLadderReward_RewardInfo* UpdateLadderReward_RewardInfo::New() const {
  return new UpdateLadderReward_RewardInfo;
}

void UpdateLadderReward_RewardInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    from_ladder_ = 0u;
    to_ladder_ = 0u;
    reward_ladder_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateLadderReward_RewardInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_ladder = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_ladder_)));
          set_has_from_ladder();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_ladder;
        break;
      }

      // required uint32 to_ladder = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_ladder:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_ladder_)));
          set_has_to_ladder();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_reward_ladder;
        break;
      }

      // required uint32 reward_ladder = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_ladder:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reward_ladder_)));
          set_has_reward_ladder();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateLadderReward_RewardInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 from_ladder = 1;
  if (has_from_ladder()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_ladder(), output);
  }

  // required uint32 to_ladder = 2;
  if (has_to_ladder()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_ladder(), output);
  }

  // required uint32 reward_ladder = 3;
  if (has_reward_ladder()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->reward_ladder(), output);
  }

}

int UpdateLadderReward_RewardInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_ladder = 1;
    if (has_from_ladder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_ladder());
    }

    // required uint32 to_ladder = 2;
    if (has_to_ladder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_ladder());
    }

    // required uint32 reward_ladder = 3;
    if (has_reward_ladder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reward_ladder());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateLadderReward_RewardInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateLadderReward_RewardInfo*>(&from));
}

void UpdateLadderReward_RewardInfo::MergeFrom(const UpdateLadderReward_RewardInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_ladder()) {
      set_from_ladder(from.from_ladder());
    }
    if (from.has_to_ladder()) {
      set_to_ladder(from.to_ladder());
    }
    if (from.has_reward_ladder()) {
      set_reward_ladder(from.reward_ladder());
    }
  }
}

void UpdateLadderReward_RewardInfo::CopyFrom(const UpdateLadderReward_RewardInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateLadderReward_RewardInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void UpdateLadderReward_RewardInfo::Swap(UpdateLadderReward_RewardInfo* other) {
  if (other != this) {
    std::swap(from_ladder_, other->from_ladder_);
    std::swap(to_ladder_, other->to_ladder_);
    std::swap(reward_ladder_, other->reward_ladder_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateLadderReward_RewardInfo::GetTypeName() const {
  return "message.UpdateLadderReward.RewardInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UpdateLadderReward::kRewardInfoFieldNumber;
const int UpdateLadderReward::kAccIdFieldNumber;
#endif  // !_MSC_VER

UpdateLadderReward::UpdateLadderReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateLadderReward::InitAsDefaultInstance() {
}

UpdateLadderReward::UpdateLadderReward(const UpdateLadderReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateLadderReward::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateLadderReward::~UpdateLadderReward() {
  SharedDtor();
}

void UpdateLadderReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateLadderReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateLadderReward& UpdateLadderReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UpdateLadderReward* UpdateLadderReward::default_instance_ = NULL;

UpdateLadderReward* UpdateLadderReward::New() const {
  return new UpdateLadderReward;
}

void UpdateLadderReward::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    acc_id_ = 0u;
  }
  reward_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateLadderReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.UpdateLadderReward.RewardInfo reward_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reward_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reward_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_reward_info;
        if (input->ExpectTag(16)) goto parse_acc_id;
        break;
      }

      // optional uint32 acc_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateLadderReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.UpdateLadderReward.RewardInfo reward_info = 1;
  for (int i = 0; i < this->reward_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->reward_info(i), output);
  }

  // optional uint32 acc_id = 2;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->acc_id(), output);
  }

}

int UpdateLadderReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 acc_id = 2;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  // repeated .message.UpdateLadderReward.RewardInfo reward_info = 1;
  total_size += 1 * this->reward_info_size();
  for (int i = 0; i < this->reward_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reward_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateLadderReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateLadderReward*>(&from));
}

void UpdateLadderReward::MergeFrom(const UpdateLadderReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  reward_info_.MergeFrom(from.reward_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void UpdateLadderReward::CopyFrom(const UpdateLadderReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateLadderReward::IsInitialized() const {

  for (int i = 0; i < reward_info_size(); i++) {
    if (!this->reward_info(i).IsInitialized()) return false;
  }
  return true;
}

void UpdateLadderReward::Swap(UpdateLadderReward* other) {
  if (other != this) {
    reward_info_.Swap(&other->reward_info_);
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateLadderReward::GetTypeName() const {
  return "message.UpdateLadderReward";
}


// ===================================================================

#ifndef _MSC_VER
const int GetLadderReward::kItemIdFieldNumber;
#endif  // !_MSC_VER

GetLadderReward::GetLadderReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetLadderReward::InitAsDefaultInstance() {
}

GetLadderReward::GetLadderReward(const GetLadderReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetLadderReward::SharedCtor() {
  _cached_size_ = 0;
  item_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetLadderReward::~GetLadderReward() {
  SharedDtor();
}

void GetLadderReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetLadderReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetLadderReward& GetLadderReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetLadderReward* GetLadderReward::default_instance_ = NULL;

GetLadderReward* GetLadderReward::New() const {
  return new GetLadderReward;
}

void GetLadderReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetLadderReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 item_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetLadderReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 item_id = 1;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->item_id(), output);
  }

}

int GetLadderReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 item_id = 1;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetLadderReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetLadderReward*>(&from));
}

void GetLadderReward::MergeFrom(const GetLadderReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
  }
}

void GetLadderReward::CopyFrom(const GetLadderReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLadderReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetLadderReward::Swap(GetLadderReward* other) {
  if (other != this) {
    std::swap(item_id_, other->item_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetLadderReward::GetTypeName() const {
  return "message.GetLadderReward";
}


// ===================================================================

#ifndef _MSC_VER
const int GetRoleData::kTypeFieldNumber;
const int GetRoleData::kCharNameFieldNumber;
const int GetRoleData::kMerNameFieldNumber;
const int GetRoleData::kIsPkFieldNumber;
#endif  // !_MSC_VER

GetRoleData::GetRoleData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetRoleData::InitAsDefaultInstance() {
}

GetRoleData::GetRoleData(const GetRoleData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetRoleData::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_pk_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetRoleData::~GetRoleData() {
  SharedDtor();
}

void GetRoleData::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (mer_name_ != &::google::protobuf::internal::kEmptyString) {
    delete mer_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetRoleData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetRoleData& GetRoleData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetRoleData* GetRoleData::default_instance_ = NULL;

GetRoleData* GetRoleData::New() const {
  return new GetRoleData;
}

void GetRoleData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    if (has_mer_name()) {
      if (mer_name_ != &::google::protobuf::internal::kEmptyString) {
        mer_name_->clear();
      }
    }
    is_pk_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetRoleData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_char_name;
        break;
      }

      // required bytes char_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_mer_name;
        break;
      }

      // optional bytes mer_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mer_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mer_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_pk;
        break;
      }

      // optional uint32 is_pk = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_pk:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_pk_)));
          set_has_is_pk();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetRoleData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required bytes char_name = 2;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->char_name(), output);
  }

  // optional bytes mer_name = 3;
  if (has_mer_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->mer_name(), output);
  }

  // optional uint32 is_pk = 4;
  if (has_is_pk()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->is_pk(), output);
  }

}

int GetRoleData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required bytes char_name = 2;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // optional bytes mer_name = 3;
    if (has_mer_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mer_name());
    }

    // optional uint32 is_pk = 4;
    if (has_is_pk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_pk());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetRoleData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetRoleData*>(&from));
}

void GetRoleData::MergeFrom(const GetRoleData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_mer_name()) {
      set_mer_name(from.mer_name());
    }
    if (from.has_is_pk()) {
      set_is_pk(from.is_pk());
    }
  }
}

void GetRoleData::CopyFrom(const GetRoleData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetRoleData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GetRoleData::Swap(GetRoleData* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(char_name_, other->char_name_);
    std::swap(mer_name_, other->mer_name_);
    std::swap(is_pk_, other->is_pk_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetRoleData::GetTypeName() const {
  return "message.GetRoleData";
}


// ===================================================================

#ifndef _MSC_VER
const int RoleData_MercInfo::kMercPosFieldNumber;
const int RoleData_MercInfo::kMercDataFieldNumber;
const int RoleData_MercInfo::kEquipDataFieldNumber;
#endif  // !_MSC_VER

RoleData_MercInfo::RoleData_MercInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoleData_MercInfo::InitAsDefaultInstance() {
}

RoleData_MercInfo::RoleData_MercInfo(const RoleData_MercInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoleData_MercInfo::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  merc_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  equip_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoleData_MercInfo::~RoleData_MercInfo() {
  SharedDtor();
}

void RoleData_MercInfo::SharedDtor() {
  if (merc_data_ != &::google::protobuf::internal::kEmptyString) {
    delete merc_data_;
  }
  if (equip_data_ != &::google::protobuf::internal::kEmptyString) {
    delete equip_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RoleData_MercInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoleData_MercInfo& RoleData_MercInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

RoleData_MercInfo* RoleData_MercInfo::default_instance_ = NULL;

RoleData_MercInfo* RoleData_MercInfo::New() const {
  return new RoleData_MercInfo;
}

void RoleData_MercInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
    if (has_merc_data()) {
      if (merc_data_ != &::google::protobuf::internal::kEmptyString) {
        merc_data_->clear();
      }
    }
    if (has_equip_data()) {
      if (equip_data_ != &::google::protobuf::internal::kEmptyString) {
        equip_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoleData_MercInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_merc_data;
        break;
      }

      // optional bytes merc_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_merc_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_merc_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_equip_data;
        break;
      }

      // optional bytes equip_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_equip_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_equip_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoleData_MercInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

  // optional bytes merc_data = 2;
  if (has_merc_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->merc_data(), output);
  }

  // optional bytes equip_data = 3;
  if (has_equip_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->equip_data(), output);
  }

}

int RoleData_MercInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // optional bytes merc_data = 2;
    if (has_merc_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->merc_data());
    }

    // optional bytes equip_data = 3;
    if (has_equip_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->equip_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoleData_MercInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoleData_MercInfo*>(&from));
}

void RoleData_MercInfo::MergeFrom(const RoleData_MercInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_merc_data()) {
      set_merc_data(from.merc_data());
    }
    if (from.has_equip_data()) {
      set_equip_data(from.equip_data());
    }
  }
}

void RoleData_MercInfo::CopyFrom(const RoleData_MercInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoleData_MercInfo::IsInitialized() const {

  return true;
}

void RoleData_MercInfo::Swap(RoleData_MercInfo* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(merc_data_, other->merc_data_);
    std::swap(equip_data_, other->equip_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoleData_MercInfo::GetTypeName() const {
  return "message.RoleData.MercInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RoleData::kTargetCharIdFieldNumber;
const int RoleData::kTargetLvFieldNumber;
const int RoleData::kTargetNameFieldNumber;
const int RoleData::kTargetJobFieldNumber;
const int RoleData::kTargetSexFieldNumber;
const int RoleData::kSuccessNumFieldNumber;
const int RoleData::kFightScoreFieldNumber;
const int RoleData::kMercInfoFieldNumber;
const int RoleData::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

RoleData::RoleData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoleData::InitAsDefaultInstance() {
}

RoleData::RoleData(const RoleData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoleData::SharedCtor() {
  _cached_size_ = 0;
  target_char_id_ = 0u;
  target_lv_ = 0u;
  target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_job_ = 0u;
  target_sex_ = 0u;
  success_num_ = 0u;
  fight_score_ = 0u;
  error_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoleData::~RoleData() {
  SharedDtor();
}

void RoleData::SharedDtor() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RoleData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoleData& RoleData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

RoleData* RoleData::default_instance_ = NULL;

RoleData* RoleData::New() const {
  return new RoleData;
}

void RoleData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    target_char_id_ = 0u;
    target_lv_ = 0u;
    if (has_target_name()) {
      if (target_name_ != &::google::protobuf::internal::kEmptyString) {
        target_name_->clear();
      }
    }
    target_job_ = 0u;
    target_sex_ = 0u;
    success_num_ = 0u;
    fight_score_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    error_code_ = 0u;
  }
  merc_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoleData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 target_char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_char_id_)));
          set_has_target_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_target_lv;
        break;
      }

      // optional uint32 target_lv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_lv_)));
          set_has_target_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_target_name;
        break;
      }

      // optional bytes target_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_target_job;
        break;
      }

      // optional uint32 target_job = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_job_)));
          set_has_target_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_target_sex;
        break;
      }

      // optional uint32 target_sex = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_sex_)));
          set_has_target_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_success_num;
        break;
      }

      // optional uint32 success_num = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_success_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &success_num_)));
          set_has_success_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_fight_score;
        break;
      }

      // optional uint32 fight_score = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fight_score_)));
          set_has_fight_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_merc_info;
        break;
      }

      // repeated .message.RoleData.MercInfo merc_info = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_merc_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_merc_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_merc_info;
        if (input->ExpectTag(72)) goto parse_error_code;
        break;
      }

      // optional uint32 error_code = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoleData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 target_char_id = 1;
  if (has_target_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->target_char_id(), output);
  }

  // optional uint32 target_lv = 2;
  if (has_target_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_lv(), output);
  }

  // optional bytes target_name = 3;
  if (has_target_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->target_name(), output);
  }

  // optional uint32 target_job = 4;
  if (has_target_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->target_job(), output);
  }

  // optional uint32 target_sex = 5;
  if (has_target_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->target_sex(), output);
  }

  // optional uint32 success_num = 6;
  if (has_success_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->success_num(), output);
  }

  // optional uint32 fight_score = 7;
  if (has_fight_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->fight_score(), output);
  }

  // repeated .message.RoleData.MercInfo merc_info = 8;
  for (int i = 0; i < this->merc_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->merc_info(i), output);
  }

  // optional uint32 error_code = 9;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->error_code(), output);
  }

}

int RoleData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 target_char_id = 1;
    if (has_target_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_char_id());
    }

    // optional uint32 target_lv = 2;
    if (has_target_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_lv());
    }

    // optional bytes target_name = 3;
    if (has_target_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target_name());
    }

    // optional uint32 target_job = 4;
    if (has_target_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_job());
    }

    // optional uint32 target_sex = 5;
    if (has_target_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_sex());
    }

    // optional uint32 success_num = 6;
    if (has_success_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->success_num());
    }

    // optional uint32 fight_score = 7;
    if (has_fight_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fight_score());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 error_code = 9;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

  }
  // repeated .message.RoleData.MercInfo merc_info = 8;
  total_size += 1 * this->merc_info_size();
  for (int i = 0; i < this->merc_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->merc_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoleData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoleData*>(&from));
}

void RoleData::MergeFrom(const RoleData& from) {
  GOOGLE_CHECK_NE(&from, this);
  merc_info_.MergeFrom(from.merc_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_char_id()) {
      set_target_char_id(from.target_char_id());
    }
    if (from.has_target_lv()) {
      set_target_lv(from.target_lv());
    }
    if (from.has_target_name()) {
      set_target_name(from.target_name());
    }
    if (from.has_target_job()) {
      set_target_job(from.target_job());
    }
    if (from.has_target_sex()) {
      set_target_sex(from.target_sex());
    }
    if (from.has_success_num()) {
      set_success_num(from.success_num());
    }
    if (from.has_fight_score()) {
      set_fight_score(from.fight_score());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void RoleData::CopyFrom(const RoleData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoleData::IsInitialized() const {

  return true;
}

void RoleData::Swap(RoleData* other) {
  if (other != this) {
    std::swap(target_char_id_, other->target_char_id_);
    std::swap(target_lv_, other->target_lv_);
    std::swap(target_name_, other->target_name_);
    std::swap(target_job_, other->target_job_);
    std::swap(target_sex_, other->target_sex_);
    std::swap(success_num_, other->success_num_);
    std::swap(fight_score_, other->fight_score_);
    merc_info_.Swap(&other->merc_info_);
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoleData::GetTypeName() const {
  return "message.RoleData";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqRoleData::kCharNameFieldNumber;
const int ReqRoleData::kTypeFieldNumber;
#endif  // !_MSC_VER

ReqRoleData::ReqRoleData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqRoleData::InitAsDefaultInstance() {
}

ReqRoleData::ReqRoleData(const ReqRoleData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqRoleData::SharedCtor() {
  _cached_size_ = 0;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqRoleData::~ReqRoleData() {
  SharedDtor();
}

void ReqRoleData::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqRoleData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqRoleData& ReqRoleData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqRoleData* ReqRoleData::default_instance_ = NULL;

ReqRoleData* ReqRoleData::New() const {
  return new ReqRoleData;
}

void ReqRoleData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqRoleData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes char_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional uint32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqRoleData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes char_name = 1;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->char_name(), output);
  }

  // optional uint32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

}

int ReqRoleData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes char_name = 1;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // optional uint32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqRoleData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqRoleData*>(&from));
}

void ReqRoleData::MergeFrom(const ReqRoleData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ReqRoleData::CopyFrom(const ReqRoleData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRoleData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqRoleData::Swap(ReqRoleData* other) {
  if (other != this) {
    std::swap(char_name_, other->char_name_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqRoleData::GetTypeName() const {
  return "message.ReqRoleData";
}


// ===================================================================

#ifndef _MSC_VER
const int AckRoleData::kTargetCharIdFieldNumber;
const int AckRoleData::kTargetJobFieldNumber;
const int AckRoleData::kTargetSexFieldNumber;
const int AckRoleData::kTargetNameFieldNumber;
const int AckRoleData::kTargetLevelFieldNumber;
const int AckRoleData::kSuccessNumFieldNumber;
const int AckRoleData::kFightScoreFieldNumber;
const int AckRoleData::kTargetRankFieldNumber;
const int AckRoleData::kCharMercFieldNumber;
const int AckRoleData::kCharEquipFieldNumber;
const int AckRoleData::kSourceRankFieldNumber;
#endif  // !_MSC_VER

AckRoleData::AckRoleData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckRoleData::InitAsDefaultInstance() {
}

AckRoleData::AckRoleData(const AckRoleData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckRoleData::SharedCtor() {
  _cached_size_ = 0;
  target_char_id_ = 0u;
  target_job_ = 0u;
  target_sex_ = 0u;
  target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_level_ = 0u;
  success_num_ = 0u;
  fight_score_ = 0u;
  target_rank_ = 0u;
  char_merc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  char_equip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  source_rank_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckRoleData::~AckRoleData() {
  SharedDtor();
}

void AckRoleData::SharedDtor() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (char_merc_ != &::google::protobuf::internal::kEmptyString) {
    delete char_merc_;
  }
  if (char_equip_ != &::google::protobuf::internal::kEmptyString) {
    delete char_equip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckRoleData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckRoleData& AckRoleData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckRoleData* AckRoleData::default_instance_ = NULL;

AckRoleData* AckRoleData::New() const {
  return new AckRoleData;
}

void AckRoleData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    target_char_id_ = 0u;
    target_job_ = 0u;
    target_sex_ = 0u;
    if (has_target_name()) {
      if (target_name_ != &::google::protobuf::internal::kEmptyString) {
        target_name_->clear();
      }
    }
    target_level_ = 0u;
    success_num_ = 0u;
    fight_score_ = 0u;
    target_rank_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_char_merc()) {
      if (char_merc_ != &::google::protobuf::internal::kEmptyString) {
        char_merc_->clear();
      }
    }
    if (has_char_equip()) {
      if (char_equip_ != &::google::protobuf::internal::kEmptyString) {
        char_equip_->clear();
      }
    }
    source_rank_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckRoleData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 target_char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_char_id_)));
          set_has_target_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_target_job;
        break;
      }

      // optional uint32 target_job = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_job_)));
          set_has_target_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_sex;
        break;
      }

      // optional uint32 target_sex = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_sex_)));
          set_has_target_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_target_name;
        break;
      }

      // optional bytes target_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_target_level;
        break;
      }

      // optional uint32 target_level = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_level_)));
          set_has_target_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_success_num;
        break;
      }

      // optional uint32 success_num = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_success_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &success_num_)));
          set_has_success_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_fight_score;
        break;
      }

      // optional uint32 fight_score = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fight_score_)));
          set_has_fight_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_target_rank;
        break;
      }

      // optional uint32 target_rank = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_rank_)));
          set_has_target_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_char_merc;
        break;
      }

      // optional bytes char_merc = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_merc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_merc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_char_equip;
        break;
      }

      // optional bytes char_equip = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_equip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_equip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_source_rank;
        break;
      }

      // optional uint32 source_rank = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_source_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_rank_)));
          set_has_source_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckRoleData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 target_char_id = 1;
  if (has_target_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->target_char_id(), output);
  }

  // optional uint32 target_job = 2;
  if (has_target_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_job(), output);
  }

  // optional uint32 target_sex = 3;
  if (has_target_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->target_sex(), output);
  }

  // optional bytes target_name = 4;
  if (has_target_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->target_name(), output);
  }

  // optional uint32 target_level = 5;
  if (has_target_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->target_level(), output);
  }

  // optional uint32 success_num = 6;
  if (has_success_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->success_num(), output);
  }

  // optional uint32 fight_score = 7;
  if (has_fight_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->fight_score(), output);
  }

  // optional uint32 target_rank = 8;
  if (has_target_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->target_rank(), output);
  }

  // optional bytes char_merc = 9;
  if (has_char_merc()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->char_merc(), output);
  }

  // optional bytes char_equip = 10;
  if (has_char_equip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->char_equip(), output);
  }

  // optional uint32 source_rank = 11;
  if (has_source_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->source_rank(), output);
  }

}

int AckRoleData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 target_char_id = 1;
    if (has_target_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_char_id());
    }

    // optional uint32 target_job = 2;
    if (has_target_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_job());
    }

    // optional uint32 target_sex = 3;
    if (has_target_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_sex());
    }

    // optional bytes target_name = 4;
    if (has_target_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target_name());
    }

    // optional uint32 target_level = 5;
    if (has_target_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_level());
    }

    // optional uint32 success_num = 6;
    if (has_success_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->success_num());
    }

    // optional uint32 fight_score = 7;
    if (has_fight_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fight_score());
    }

    // optional uint32 target_rank = 8;
    if (has_target_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_rank());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes char_merc = 9;
    if (has_char_merc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_merc());
    }

    // optional bytes char_equip = 10;
    if (has_char_equip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_equip());
    }

    // optional uint32 source_rank = 11;
    if (has_source_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->source_rank());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckRoleData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckRoleData*>(&from));
}

void AckRoleData::MergeFrom(const AckRoleData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_char_id()) {
      set_target_char_id(from.target_char_id());
    }
    if (from.has_target_job()) {
      set_target_job(from.target_job());
    }
    if (from.has_target_sex()) {
      set_target_sex(from.target_sex());
    }
    if (from.has_target_name()) {
      set_target_name(from.target_name());
    }
    if (from.has_target_level()) {
      set_target_level(from.target_level());
    }
    if (from.has_success_num()) {
      set_success_num(from.success_num());
    }
    if (from.has_fight_score()) {
      set_fight_score(from.fight_score());
    }
    if (from.has_target_rank()) {
      set_target_rank(from.target_rank());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_char_merc()) {
      set_char_merc(from.char_merc());
    }
    if (from.has_char_equip()) {
      set_char_equip(from.char_equip());
    }
    if (from.has_source_rank()) {
      set_source_rank(from.source_rank());
    }
  }
}

void AckRoleData::CopyFrom(const AckRoleData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckRoleData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckRoleData::Swap(AckRoleData* other) {
  if (other != this) {
    std::swap(target_char_id_, other->target_char_id_);
    std::swap(target_job_, other->target_job_);
    std::swap(target_sex_, other->target_sex_);
    std::swap(target_name_, other->target_name_);
    std::swap(target_level_, other->target_level_);
    std::swap(success_num_, other->success_num_);
    std::swap(fight_score_, other->fight_score_);
    std::swap(target_rank_, other->target_rank_);
    std::swap(char_merc_, other->char_merc_);
    std::swap(char_equip_, other->char_equip_);
    std::swap(source_rank_, other->source_rank_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckRoleData::GetTypeName() const {
  return "message.AckRoleData";
}


// ===================================================================

#ifndef _MSC_VER
const int GetShopItemFromDB::kAccIdFieldNumber;
#endif  // !_MSC_VER

GetShopItemFromDB::GetShopItemFromDB()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetShopItemFromDB::InitAsDefaultInstance() {
}

GetShopItemFromDB::GetShopItemFromDB(const GetShopItemFromDB& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetShopItemFromDB::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetShopItemFromDB::~GetShopItemFromDB() {
  SharedDtor();
}

void GetShopItemFromDB::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetShopItemFromDB::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetShopItemFromDB& GetShopItemFromDB::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetShopItemFromDB* GetShopItemFromDB::default_instance_ = NULL;

GetShopItemFromDB* GetShopItemFromDB::New() const {
  return new GetShopItemFromDB;
}

void GetShopItemFromDB::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetShopItemFromDB::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetShopItemFromDB::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

}

int GetShopItemFromDB::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetShopItemFromDB::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetShopItemFromDB*>(&from));
}

void GetShopItemFromDB::MergeFrom(const GetShopItemFromDB& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void GetShopItemFromDB::CopyFrom(const GetShopItemFromDB& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetShopItemFromDB::IsInitialized() const {

  return true;
}

void GetShopItemFromDB::Swap(GetShopItemFromDB* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetShopItemFromDB::GetTypeName() const {
  return "message.GetShopItemFromDB";
}


// ===================================================================

#ifndef _MSC_VER
const int GetShopItemAck::kShopTypeFieldNumber;
const int GetShopItemAck::kItemDataFieldNumber;
const int GetShopItemAck::kIsEmptyFieldNumber;
#endif  // !_MSC_VER

GetShopItemAck::GetShopItemAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetShopItemAck::InitAsDefaultInstance() {
}

GetShopItemAck::GetShopItemAck(const GetShopItemAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetShopItemAck::SharedCtor() {
  _cached_size_ = 0;
  is_empty_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetShopItemAck::~GetShopItemAck() {
  SharedDtor();
}

void GetShopItemAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetShopItemAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetShopItemAck& GetShopItemAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetShopItemAck* GetShopItemAck::default_instance_ = NULL;

GetShopItemAck* GetShopItemAck::New() const {
  return new GetShopItemAck;
}

void GetShopItemAck::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    is_empty_ = 0u;
  }
  shop_type_.Clear();
  item_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetShopItemAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 shop_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shop_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_shop_type())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_shop_type())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_shop_type;
        if (input->ExpectTag(18)) goto parse_item_data;
        break;
      }

      // repeated bytes item_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_item_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_item_data;
        if (input->ExpectTag(24)) goto parse_is_empty;
        break;
      }

      // optional uint32 is_empty = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_empty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_empty_)));
          set_has_is_empty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetShopItemAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 shop_type = 1;
  for (int i = 0; i < this->shop_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->shop_type(i), output);
  }

  // repeated bytes item_data = 2;
  for (int i = 0; i < this->item_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->item_data(i), output);
  }

  // optional uint32 is_empty = 3;
  if (has_is_empty()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->is_empty(), output);
  }

}

int GetShopItemAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional uint32 is_empty = 3;
    if (has_is_empty()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_empty());
    }

  }
  // repeated uint32 shop_type = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->shop_type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->shop_type(i));
    }
    total_size += 1 * this->shop_type_size() + data_size;
  }

  // repeated bytes item_data = 2;
  total_size += 1 * this->item_data_size();
  for (int i = 0; i < this->item_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->item_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetShopItemAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetShopItemAck*>(&from));
}

void GetShopItemAck::MergeFrom(const GetShopItemAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  shop_type_.MergeFrom(from.shop_type_);
  item_data_.MergeFrom(from.item_data_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_is_empty()) {
      set_is_empty(from.is_empty());
    }
  }
}

void GetShopItemAck::CopyFrom(const GetShopItemAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetShopItemAck::IsInitialized() const {

  return true;
}

void GetShopItemAck::Swap(GetShopItemAck* other) {
  if (other != this) {
    shop_type_.Swap(&other->shop_type_);
    item_data_.Swap(&other->item_data_);
    std::swap(is_empty_, other->is_empty_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetShopItemAck::GetTypeName() const {
  return "message.GetShopItemAck";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenShopUiReq::kShopTypeFieldNumber;
#endif  // !_MSC_VER

OpenShopUiReq::OpenShopUiReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OpenShopUiReq::InitAsDefaultInstance() {
}

OpenShopUiReq::OpenShopUiReq(const OpenShopUiReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OpenShopUiReq::SharedCtor() {
  _cached_size_ = 0;
  shop_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenShopUiReq::~OpenShopUiReq() {
  SharedDtor();
}

void OpenShopUiReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenShopUiReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenShopUiReq& OpenShopUiReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OpenShopUiReq* OpenShopUiReq::default_instance_ = NULL;

OpenShopUiReq* OpenShopUiReq::New() const {
  return new OpenShopUiReq;
}

void OpenShopUiReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    shop_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OpenShopUiReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 shop_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shop_type_)));
          set_has_shop_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenShopUiReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 shop_type = 1;
  if (has_shop_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shop_type(), output);
  }

}

int OpenShopUiReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 shop_type = 1;
    if (has_shop_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shop_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenShopUiReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenShopUiReq*>(&from));
}

void OpenShopUiReq::MergeFrom(const OpenShopUiReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shop_type()) {
      set_shop_type(from.shop_type());
    }
  }
}

void OpenShopUiReq::CopyFrom(const OpenShopUiReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenShopUiReq::IsInitialized() const {

  return true;
}

void OpenShopUiReq::Swap(OpenShopUiReq* other) {
  if (other != this) {
    std::swap(shop_type_, other->shop_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenShopUiReq::GetTypeName() const {
  return "message.OpenShopUiReq";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenShopUiAck::kErrorCodeFieldNumber;
const int OpenShopUiAck::kOperTypeFieldNumber;
const int OpenShopUiAck::kItemDataFieldNumber;
#endif  // !_MSC_VER

OpenShopUiAck::OpenShopUiAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OpenShopUiAck::InitAsDefaultInstance() {
}

OpenShopUiAck::OpenShopUiAck(const OpenShopUiAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OpenShopUiAck::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  oper_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenShopUiAck::~OpenShopUiAck() {
  SharedDtor();
}

void OpenShopUiAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenShopUiAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenShopUiAck& OpenShopUiAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OpenShopUiAck* OpenShopUiAck::default_instance_ = NULL;

OpenShopUiAck* OpenShopUiAck::New() const {
  return new OpenShopUiAck;
}

void OpenShopUiAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    oper_type_ = 0u;
  }
  item_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OpenShopUiAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_oper_type;
        break;
      }

      // optional uint32 oper_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_type_)));
          set_has_oper_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_item_data;
        break;
      }

      // repeated bytes item_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_item_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_item_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenShopUiAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // optional uint32 oper_type = 2;
  if (has_oper_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->oper_type(), output);
  }

  // repeated bytes item_data = 3;
  for (int i = 0; i < this->item_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->item_data(i), output);
  }

}

int OpenShopUiAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // optional uint32 oper_type = 2;
    if (has_oper_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_type());
    }

  }
  // repeated bytes item_data = 3;
  total_size += 1 * this->item_data_size();
  for (int i = 0; i < this->item_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->item_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenShopUiAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenShopUiAck*>(&from));
}

void OpenShopUiAck::MergeFrom(const OpenShopUiAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_data_.MergeFrom(from.item_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_oper_type()) {
      set_oper_type(from.oper_type());
    }
  }
}

void OpenShopUiAck::CopyFrom(const OpenShopUiAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenShopUiAck::IsInitialized() const {

  return true;
}

void OpenShopUiAck::Swap(OpenShopUiAck* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(oper_type_, other->oper_type_);
    item_data_.Swap(&other->item_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenShopUiAck::GetTypeName() const {
  return "message.OpenShopUiAck";
}


// ===================================================================

#ifndef _MSC_VER
const int BuyItem::kShopTypeFieldNumber;
const int BuyItem::kItemPosFieldNumber;
#endif  // !_MSC_VER

BuyItem::BuyItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BuyItem::InitAsDefaultInstance() {
}

BuyItem::BuyItem(const BuyItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BuyItem::SharedCtor() {
  _cached_size_ = 0;
  shop_type_ = 0u;
  item_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuyItem::~BuyItem() {
  SharedDtor();
}

void BuyItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BuyItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BuyItem& BuyItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BuyItem* BuyItem::default_instance_ = NULL;

BuyItem* BuyItem::New() const {
  return new BuyItem;
}

void BuyItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    shop_type_ = 0u;
    item_pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BuyItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 shop_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shop_type_)));
          set_has_shop_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_pos;
        break;
      }

      // optional uint32 item_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_pos_)));
          set_has_item_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuyItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 shop_type = 1;
  if (has_shop_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shop_type(), output);
  }

  // optional uint32 item_pos = 2;
  if (has_item_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_pos(), output);
  }

}

int BuyItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 shop_type = 1;
    if (has_shop_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shop_type());
    }

    // optional uint32 item_pos = 2;
    if (has_item_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuyItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BuyItem*>(&from));
}

void BuyItem::MergeFrom(const BuyItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shop_type()) {
      set_shop_type(from.shop_type());
    }
    if (from.has_item_pos()) {
      set_item_pos(from.item_pos());
    }
  }
}

void BuyItem::CopyFrom(const BuyItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuyItem::IsInitialized() const {

  return true;
}

void BuyItem::Swap(BuyItem* other) {
  if (other != this) {
    std::swap(shop_type_, other->shop_type_);
    std::swap(item_pos_, other->item_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BuyItem::GetTypeName() const {
  return "message.BuyItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RefreshShopReq::kShopTypeFieldNumber;
#endif  // !_MSC_VER

RefreshShopReq::RefreshShopReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RefreshShopReq::InitAsDefaultInstance() {
}

RefreshShopReq::RefreshShopReq(const RefreshShopReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RefreshShopReq::SharedCtor() {
  _cached_size_ = 0;
  shop_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RefreshShopReq::~RefreshShopReq() {
  SharedDtor();
}

void RefreshShopReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RefreshShopReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RefreshShopReq& RefreshShopReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

RefreshShopReq* RefreshShopReq::default_instance_ = NULL;

RefreshShopReq* RefreshShopReq::New() const {
  return new RefreshShopReq;
}

void RefreshShopReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    shop_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RefreshShopReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 shop_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shop_type_)));
          set_has_shop_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RefreshShopReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 shop_type = 1;
  if (has_shop_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shop_type(), output);
  }

}

int RefreshShopReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 shop_type = 1;
    if (has_shop_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shop_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RefreshShopReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RefreshShopReq*>(&from));
}

void RefreshShopReq::MergeFrom(const RefreshShopReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shop_type()) {
      set_shop_type(from.shop_type());
    }
  }
}

void RefreshShopReq::CopyFrom(const RefreshShopReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshShopReq::IsInitialized() const {

  return true;
}

void RefreshShopReq::Swap(RefreshShopReq* other) {
  if (other != this) {
    std::swap(shop_type_, other->shop_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RefreshShopReq::GetTypeName() const {
  return "message.RefreshShopReq";
}


// ===================================================================

#ifndef _MSC_VER
const int SellItem::kItemOnlyIdFieldNumber;
const int SellItem::kItemNumFieldNumber;
const int SellItem::kIsChooseFieldNumber;
#endif  // !_MSC_VER

SellItem::SellItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SellItem::InitAsDefaultInstance() {
}

SellItem::SellItem(const SellItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SellItem::SharedCtor() {
  _cached_size_ = 0;
  item_only_id_ = GOOGLE_ULONGLONG(0);
  item_num_ = 0u;
  is_choose_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SellItem::~SellItem() {
  SharedDtor();
}

void SellItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SellItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SellItem& SellItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SellItem* SellItem::default_instance_ = NULL;

SellItem* SellItem::New() const {
  return new SellItem;
}

void SellItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_only_id_ = GOOGLE_ULONGLONG(0);
    item_num_ = 0u;
    is_choose_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SellItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 item_only_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &item_only_id_)));
          set_has_item_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_num;
        break;
      }

      // required uint32 item_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_choose;
        break;
      }

      // optional uint32 is_choose = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_choose:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_choose_)));
          set_has_is_choose();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SellItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 item_only_id = 1;
  if (has_item_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->item_only_id(), output);
  }

  // required uint32 item_num = 2;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_num(), output);
  }

  // optional uint32 is_choose = 3;
  if (has_is_choose()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->is_choose(), output);
  }

}

int SellItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 item_only_id = 1;
    if (has_item_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->item_only_id());
    }

    // required uint32 item_num = 2;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_num());
    }

    // optional uint32 is_choose = 3;
    if (has_is_choose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_choose());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SellItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SellItem*>(&from));
}

void SellItem::MergeFrom(const SellItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_only_id()) {
      set_item_only_id(from.item_only_id());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
    if (from.has_is_choose()) {
      set_is_choose(from.is_choose());
    }
  }
}

void SellItem::CopyFrom(const SellItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SellItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SellItem::Swap(SellItem* other) {
  if (other != this) {
    std::swap(item_only_id_, other->item_only_id_);
    std::swap(item_num_, other->item_num_);
    std::swap(is_choose_, other->is_choose_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SellItem::GetTypeName() const {
  return "message.SellItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeSkill::kPosFieldNumber;
const int ChangeSkill::kSkillIdFieldNumber;
#endif  // !_MSC_VER

ChangeSkill::ChangeSkill()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeSkill::InitAsDefaultInstance() {
}

ChangeSkill::ChangeSkill(const ChangeSkill& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeSkill::SharedCtor() {
  _cached_size_ = 0;
  pos_ = 0u;
  skill_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeSkill::~ChangeSkill() {
  SharedDtor();
}

void ChangeSkill::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeSkill& ChangeSkill::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ChangeSkill* ChangeSkill::default_instance_ = NULL;

ChangeSkill* ChangeSkill::New() const {
  return new ChangeSkill;
}

void ChangeSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pos_ = 0u;
    skill_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_id;
        break;
      }

      // required uint32 skill_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_id_)));
          set_has_skill_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pos(), output);
  }

  // required uint32 skill_id = 2;
  if (has_skill_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->skill_id(), output);
  }

}

int ChangeSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

    // required uint32 skill_id = 2;
    if (has_skill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeSkill::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeSkill*>(&from));
}

void ChangeSkill::MergeFrom(const ChangeSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      set_pos(from.pos());
    }
    if (from.has_skill_id()) {
      set_skill_id(from.skill_id());
    }
  }
}

void ChangeSkill::CopyFrom(const ChangeSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeSkill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ChangeSkill::Swap(ChangeSkill* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(skill_id_, other->skill_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeSkill::GetTypeName() const {
  return "message.ChangeSkill";
}


// ===================================================================

#ifndef _MSC_VER
const int SkillLevelUp::kPosFieldNumber;
const int SkillLevelUp::kSkillIdFieldNumber;
#endif  // !_MSC_VER

SkillLevelUp::SkillLevelUp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SkillLevelUp::InitAsDefaultInstance() {
}

SkillLevelUp::SkillLevelUp(const SkillLevelUp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SkillLevelUp::SharedCtor() {
  _cached_size_ = 0;
  pos_ = 0u;
  skill_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SkillLevelUp::~SkillLevelUp() {
  SharedDtor();
}

void SkillLevelUp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SkillLevelUp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SkillLevelUp& SkillLevelUp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SkillLevelUp* SkillLevelUp::default_instance_ = NULL;

SkillLevelUp* SkillLevelUp::New() const {
  return new SkillLevelUp;
}

void SkillLevelUp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pos_ = 0u;
    skill_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SkillLevelUp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_id;
        break;
      }

      // required uint32 skill_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_id_)));
          set_has_skill_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SkillLevelUp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pos(), output);
  }

  // required uint32 skill_id = 2;
  if (has_skill_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->skill_id(), output);
  }

}

int SkillLevelUp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

    // required uint32 skill_id = 2;
    if (has_skill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SkillLevelUp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SkillLevelUp*>(&from));
}

void SkillLevelUp::MergeFrom(const SkillLevelUp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      set_pos(from.pos());
    }
    if (from.has_skill_id()) {
      set_skill_id(from.skill_id());
    }
  }
}

void SkillLevelUp::CopyFrom(const SkillLevelUp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SkillLevelUp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SkillLevelUp::Swap(SkillLevelUp* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(skill_id_, other->skill_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SkillLevelUp::GetTypeName() const {
  return "message.SkillLevelUp";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqLevelUpStar::kPosFieldNumber;
const int ReqLevelUpStar::kIsChooseFieldNumber;
#endif  // !_MSC_VER

ReqLevelUpStar::ReqLevelUpStar()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqLevelUpStar::InitAsDefaultInstance() {
}

ReqLevelUpStar::ReqLevelUpStar(const ReqLevelUpStar& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqLevelUpStar::SharedCtor() {
  _cached_size_ = 0;
  pos_ = 0u;
  is_choose_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqLevelUpStar::~ReqLevelUpStar() {
  SharedDtor();
}

void ReqLevelUpStar::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqLevelUpStar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqLevelUpStar& ReqLevelUpStar::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqLevelUpStar* ReqLevelUpStar::default_instance_ = NULL;

ReqLevelUpStar* ReqLevelUpStar::New() const {
  return new ReqLevelUpStar;
}

void ReqLevelUpStar::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pos_ = 0u;
    is_choose_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqLevelUpStar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_choose;
        break;
      }

      // optional uint32 is_choose = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_choose:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_choose_)));
          set_has_is_choose();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqLevelUpStar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pos(), output);
  }

  // optional uint32 is_choose = 2;
  if (has_is_choose()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->is_choose(), output);
  }

}

int ReqLevelUpStar::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

    // optional uint32 is_choose = 2;
    if (has_is_choose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_choose());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqLevelUpStar::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqLevelUpStar*>(&from));
}

void ReqLevelUpStar::MergeFrom(const ReqLevelUpStar& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      set_pos(from.pos());
    }
    if (from.has_is_choose()) {
      set_is_choose(from.is_choose());
    }
  }
}

void ReqLevelUpStar::CopyFrom(const ReqLevelUpStar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqLevelUpStar::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqLevelUpStar::Swap(ReqLevelUpStar* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(is_choose_, other->is_choose_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqLevelUpStar::GetTypeName() const {
  return "message.ReqLevelUpStar";
}


// ===================================================================

#ifndef _MSC_VER
const int UpgradeItem::kCharPosFieldNumber;
const int UpgradeItem::kItemPosFieldNumber;
const int UpgradeItem::kItemOnlyIdFieldNumber;
const int UpgradeItem::kIsDestFieldNumber;
const int UpgradeItem::kQuickUpgradeFieldNumber;
#endif  // !_MSC_VER

UpgradeItem::UpgradeItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpgradeItem::InitAsDefaultInstance() {
}

UpgradeItem::UpgradeItem(const UpgradeItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpgradeItem::SharedCtor() {
  _cached_size_ = 0;
  char_pos_ = 0u;
  item_pos_ = 0u;
  item_only_id_ = GOOGLE_ULONGLONG(0);
  is_dest_ = 0u;
  quick_upgrade_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpgradeItem::~UpgradeItem() {
  SharedDtor();
}

void UpgradeItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpgradeItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpgradeItem& UpgradeItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UpgradeItem* UpgradeItem::default_instance_ = NULL;

UpgradeItem* UpgradeItem::New() const {
  return new UpgradeItem;
}

void UpgradeItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_pos_ = 0u;
    item_pos_ = 0u;
    item_only_id_ = GOOGLE_ULONGLONG(0);
    is_dest_ = 0u;
    quick_upgrade_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpgradeItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_pos_)));
          set_has_char_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_pos;
        break;
      }

      // required uint32 item_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_pos_)));
          set_has_item_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_only_id;
        break;
      }

      // required uint64 item_only_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_only_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &item_only_id_)));
          set_has_item_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_dest;
        break;
      }

      // optional uint32 is_dest = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_dest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_dest_)));
          set_has_is_dest();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_quick_upgrade;
        break;
      }

      // optional uint32 quick_upgrade = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_quick_upgrade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &quick_upgrade_)));
          set_has_quick_upgrade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpgradeItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_pos = 1;
  if (has_char_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_pos(), output);
  }

  // required uint32 item_pos = 2;
  if (has_item_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_pos(), output);
  }

  // required uint64 item_only_id = 3;
  if (has_item_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->item_only_id(), output);
  }

  // optional uint32 is_dest = 4;
  if (has_is_dest()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->is_dest(), output);
  }

  // optional uint32 quick_upgrade = 5;
  if (has_quick_upgrade()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->quick_upgrade(), output);
  }

}

int UpgradeItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_pos = 1;
    if (has_char_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_pos());
    }

    // required uint32 item_pos = 2;
    if (has_item_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_pos());
    }

    // required uint64 item_only_id = 3;
    if (has_item_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->item_only_id());
    }

    // optional uint32 is_dest = 4;
    if (has_is_dest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_dest());
    }

    // optional uint32 quick_upgrade = 5;
    if (has_quick_upgrade()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->quick_upgrade());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpgradeItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpgradeItem*>(&from));
}

void UpgradeItem::MergeFrom(const UpgradeItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_pos()) {
      set_char_pos(from.char_pos());
    }
    if (from.has_item_pos()) {
      set_item_pos(from.item_pos());
    }
    if (from.has_item_only_id()) {
      set_item_only_id(from.item_only_id());
    }
    if (from.has_is_dest()) {
      set_is_dest(from.is_dest());
    }
    if (from.has_quick_upgrade()) {
      set_quick_upgrade(from.quick_upgrade());
    }
  }
}

void UpgradeItem::CopyFrom(const UpgradeItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void UpgradeItem::Swap(UpgradeItem* other) {
  if (other != this) {
    std::swap(char_pos_, other->char_pos_);
    std::swap(item_pos_, other->item_pos_);
    std::swap(item_only_id_, other->item_only_id_);
    std::swap(is_dest_, other->is_dest_);
    std::swap(quick_upgrade_, other->quick_upgrade_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpgradeItem::GetTypeName() const {
  return "message.UpgradeItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqRankList::kRankTypeFieldNumber;
const int ReqRankList::kPageFieldNumber;
#endif  // !_MSC_VER

ReqRankList::ReqRankList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqRankList::InitAsDefaultInstance() {
}

ReqRankList::ReqRankList(const ReqRankList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqRankList::SharedCtor() {
  _cached_size_ = 0;
  rank_type_ = 0u;
  page_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqRankList::~ReqRankList() {
  SharedDtor();
}

void ReqRankList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqRankList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqRankList& ReqRankList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqRankList* ReqRankList::default_instance_ = NULL;

ReqRankList* ReqRankList::New() const {
  return new ReqRankList;
}

void ReqRankList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rank_type_ = 0u;
    page_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqRankList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 rank_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_type_)));
          set_has_rank_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_page;
        break;
      }

      // optional uint32 page = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqRankList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 rank_type = 1;
  if (has_rank_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rank_type(), output);
  }

  // optional uint32 page = 2;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->page(), output);
  }

}

int ReqRankList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 rank_type = 1;
    if (has_rank_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank_type());
    }

    // optional uint32 page = 2;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->page());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqRankList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqRankList*>(&from));
}

void ReqRankList::MergeFrom(const ReqRankList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rank_type()) {
      set_rank_type(from.rank_type());
    }
    if (from.has_page()) {
      set_page(from.page());
    }
  }
}

void ReqRankList::CopyFrom(const ReqRankList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRankList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqRankList::Swap(ReqRankList* other) {
  if (other != this) {
    std::swap(rank_type_, other->rank_type_);
    std::swap(page_, other->page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqRankList::GetTypeName() const {
  return "message.ReqRankList";
}


// ===================================================================

#ifndef _MSC_VER
const int AckRankList_RankInfo::kRankIdFieldNumber;
const int AckRankList_RankInfo::kCharNameFieldNumber;
const int AckRankList_RankInfo::kCharRankFieldNumber;
const int AckRankList_RankInfo::kRankValueFieldNumber;
const int AckRankList_RankInfo::kIsMyselfFieldNumber;
const int AckRankList_RankInfo::kFightScoreFieldNumber;
const int AckRankList_RankInfo::kCharLevelFieldNumber;
#endif  // !_MSC_VER

AckRankList_RankInfo::AckRankList_RankInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckRankList_RankInfo::InitAsDefaultInstance() {
}

AckRankList_RankInfo::AckRankList_RankInfo(const AckRankList_RankInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckRankList_RankInfo::SharedCtor() {
  _cached_size_ = 0;
  rank_id_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  char_rank_ = 0u;
  rank_value_ = 0u;
  is_myself_ = 0u;
  fight_score_ = 0u;
  char_level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckRankList_RankInfo::~AckRankList_RankInfo() {
  SharedDtor();
}

void AckRankList_RankInfo::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckRankList_RankInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckRankList_RankInfo& AckRankList_RankInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckRankList_RankInfo* AckRankList_RankInfo::default_instance_ = NULL;

AckRankList_RankInfo* AckRankList_RankInfo::New() const {
  return new AckRankList_RankInfo;
}

void AckRankList_RankInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rank_id_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    char_rank_ = 0u;
    rank_value_ = 0u;
    is_myself_ = 0u;
    fight_score_ = 0u;
    char_level_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckRankList_RankInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 rank_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_id_)));
          set_has_rank_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_char_name;
        break;
      }

      // required bytes char_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_char_rank;
        break;
      }

      // required uint32 char_rank = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_rank_)));
          set_has_char_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_rank_value;
        break;
      }

      // required uint32 rank_value = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rank_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_value_)));
          set_has_rank_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_is_myself;
        break;
      }

      // optional uint32 is_myself = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_myself:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_myself_)));
          set_has_is_myself();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_fight_score;
        break;
      }

      // optional uint32 fight_score = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fight_score_)));
          set_has_fight_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_char_level;
        break;
      }

      // optional uint32 char_level = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_level_)));
          set_has_char_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckRankList_RankInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 rank_id = 1;
  if (has_rank_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rank_id(), output);
  }

  // required bytes char_name = 2;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->char_name(), output);
  }

  // required uint32 char_rank = 3;
  if (has_char_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->char_rank(), output);
  }

  // required uint32 rank_value = 4;
  if (has_rank_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rank_value(), output);
  }

  // optional uint32 is_myself = 5;
  if (has_is_myself()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->is_myself(), output);
  }

  // optional uint32 fight_score = 6;
  if (has_fight_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->fight_score(), output);
  }

  // optional uint32 char_level = 7;
  if (has_char_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->char_level(), output);
  }

}

int AckRankList_RankInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 rank_id = 1;
    if (has_rank_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank_id());
    }

    // required bytes char_name = 2;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // required uint32 char_rank = 3;
    if (has_char_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_rank());
    }

    // required uint32 rank_value = 4;
    if (has_rank_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank_value());
    }

    // optional uint32 is_myself = 5;
    if (has_is_myself()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_myself());
    }

    // optional uint32 fight_score = 6;
    if (has_fight_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fight_score());
    }

    // optional uint32 char_level = 7;
    if (has_char_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_level());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckRankList_RankInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckRankList_RankInfo*>(&from));
}

void AckRankList_RankInfo::MergeFrom(const AckRankList_RankInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rank_id()) {
      set_rank_id(from.rank_id());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_char_rank()) {
      set_char_rank(from.char_rank());
    }
    if (from.has_rank_value()) {
      set_rank_value(from.rank_value());
    }
    if (from.has_is_myself()) {
      set_is_myself(from.is_myself());
    }
    if (from.has_fight_score()) {
      set_fight_score(from.fight_score());
    }
    if (from.has_char_level()) {
      set_char_level(from.char_level());
    }
  }
}

void AckRankList_RankInfo::CopyFrom(const AckRankList_RankInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckRankList_RankInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void AckRankList_RankInfo::Swap(AckRankList_RankInfo* other) {
  if (other != this) {
    std::swap(rank_id_, other->rank_id_);
    std::swap(char_name_, other->char_name_);
    std::swap(char_rank_, other->char_rank_);
    std::swap(rank_value_, other->rank_value_);
    std::swap(is_myself_, other->is_myself_);
    std::swap(fight_score_, other->fight_score_);
    std::swap(char_level_, other->char_level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckRankList_RankInfo::GetTypeName() const {
  return "message.AckRankList.RankInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AckRankList::kRankInfoFieldNumber;
const int AckRankList::kRankTimeFieldNumber;
const int AckRankList::kMyRankFieldNumber;
const int AckRankList::kPageFieldNumber;
#endif  // !_MSC_VER

AckRankList::AckRankList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckRankList::InitAsDefaultInstance() {
}

AckRankList::AckRankList(const AckRankList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckRankList::SharedCtor() {
  _cached_size_ = 0;
  rank_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  my_rank_ = 0u;
  page_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckRankList::~AckRankList() {
  SharedDtor();
}

void AckRankList::SharedDtor() {
  if (rank_time_ != &::google::protobuf::internal::kEmptyString) {
    delete rank_time_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckRankList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckRankList& AckRankList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckRankList* AckRankList::default_instance_ = NULL;

AckRankList* AckRankList::New() const {
  return new AckRankList;
}

void AckRankList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_rank_time()) {
      if (rank_time_ != &::google::protobuf::internal::kEmptyString) {
        rank_time_->clear();
      }
    }
    my_rank_ = 0u;
    page_ = 0u;
  }
  rank_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckRankList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.AckRankList.RankInfo rank_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rank_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rank_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_rank_info;
        if (input->ExpectTag(18)) goto parse_rank_time;
        break;
      }

      // optional bytes rank_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rank_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_rank_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_my_rank;
        break;
      }

      // optional uint32 my_rank = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_my_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &my_rank_)));
          set_has_my_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_page;
        break;
      }

      // optional uint32 page = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckRankList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.AckRankList.RankInfo rank_info = 1;
  for (int i = 0; i < this->rank_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rank_info(i), output);
  }

  // optional bytes rank_time = 2;
  if (has_rank_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->rank_time(), output);
  }

  // optional uint32 my_rank = 3;
  if (has_my_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->my_rank(), output);
  }

  // optional uint32 page = 4;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->page(), output);
  }

}

int AckRankList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes rank_time = 2;
    if (has_rank_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->rank_time());
    }

    // optional uint32 my_rank = 3;
    if (has_my_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->my_rank());
    }

    // optional uint32 page = 4;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->page());
    }

  }
  // repeated .message.AckRankList.RankInfo rank_info = 1;
  total_size += 1 * this->rank_info_size();
  for (int i = 0; i < this->rank_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rank_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckRankList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckRankList*>(&from));
}

void AckRankList::MergeFrom(const AckRankList& from) {
  GOOGLE_CHECK_NE(&from, this);
  rank_info_.MergeFrom(from.rank_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_rank_time()) {
      set_rank_time(from.rank_time());
    }
    if (from.has_my_rank()) {
      set_my_rank(from.my_rank());
    }
    if (from.has_page()) {
      set_page(from.page());
    }
  }
}

void AckRankList::CopyFrom(const AckRankList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckRankList::IsInitialized() const {

  for (int i = 0; i < rank_info_size(); i++) {
    if (!this->rank_info(i).IsInitialized()) return false;
  }
  return true;
}

void AckRankList::Swap(AckRankList* other) {
  if (other != this) {
    rank_info_.Swap(&other->rank_info_);
    std::swap(rank_time_, other->rank_time_);
    std::swap(my_rank_, other->my_rank_);
    std::swap(page_, other->page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckRankList::GetTypeName() const {
  return "message.AckRankList";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqServerRank::kRankIdFieldNumber;
#endif  // !_MSC_VER

ReqServerRank::ReqServerRank()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqServerRank::InitAsDefaultInstance() {
}

ReqServerRank::ReqServerRank(const ReqServerRank& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqServerRank::SharedCtor() {
  _cached_size_ = 0;
  rank_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqServerRank::~ReqServerRank() {
  SharedDtor();
}

void ReqServerRank::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqServerRank::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqServerRank& ReqServerRank::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqServerRank* ReqServerRank::default_instance_ = NULL;

ReqServerRank* ReqServerRank::New() const {
  return new ReqServerRank;
}

void ReqServerRank::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rank_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqServerRank::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 rank_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_id_)));
          set_has_rank_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqServerRank::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 rank_id = 1;
  if (has_rank_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rank_id(), output);
  }

}

int ReqServerRank::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 rank_id = 1;
    if (has_rank_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqServerRank::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqServerRank*>(&from));
}

void ReqServerRank::MergeFrom(const ReqServerRank& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rank_id()) {
      set_rank_id(from.rank_id());
    }
  }
}

void ReqServerRank::CopyFrom(const ReqServerRank& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqServerRank::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqServerRank::Swap(ReqServerRank* other) {
  if (other != this) {
    std::swap(rank_id_, other->rank_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqServerRank::GetTypeName() const {
  return "message.ReqServerRank";
}


// ===================================================================

#ifndef _MSC_VER
const int AckServerRank_RankInfo::kCharIdFieldNumber;
const int AckServerRank_RankInfo::kNameFieldNumber;
const int AckServerRank_RankInfo::kRankFieldNumber;
const int AckServerRank_RankInfo::kLevelFieldNumber;
const int AckServerRank_RankInfo::kSexFieldNumber;
const int AckServerRank_RankInfo::kJobFieldNumber;
const int AckServerRank_RankInfo::kRankValueFieldNumber;
#endif  // !_MSC_VER

AckServerRank_RankInfo::AckServerRank_RankInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckServerRank_RankInfo::InitAsDefaultInstance() {
}

AckServerRank_RankInfo::AckServerRank_RankInfo(const AckServerRank_RankInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckServerRank_RankInfo::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  rank_ = 0u;
  level_ = 0u;
  sex_ = 0u;
  job_ = 0u;
  rank_value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckServerRank_RankInfo::~AckServerRank_RankInfo() {
  SharedDtor();
}

void AckServerRank_RankInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckServerRank_RankInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckServerRank_RankInfo& AckServerRank_RankInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckServerRank_RankInfo* AckServerRank_RankInfo::default_instance_ = NULL;

AckServerRank_RankInfo* AckServerRank_RankInfo::New() const {
  return new AckServerRank_RankInfo;
}

void AckServerRank_RankInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    rank_ = 0u;
    level_ = 0u;
    sex_ = 0u;
    job_ = 0u;
    rank_value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckServerRank_RankInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional bytes name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_rank;
        break;
      }

      // optional uint32 rank = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_level;
        break;
      }

      // optional uint32 level = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_sex;
        break;
      }

      // optional uint32 sex = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_job;
        break;
      }

      // optional uint32 job = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_rank_value;
        break;
      }

      // optional uint32 rank_value = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rank_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_value_)));
          set_has_rank_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckServerRank_RankInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

  // optional bytes name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->name(), output);
  }

  // optional uint32 rank = 3;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rank(), output);
  }

  // optional uint32 level = 4;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->level(), output);
  }

  // optional uint32 sex = 5;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sex(), output);
  }

  // optional uint32 job = 6;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->job(), output);
  }

  // optional uint32 rank_value = 7;
  if (has_rank_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->rank_value(), output);
  }

}

int AckServerRank_RankInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // optional bytes name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

    // optional uint32 rank = 3;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // optional uint32 level = 4;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // optional uint32 sex = 5;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sex());
    }

    // optional uint32 job = 6;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->job());
    }

    // optional uint32 rank_value = 7;
    if (has_rank_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank_value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckServerRank_RankInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckServerRank_RankInfo*>(&from));
}

void AckServerRank_RankInfo::MergeFrom(const AckServerRank_RankInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
    if (from.has_rank_value()) {
      set_rank_value(from.rank_value());
    }
  }
}

void AckServerRank_RankInfo::CopyFrom(const AckServerRank_RankInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckServerRank_RankInfo::IsInitialized() const {

  return true;
}

void AckServerRank_RankInfo::Swap(AckServerRank_RankInfo* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(name_, other->name_);
    std::swap(rank_, other->rank_);
    std::swap(level_, other->level_);
    std::swap(sex_, other->sex_);
    std::swap(job_, other->job_);
    std::swap(rank_value_, other->rank_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckServerRank_RankInfo::GetTypeName() const {
  return "message.AckServerRank.RankInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AckServerRank::kRankInfoFieldNumber;
const int AckServerRank::kRankTypeFieldNumber;
#endif  // !_MSC_VER

AckServerRank::AckServerRank()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckServerRank::InitAsDefaultInstance() {
}

AckServerRank::AckServerRank(const AckServerRank& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckServerRank::SharedCtor() {
  _cached_size_ = 0;
  rank_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckServerRank::~AckServerRank() {
  SharedDtor();
}

void AckServerRank::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckServerRank::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckServerRank& AckServerRank::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckServerRank* AckServerRank::default_instance_ = NULL;

AckServerRank* AckServerRank::New() const {
  return new AckServerRank;
}

void AckServerRank::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    rank_type_ = 0u;
  }
  rank_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckServerRank::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.AckServerRank.RankInfo rank_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rank_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rank_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_rank_info;
        if (input->ExpectTag(16)) goto parse_rank_type;
        break;
      }

      // optional uint32 rank_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rank_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_type_)));
          set_has_rank_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckServerRank::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.AckServerRank.RankInfo rank_info = 1;
  for (int i = 0; i < this->rank_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rank_info(i), output);
  }

  // optional uint32 rank_type = 2;
  if (has_rank_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->rank_type(), output);
  }

}

int AckServerRank::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 rank_type = 2;
    if (has_rank_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank_type());
    }

  }
  // repeated .message.AckServerRank.RankInfo rank_info = 1;
  total_size += 1 * this->rank_info_size();
  for (int i = 0; i < this->rank_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rank_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckServerRank::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckServerRank*>(&from));
}

void AckServerRank::MergeFrom(const AckServerRank& from) {
  GOOGLE_CHECK_NE(&from, this);
  rank_info_.MergeFrom(from.rank_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_rank_type()) {
      set_rank_type(from.rank_type());
    }
  }
}

void AckServerRank::CopyFrom(const AckServerRank& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckServerRank::IsInitialized() const {

  return true;
}

void AckServerRank::Swap(AckServerRank* other) {
  if (other != this) {
    rank_info_.Swap(&other->rank_info_);
    std::swap(rank_type_, other->rank_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckServerRank::GetTypeName() const {
  return "message.AckServerRank";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqChessData::kChessTypeFieldNumber;
const int ReqChessData::kFriendIdFieldNumber;
#endif  // !_MSC_VER

ReqChessData::ReqChessData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqChessData::InitAsDefaultInstance() {
}

ReqChessData::ReqChessData(const ReqChessData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqChessData::SharedCtor() {
  _cached_size_ = 0;
  chess_type_ = 0u;
  friend_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqChessData::~ReqChessData() {
  SharedDtor();
}

void ReqChessData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqChessData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqChessData& ReqChessData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqChessData* ReqChessData::default_instance_ = NULL;

ReqChessData* ReqChessData::New() const {
  return new ReqChessData;
}

void ReqChessData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    chess_type_ = 0u;
    friend_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqChessData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 chess_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chess_type_)));
          set_has_chess_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_friend_id;
        break;
      }

      // required uint32 friend_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_id_)));
          set_has_friend_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqChessData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 chess_type = 1;
  if (has_chess_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chess_type(), output);
  }

  // required uint32 friend_id = 2;
  if (has_friend_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->friend_id(), output);
  }

}

int ReqChessData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 chess_type = 1;
    if (has_chess_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chess_type());
    }

    // required uint32 friend_id = 2;
    if (has_friend_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqChessData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqChessData*>(&from));
}

void ReqChessData::MergeFrom(const ReqChessData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chess_type()) {
      set_chess_type(from.chess_type());
    }
    if (from.has_friend_id()) {
      set_friend_id(from.friend_id());
    }
  }
}

void ReqChessData::CopyFrom(const ReqChessData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqChessData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ReqChessData::Swap(ReqChessData* other) {
  if (other != this) {
    std::swap(chess_type_, other->chess_type_);
    std::swap(friend_id_, other->friend_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqChessData::GetTypeName() const {
  return "message.ReqChessData";
}


// ===================================================================

#ifndef _MSC_VER
const int AckChessData::kRemainTimeFieldNumber;
#endif  // !_MSC_VER

AckChessData::AckChessData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckChessData::InitAsDefaultInstance() {
}

AckChessData::AckChessData(const AckChessData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckChessData::SharedCtor() {
  _cached_size_ = 0;
  remain_time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckChessData::~AckChessData() {
  SharedDtor();
}

void AckChessData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckChessData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckChessData& AckChessData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckChessData* AckChessData::default_instance_ = NULL;

AckChessData* AckChessData::New() const {
  return new AckChessData;
}

void AckChessData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    remain_time_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckChessData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 remain_time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remain_time_)));
          set_has_remain_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckChessData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 remain_time = 1;
  if (has_remain_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->remain_time(), output);
  }

}

int AckChessData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 remain_time = 1;
    if (has_remain_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remain_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckChessData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckChessData*>(&from));
}

void AckChessData::MergeFrom(const AckChessData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_remain_time()) {
      set_remain_time(from.remain_time());
    }
  }
}

void AckChessData::CopyFrom(const AckChessData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckChessData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckChessData::Swap(AckChessData* other) {
  if (other != this) {
    std::swap(remain_time_, other->remain_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckChessData::GetTypeName() const {
  return "message.AckChessData";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqRunChess::kChessTypeFieldNumber;
const int ReqRunChess::kFriendIdFieldNumber;
const int ReqRunChess::kIsFastFieldNumber;
#endif  // !_MSC_VER

ReqRunChess::ReqRunChess()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqRunChess::InitAsDefaultInstance() {
}

ReqRunChess::ReqRunChess(const ReqRunChess& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqRunChess::SharedCtor() {
  _cached_size_ = 0;
  chess_type_ = 0u;
  friend_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_fast_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqRunChess::~ReqRunChess() {
  SharedDtor();
}

void ReqRunChess::SharedDtor() {
  if (friend_id_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqRunChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqRunChess& ReqRunChess::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqRunChess* ReqRunChess::default_instance_ = NULL;

ReqRunChess* ReqRunChess::New() const {
  return new ReqRunChess;
}

void ReqRunChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    chess_type_ = 0u;
    if (has_friend_id()) {
      if (friend_id_ != &::google::protobuf::internal::kEmptyString) {
        friend_id_->clear();
      }
    }
    is_fast_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqRunChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 chess_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chess_type_)));
          set_has_chess_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_friend_id;
        break;
      }

      // optional bytes friend_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_friend_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_friend_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_fast;
        break;
      }

      // optional uint32 is_fast = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_fast:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_fast_)));
          set_has_is_fast();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqRunChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 chess_type = 1;
  if (has_chess_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chess_type(), output);
  }

  // optional bytes friend_id = 2;
  if (has_friend_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->friend_id(), output);
  }

  // optional uint32 is_fast = 3;
  if (has_is_fast()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->is_fast(), output);
  }

}

int ReqRunChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 chess_type = 1;
    if (has_chess_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chess_type());
    }

    // optional bytes friend_id = 2;
    if (has_friend_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->friend_id());
    }

    // optional uint32 is_fast = 3;
    if (has_is_fast()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_fast());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqRunChess::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqRunChess*>(&from));
}

void ReqRunChess::MergeFrom(const ReqRunChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chess_type()) {
      set_chess_type(from.chess_type());
    }
    if (from.has_friend_id()) {
      set_friend_id(from.friend_id());
    }
    if (from.has_is_fast()) {
      set_is_fast(from.is_fast());
    }
  }
}

void ReqRunChess::CopyFrom(const ReqRunChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRunChess::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqRunChess::Swap(ReqRunChess* other) {
  if (other != this) {
    std::swap(chess_type_, other->chess_type_);
    std::swap(friend_id_, other->friend_id_);
    std::swap(is_fast_, other->is_fast_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqRunChess::GetTypeName() const {
  return "message.ReqRunChess";
}


// ===================================================================

#ifndef _MSC_VER
const int AckRunChess::kChessTypeFieldNumber;
const int AckRunChess::kChessMoveFieldNumber;
const int AckRunChess::kRewardItemFieldNumber;
const int AckRunChess::kRewardItemNumFieldNumber;
const int AckRunChess::kEventIdFieldNumber;
const int AckRunChess::kIsFriendFieldNumber;
const int AckRunChess::kIsFastFieldNumber;
const int AckRunChess::kIsBigFieldNumber;
#endif  // !_MSC_VER

AckRunChess::AckRunChess()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckRunChess::InitAsDefaultInstance() {
}

AckRunChess::AckRunChess(const AckRunChess& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckRunChess::SharedCtor() {
  _cached_size_ = 0;
  chess_type_ = 0u;
  chess_move_ = 0u;
  event_id_ = 0u;
  is_friend_ = 0u;
  is_fast_ = 0u;
  is_big_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckRunChess::~AckRunChess() {
  SharedDtor();
}

void AckRunChess::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckRunChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckRunChess& AckRunChess::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckRunChess* AckRunChess::default_instance_ = NULL;

AckRunChess* AckRunChess::New() const {
  return new AckRunChess;
}

void AckRunChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    chess_type_ = 0u;
    chess_move_ = 0u;
    event_id_ = 0u;
    is_friend_ = 0u;
    is_fast_ = 0u;
    is_big_ = 0u;
  }
  reward_item_.Clear();
  reward_item_num_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckRunChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 chess_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chess_type_)));
          set_has_chess_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_chess_move;
        break;
      }

      // required uint32 chess_move = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_chess_move:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chess_move_)));
          set_has_chess_move();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_reward_item;
        break;
      }

      // repeated uint32 reward_item = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_item:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_reward_item())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_reward_item())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_reward_item;
        if (input->ExpectTag(32)) goto parse_reward_item_num;
        break;
      }

      // repeated uint32 reward_item_num = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_reward_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_reward_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_reward_item_num;
        if (input->ExpectTag(40)) goto parse_event_id;
        break;
      }

      // optional uint32 event_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_event_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &event_id_)));
          set_has_event_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_is_friend;
        break;
      }

      // optional uint32 is_friend = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_friend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_friend_)));
          set_has_is_friend();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_is_fast;
        break;
      }

      // optional uint32 is_fast = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_fast:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_fast_)));
          set_has_is_fast();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_is_big;
        break;
      }

      // optional uint32 is_big = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_big:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_big_)));
          set_has_is_big();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckRunChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 chess_type = 1;
  if (has_chess_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->chess_type(), output);
  }

  // required uint32 chess_move = 2;
  if (has_chess_move()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->chess_move(), output);
  }

  // repeated uint32 reward_item = 3;
  for (int i = 0; i < this->reward_item_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->reward_item(i), output);
  }

  // repeated uint32 reward_item_num = 4;
  for (int i = 0; i < this->reward_item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->reward_item_num(i), output);
  }

  // optional uint32 event_id = 5;
  if (has_event_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->event_id(), output);
  }

  // optional uint32 is_friend = 6;
  if (has_is_friend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->is_friend(), output);
  }

  // optional uint32 is_fast = 7;
  if (has_is_fast()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->is_fast(), output);
  }

  // optional uint32 is_big = 8;
  if (has_is_big()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->is_big(), output);
  }

}

int AckRunChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 chess_type = 1;
    if (has_chess_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chess_type());
    }

    // required uint32 chess_move = 2;
    if (has_chess_move()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chess_move());
    }

    // optional uint32 event_id = 5;
    if (has_event_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->event_id());
    }

    // optional uint32 is_friend = 6;
    if (has_is_friend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_friend());
    }

    // optional uint32 is_fast = 7;
    if (has_is_fast()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_fast());
    }

    // optional uint32 is_big = 8;
    if (has_is_big()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_big());
    }

  }
  // repeated uint32 reward_item = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->reward_item_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->reward_item(i));
    }
    total_size += 1 * this->reward_item_size() + data_size;
  }

  // repeated uint32 reward_item_num = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->reward_item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->reward_item_num(i));
    }
    total_size += 1 * this->reward_item_num_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckRunChess::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckRunChess*>(&from));
}

void AckRunChess::MergeFrom(const AckRunChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  reward_item_.MergeFrom(from.reward_item_);
  reward_item_num_.MergeFrom(from.reward_item_num_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chess_type()) {
      set_chess_type(from.chess_type());
    }
    if (from.has_chess_move()) {
      set_chess_move(from.chess_move());
    }
    if (from.has_event_id()) {
      set_event_id(from.event_id());
    }
    if (from.has_is_friend()) {
      set_is_friend(from.is_friend());
    }
    if (from.has_is_fast()) {
      set_is_fast(from.is_fast());
    }
    if (from.has_is_big()) {
      set_is_big(from.is_big());
    }
  }
}

void AckRunChess::CopyFrom(const AckRunChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckRunChess::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AckRunChess::Swap(AckRunChess* other) {
  if (other != this) {
    std::swap(chess_type_, other->chess_type_);
    std::swap(chess_move_, other->chess_move_);
    reward_item_.Swap(&other->reward_item_);
    reward_item_num_.Swap(&other->reward_item_num_);
    std::swap(event_id_, other->event_id_);
    std::swap(is_friend_, other->is_friend_);
    std::swap(is_fast_, other->is_fast_);
    std::swap(is_big_, other->is_big_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckRunChess::GetTypeName() const {
  return "message.AckRunChess";
}


// ===================================================================

#ifndef _MSC_VER
const int AckChessRank_RankInfo::kCharIdFieldNumber;
const int AckChessRank_RankInfo::kCharNameFieldNumber;
const int AckChessRank_RankInfo::kCharRankFieldNumber;
const int AckChessRank_RankInfo::kRankValueFieldNumber;
#endif  // !_MSC_VER

AckChessRank_RankInfo::AckChessRank_RankInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckChessRank_RankInfo::InitAsDefaultInstance() {
}

AckChessRank_RankInfo::AckChessRank_RankInfo(const AckChessRank_RankInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckChessRank_RankInfo::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  char_rank_ = 0u;
  rank_value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckChessRank_RankInfo::~AckChessRank_RankInfo() {
  SharedDtor();
}

void AckChessRank_RankInfo::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckChessRank_RankInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckChessRank_RankInfo& AckChessRank_RankInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckChessRank_RankInfo* AckChessRank_RankInfo::default_instance_ = NULL;

AckChessRank_RankInfo* AckChessRank_RankInfo::New() const {
  return new AckChessRank_RankInfo;
}

void AckChessRank_RankInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    char_rank_ = 0u;
    rank_value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckChessRank_RankInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_char_name;
        break;
      }

      // required bytes char_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_char_rank;
        break;
      }

      // required uint32 char_rank = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_rank_)));
          set_has_char_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_rank_value;
        break;
      }

      // required uint32 rank_value = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rank_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_value_)));
          set_has_rank_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckChessRank_RankInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

  // required bytes char_name = 2;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->char_name(), output);
  }

  // required uint32 char_rank = 3;
  if (has_char_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->char_rank(), output);
  }

  // required uint32 rank_value = 4;
  if (has_rank_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rank_value(), output);
  }

}

int AckChessRank_RankInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // required bytes char_name = 2;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // required uint32 char_rank = 3;
    if (has_char_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_rank());
    }

    // required uint32 rank_value = 4;
    if (has_rank_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank_value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckChessRank_RankInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckChessRank_RankInfo*>(&from));
}

void AckChessRank_RankInfo::MergeFrom(const AckChessRank_RankInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_char_rank()) {
      set_char_rank(from.char_rank());
    }
    if (from.has_rank_value()) {
      set_rank_value(from.rank_value());
    }
  }
}

void AckChessRank_RankInfo::CopyFrom(const AckChessRank_RankInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckChessRank_RankInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void AckChessRank_RankInfo::Swap(AckChessRank_RankInfo* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(char_name_, other->char_name_);
    std::swap(char_rank_, other->char_rank_);
    std::swap(rank_value_, other->rank_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckChessRank_RankInfo::GetTypeName() const {
  return "message.AckChessRank.RankInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AckChessRank::kRankInfoFieldNumber;
const int AckChessRank::kChessTypeFieldNumber;
#endif  // !_MSC_VER

AckChessRank::AckChessRank()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckChessRank::InitAsDefaultInstance() {
}

AckChessRank::AckChessRank(const AckChessRank& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckChessRank::SharedCtor() {
  _cached_size_ = 0;
  chess_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckChessRank::~AckChessRank() {
  SharedDtor();
}

void AckChessRank::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckChessRank::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckChessRank& AckChessRank::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckChessRank* AckChessRank::default_instance_ = NULL;

AckChessRank* AckChessRank::New() const {
  return new AckChessRank;
}

void AckChessRank::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    chess_type_ = 0u;
  }
  rank_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckChessRank::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.AckChessRank.RankInfo rank_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rank_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rank_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_rank_info;
        if (input->ExpectTag(16)) goto parse_chess_type;
        break;
      }

      // required uint32 chess_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_chess_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chess_type_)));
          set_has_chess_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckChessRank::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.AckChessRank.RankInfo rank_info = 1;
  for (int i = 0; i < this->rank_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rank_info(i), output);
  }

  // required uint32 chess_type = 2;
  if (has_chess_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->chess_type(), output);
  }

}

int AckChessRank::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 chess_type = 2;
    if (has_chess_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chess_type());
    }

  }
  // repeated .message.AckChessRank.RankInfo rank_info = 1;
  total_size += 1 * this->rank_info_size();
  for (int i = 0; i < this->rank_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rank_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckChessRank::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckChessRank*>(&from));
}

void AckChessRank::MergeFrom(const AckChessRank& from) {
  GOOGLE_CHECK_NE(&from, this);
  rank_info_.MergeFrom(from.rank_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_chess_type()) {
      set_chess_type(from.chess_type());
    }
  }
}

void AckChessRank::CopyFrom(const AckChessRank& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckChessRank::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  for (int i = 0; i < rank_info_size(); i++) {
    if (!this->rank_info(i).IsInitialized()) return false;
  }
  return true;
}

void AckChessRank::Swap(AckChessRank* other) {
  if (other != this) {
    rank_info_.Swap(&other->rank_info_);
    std::swap(chess_type_, other->chess_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckChessRank::GetTypeName() const {
  return "message.AckChessRank";
}


// ===================================================================

#ifndef _MSC_VER
const int UnlockTrainMercenary::kPosFieldNumber;
#endif  // !_MSC_VER

UnlockTrainMercenary::UnlockTrainMercenary()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UnlockTrainMercenary::InitAsDefaultInstance() {
}

UnlockTrainMercenary::UnlockTrainMercenary(const UnlockTrainMercenary& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UnlockTrainMercenary::SharedCtor() {
  _cached_size_ = 0;
  pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnlockTrainMercenary::~UnlockTrainMercenary() {
  SharedDtor();
}

void UnlockTrainMercenary::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnlockTrainMercenary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnlockTrainMercenary& UnlockTrainMercenary::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UnlockTrainMercenary* UnlockTrainMercenary::default_instance_ = NULL;

UnlockTrainMercenary* UnlockTrainMercenary::New() const {
  return new UnlockTrainMercenary;
}

void UnlockTrainMercenary::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UnlockTrainMercenary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UnlockTrainMercenary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pos(), output);
  }

}

int UnlockTrainMercenary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnlockTrainMercenary::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnlockTrainMercenary*>(&from));
}

void UnlockTrainMercenary::MergeFrom(const UnlockTrainMercenary& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      set_pos(from.pos());
    }
  }
}

void UnlockTrainMercenary::CopyFrom(const UnlockTrainMercenary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnlockTrainMercenary::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UnlockTrainMercenary::Swap(UnlockTrainMercenary* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UnlockTrainMercenary::GetTypeName() const {
  return "message.UnlockTrainMercenary";
}


// ===================================================================

#ifndef _MSC_VER
const int TrainMercenary::kMercPosFieldNumber;
const int TrainMercenary::kTrainTypeFieldNumber;
const int TrainMercenary::kFriendIdFieldNumber;
#endif  // !_MSC_VER

TrainMercenary::TrainMercenary()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TrainMercenary::InitAsDefaultInstance() {
}

TrainMercenary::TrainMercenary(const TrainMercenary& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TrainMercenary::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  train_type_ = 0u;
  friend_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrainMercenary::~TrainMercenary() {
  SharedDtor();
}

void TrainMercenary::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TrainMercenary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TrainMercenary& TrainMercenary::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

TrainMercenary* TrainMercenary::default_instance_ = NULL;

TrainMercenary* TrainMercenary::New() const {
  return new TrainMercenary;
}

void TrainMercenary::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
    train_type_ = 0u;
    friend_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TrainMercenary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_train_type;
        break;
      }

      // required uint32 train_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_train_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &train_type_)));
          set_has_train_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_friend_id;
        break;
      }

      // optional uint32 friend_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friend_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_id_)));
          set_has_friend_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TrainMercenary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

  // required uint32 train_type = 2;
  if (has_train_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->train_type(), output);
  }

  // optional uint32 friend_id = 3;
  if (has_friend_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->friend_id(), output);
  }

}

int TrainMercenary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // required uint32 train_type = 2;
    if (has_train_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->train_type());
    }

    // optional uint32 friend_id = 3;
    if (has_friend_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrainMercenary::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TrainMercenary*>(&from));
}

void TrainMercenary::MergeFrom(const TrainMercenary& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_train_type()) {
      set_train_type(from.train_type());
    }
    if (from.has_friend_id()) {
      set_friend_id(from.friend_id());
    }
  }
}

void TrainMercenary::CopyFrom(const TrainMercenary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrainMercenary::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TrainMercenary::Swap(TrainMercenary* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(train_type_, other->train_type_);
    std::swap(friend_id_, other->friend_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TrainMercenary::GetTypeName() const {
  return "message.TrainMercenary";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqTrainMercenaryTime::kTrainIdFieldNumber;
#endif  // !_MSC_VER

ReqTrainMercenaryTime::ReqTrainMercenaryTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqTrainMercenaryTime::InitAsDefaultInstance() {
}

ReqTrainMercenaryTime::ReqTrainMercenaryTime(const ReqTrainMercenaryTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqTrainMercenaryTime::SharedCtor() {
  _cached_size_ = 0;
  train_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqTrainMercenaryTime::~ReqTrainMercenaryTime() {
  SharedDtor();
}

void ReqTrainMercenaryTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqTrainMercenaryTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqTrainMercenaryTime& ReqTrainMercenaryTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqTrainMercenaryTime* ReqTrainMercenaryTime::default_instance_ = NULL;

ReqTrainMercenaryTime* ReqTrainMercenaryTime::New() const {
  return new ReqTrainMercenaryTime;
}

void ReqTrainMercenaryTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    train_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqTrainMercenaryTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 train_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &train_id_)));
          set_has_train_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqTrainMercenaryTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 train_id = 1;
  if (has_train_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->train_id(), output);
  }

}

int ReqTrainMercenaryTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 train_id = 1;
    if (has_train_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->train_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqTrainMercenaryTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqTrainMercenaryTime*>(&from));
}

void ReqTrainMercenaryTime::MergeFrom(const ReqTrainMercenaryTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_train_id()) {
      set_train_id(from.train_id());
    }
  }
}

void ReqTrainMercenaryTime::CopyFrom(const ReqTrainMercenaryTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqTrainMercenaryTime::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqTrainMercenaryTime::Swap(ReqTrainMercenaryTime* other) {
  if (other != this) {
    std::swap(train_id_, other->train_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqTrainMercenaryTime::GetTypeName() const {
  return "message.ReqTrainMercenaryTime";
}


// ===================================================================

#ifndef _MSC_VER
const int AckTrainMercenaryTime::kMercPosFieldNumber;
const int AckTrainMercenaryTime::kRemainTimeFieldNumber;
#endif  // !_MSC_VER

AckTrainMercenaryTime::AckTrainMercenaryTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckTrainMercenaryTime::InitAsDefaultInstance() {
}

AckTrainMercenaryTime::AckTrainMercenaryTime(const AckTrainMercenaryTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckTrainMercenaryTime::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckTrainMercenaryTime::~AckTrainMercenaryTime() {
  SharedDtor();
}

void AckTrainMercenaryTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckTrainMercenaryTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckTrainMercenaryTime& AckTrainMercenaryTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckTrainMercenaryTime* AckTrainMercenaryTime::default_instance_ = NULL;

AckTrainMercenaryTime* AckTrainMercenaryTime::New() const {
  return new AckTrainMercenaryTime;
}

void AckTrainMercenaryTime::Clear() {
  merc_pos_.Clear();
  remain_time_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckTrainMercenaryTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_merc_pos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_merc_pos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_merc_pos;
        if (input->ExpectTag(16)) goto parse_remain_time;
        break;
      }

      // repeated uint32 remain_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remain_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_remain_time())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_remain_time())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_remain_time;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckTrainMercenaryTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 merc_pos = 1;
  for (int i = 0; i < this->merc_pos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->merc_pos(i), output);
  }

  // repeated uint32 remain_time = 2;
  for (int i = 0; i < this->remain_time_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->remain_time(i), output);
  }

}

int AckTrainMercenaryTime::ByteSize() const {
  int total_size = 0;

  // repeated uint32 merc_pos = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->merc_pos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->merc_pos(i));
    }
    total_size += 1 * this->merc_pos_size() + data_size;
  }

  // repeated uint32 remain_time = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->remain_time_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->remain_time(i));
    }
    total_size += 1 * this->remain_time_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckTrainMercenaryTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckTrainMercenaryTime*>(&from));
}

void AckTrainMercenaryTime::MergeFrom(const AckTrainMercenaryTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  merc_pos_.MergeFrom(from.merc_pos_);
  remain_time_.MergeFrom(from.remain_time_);
}

void AckTrainMercenaryTime::CopyFrom(const AckTrainMercenaryTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckTrainMercenaryTime::IsInitialized() const {

  return true;
}

void AckTrainMercenaryTime::Swap(AckTrainMercenaryTime* other) {
  if (other != this) {
    merc_pos_.Swap(&other->merc_pos_);
    remain_time_.Swap(&other->remain_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckTrainMercenaryTime::GetTypeName() const {
  return "message.AckTrainMercenaryTime";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqFriendTrainMercenaryTime::kTrainIdFieldNumber;
#endif  // !_MSC_VER

ReqFriendTrainMercenaryTime::ReqFriendTrainMercenaryTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqFriendTrainMercenaryTime::InitAsDefaultInstance() {
}

ReqFriendTrainMercenaryTime::ReqFriendTrainMercenaryTime(const ReqFriendTrainMercenaryTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqFriendTrainMercenaryTime::SharedCtor() {
  _cached_size_ = 0;
  train_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqFriendTrainMercenaryTime::~ReqFriendTrainMercenaryTime() {
  SharedDtor();
}

void ReqFriendTrainMercenaryTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqFriendTrainMercenaryTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqFriendTrainMercenaryTime& ReqFriendTrainMercenaryTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqFriendTrainMercenaryTime* ReqFriendTrainMercenaryTime::default_instance_ = NULL;

ReqFriendTrainMercenaryTime* ReqFriendTrainMercenaryTime::New() const {
  return new ReqFriendTrainMercenaryTime;
}

void ReqFriendTrainMercenaryTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    train_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqFriendTrainMercenaryTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 train_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &train_id_)));
          set_has_train_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqFriendTrainMercenaryTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 train_id = 1;
  if (has_train_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->train_id(), output);
  }

}

int ReqFriendTrainMercenaryTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 train_id = 1;
    if (has_train_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->train_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqFriendTrainMercenaryTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqFriendTrainMercenaryTime*>(&from));
}

void ReqFriendTrainMercenaryTime::MergeFrom(const ReqFriendTrainMercenaryTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_train_id()) {
      set_train_id(from.train_id());
    }
  }
}

void ReqFriendTrainMercenaryTime::CopyFrom(const ReqFriendTrainMercenaryTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqFriendTrainMercenaryTime::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqFriendTrainMercenaryTime::Swap(ReqFriendTrainMercenaryTime* other) {
  if (other != this) {
    std::swap(train_id_, other->train_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqFriendTrainMercenaryTime::GetTypeName() const {
  return "message.ReqFriendTrainMercenaryTime";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqAccelerateTrainMercenary::kMercPosFieldNumber;
#endif  // !_MSC_VER

ReqAccelerateTrainMercenary::ReqAccelerateTrainMercenary()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqAccelerateTrainMercenary::InitAsDefaultInstance() {
}

ReqAccelerateTrainMercenary::ReqAccelerateTrainMercenary(const ReqAccelerateTrainMercenary& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqAccelerateTrainMercenary::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqAccelerateTrainMercenary::~ReqAccelerateTrainMercenary() {
  SharedDtor();
}

void ReqAccelerateTrainMercenary::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqAccelerateTrainMercenary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqAccelerateTrainMercenary& ReqAccelerateTrainMercenary::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqAccelerateTrainMercenary* ReqAccelerateTrainMercenary::default_instance_ = NULL;

ReqAccelerateTrainMercenary* ReqAccelerateTrainMercenary::New() const {
  return new ReqAccelerateTrainMercenary;
}

void ReqAccelerateTrainMercenary::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqAccelerateTrainMercenary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqAccelerateTrainMercenary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

}

int ReqAccelerateTrainMercenary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqAccelerateTrainMercenary::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqAccelerateTrainMercenary*>(&from));
}

void ReqAccelerateTrainMercenary::MergeFrom(const ReqAccelerateTrainMercenary& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
  }
}

void ReqAccelerateTrainMercenary::CopyFrom(const ReqAccelerateTrainMercenary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqAccelerateTrainMercenary::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqAccelerateTrainMercenary::Swap(ReqAccelerateTrainMercenary* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqAccelerateTrainMercenary::GetTypeName() const {
  return "message.ReqAccelerateTrainMercenary";
}


// ===================================================================

#ifndef _MSC_VER
const int AckFriendTrainMercenaryTime_FriendTrainInfo::kTypeIdFieldNumber;
const int AckFriendTrainMercenaryTime_FriendTrainInfo::kMercPosFieldNumber;
const int AckFriendTrainMercenaryTime_FriendTrainInfo::kIsHelpFieldNumber;
#endif  // !_MSC_VER

AckFriendTrainMercenaryTime_FriendTrainInfo::AckFriendTrainMercenaryTime_FriendTrainInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::InitAsDefaultInstance() {
}

AckFriendTrainMercenaryTime_FriendTrainInfo::AckFriendTrainMercenaryTime_FriendTrainInfo(const AckFriendTrainMercenaryTime_FriendTrainInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::SharedCtor() {
  _cached_size_ = 0;
  type_id_ = 0u;
  merc_pos_ = 0u;
  is_help_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckFriendTrainMercenaryTime_FriendTrainInfo::~AckFriendTrainMercenaryTime_FriendTrainInfo() {
  SharedDtor();
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckFriendTrainMercenaryTime_FriendTrainInfo& AckFriendTrainMercenaryTime_FriendTrainInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckFriendTrainMercenaryTime_FriendTrainInfo* AckFriendTrainMercenaryTime_FriendTrainInfo::default_instance_ = NULL;

AckFriendTrainMercenaryTime_FriendTrainInfo* AckFriendTrainMercenaryTime_FriendTrainInfo::New() const {
  return new AckFriendTrainMercenaryTime_FriendTrainInfo;
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_id_ = 0u;
    merc_pos_ = 0u;
    is_help_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckFriendTrainMercenaryTime_FriendTrainInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_id_)));
          set_has_type_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_merc_pos;
        break;
      }

      // required uint32 merc_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_help;
        break;
      }

      // required bool is_help = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_help:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_help_)));
          set_has_is_help();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 type_id = 1;
  if (has_type_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type_id(), output);
  }

  // required uint32 merc_pos = 2;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->merc_pos(), output);
  }

  // required bool is_help = 3;
  if (has_is_help()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_help(), output);
  }

}

int AckFriendTrainMercenaryTime_FriendTrainInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type_id = 1;
    if (has_type_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type_id());
    }

    // required uint32 merc_pos = 2;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // required bool is_help = 3;
    if (has_is_help()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckFriendTrainMercenaryTime_FriendTrainInfo*>(&from));
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::MergeFrom(const AckFriendTrainMercenaryTime_FriendTrainInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type_id()) {
      set_type_id(from.type_id());
    }
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_is_help()) {
      set_is_help(from.is_help());
    }
  }
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::CopyFrom(const AckFriendTrainMercenaryTime_FriendTrainInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckFriendTrainMercenaryTime_FriendTrainInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void AckFriendTrainMercenaryTime_FriendTrainInfo::Swap(AckFriendTrainMercenaryTime_FriendTrainInfo* other) {
  if (other != this) {
    std::swap(type_id_, other->type_id_);
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(is_help_, other->is_help_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckFriendTrainMercenaryTime_FriendTrainInfo::GetTypeName() const {
  return "message.AckFriendTrainMercenaryTime.FriendTrainInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AckFriendTrainMercenaryTime::kFriendTrainInfoFieldNumber;
#endif  // !_MSC_VER

AckFriendTrainMercenaryTime::AckFriendTrainMercenaryTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckFriendTrainMercenaryTime::InitAsDefaultInstance() {
}

AckFriendTrainMercenaryTime::AckFriendTrainMercenaryTime(const AckFriendTrainMercenaryTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckFriendTrainMercenaryTime::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckFriendTrainMercenaryTime::~AckFriendTrainMercenaryTime() {
  SharedDtor();
}

void AckFriendTrainMercenaryTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckFriendTrainMercenaryTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckFriendTrainMercenaryTime& AckFriendTrainMercenaryTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckFriendTrainMercenaryTime* AckFriendTrainMercenaryTime::default_instance_ = NULL;

AckFriendTrainMercenaryTime* AckFriendTrainMercenaryTime::New() const {
  return new AckFriendTrainMercenaryTime;
}

void AckFriendTrainMercenaryTime::Clear() {
  friend_train_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckFriendTrainMercenaryTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.AckFriendTrainMercenaryTime.FriendTrainInfo friend_train_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_friend_train_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_friend_train_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_friend_train_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckFriendTrainMercenaryTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.AckFriendTrainMercenaryTime.FriendTrainInfo friend_train_info = 1;
  for (int i = 0; i < this->friend_train_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->friend_train_info(i), output);
  }

}

int AckFriendTrainMercenaryTime::ByteSize() const {
  int total_size = 0;

  // repeated .message.AckFriendTrainMercenaryTime.FriendTrainInfo friend_train_info = 1;
  total_size += 1 * this->friend_train_info_size();
  for (int i = 0; i < this->friend_train_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->friend_train_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckFriendTrainMercenaryTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckFriendTrainMercenaryTime*>(&from));
}

void AckFriendTrainMercenaryTime::MergeFrom(const AckFriendTrainMercenaryTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  friend_train_info_.MergeFrom(from.friend_train_info_);
}

void AckFriendTrainMercenaryTime::CopyFrom(const AckFriendTrainMercenaryTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckFriendTrainMercenaryTime::IsInitialized() const {

  for (int i = 0; i < friend_train_info_size(); i++) {
    if (!this->friend_train_info(i).IsInitialized()) return false;
  }
  return true;
}

void AckFriendTrainMercenaryTime::Swap(AckFriendTrainMercenaryTime* other) {
  if (other != this) {
    friend_train_info_.Swap(&other->friend_train_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckFriendTrainMercenaryTime::GetTypeName() const {
  return "message.AckFriendTrainMercenaryTime";
}


// ===================================================================

#ifndef _MSC_VER
const int BuyMallItem::kMallIdFieldNumber;
const int BuyMallItem::kItemNumFieldNumber;
#endif  // !_MSC_VER

BuyMallItem::BuyMallItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BuyMallItem::InitAsDefaultInstance() {
}

BuyMallItem::BuyMallItem(const BuyMallItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BuyMallItem::SharedCtor() {
  _cached_size_ = 0;
  mall_id_ = 0u;
  item_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuyMallItem::~BuyMallItem() {
  SharedDtor();
}

void BuyMallItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BuyMallItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BuyMallItem& BuyMallItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BuyMallItem* BuyMallItem::default_instance_ = NULL;

BuyMallItem* BuyMallItem::New() const {
  return new BuyMallItem;
}

void BuyMallItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mall_id_ = 0u;
    item_num_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BuyMallItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 mall_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mall_id_)));
          set_has_mall_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_num;
        break;
      }

      // required uint32 item_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuyMallItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 mall_id = 1;
  if (has_mall_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mall_id(), output);
  }

  // required uint32 item_num = 2;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_num(), output);
  }

}

int BuyMallItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 mall_id = 1;
    if (has_mall_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mall_id());
    }

    // required uint32 item_num = 2;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuyMallItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BuyMallItem*>(&from));
}

void BuyMallItem::MergeFrom(const BuyMallItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mall_id()) {
      set_mall_id(from.mall_id());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
  }
}

void BuyMallItem::CopyFrom(const BuyMallItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuyMallItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BuyMallItem::Swap(BuyMallItem* other) {
  if (other != this) {
    std::swap(mall_id_, other->mall_id_);
    std::swap(item_num_, other->item_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BuyMallItem::GetTypeName() const {
  return "message.BuyMallItem";
}


// ===================================================================

#ifndef _MSC_VER
const int DailyWeekOnline::kDayIdFieldNumber;
#endif  // !_MSC_VER

DailyWeekOnline::DailyWeekOnline()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DailyWeekOnline::InitAsDefaultInstance() {
}

DailyWeekOnline::DailyWeekOnline(const DailyWeekOnline& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DailyWeekOnline::SharedCtor() {
  _cached_size_ = 0;
  day_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DailyWeekOnline::~DailyWeekOnline() {
  SharedDtor();
}

void DailyWeekOnline::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DailyWeekOnline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DailyWeekOnline& DailyWeekOnline::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

DailyWeekOnline* DailyWeekOnline::default_instance_ = NULL;

DailyWeekOnline* DailyWeekOnline::New() const {
  return new DailyWeekOnline;
}

void DailyWeekOnline::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    day_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DailyWeekOnline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 day_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &day_id_)));
          set_has_day_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DailyWeekOnline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 day_id = 1;
  if (has_day_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->day_id(), output);
  }

}

int DailyWeekOnline::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 day_id = 1;
    if (has_day_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->day_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DailyWeekOnline::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DailyWeekOnline*>(&from));
}

void DailyWeekOnline::MergeFrom(const DailyWeekOnline& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_day_id()) {
      set_day_id(from.day_id());
    }
  }
}

void DailyWeekOnline::CopyFrom(const DailyWeekOnline& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DailyWeekOnline::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DailyWeekOnline::Swap(DailyWeekOnline* other) {
  if (other != this) {
    std::swap(day_id_, other->day_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DailyWeekOnline::GetTypeName() const {
  return "message.DailyWeekOnline";
}


// ===================================================================

#ifndef _MSC_VER
const int GetMonthSignInDataReq::kValueFieldNumber;
#endif  // !_MSC_VER

GetMonthSignInDataReq::GetMonthSignInDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetMonthSignInDataReq::InitAsDefaultInstance() {
}

GetMonthSignInDataReq::GetMonthSignInDataReq(const GetMonthSignInDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetMonthSignInDataReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMonthSignInDataReq::~GetMonthSignInDataReq() {
  SharedDtor();
}

void GetMonthSignInDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetMonthSignInDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetMonthSignInDataReq& GetMonthSignInDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetMonthSignInDataReq* GetMonthSignInDataReq::default_instance_ = NULL;

GetMonthSignInDataReq* GetMonthSignInDataReq::New() const {
  return new GetMonthSignInDataReq;
}

void GetMonthSignInDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetMonthSignInDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetMonthSignInDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int GetMonthSignInDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMonthSignInDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetMonthSignInDataReq*>(&from));
}

void GetMonthSignInDataReq::MergeFrom(const GetMonthSignInDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void GetMonthSignInDataReq::CopyFrom(const GetMonthSignInDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMonthSignInDataReq::IsInitialized() const {

  return true;
}

void GetMonthSignInDataReq::Swap(GetMonthSignInDataReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetMonthSignInDataReq::GetTypeName() const {
  return "message.GetMonthSignInDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetMonthSignInDataAck::kRefreshTimeFieldNumber;
const int GetMonthSignInDataAck::kItemIdFieldNumber;
const int GetMonthSignInDataAck::kItemNumFieldNumber;
const int GetMonthSignInDataAck::kVipLimitFieldNumber;
const int GetMonthSignInDataAck::kRewardTimesFieldNumber;
const int GetMonthSignInDataAck::kWeekItemIdFieldNumber;
const int GetMonthSignInDataAck::kWeekItemNumFieldNumber;
#endif  // !_MSC_VER

GetMonthSignInDataAck::GetMonthSignInDataAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetMonthSignInDataAck::InitAsDefaultInstance() {
}

GetMonthSignInDataAck::GetMonthSignInDataAck(const GetMonthSignInDataAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetMonthSignInDataAck::SharedCtor() {
  _cached_size_ = 0;
  refresh_time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMonthSignInDataAck::~GetMonthSignInDataAck() {
  SharedDtor();
}

void GetMonthSignInDataAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetMonthSignInDataAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetMonthSignInDataAck& GetMonthSignInDataAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetMonthSignInDataAck* GetMonthSignInDataAck::default_instance_ = NULL;

GetMonthSignInDataAck* GetMonthSignInDataAck::New() const {
  return new GetMonthSignInDataAck;
}

void GetMonthSignInDataAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    refresh_time_ = 0u;
  }
  item_id_.Clear();
  item_num_.Clear();
  vip_limit_.Clear();
  reward_times_.Clear();
  week_item_id_.Clear();
  week_item_num_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetMonthSignInDataAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 refresh_time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &refresh_time_)));
          set_has_refresh_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_id;
        break;
      }

      // repeated uint32 item_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_item_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_id;
        if (input->ExpectTag(24)) goto parse_item_num;
        break;
      }

      // repeated uint32 item_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_num;
        if (input->ExpectTag(32)) goto parse_vip_limit;
        break;
      }

      // repeated uint32 vip_limit = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_vip_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_vip_limit())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_vip_limit())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_vip_limit;
        if (input->ExpectTag(40)) goto parse_reward_times;
        break;
      }

      // repeated uint32 reward_times = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_reward_times())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_reward_times())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_reward_times;
        if (input->ExpectTag(48)) goto parse_week_item_id;
        break;
      }

      // repeated uint32 week_item_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_week_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_week_item_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_week_item_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_week_item_id;
        if (input->ExpectTag(56)) goto parse_week_item_num;
        break;
      }

      // repeated uint32 week_item_num = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_week_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56, input, this->mutable_week_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_week_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_week_item_num;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetMonthSignInDataAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 refresh_time = 1;
  if (has_refresh_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->refresh_time(), output);
  }

  // repeated uint32 item_id = 2;
  for (int i = 0; i < this->item_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->item_id(i), output);
  }

  // repeated uint32 item_num = 3;
  for (int i = 0; i < this->item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->item_num(i), output);
  }

  // repeated uint32 vip_limit = 4;
  for (int i = 0; i < this->vip_limit_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->vip_limit(i), output);
  }

  // repeated uint32 reward_times = 5;
  for (int i = 0; i < this->reward_times_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->reward_times(i), output);
  }

  // repeated uint32 week_item_id = 6;
  for (int i = 0; i < this->week_item_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->week_item_id(i), output);
  }

  // repeated uint32 week_item_num = 7;
  for (int i = 0; i < this->week_item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->week_item_num(i), output);
  }

}

int GetMonthSignInDataAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 refresh_time = 1;
    if (has_refresh_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->refresh_time());
    }

  }
  // repeated uint32 item_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_id(i));
    }
    total_size += 1 * this->item_id_size() + data_size;
  }

  // repeated uint32 item_num = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_num(i));
    }
    total_size += 1 * this->item_num_size() + data_size;
  }

  // repeated uint32 vip_limit = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->vip_limit_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->vip_limit(i));
    }
    total_size += 1 * this->vip_limit_size() + data_size;
  }

  // repeated uint32 reward_times = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->reward_times_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->reward_times(i));
    }
    total_size += 1 * this->reward_times_size() + data_size;
  }

  // repeated uint32 week_item_id = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->week_item_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->week_item_id(i));
    }
    total_size += 1 * this->week_item_id_size() + data_size;
  }

  // repeated uint32 week_item_num = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->week_item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->week_item_num(i));
    }
    total_size += 1 * this->week_item_num_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMonthSignInDataAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetMonthSignInDataAck*>(&from));
}

void GetMonthSignInDataAck::MergeFrom(const GetMonthSignInDataAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_id_.MergeFrom(from.item_id_);
  item_num_.MergeFrom(from.item_num_);
  vip_limit_.MergeFrom(from.vip_limit_);
  reward_times_.MergeFrom(from.reward_times_);
  week_item_id_.MergeFrom(from.week_item_id_);
  week_item_num_.MergeFrom(from.week_item_num_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_refresh_time()) {
      set_refresh_time(from.refresh_time());
    }
  }
}

void GetMonthSignInDataAck::CopyFrom(const GetMonthSignInDataAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMonthSignInDataAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetMonthSignInDataAck::Swap(GetMonthSignInDataAck* other) {
  if (other != this) {
    std::swap(refresh_time_, other->refresh_time_);
    item_id_.Swap(&other->item_id_);
    item_num_.Swap(&other->item_num_);
    vip_limit_.Swap(&other->vip_limit_);
    reward_times_.Swap(&other->reward_times_);
    week_item_id_.Swap(&other->week_item_id_);
    week_item_num_.Swap(&other->week_item_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetMonthSignInDataAck::GetTypeName() const {
  return "message.GetMonthSignInDataAck";
}


// ===================================================================

#ifndef _MSC_VER
const int DailyMonthOnline::kDayIdFieldNumber;
#endif  // !_MSC_VER

DailyMonthOnline::DailyMonthOnline()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DailyMonthOnline::InitAsDefaultInstance() {
}

DailyMonthOnline::DailyMonthOnline(const DailyMonthOnline& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DailyMonthOnline::SharedCtor() {
  _cached_size_ = 0;
  day_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DailyMonthOnline::~DailyMonthOnline() {
  SharedDtor();
}

void DailyMonthOnline::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DailyMonthOnline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DailyMonthOnline& DailyMonthOnline::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

DailyMonthOnline* DailyMonthOnline::default_instance_ = NULL;

DailyMonthOnline* DailyMonthOnline::New() const {
  return new DailyMonthOnline;
}

void DailyMonthOnline::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    day_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DailyMonthOnline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 day_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &day_id_)));
          set_has_day_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DailyMonthOnline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 day_id = 1;
  if (has_day_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->day_id(), output);
  }

}

int DailyMonthOnline::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 day_id = 1;
    if (has_day_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->day_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DailyMonthOnline::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DailyMonthOnline*>(&from));
}

void DailyMonthOnline::MergeFrom(const DailyMonthOnline& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_day_id()) {
      set_day_id(from.day_id());
    }
  }
}

void DailyMonthOnline::CopyFrom(const DailyMonthOnline& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DailyMonthOnline::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DailyMonthOnline::Swap(DailyMonthOnline* other) {
  if (other != this) {
    std::swap(day_id_, other->day_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DailyMonthOnline::GetTypeName() const {
  return "message.DailyMonthOnline";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqDailyMonthOnlineData::kDataIdFieldNumber;
#endif  // !_MSC_VER

ReqDailyMonthOnlineData::ReqDailyMonthOnlineData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqDailyMonthOnlineData::InitAsDefaultInstance() {
}

ReqDailyMonthOnlineData::ReqDailyMonthOnlineData(const ReqDailyMonthOnlineData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqDailyMonthOnlineData::SharedCtor() {
  _cached_size_ = 0;
  data_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqDailyMonthOnlineData::~ReqDailyMonthOnlineData() {
  SharedDtor();
}

void ReqDailyMonthOnlineData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqDailyMonthOnlineData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqDailyMonthOnlineData& ReqDailyMonthOnlineData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqDailyMonthOnlineData* ReqDailyMonthOnlineData::default_instance_ = NULL;

ReqDailyMonthOnlineData* ReqDailyMonthOnlineData::New() const {
  return new ReqDailyMonthOnlineData;
}

void ReqDailyMonthOnlineData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    data_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqDailyMonthOnlineData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 data_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_id_)));
          set_has_data_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqDailyMonthOnlineData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 data_id = 1;
  if (has_data_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->data_id(), output);
  }

}

int ReqDailyMonthOnlineData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 data_id = 1;
    if (has_data_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqDailyMonthOnlineData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqDailyMonthOnlineData*>(&from));
}

void ReqDailyMonthOnlineData::MergeFrom(const ReqDailyMonthOnlineData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data_id()) {
      set_data_id(from.data_id());
    }
  }
}

void ReqDailyMonthOnlineData::CopyFrom(const ReqDailyMonthOnlineData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqDailyMonthOnlineData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqDailyMonthOnlineData::Swap(ReqDailyMonthOnlineData* other) {
  if (other != this) {
    std::swap(data_id_, other->data_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqDailyMonthOnlineData::GetTypeName() const {
  return "message.ReqDailyMonthOnlineData";
}


// ===================================================================

#ifndef _MSC_VER
const int AckDailyMonthOnlineData::kDailyDataFieldNumber;
#endif  // !_MSC_VER

AckDailyMonthOnlineData::AckDailyMonthOnlineData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckDailyMonthOnlineData::InitAsDefaultInstance() {
}

AckDailyMonthOnlineData::AckDailyMonthOnlineData(const AckDailyMonthOnlineData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckDailyMonthOnlineData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckDailyMonthOnlineData::~AckDailyMonthOnlineData() {
  SharedDtor();
}

void AckDailyMonthOnlineData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckDailyMonthOnlineData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckDailyMonthOnlineData& AckDailyMonthOnlineData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckDailyMonthOnlineData* AckDailyMonthOnlineData::default_instance_ = NULL;

AckDailyMonthOnlineData* AckDailyMonthOnlineData::New() const {
  return new AckDailyMonthOnlineData;
}

void AckDailyMonthOnlineData::Clear() {
  daily_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckDailyMonthOnlineData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes daily_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_daily_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_daily_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_daily_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckDailyMonthOnlineData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes daily_data = 1;
  for (int i = 0; i < this->daily_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->daily_data(i), output);
  }

}

int AckDailyMonthOnlineData::ByteSize() const {
  int total_size = 0;

  // repeated bytes daily_data = 1;
  total_size += 1 * this->daily_data_size();
  for (int i = 0; i < this->daily_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->daily_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckDailyMonthOnlineData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckDailyMonthOnlineData*>(&from));
}

void AckDailyMonthOnlineData::MergeFrom(const AckDailyMonthOnlineData& from) {
  GOOGLE_CHECK_NE(&from, this);
  daily_data_.MergeFrom(from.daily_data_);
}

void AckDailyMonthOnlineData::CopyFrom(const AckDailyMonthOnlineData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckDailyMonthOnlineData::IsInitialized() const {

  return true;
}

void AckDailyMonthOnlineData::Swap(AckDailyMonthOnlineData* other) {
  if (other != this) {
    daily_data_.Swap(&other->daily_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckDailyMonthOnlineData::GetTypeName() const {
  return "message.AckDailyMonthOnlineData";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqSoulBag::kBagIdFieldNumber;
const int ReqSoulBag::kIsDestFieldNumber;
#endif  // !_MSC_VER

ReqSoulBag::ReqSoulBag()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqSoulBag::InitAsDefaultInstance() {
}

ReqSoulBag::ReqSoulBag(const ReqSoulBag& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqSoulBag::SharedCtor() {
  _cached_size_ = 0;
  bag_id_ = 0u;
  is_dest_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqSoulBag::~ReqSoulBag() {
  SharedDtor();
}

void ReqSoulBag::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqSoulBag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqSoulBag& ReqSoulBag::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqSoulBag* ReqSoulBag::default_instance_ = NULL;

ReqSoulBag* ReqSoulBag::New() const {
  return new ReqSoulBag;
}

void ReqSoulBag::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bag_id_ = 0u;
    is_dest_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqSoulBag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 bag_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bag_id_)));
          set_has_bag_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_dest;
        break;
      }

      // optional uint32 is_dest = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_dest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_dest_)));
          set_has_is_dest();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqSoulBag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 bag_id = 1;
  if (has_bag_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->bag_id(), output);
  }

  // optional uint32 is_dest = 2;
  if (has_is_dest()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->is_dest(), output);
  }

}

int ReqSoulBag::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 bag_id = 1;
    if (has_bag_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bag_id());
    }

    // optional uint32 is_dest = 2;
    if (has_is_dest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_dest());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqSoulBag::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqSoulBag*>(&from));
}

void ReqSoulBag::MergeFrom(const ReqSoulBag& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bag_id()) {
      set_bag_id(from.bag_id());
    }
    if (from.has_is_dest()) {
      set_is_dest(from.is_dest());
    }
  }
}

void ReqSoulBag::CopyFrom(const ReqSoulBag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqSoulBag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqSoulBag::Swap(ReqSoulBag* other) {
  if (other != this) {
    std::swap(bag_id_, other->bag_id_);
    std::swap(is_dest_, other->is_dest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqSoulBag::GetTypeName() const {
  return "message.ReqSoulBag";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqQuickSoulBag::kIsChooseFieldNumber;
#endif  // !_MSC_VER

ReqQuickSoulBag::ReqQuickSoulBag()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqQuickSoulBag::InitAsDefaultInstance() {
}

ReqQuickSoulBag::ReqQuickSoulBag(const ReqQuickSoulBag& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqQuickSoulBag::SharedCtor() {
  _cached_size_ = 0;
  is_choose_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqQuickSoulBag::~ReqQuickSoulBag() {
  SharedDtor();
}

void ReqQuickSoulBag::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqQuickSoulBag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqQuickSoulBag& ReqQuickSoulBag::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqQuickSoulBag* ReqQuickSoulBag::default_instance_ = NULL;

ReqQuickSoulBag* ReqQuickSoulBag::New() const {
  return new ReqQuickSoulBag;
}

void ReqQuickSoulBag::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    is_choose_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqQuickSoulBag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 is_choose = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_choose_)));
          set_has_is_choose();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqQuickSoulBag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 is_choose = 1;
  if (has_is_choose()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->is_choose(), output);
  }

}

int ReqQuickSoulBag::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 is_choose = 1;
    if (has_is_choose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_choose());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqQuickSoulBag::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqQuickSoulBag*>(&from));
}

void ReqQuickSoulBag::MergeFrom(const ReqQuickSoulBag& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_choose()) {
      set_is_choose(from.is_choose());
    }
  }
}

void ReqQuickSoulBag::CopyFrom(const ReqQuickSoulBag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqQuickSoulBag::IsInitialized() const {

  return true;
}

void ReqQuickSoulBag::Swap(ReqQuickSoulBag* other) {
  if (other != this) {
    std::swap(is_choose_, other->is_choose_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqQuickSoulBag::GetTypeName() const {
  return "message.ReqQuickSoulBag";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqChangeType::kValueFieldNumber;
#endif  // !_MSC_VER

ReqChangeType::ReqChangeType()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqChangeType::InitAsDefaultInstance() {
}

ReqChangeType::ReqChangeType(const ReqChangeType& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqChangeType::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqChangeType::~ReqChangeType() {
  SharedDtor();
}

void ReqChangeType::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqChangeType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqChangeType& ReqChangeType::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqChangeType* ReqChangeType::default_instance_ = NULL;

ReqChangeType* ReqChangeType::New() const {
  return new ReqChangeType;
}

void ReqChangeType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqChangeType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqChangeType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqChangeType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqChangeType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqChangeType*>(&from));
}

void ReqChangeType::MergeFrom(const ReqChangeType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqChangeType::CopyFrom(const ReqChangeType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqChangeType::IsInitialized() const {

  return true;
}

void ReqChangeType::Swap(ReqChangeType* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqChangeType::GetTypeName() const {
  return "message.ReqChangeType";
}


// ===================================================================

#ifndef _MSC_VER
const int AckSoulBag::kItemIdFieldNumber;
const int AckSoulBag::kIsDestFieldNumber;
#endif  // !_MSC_VER

AckSoulBag::AckSoulBag()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckSoulBag::InitAsDefaultInstance() {
}

AckSoulBag::AckSoulBag(const AckSoulBag& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckSoulBag::SharedCtor() {
  _cached_size_ = 0;
  is_dest_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckSoulBag::~AckSoulBag() {
  SharedDtor();
}

void AckSoulBag::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckSoulBag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckSoulBag& AckSoulBag::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckSoulBag* AckSoulBag::default_instance_ = NULL;

AckSoulBag* AckSoulBag::New() const {
  return new AckSoulBag;
}

void AckSoulBag::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    is_dest_ = 0u;
  }
  item_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckSoulBag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 item_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_item_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_item_id;
        if (input->ExpectTag(16)) goto parse_is_dest;
        break;
      }

      // optional uint32 is_dest = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_dest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_dest_)));
          set_has_is_dest();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckSoulBag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 item_id = 1;
  for (int i = 0; i < this->item_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->item_id(i), output);
  }

  // optional uint32 is_dest = 2;
  if (has_is_dest()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->is_dest(), output);
  }

}

int AckSoulBag::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 is_dest = 2;
    if (has_is_dest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_dest());
    }

  }
  // repeated uint32 item_id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_id(i));
    }
    total_size += 1 * this->item_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckSoulBag::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckSoulBag*>(&from));
}

void AckSoulBag::MergeFrom(const AckSoulBag& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_id_.MergeFrom(from.item_id_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_is_dest()) {
      set_is_dest(from.is_dest());
    }
  }
}

void AckSoulBag::CopyFrom(const AckSoulBag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckSoulBag::IsInitialized() const {

  return true;
}

void AckSoulBag::Swap(AckSoulBag* other) {
  if (other != this) {
    item_id_.Swap(&other->item_id_);
    std::swap(is_dest_, other->is_dest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckSoulBag::GetTypeName() const {
  return "message.AckSoulBag";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqSoulBagAction::kItemPosFieldNumber;
const int ReqSoulBagAction::kItemOnlyIdFieldNumber;
const int ReqSoulBagAction::kOperIdFieldNumber;
const int ReqSoulBagAction::kMercPosFieldNumber;
const int ReqSoulBagAction::kIsDestFieldNumber;
const int ReqSoulBagAction::kItemNumFieldNumber;
#endif  // !_MSC_VER

ReqSoulBagAction::ReqSoulBagAction()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqSoulBagAction::InitAsDefaultInstance() {
}

ReqSoulBagAction::ReqSoulBagAction(const ReqSoulBagAction& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqSoulBagAction::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  is_dest_ = 0u;
  item_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqSoulBagAction::~ReqSoulBagAction() {
  SharedDtor();
}

void ReqSoulBagAction::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqSoulBagAction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqSoulBagAction& ReqSoulBagAction::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqSoulBagAction* ReqSoulBagAction::default_instance_ = NULL;

ReqSoulBagAction* ReqSoulBagAction::New() const {
  return new ReqSoulBagAction;
}

void ReqSoulBagAction::Clear() {
  if (_has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    merc_pos_ = 0u;
    is_dest_ = 0u;
    item_num_ = 0u;
  }
  item_pos_.Clear();
  item_only_id_.Clear();
  oper_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqSoulBagAction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 item_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_item_pos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_pos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_item_pos;
        if (input->ExpectTag(16)) goto parse_item_only_id;
        break;
      }

      // repeated uint64 item_only_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_only_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_item_only_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_item_only_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_only_id;
        if (input->ExpectTag(24)) goto parse_oper_id;
        break;
      }

      // repeated uint32 oper_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_oper_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_oper_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_oper_id;
        if (input->ExpectTag(32)) goto parse_merc_pos;
        break;
      }

      // optional uint32 merc_pos = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_is_dest;
        break;
      }

      // optional uint32 is_dest = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_dest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_dest_)));
          set_has_is_dest();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_item_num;
        break;
      }

      // optional uint32 item_num = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqSoulBagAction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 item_pos = 1;
  for (int i = 0; i < this->item_pos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->item_pos(i), output);
  }

  // repeated uint64 item_only_id = 2;
  for (int i = 0; i < this->item_only_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->item_only_id(i), output);
  }

  // repeated uint32 oper_id = 3;
  for (int i = 0; i < this->oper_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->oper_id(i), output);
  }

  // optional uint32 merc_pos = 4;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->merc_pos(), output);
  }

  // optional uint32 is_dest = 5;
  if (has_is_dest()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->is_dest(), output);
  }

  // optional uint32 item_num = 6;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->item_num(), output);
  }

}

int ReqSoulBagAction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    // optional uint32 merc_pos = 4;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // optional uint32 is_dest = 5;
    if (has_is_dest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_dest());
    }

    // optional uint32 item_num = 6;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_num());
    }

  }
  // repeated uint32 item_pos = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_pos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_pos(i));
    }
    total_size += 1 * this->item_pos_size() + data_size;
  }

  // repeated uint64 item_only_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_only_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->item_only_id(i));
    }
    total_size += 1 * this->item_only_id_size() + data_size;
  }

  // repeated uint32 oper_id = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->oper_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->oper_id(i));
    }
    total_size += 1 * this->oper_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqSoulBagAction::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqSoulBagAction*>(&from));
}

void ReqSoulBagAction::MergeFrom(const ReqSoulBagAction& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_pos_.MergeFrom(from.item_pos_);
  item_only_id_.MergeFrom(from.item_only_id_);
  oper_id_.MergeFrom(from.oper_id_);
  if (from._has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_is_dest()) {
      set_is_dest(from.is_dest());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
  }
}

void ReqSoulBagAction::CopyFrom(const ReqSoulBagAction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqSoulBagAction::IsInitialized() const {

  return true;
}

void ReqSoulBagAction::Swap(ReqSoulBagAction* other) {
  if (other != this) {
    item_pos_.Swap(&other->item_pos_);
    item_only_id_.Swap(&other->item_only_id_);
    oper_id_.Swap(&other->oper_id_);
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(is_dest_, other->is_dest_);
    std::swap(item_num_, other->item_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqSoulBagAction::GetTypeName() const {
  return "message.ReqSoulBagAction";
}


// ===================================================================

#ifndef _MSC_VER
const int AckSoulBagAction::kMoneyFieldNumber;
const int AckSoulBagAction::kAttrPointFieldNumber;
const int AckSoulBagAction::kDestGlodFieldNumber;
#endif  // !_MSC_VER

AckSoulBagAction::AckSoulBagAction()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckSoulBagAction::InitAsDefaultInstance() {
}

AckSoulBagAction::AckSoulBagAction(const AckSoulBagAction& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckSoulBagAction::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckSoulBagAction::~AckSoulBagAction() {
  SharedDtor();
}

void AckSoulBagAction::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckSoulBagAction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckSoulBagAction& AckSoulBagAction::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckSoulBagAction* AckSoulBagAction::default_instance_ = NULL;

AckSoulBagAction* AckSoulBagAction::New() const {
  return new AckSoulBagAction;
}

void AckSoulBagAction::Clear() {
  money_.Clear();
  attr_point_.Clear();
  dest_glod_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckSoulBagAction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 money = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_money())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_money())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_money;
        if (input->ExpectTag(16)) goto parse_attr_point;
        break;
      }

      // repeated uint32 attr_point = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attr_point:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_attr_point())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_attr_point())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_attr_point;
        if (input->ExpectTag(24)) goto parse_dest_glod;
        break;
      }

      // repeated uint32 dest_glod = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dest_glod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_dest_glod())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_dest_glod())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_dest_glod;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckSoulBagAction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 money = 1;
  for (int i = 0; i < this->money_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->money(i), output);
  }

  // repeated uint32 attr_point = 2;
  for (int i = 0; i < this->attr_point_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->attr_point(i), output);
  }

  // repeated uint32 dest_glod = 3;
  for (int i = 0; i < this->dest_glod_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->dest_glod(i), output);
  }

}

int AckSoulBagAction::ByteSize() const {
  int total_size = 0;

  // repeated uint32 money = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->money_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->money(i));
    }
    total_size += 1 * this->money_size() + data_size;
  }

  // repeated uint32 attr_point = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->attr_point_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->attr_point(i));
    }
    total_size += 1 * this->attr_point_size() + data_size;
  }

  // repeated uint32 dest_glod = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->dest_glod_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->dest_glod(i));
    }
    total_size += 1 * this->dest_glod_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckSoulBagAction::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckSoulBagAction*>(&from));
}

void AckSoulBagAction::MergeFrom(const AckSoulBagAction& from) {
  GOOGLE_CHECK_NE(&from, this);
  money_.MergeFrom(from.money_);
  attr_point_.MergeFrom(from.attr_point_);
  dest_glod_.MergeFrom(from.dest_glod_);
}

void AckSoulBagAction::CopyFrom(const AckSoulBagAction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckSoulBagAction::IsInitialized() const {

  return true;
}

void AckSoulBagAction::Swap(AckSoulBagAction* other) {
  if (other != this) {
    money_.Swap(&other->money_);
    attr_point_.Swap(&other->attr_point_);
    dest_glod_.Swap(&other->dest_glod_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckSoulBagAction::GetTypeName() const {
  return "message.AckSoulBagAction";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqSoulCombine::kCombineIdFieldNumber;
#endif  // !_MSC_VER

ReqSoulCombine::ReqSoulCombine()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqSoulCombine::InitAsDefaultInstance() {
}

ReqSoulCombine::ReqSoulCombine(const ReqSoulCombine& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqSoulCombine::SharedCtor() {
  _cached_size_ = 0;
  combine_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqSoulCombine::~ReqSoulCombine() {
  SharedDtor();
}

void ReqSoulCombine::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqSoulCombine::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqSoulCombine& ReqSoulCombine::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqSoulCombine* ReqSoulCombine::default_instance_ = NULL;

ReqSoulCombine* ReqSoulCombine::New() const {
  return new ReqSoulCombine;
}

void ReqSoulCombine::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    combine_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqSoulCombine::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 combine_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &combine_id_)));
          set_has_combine_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqSoulCombine::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 combine_id = 1;
  if (has_combine_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->combine_id(), output);
  }

}

int ReqSoulCombine::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 combine_id = 1;
    if (has_combine_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->combine_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqSoulCombine::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqSoulCombine*>(&from));
}

void ReqSoulCombine::MergeFrom(const ReqSoulCombine& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_combine_id()) {
      set_combine_id(from.combine_id());
    }
  }
}

void ReqSoulCombine::CopyFrom(const ReqSoulCombine& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqSoulCombine::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqSoulCombine::Swap(ReqSoulCombine* other) {
  if (other != this) {
    std::swap(combine_id_, other->combine_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqSoulCombine::GetTypeName() const {
  return "message.ReqSoulCombine";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqPlatMoney::kAppIdFieldNumber;
const int ReqPlatMoney::kOrderIdFieldNumber;
#endif  // !_MSC_VER

ReqPlatMoney::ReqPlatMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqPlatMoney::InitAsDefaultInstance() {
}

ReqPlatMoney::ReqPlatMoney(const ReqPlatMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqPlatMoney::SharedCtor() {
  _cached_size_ = 0;
  app_id_ = 0u;
  order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqPlatMoney::~ReqPlatMoney() {
  SharedDtor();
}

void ReqPlatMoney::SharedDtor() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqPlatMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqPlatMoney& ReqPlatMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqPlatMoney* ReqPlatMoney::default_instance_ = NULL;

ReqPlatMoney* ReqPlatMoney::New() const {
  return new ReqPlatMoney;
}

void ReqPlatMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    app_id_ = 0u;
    if (has_order_id()) {
      if (order_id_ != &::google::protobuf::internal::kEmptyString) {
        order_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqPlatMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 app_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &app_id_)));
          set_has_app_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_order_id;
        break;
      }

      // required bytes order_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_order_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_order_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqPlatMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 app_id = 1;
  if (has_app_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->app_id(), output);
  }

  // required bytes order_id = 2;
  if (has_order_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->order_id(), output);
  }

}

int ReqPlatMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 app_id = 1;
    if (has_app_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->app_id());
    }

    // required bytes order_id = 2;
    if (has_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->order_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqPlatMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqPlatMoney*>(&from));
}

void ReqPlatMoney::MergeFrom(const ReqPlatMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_app_id()) {
      set_app_id(from.app_id());
    }
    if (from.has_order_id()) {
      set_order_id(from.order_id());
    }
  }
}

void ReqPlatMoney::CopyFrom(const ReqPlatMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqPlatMoney::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ReqPlatMoney::Swap(ReqPlatMoney* other) {
  if (other != this) {
    std::swap(app_id_, other->app_id_);
    std::swap(order_id_, other->order_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqPlatMoney::GetTypeName() const {
  return "message.ReqPlatMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqPlatOrderID::kAppIdFieldNumber;
#endif  // !_MSC_VER

ReqPlatOrderID::ReqPlatOrderID()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqPlatOrderID::InitAsDefaultInstance() {
}

ReqPlatOrderID::ReqPlatOrderID(const ReqPlatOrderID& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqPlatOrderID::SharedCtor() {
  _cached_size_ = 0;
  app_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqPlatOrderID::~ReqPlatOrderID() {
  SharedDtor();
}

void ReqPlatOrderID::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqPlatOrderID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqPlatOrderID& ReqPlatOrderID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqPlatOrderID* ReqPlatOrderID::default_instance_ = NULL;

ReqPlatOrderID* ReqPlatOrderID::New() const {
  return new ReqPlatOrderID;
}

void ReqPlatOrderID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    app_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqPlatOrderID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 app_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &app_id_)));
          set_has_app_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqPlatOrderID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 app_id = 1;
  if (has_app_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->app_id(), output);
  }

}

int ReqPlatOrderID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 app_id = 1;
    if (has_app_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->app_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqPlatOrderID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqPlatOrderID*>(&from));
}

void ReqPlatOrderID::MergeFrom(const ReqPlatOrderID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_app_id()) {
      set_app_id(from.app_id());
    }
  }
}

void ReqPlatOrderID::CopyFrom(const ReqPlatOrderID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqPlatOrderID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqPlatOrderID::Swap(ReqPlatOrderID* other) {
  if (other != this) {
    std::swap(app_id_, other->app_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqPlatOrderID::GetTypeName() const {
  return "message.ReqPlatOrderID";
}


// ===================================================================

#ifndef _MSC_VER
const int AckPlatOrderID::kOrderIdFieldNumber;
#endif  // !_MSC_VER

AckPlatOrderID::AckPlatOrderID()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckPlatOrderID::InitAsDefaultInstance() {
}

AckPlatOrderID::AckPlatOrderID(const AckPlatOrderID& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckPlatOrderID::SharedCtor() {
  _cached_size_ = 0;
  order_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckPlatOrderID::~AckPlatOrderID() {
  SharedDtor();
}

void AckPlatOrderID::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckPlatOrderID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckPlatOrderID& AckPlatOrderID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckPlatOrderID* AckPlatOrderID::default_instance_ = NULL;

AckPlatOrderID* AckPlatOrderID::New() const {
  return new AckPlatOrderID;
}

void AckPlatOrderID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    order_id_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckPlatOrderID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 order_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &order_id_)));
          set_has_order_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckPlatOrderID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 order_id = 1;
  if (has_order_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->order_id(), output);
  }

}

int AckPlatOrderID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 order_id = 1;
    if (has_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->order_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckPlatOrderID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckPlatOrderID*>(&from));
}

void AckPlatOrderID::MergeFrom(const AckPlatOrderID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_order_id()) {
      set_order_id(from.order_id());
    }
  }
}

void AckPlatOrderID::CopyFrom(const AckPlatOrderID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckPlatOrderID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckPlatOrderID::Swap(AckPlatOrderID* other) {
  if (other != this) {
    std::swap(order_id_, other->order_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckPlatOrderID::GetTypeName() const {
  return "message.AckPlatOrderID";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqAddStamina::kStaminaFieldNumber;
#endif  // !_MSC_VER

ReqAddStamina::ReqAddStamina()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqAddStamina::InitAsDefaultInstance() {
}

ReqAddStamina::ReqAddStamina(const ReqAddStamina& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqAddStamina::SharedCtor() {
  _cached_size_ = 0;
  stamina_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqAddStamina::~ReqAddStamina() {
  SharedDtor();
}

void ReqAddStamina::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqAddStamina::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqAddStamina& ReqAddStamina::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqAddStamina* ReqAddStamina::default_instance_ = NULL;

ReqAddStamina* ReqAddStamina::New() const {
  return new ReqAddStamina;
}

void ReqAddStamina::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    stamina_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqAddStamina::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 stamina = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stamina_)));
          set_has_stamina();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqAddStamina::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 stamina = 1;
  if (has_stamina()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->stamina(), output);
  }

}

int ReqAddStamina::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 stamina = 1;
    if (has_stamina()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stamina());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqAddStamina::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqAddStamina*>(&from));
}

void ReqAddStamina::MergeFrom(const ReqAddStamina& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stamina()) {
      set_stamina(from.stamina());
    }
  }
}

void ReqAddStamina::CopyFrom(const ReqAddStamina& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqAddStamina::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqAddStamina::Swap(ReqAddStamina* other) {
  if (other != this) {
    std::swap(stamina_, other->stamina_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqAddStamina::GetTypeName() const {
  return "message.ReqAddStamina";
}


// ===================================================================

#ifndef _MSC_VER
const int OfflineTrainMercenary::kNmercposFieldNumber;
const int OfflineTrainMercenary::kNtraintypeFieldNumber;
const int OfflineTrainMercenary::kNfriendidFieldNumber;
#endif  // !_MSC_VER

OfflineTrainMercenary::OfflineTrainMercenary()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OfflineTrainMercenary::InitAsDefaultInstance() {
}

OfflineTrainMercenary::OfflineTrainMercenary(const OfflineTrainMercenary& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OfflineTrainMercenary::SharedCtor() {
  _cached_size_ = 0;
  nmercpos_ = 0u;
  ntraintype_ = 0u;
  nfriendid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OfflineTrainMercenary::~OfflineTrainMercenary() {
  SharedDtor();
}

void OfflineTrainMercenary::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OfflineTrainMercenary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OfflineTrainMercenary& OfflineTrainMercenary::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OfflineTrainMercenary* OfflineTrainMercenary::default_instance_ = NULL;

OfflineTrainMercenary* OfflineTrainMercenary::New() const {
  return new OfflineTrainMercenary;
}

void OfflineTrainMercenary::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    nmercpos_ = 0u;
    ntraintype_ = 0u;
    nfriendid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OfflineTrainMercenary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 nmercpos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nmercpos_)));
          set_has_nmercpos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ntraintype;
        break;
      }

      // required uint32 ntraintype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ntraintype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ntraintype_)));
          set_has_ntraintype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_nfriendid;
        break;
      }

      // required uint32 nfriendid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nfriendid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nfriendid_)));
          set_has_nfriendid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OfflineTrainMercenary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 nmercpos = 1;
  if (has_nmercpos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->nmercpos(), output);
  }

  // required uint32 ntraintype = 2;
  if (has_ntraintype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ntraintype(), output);
  }

  // required uint32 nfriendid = 3;
  if (has_nfriendid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->nfriendid(), output);
  }

}

int OfflineTrainMercenary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 nmercpos = 1;
    if (has_nmercpos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nmercpos());
    }

    // required uint32 ntraintype = 2;
    if (has_ntraintype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ntraintype());
    }

    // required uint32 nfriendid = 3;
    if (has_nfriendid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nfriendid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OfflineTrainMercenary::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OfflineTrainMercenary*>(&from));
}

void OfflineTrainMercenary::MergeFrom(const OfflineTrainMercenary& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nmercpos()) {
      set_nmercpos(from.nmercpos());
    }
    if (from.has_ntraintype()) {
      set_ntraintype(from.ntraintype());
    }
    if (from.has_nfriendid()) {
      set_nfriendid(from.nfriendid());
    }
  }
}

void OfflineTrainMercenary::CopyFrom(const OfflineTrainMercenary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineTrainMercenary::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void OfflineTrainMercenary::Swap(OfflineTrainMercenary* other) {
  if (other != this) {
    std::swap(nmercpos_, other->nmercpos_);
    std::swap(ntraintype_, other->ntraintype_);
    std::swap(nfriendid_, other->nfriendid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OfflineTrainMercenary::GetTypeName() const {
  return "message.OfflineTrainMercenary";
}


// ===================================================================

#ifndef _MSC_VER
const int OfflineOper::kFromCharIdFieldNumber;
const int OfflineOper::kToCharIdFieldNumber;
const int OfflineOper::kOperIdFieldNumber;
const int OfflineOper::kOperValue1FieldNumber;
const int OfflineOper::kOperValue2FieldNumber;
const int OfflineOper::kOperPosFieldNumber;
const int OfflineOper::kOperTimeFieldNumber;
const int OfflineOper::kModeIdFieldNumber;
#endif  // !_MSC_VER

OfflineOper::OfflineOper()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OfflineOper::InitAsDefaultInstance() {
}

OfflineOper::OfflineOper(const OfflineOper& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OfflineOper::SharedCtor() {
  _cached_size_ = 0;
  from_char_id_ = 0u;
  to_char_id_ = 0u;
  oper_id_ = 0u;
  oper_value1_ = 0u;
  oper_value2_ = 0u;
  oper_pos_ = 0u;
  oper_time_ = GOOGLE_ULONGLONG(0);
  mode_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OfflineOper::~OfflineOper() {
  SharedDtor();
}

void OfflineOper::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OfflineOper::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OfflineOper& OfflineOper::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OfflineOper* OfflineOper::default_instance_ = NULL;

OfflineOper* OfflineOper::New() const {
  return new OfflineOper;
}

void OfflineOper::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    from_char_id_ = 0u;
    to_char_id_ = 0u;
    oper_id_ = 0u;
    oper_value1_ = 0u;
    oper_value2_ = 0u;
    oper_pos_ = 0u;
    oper_time_ = GOOGLE_ULONGLONG(0);
    mode_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OfflineOper::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_char_id_)));
          set_has_from_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_char_id;
        break;
      }

      // required uint32 to_char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_char_id_)));
          set_has_to_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_oper_id;
        break;
      }

      // required uint32 oper_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_id_)));
          set_has_oper_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_oper_value1;
        break;
      }

      // required uint32 oper_value1 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_value1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_value1_)));
          set_has_oper_value1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_oper_value2;
        break;
      }

      // required uint32 oper_value2 = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_value2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_value2_)));
          set_has_oper_value2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_oper_pos;
        break;
      }

      // required uint32 oper_pos = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_pos_)));
          set_has_oper_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_oper_time;
        break;
      }

      // required uint64 oper_time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &oper_time_)));
          set_has_oper_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_mode_id;
        break;
      }

      // optional uint32 mode_id = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mode_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_id_)));
          set_has_mode_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OfflineOper::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 from_char_id = 1;
  if (has_from_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_char_id(), output);
  }

  // required uint32 to_char_id = 2;
  if (has_to_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_char_id(), output);
  }

  // required uint32 oper_id = 3;
  if (has_oper_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->oper_id(), output);
  }

  // required uint32 oper_value1 = 4;
  if (has_oper_value1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->oper_value1(), output);
  }

  // required uint32 oper_value2 = 5;
  if (has_oper_value2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->oper_value2(), output);
  }

  // required uint32 oper_pos = 6;
  if (has_oper_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->oper_pos(), output);
  }

  // required uint64 oper_time = 7;
  if (has_oper_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->oper_time(), output);
  }

  // optional uint32 mode_id = 8;
  if (has_mode_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->mode_id(), output);
  }

}

int OfflineOper::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_char_id = 1;
    if (has_from_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_char_id());
    }

    // required uint32 to_char_id = 2;
    if (has_to_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_char_id());
    }

    // required uint32 oper_id = 3;
    if (has_oper_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_id());
    }

    // required uint32 oper_value1 = 4;
    if (has_oper_value1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_value1());
    }

    // required uint32 oper_value2 = 5;
    if (has_oper_value2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_value2());
    }

    // required uint32 oper_pos = 6;
    if (has_oper_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_pos());
    }

    // required uint64 oper_time = 7;
    if (has_oper_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->oper_time());
    }

    // optional uint32 mode_id = 8;
    if (has_mode_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mode_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OfflineOper::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OfflineOper*>(&from));
}

void OfflineOper::MergeFrom(const OfflineOper& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_char_id()) {
      set_from_char_id(from.from_char_id());
    }
    if (from.has_to_char_id()) {
      set_to_char_id(from.to_char_id());
    }
    if (from.has_oper_id()) {
      set_oper_id(from.oper_id());
    }
    if (from.has_oper_value1()) {
      set_oper_value1(from.oper_value1());
    }
    if (from.has_oper_value2()) {
      set_oper_value2(from.oper_value2());
    }
    if (from.has_oper_pos()) {
      set_oper_pos(from.oper_pos());
    }
    if (from.has_oper_time()) {
      set_oper_time(from.oper_time());
    }
    if (from.has_mode_id()) {
      set_mode_id(from.mode_id());
    }
  }
}

void OfflineOper::CopyFrom(const OfflineOper& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineOper::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void OfflineOper::Swap(OfflineOper* other) {
  if (other != this) {
    std::swap(from_char_id_, other->from_char_id_);
    std::swap(to_char_id_, other->to_char_id_);
    std::swap(oper_id_, other->oper_id_);
    std::swap(oper_value1_, other->oper_value1_);
    std::swap(oper_value2_, other->oper_value2_);
    std::swap(oper_pos_, other->oper_pos_);
    std::swap(oper_time_, other->oper_time_);
    std::swap(mode_id_, other->mode_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OfflineOper::GetTypeName() const {
  return "message.OfflineOper";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqOfflineOperList::kAccIdFieldNumber;
const int ReqOfflineOperList::kCharIdFieldNumber;
const int ReqOfflineOperList::kIsDeleteFieldNumber;
const int ReqOfflineOperList::kOperIdFieldNumber;
#endif  // !_MSC_VER

ReqOfflineOperList::ReqOfflineOperList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqOfflineOperList::InitAsDefaultInstance() {
}

ReqOfflineOperList::ReqOfflineOperList(const ReqOfflineOperList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqOfflineOperList::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  is_delete_ = 0u;
  oper_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqOfflineOperList::~ReqOfflineOperList() {
  SharedDtor();
}

void ReqOfflineOperList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqOfflineOperList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqOfflineOperList& ReqOfflineOperList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqOfflineOperList* ReqOfflineOperList::default_instance_ = NULL;

ReqOfflineOperList* ReqOfflineOperList::New() const {
  return new ReqOfflineOperList;
}

void ReqOfflineOperList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    is_delete_ = 0u;
    oper_id_ = 0u;
  }
  char_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqOfflineOperList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // repeated uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_char_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_char_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        if (input->ExpectTag(24)) goto parse_is_delete;
        break;
      }

      // optional uint32 is_delete = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_delete_)));
          set_has_is_delete();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_oper_id;
        break;
      }

      // optional uint32 oper_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_id_)));
          set_has_oper_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqOfflineOperList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // repeated uint32 char_id = 2;
  for (int i = 0; i < this->char_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->char_id(i), output);
  }

  // optional uint32 is_delete = 3;
  if (has_is_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->is_delete(), output);
  }

  // optional uint32 oper_id = 4;
  if (has_oper_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->oper_id(), output);
  }

}

int ReqOfflineOperList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional uint32 is_delete = 3;
    if (has_is_delete()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_delete());
    }

    // optional uint32 oper_id = 4;
    if (has_oper_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_id());
    }

  }
  // repeated uint32 char_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->char_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->char_id(i));
    }
    total_size += 1 * this->char_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqOfflineOperList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqOfflineOperList*>(&from));
}

void ReqOfflineOperList::MergeFrom(const ReqOfflineOperList& from) {
  GOOGLE_CHECK_NE(&from, this);
  char_id_.MergeFrom(from.char_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_is_delete()) {
      set_is_delete(from.is_delete());
    }
    if (from.has_oper_id()) {
      set_oper_id(from.oper_id());
    }
  }
}

void ReqOfflineOperList::CopyFrom(const ReqOfflineOperList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqOfflineOperList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqOfflineOperList::Swap(ReqOfflineOperList* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    char_id_.Swap(&other->char_id_);
    std::swap(is_delete_, other->is_delete_);
    std::swap(oper_id_, other->oper_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqOfflineOperList::GetTypeName() const {
  return "message.ReqOfflineOperList";
}


// ===================================================================

#ifndef _MSC_VER
const int AckOfflineOperList::kFromCharIdFieldNumber;
const int AckOfflineOperList::kToCharIdFieldNumber;
const int AckOfflineOperList::kOperIdFieldNumber;
const int AckOfflineOperList::kOperValue1FieldNumber;
const int AckOfflineOperList::kOperValue2FieldNumber;
const int AckOfflineOperList::kOperPosFieldNumber;
const int AckOfflineOperList::kOperTimeFieldNumber;
const int AckOfflineOperList::kModeIdFieldNumber;
const int AckOfflineOperList::kSysMsgFieldNumber;
#endif  // !_MSC_VER

AckOfflineOperList::AckOfflineOperList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckOfflineOperList::InitAsDefaultInstance() {
}

AckOfflineOperList::AckOfflineOperList(const AckOfflineOperList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckOfflineOperList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckOfflineOperList::~AckOfflineOperList() {
  SharedDtor();
}

void AckOfflineOperList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckOfflineOperList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckOfflineOperList& AckOfflineOperList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckOfflineOperList* AckOfflineOperList::default_instance_ = NULL;

AckOfflineOperList* AckOfflineOperList::New() const {
  return new AckOfflineOperList;
}

void AckOfflineOperList::Clear() {
  from_char_id_.Clear();
  to_char_id_.Clear();
  oper_id_.Clear();
  oper_value1_.Clear();
  oper_value2_.Clear();
  oper_pos_.Clear();
  oper_time_.Clear();
  mode_id_.Clear();
  sys_msg_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckOfflineOperList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 from_char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_from_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_from_char_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_from_char_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_from_char_id;
        if (input->ExpectTag(16)) goto parse_to_char_id;
        break;
      }

      // repeated uint32 to_char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_to_char_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_to_char_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_char_id;
        if (input->ExpectTag(24)) goto parse_oper_id;
        break;
      }

      // repeated uint32 oper_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_oper_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_oper_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_oper_id;
        if (input->ExpectTag(32)) goto parse_oper_value1;
        break;
      }

      // repeated uint32 oper_value1 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_value1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_oper_value1())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_oper_value1())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_oper_value1;
        if (input->ExpectTag(40)) goto parse_oper_value2;
        break;
      }

      // repeated uint32 oper_value2 = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_value2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_oper_value2())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_oper_value2())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_oper_value2;
        if (input->ExpectTag(48)) goto parse_oper_pos;
        break;
      }

      // repeated uint32 oper_pos = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_oper_pos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_oper_pos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_oper_pos;
        if (input->ExpectTag(56)) goto parse_oper_time;
        break;
      }

      // repeated uint64 oper_time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 56, input, this->mutable_oper_time())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_oper_time())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_oper_time;
        if (input->ExpectTag(64)) goto parse_mode_id;
        break;
      }

      // repeated uint32 mode_id = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mode_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_mode_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_mode_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_mode_id;
        if (input->ExpectTag(74)) goto parse_sys_msg;
        break;
      }

      // repeated bytes sys_msg = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sys_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_sys_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_sys_msg;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckOfflineOperList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 from_char_id = 1;
  for (int i = 0; i < this->from_char_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->from_char_id(i), output);
  }

  // repeated uint32 to_char_id = 2;
  for (int i = 0; i < this->to_char_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->to_char_id(i), output);
  }

  // repeated uint32 oper_id = 3;
  for (int i = 0; i < this->oper_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->oper_id(i), output);
  }

  // repeated uint32 oper_value1 = 4;
  for (int i = 0; i < this->oper_value1_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->oper_value1(i), output);
  }

  // repeated uint32 oper_value2 = 5;
  for (int i = 0; i < this->oper_value2_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->oper_value2(i), output);
  }

  // repeated uint32 oper_pos = 6;
  for (int i = 0; i < this->oper_pos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->oper_pos(i), output);
  }

  // repeated uint64 oper_time = 7;
  for (int i = 0; i < this->oper_time_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      7, this->oper_time(i), output);
  }

  // repeated uint32 mode_id = 8;
  for (int i = 0; i < this->mode_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->mode_id(i), output);
  }

  // repeated bytes sys_msg = 9;
  for (int i = 0; i < this->sys_msg_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->sys_msg(i), output);
  }

}

int AckOfflineOperList::ByteSize() const {
  int total_size = 0;

  // repeated uint32 from_char_id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->from_char_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->from_char_id(i));
    }
    total_size += 1 * this->from_char_id_size() + data_size;
  }

  // repeated uint32 to_char_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->to_char_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->to_char_id(i));
    }
    total_size += 1 * this->to_char_id_size() + data_size;
  }

  // repeated uint32 oper_id = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->oper_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->oper_id(i));
    }
    total_size += 1 * this->oper_id_size() + data_size;
  }

  // repeated uint32 oper_value1 = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->oper_value1_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->oper_value1(i));
    }
    total_size += 1 * this->oper_value1_size() + data_size;
  }

  // repeated uint32 oper_value2 = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->oper_value2_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->oper_value2(i));
    }
    total_size += 1 * this->oper_value2_size() + data_size;
  }

  // repeated uint32 oper_pos = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->oper_pos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->oper_pos(i));
    }
    total_size += 1 * this->oper_pos_size() + data_size;
  }

  // repeated uint64 oper_time = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->oper_time_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->oper_time(i));
    }
    total_size += 1 * this->oper_time_size() + data_size;
  }

  // repeated uint32 mode_id = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->mode_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->mode_id(i));
    }
    total_size += 1 * this->mode_id_size() + data_size;
  }

  // repeated bytes sys_msg = 9;
  total_size += 1 * this->sys_msg_size();
  for (int i = 0; i < this->sys_msg_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->sys_msg(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckOfflineOperList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckOfflineOperList*>(&from));
}

void AckOfflineOperList::MergeFrom(const AckOfflineOperList& from) {
  GOOGLE_CHECK_NE(&from, this);
  from_char_id_.MergeFrom(from.from_char_id_);
  to_char_id_.MergeFrom(from.to_char_id_);
  oper_id_.MergeFrom(from.oper_id_);
  oper_value1_.MergeFrom(from.oper_value1_);
  oper_value2_.MergeFrom(from.oper_value2_);
  oper_pos_.MergeFrom(from.oper_pos_);
  oper_time_.MergeFrom(from.oper_time_);
  mode_id_.MergeFrom(from.mode_id_);
  sys_msg_.MergeFrom(from.sys_msg_);
}

void AckOfflineOperList::CopyFrom(const AckOfflineOperList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckOfflineOperList::IsInitialized() const {

  return true;
}

void AckOfflineOperList::Swap(AckOfflineOperList* other) {
  if (other != this) {
    from_char_id_.Swap(&other->from_char_id_);
    to_char_id_.Swap(&other->to_char_id_);
    oper_id_.Swap(&other->oper_id_);
    oper_value1_.Swap(&other->oper_value1_);
    oper_value2_.Swap(&other->oper_value2_);
    oper_pos_.Swap(&other->oper_pos_);
    oper_time_.Swap(&other->oper_time_);
    mode_id_.Swap(&other->mode_id_);
    sys_msg_.Swap(&other->sys_msg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckOfflineOperList::GetTypeName() const {
  return "message.AckOfflineOperList";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqActiveCode::kCodeFieldNumber;
const int ReqActiveCode::kIsInviteFieldNumber;
#endif  // !_MSC_VER

ReqActiveCode::ReqActiveCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqActiveCode::InitAsDefaultInstance() {
}

ReqActiveCode::ReqActiveCode(const ReqActiveCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqActiveCode::SharedCtor() {
  _cached_size_ = 0;
  is_invite_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqActiveCode::~ReqActiveCode() {
  SharedDtor();
}

void ReqActiveCode::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqActiveCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqActiveCode& ReqActiveCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqActiveCode* ReqActiveCode::default_instance_ = NULL;

ReqActiveCode* ReqActiveCode::New() const {
  return new ReqActiveCode;
}

void ReqActiveCode::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    is_invite_ = 0;
  }
  code_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqActiveCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_code;
        if (input->ExpectTag(16)) goto parse_is_invite;
        break;
      }

      // optional int32 is_invite = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_invite:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_invite_)));
          set_has_is_invite();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqActiveCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes code = 1;
  for (int i = 0; i < this->code_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->code(i), output);
  }

  // optional int32 is_invite = 2;
  if (has_is_invite()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->is_invite(), output);
  }

}

int ReqActiveCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 is_invite = 2;
    if (has_is_invite()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_invite());
    }

  }
  // repeated bytes code = 1;
  total_size += 1 * this->code_size();
  for (int i = 0; i < this->code_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->code(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqActiveCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqActiveCode*>(&from));
}

void ReqActiveCode::MergeFrom(const ReqActiveCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  code_.MergeFrom(from.code_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_is_invite()) {
      set_is_invite(from.is_invite());
    }
  }
}

void ReqActiveCode::CopyFrom(const ReqActiveCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqActiveCode::IsInitialized() const {

  return true;
}

void ReqActiveCode::Swap(ReqActiveCode* other) {
  if (other != this) {
    code_.Swap(&other->code_);
    std::swap(is_invite_, other->is_invite_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqActiveCode::GetTypeName() const {
  return "message.ReqActiveCode";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqServerActiveCode::kCodeFieldNumber;
const int ReqServerActiveCode::kIsDeleteFieldNumber;
const int ReqServerActiveCode::kItemIdFieldNumber;
const int ReqServerActiveCode::kIsInviteFieldNumber;
#endif  // !_MSC_VER

ReqServerActiveCode::ReqServerActiveCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqServerActiveCode::InitAsDefaultInstance() {
}

ReqServerActiveCode::ReqServerActiveCode(const ReqServerActiveCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqServerActiveCode::SharedCtor() {
  _cached_size_ = 0;
  is_delete_ = 0u;
  item_id_ = 0u;
  is_invite_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqServerActiveCode::~ReqServerActiveCode() {
  SharedDtor();
}

void ReqServerActiveCode::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqServerActiveCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqServerActiveCode& ReqServerActiveCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqServerActiveCode* ReqServerActiveCode::default_instance_ = NULL;

ReqServerActiveCode* ReqServerActiveCode::New() const {
  return new ReqServerActiveCode;
}

void ReqServerActiveCode::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    is_delete_ = 0u;
    item_id_ = 0u;
    is_invite_ = 0u;
  }
  code_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqServerActiveCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_code;
        if (input->ExpectTag(16)) goto parse_is_delete;
        break;
      }

      // optional uint32 is_delete = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_delete_)));
          set_has_is_delete();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_id;
        break;
      }

      // optional uint32 item_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_invite;
        break;
      }

      // optional uint32 is_invite = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_invite:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_invite_)));
          set_has_is_invite();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqServerActiveCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes code = 1;
  for (int i = 0; i < this->code_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->code(i), output);
  }

  // optional uint32 is_delete = 2;
  if (has_is_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->is_delete(), output);
  }

  // optional uint32 item_id = 3;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->item_id(), output);
  }

  // optional uint32 is_invite = 4;
  if (has_is_invite()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->is_invite(), output);
  }

}

int ReqServerActiveCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 is_delete = 2;
    if (has_is_delete()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_delete());
    }

    // optional uint32 item_id = 3;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // optional uint32 is_invite = 4;
    if (has_is_invite()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_invite());
    }

  }
  // repeated bytes code = 1;
  total_size += 1 * this->code_size();
  for (int i = 0; i < this->code_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->code(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqServerActiveCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqServerActiveCode*>(&from));
}

void ReqServerActiveCode::MergeFrom(const ReqServerActiveCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  code_.MergeFrom(from.code_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_is_delete()) {
      set_is_delete(from.is_delete());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_is_invite()) {
      set_is_invite(from.is_invite());
    }
  }
}

void ReqServerActiveCode::CopyFrom(const ReqServerActiveCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqServerActiveCode::IsInitialized() const {

  return true;
}

void ReqServerActiveCode::Swap(ReqServerActiveCode* other) {
  if (other != this) {
    code_.Swap(&other->code_);
    std::swap(is_delete_, other->is_delete_);
    std::swap(item_id_, other->item_id_);
    std::swap(is_invite_, other->is_invite_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqServerActiveCode::GetTypeName() const {
  return "message.ReqServerActiveCode";
}


// ===================================================================

#ifndef _MSC_VER
const int AckServerActiveCode::kItemIdFieldNumber;
const int AckServerActiveCode::kIsInviteFieldNumber;
#endif  // !_MSC_VER

AckServerActiveCode::AckServerActiveCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckServerActiveCode::InitAsDefaultInstance() {
}

AckServerActiveCode::AckServerActiveCode(const AckServerActiveCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckServerActiveCode::SharedCtor() {
  _cached_size_ = 0;
  item_id_ = 0u;
  is_invite_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckServerActiveCode::~AckServerActiveCode() {
  SharedDtor();
}

void AckServerActiveCode::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckServerActiveCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckServerActiveCode& AckServerActiveCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckServerActiveCode* AckServerActiveCode::default_instance_ = NULL;

AckServerActiveCode* AckServerActiveCode::New() const {
  return new AckServerActiveCode;
}

void AckServerActiveCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_id_ = 0u;
    is_invite_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckServerActiveCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 item_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_invite;
        break;
      }

      // optional uint32 is_invite = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_invite:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_invite_)));
          set_has_is_invite();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckServerActiveCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 item_id = 1;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->item_id(), output);
  }

  // optional uint32 is_invite = 2;
  if (has_is_invite()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->is_invite(), output);
  }

}

int AckServerActiveCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 item_id = 1;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // optional uint32 is_invite = 2;
    if (has_is_invite()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_invite());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckServerActiveCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckServerActiveCode*>(&from));
}

void AckServerActiveCode::MergeFrom(const AckServerActiveCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_is_invite()) {
      set_is_invite(from.is_invite());
    }
  }
}

void AckServerActiveCode::CopyFrom(const AckServerActiveCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckServerActiveCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckServerActiveCode::Swap(AckServerActiveCode* other) {
  if (other != this) {
    std::swap(item_id_, other->item_id_);
    std::swap(is_invite_, other->is_invite_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckServerActiveCode::GetTypeName() const {
  return "message.AckServerActiveCode";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqRefreshGate::kRefreshGateFieldNumber;
#endif  // !_MSC_VER

ReqRefreshGate::ReqRefreshGate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqRefreshGate::InitAsDefaultInstance() {
}

ReqRefreshGate::ReqRefreshGate(const ReqRefreshGate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqRefreshGate::SharedCtor() {
  _cached_size_ = 0;
  refresh_gate_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqRefreshGate::~ReqRefreshGate() {
  SharedDtor();
}

void ReqRefreshGate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqRefreshGate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqRefreshGate& ReqRefreshGate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqRefreshGate* ReqRefreshGate::default_instance_ = NULL;

ReqRefreshGate* ReqRefreshGate::New() const {
  return new ReqRefreshGate;
}

void ReqRefreshGate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    refresh_gate_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqRefreshGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 refresh_gate = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &refresh_gate_)));
          set_has_refresh_gate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqRefreshGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 refresh_gate = 1;
  if (has_refresh_gate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->refresh_gate(), output);
  }

}

int ReqRefreshGate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 refresh_gate = 1;
    if (has_refresh_gate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->refresh_gate());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqRefreshGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqRefreshGate*>(&from));
}

void ReqRefreshGate::MergeFrom(const ReqRefreshGate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_refresh_gate()) {
      set_refresh_gate(from.refresh_gate());
    }
  }
}

void ReqRefreshGate::CopyFrom(const ReqRefreshGate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRefreshGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqRefreshGate::Swap(ReqRefreshGate* other) {
  if (other != this) {
    std::swap(refresh_gate_, other->refresh_gate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqRefreshGate::GetTypeName() const {
  return "message.ReqRefreshGate";
}


// ===================================================================

#ifndef _MSC_VER
const int RefreshGateCost::kCostFieldNumber;
#endif  // !_MSC_VER

RefreshGateCost::RefreshGateCost()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RefreshGateCost::InitAsDefaultInstance() {
}

RefreshGateCost::RefreshGateCost(const RefreshGateCost& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RefreshGateCost::SharedCtor() {
  _cached_size_ = 0;
  cost_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RefreshGateCost::~RefreshGateCost() {
  SharedDtor();
}

void RefreshGateCost::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RefreshGateCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RefreshGateCost& RefreshGateCost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

RefreshGateCost* RefreshGateCost::default_instance_ = NULL;

RefreshGateCost* RefreshGateCost::New() const {
  return new RefreshGateCost;
}

void RefreshGateCost::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cost_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RefreshGateCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 cost = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_)));
          set_has_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RefreshGateCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 cost = 1;
  if (has_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->cost(), output);
  }

}

int RefreshGateCost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 cost = 1;
    if (has_cost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cost());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RefreshGateCost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RefreshGateCost*>(&from));
}

void RefreshGateCost::MergeFrom(const RefreshGateCost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cost()) {
      set_cost(from.cost());
    }
  }
}

void RefreshGateCost::CopyFrom(const RefreshGateCost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshGateCost::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RefreshGateCost::Swap(RefreshGateCost* other) {
  if (other != this) {
    std::swap(cost_, other->cost_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RefreshGateCost::GetTypeName() const {
  return "message.RefreshGateCost";
}


// ===================================================================

#ifndef _MSC_VER
const int RefreshGate::kValueFieldNumber;
#endif  // !_MSC_VER

RefreshGate::RefreshGate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RefreshGate::InitAsDefaultInstance() {
}

RefreshGate::RefreshGate(const RefreshGate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RefreshGate::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RefreshGate::~RefreshGate() {
  SharedDtor();
}

void RefreshGate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RefreshGate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RefreshGate& RefreshGate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

RefreshGate* RefreshGate::default_instance_ = NULL;

RefreshGate* RefreshGate::New() const {
  return new RefreshGate;
}

void RefreshGate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RefreshGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RefreshGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int RefreshGate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RefreshGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RefreshGate*>(&from));
}

void RefreshGate::MergeFrom(const RefreshGate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void RefreshGate::CopyFrom(const RefreshGate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RefreshGate::Swap(RefreshGate* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RefreshGate::GetTypeName() const {
  return "message.RefreshGate";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGateLevelUp::kTypeFieldNumber;
const int ReqGateLevelUp::kGateNumFieldNumber;
#endif  // !_MSC_VER

ReqGateLevelUp::ReqGateLevelUp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqGateLevelUp::InitAsDefaultInstance() {
}

ReqGateLevelUp::ReqGateLevelUp(const ReqGateLevelUp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqGateLevelUp::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  gate_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGateLevelUp::~ReqGateLevelUp() {
  SharedDtor();
}

void ReqGateLevelUp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqGateLevelUp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqGateLevelUp& ReqGateLevelUp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqGateLevelUp* ReqGateLevelUp::default_instance_ = NULL;

ReqGateLevelUp* ReqGateLevelUp::New() const {
  return new ReqGateLevelUp;
}

void ReqGateLevelUp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0u;
    gate_num_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqGateLevelUp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gate_num;
        break;
      }

      // required uint32 gate_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gate_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gate_num_)));
          set_has_gate_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqGateLevelUp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required uint32 gate_num = 2;
  if (has_gate_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->gate_num(), output);
  }

}

int ReqGateLevelUp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 gate_num = 2;
    if (has_gate_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gate_num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGateLevelUp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqGateLevelUp*>(&from));
}

void ReqGateLevelUp::MergeFrom(const ReqGateLevelUp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_gate_num()) {
      set_gate_num(from.gate_num());
    }
  }
}

void ReqGateLevelUp::CopyFrom(const ReqGateLevelUp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGateLevelUp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ReqGateLevelUp::Swap(ReqGateLevelUp* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(gate_num_, other->gate_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqGateLevelUp::GetTypeName() const {
  return "message.ReqGateLevelUp";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqChooseBigGate::kOperTypeFieldNumber;
#endif  // !_MSC_VER

ReqChooseBigGate::ReqChooseBigGate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqChooseBigGate::InitAsDefaultInstance() {
}

ReqChooseBigGate::ReqChooseBigGate(const ReqChooseBigGate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqChooseBigGate::SharedCtor() {
  _cached_size_ = 0;
  oper_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqChooseBigGate::~ReqChooseBigGate() {
  SharedDtor();
}

void ReqChooseBigGate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqChooseBigGate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqChooseBigGate& ReqChooseBigGate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqChooseBigGate* ReqChooseBigGate::default_instance_ = NULL;

ReqChooseBigGate* ReqChooseBigGate::New() const {
  return new ReqChooseBigGate;
}

void ReqChooseBigGate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    oper_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqChooseBigGate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 oper_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_type_)));
          set_has_oper_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqChooseBigGate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 oper_type = 1;
  if (has_oper_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->oper_type(), output);
  }

}

int ReqChooseBigGate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 oper_type = 1;
    if (has_oper_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqChooseBigGate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqChooseBigGate*>(&from));
}

void ReqChooseBigGate::MergeFrom(const ReqChooseBigGate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_oper_type()) {
      set_oper_type(from.oper_type());
    }
  }
}

void ReqChooseBigGate::CopyFrom(const ReqChooseBigGate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqChooseBigGate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqChooseBigGate::Swap(ReqChooseBigGate* other) {
  if (other != this) {
    std::swap(oper_type_, other->oper_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqChooseBigGate::GetTypeName() const {
  return "message.ReqChooseBigGate";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqMercenaryUpgrade::kPosFieldNumber;
#endif  // !_MSC_VER

ReqMercenaryUpgrade::ReqMercenaryUpgrade()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqMercenaryUpgrade::InitAsDefaultInstance() {
}

ReqMercenaryUpgrade::ReqMercenaryUpgrade(const ReqMercenaryUpgrade& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqMercenaryUpgrade::SharedCtor() {
  _cached_size_ = 0;
  pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqMercenaryUpgrade::~ReqMercenaryUpgrade() {
  SharedDtor();
}

void ReqMercenaryUpgrade::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqMercenaryUpgrade::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqMercenaryUpgrade& ReqMercenaryUpgrade::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqMercenaryUpgrade* ReqMercenaryUpgrade::default_instance_ = NULL;

ReqMercenaryUpgrade* ReqMercenaryUpgrade::New() const {
  return new ReqMercenaryUpgrade;
}

void ReqMercenaryUpgrade::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqMercenaryUpgrade::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqMercenaryUpgrade::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pos(), output);
  }

}

int ReqMercenaryUpgrade::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqMercenaryUpgrade::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqMercenaryUpgrade*>(&from));
}

void ReqMercenaryUpgrade::MergeFrom(const ReqMercenaryUpgrade& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      set_pos(from.pos());
    }
  }
}

void ReqMercenaryUpgrade::CopyFrom(const ReqMercenaryUpgrade& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqMercenaryUpgrade::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqMercenaryUpgrade::Swap(ReqMercenaryUpgrade* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqMercenaryUpgrade::GetTypeName() const {
  return "message.ReqMercenaryUpgrade";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqLadderReward::kPosFieldNumber;
#endif  // !_MSC_VER

ReqLadderReward::ReqLadderReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqLadderReward::InitAsDefaultInstance() {
}

ReqLadderReward::ReqLadderReward(const ReqLadderReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqLadderReward::SharedCtor() {
  _cached_size_ = 0;
  pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqLadderReward::~ReqLadderReward() {
  SharedDtor();
}

void ReqLadderReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqLadderReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqLadderReward& ReqLadderReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqLadderReward* ReqLadderReward::default_instance_ = NULL;

ReqLadderReward* ReqLadderReward::New() const {
  return new ReqLadderReward;
}

void ReqLadderReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqLadderReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqLadderReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pos(), output);
  }

}

int ReqLadderReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqLadderReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqLadderReward*>(&from));
}

void ReqLadderReward::MergeFrom(const ReqLadderReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      set_pos(from.pos());
    }
  }
}

void ReqLadderReward::CopyFrom(const ReqLadderReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqLadderReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqLadderReward::Swap(ReqLadderReward* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqLadderReward::GetTypeName() const {
  return "message.ReqLadderReward";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGetLevelReward::kValueFieldNumber;
#endif  // !_MSC_VER

ReqGetLevelReward::ReqGetLevelReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqGetLevelReward::InitAsDefaultInstance() {
}

ReqGetLevelReward::ReqGetLevelReward(const ReqGetLevelReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqGetLevelReward::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGetLevelReward::~ReqGetLevelReward() {
  SharedDtor();
}

void ReqGetLevelReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqGetLevelReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqGetLevelReward& ReqGetLevelReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqGetLevelReward* ReqGetLevelReward::default_instance_ = NULL;

ReqGetLevelReward* ReqGetLevelReward::New() const {
  return new ReqGetLevelReward;
}

void ReqGetLevelReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqGetLevelReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqGetLevelReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqGetLevelReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGetLevelReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqGetLevelReward*>(&from));
}

void ReqGetLevelReward::MergeFrom(const ReqGetLevelReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqGetLevelReward::CopyFrom(const ReqGetLevelReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGetLevelReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqGetLevelReward::Swap(ReqGetLevelReward* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqGetLevelReward::GetTypeName() const {
  return "message.ReqGetLevelReward";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGetActiveReward::kValueFieldNumber;
#endif  // !_MSC_VER

ReqGetActiveReward::ReqGetActiveReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqGetActiveReward::InitAsDefaultInstance() {
}

ReqGetActiveReward::ReqGetActiveReward(const ReqGetActiveReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqGetActiveReward::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGetActiveReward::~ReqGetActiveReward() {
  SharedDtor();
}

void ReqGetActiveReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqGetActiveReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqGetActiveReward& ReqGetActiveReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqGetActiveReward* ReqGetActiveReward::default_instance_ = NULL;

ReqGetActiveReward* ReqGetActiveReward::New() const {
  return new ReqGetActiveReward;
}

void ReqGetActiveReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqGetActiveReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqGetActiveReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqGetActiveReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGetActiveReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqGetActiveReward*>(&from));
}

void ReqGetActiveReward::MergeFrom(const ReqGetActiveReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqGetActiveReward::CopyFrom(const ReqGetActiveReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGetActiveReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqGetActiveReward::Swap(ReqGetActiveReward* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqGetActiveReward::GetTypeName() const {
  return "message.ReqGetActiveReward";
}


// ===================================================================

#ifndef _MSC_VER
const int RechargeLogInfo::kAccIdFieldNumber;
const int RechargeLogInfo::kServerIdFieldNumber;
const int RechargeLogInfo::kRechargePlatidFieldNumber;
const int RechargeLogInfo::kRechargeAmountFieldNumber;
const int RechargeLogInfo::kCharNameFieldNumber;
const int RechargeLogInfo::kRechargeTimeFieldNumber;
#endif  // !_MSC_VER

RechargeLogInfo::RechargeLogInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RechargeLogInfo::InitAsDefaultInstance() {
}

RechargeLogInfo::RechargeLogInfo(const RechargeLogInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RechargeLogInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  server_id_ = 0u;
  recharge_platid_ = 0u;
  recharge_amount_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  recharge_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RechargeLogInfo::~RechargeLogInfo() {
  SharedDtor();
}

void RechargeLogInfo::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (recharge_time_ != &::google::protobuf::internal::kEmptyString) {
    delete recharge_time_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RechargeLogInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RechargeLogInfo& RechargeLogInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

RechargeLogInfo* RechargeLogInfo::default_instance_ = NULL;

RechargeLogInfo* RechargeLogInfo::New() const {
  return new RechargeLogInfo;
}

void RechargeLogInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    server_id_ = 0u;
    recharge_platid_ = 0u;
    recharge_amount_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    if (has_recharge_time()) {
      if (recharge_time_ != &::google::protobuf::internal::kEmptyString) {
        recharge_time_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RechargeLogInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_recharge_platid;
        break;
      }

      // optional uint32 recharge_platid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_recharge_platid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &recharge_platid_)));
          set_has_recharge_platid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_recharge_amount;
        break;
      }

      // optional uint32 recharge_amount = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_recharge_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &recharge_amount_)));
          set_has_recharge_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_char_name;
        break;
      }

      // optional bytes char_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_recharge_time;
        break;
      }

      // optional bytes recharge_time = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_recharge_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_recharge_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RechargeLogInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // optional uint32 server_id = 2;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->server_id(), output);
  }

  // optional uint32 recharge_platid = 3;
  if (has_recharge_platid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->recharge_platid(), output);
  }

  // optional uint32 recharge_amount = 4;
  if (has_recharge_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->recharge_amount(), output);
  }

  // optional bytes char_name = 5;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->char_name(), output);
  }

  // optional bytes recharge_time = 6;
  if (has_recharge_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->recharge_time(), output);
  }

}

int RechargeLogInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional uint32 server_id = 2;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 recharge_platid = 3;
    if (has_recharge_platid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->recharge_platid());
    }

    // optional uint32 recharge_amount = 4;
    if (has_recharge_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->recharge_amount());
    }

    // optional bytes char_name = 5;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // optional bytes recharge_time = 6;
    if (has_recharge_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->recharge_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RechargeLogInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RechargeLogInfo*>(&from));
}

void RechargeLogInfo::MergeFrom(const RechargeLogInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_recharge_platid()) {
      set_recharge_platid(from.recharge_platid());
    }
    if (from.has_recharge_amount()) {
      set_recharge_amount(from.recharge_amount());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_recharge_time()) {
      set_recharge_time(from.recharge_time());
    }
  }
}

void RechargeLogInfo::CopyFrom(const RechargeLogInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RechargeLogInfo::IsInitialized() const {

  return true;
}

void RechargeLogInfo::Swap(RechargeLogInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(server_id_, other->server_id_);
    std::swap(recharge_platid_, other->recharge_platid_);
    std::swap(recharge_amount_, other->recharge_amount_);
    std::swap(char_name_, other->char_name_);
    std::swap(recharge_time_, other->recharge_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RechargeLogInfo::GetTypeName() const {
  return "message.RechargeLogInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ResetByDay::kIsDailyOnlineFieldNumber;
#endif  // !_MSC_VER

ResetByDay::ResetByDay()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResetByDay::InitAsDefaultInstance() {
}

ResetByDay::ResetByDay(const ResetByDay& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResetByDay::SharedCtor() {
  _cached_size_ = 0;
  isdailyonline_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetByDay::~ResetByDay() {
  SharedDtor();
}

void ResetByDay::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResetByDay::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResetByDay& ResetByDay::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ResetByDay* ResetByDay::default_instance_ = NULL;

ResetByDay* ResetByDay::New() const {
  return new ResetByDay;
}

void ResetByDay::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    isdailyonline_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResetByDay::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool isDailyOnline = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isdailyonline_)));
          set_has_isdailyonline();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResetByDay::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool isDailyOnline = 1;
  if (has_isdailyonline()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->isdailyonline(), output);
  }

}

int ResetByDay::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool isDailyOnline = 1;
    if (has_isdailyonline()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetByDay::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResetByDay*>(&from));
}

void ResetByDay::MergeFrom(const ResetByDay& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isdailyonline()) {
      set_isdailyonline(from.isdailyonline());
    }
  }
}

void ResetByDay::CopyFrom(const ResetByDay& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetByDay::IsInitialized() const {

  return true;
}

void ResetByDay::Swap(ResetByDay* other) {
  if (other != this) {
    std::swap(isdailyonline_, other->isdailyonline_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResetByDay::GetTypeName() const {
  return "message.ResetByDay";
}


// ===================================================================

#ifndef _MSC_VER
const int UserBehaviorLogInfo::kAccIdFieldNumber;
const int UserBehaviorLogInfo::kServerIdFieldNumber;
const int UserBehaviorLogInfo::kEnumIntentFieldNumber;
const int UserBehaviorLogInfo::kEnumOperFieldNumber;
const int UserBehaviorLogInfo::kEnumAttrFieldNumber;
const int UserBehaviorLogInfo::kAttrAmountFieldNumber;
const int UserBehaviorLogInfo::kItemAmountFieldNumber;
const int UserBehaviorLogInfo::kItemIdFieldNumber;
const int UserBehaviorLogInfo::kPreAmountFieldNumber;
const int UserBehaviorLogInfo::kAfterAmountFieldNumber;
const int UserBehaviorLogInfo::kCharNameFieldNumber;
const int UserBehaviorLogInfo::kBehaviorTimeFieldNumber;
#endif  // !_MSC_VER

UserBehaviorLogInfo::UserBehaviorLogInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserBehaviorLogInfo::InitAsDefaultInstance() {
}

UserBehaviorLogInfo::UserBehaviorLogInfo(const UserBehaviorLogInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserBehaviorLogInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  server_id_ = 0u;
  enum_intent_ = 0u;
  enum_oper_ = 0u;
  enum_attr_ = 0u;
  attr_amount_ = 0u;
  item_amount_ = 0u;
  item_id_ = 0u;
  pre_amount_ = 0u;
  after_amount_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  behavior_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserBehaviorLogInfo::~UserBehaviorLogInfo() {
  SharedDtor();
}

void UserBehaviorLogInfo::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (behavior_time_ != &::google::protobuf::internal::kEmptyString) {
    delete behavior_time_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserBehaviorLogInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserBehaviorLogInfo& UserBehaviorLogInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UserBehaviorLogInfo* UserBehaviorLogInfo::default_instance_ = NULL;

UserBehaviorLogInfo* UserBehaviorLogInfo::New() const {
  return new UserBehaviorLogInfo;
}

void UserBehaviorLogInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    server_id_ = 0u;
    enum_intent_ = 0u;
    enum_oper_ = 0u;
    enum_attr_ = 0u;
    attr_amount_ = 0u;
    item_amount_ = 0u;
    item_id_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    pre_amount_ = 0u;
    after_amount_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    if (has_behavior_time()) {
      if (behavior_time_ != &::google::protobuf::internal::kEmptyString) {
        behavior_time_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserBehaviorLogInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_enum_intent;
        break;
      }

      // optional uint32 enum_intent = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enum_intent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enum_intent_)));
          set_has_enum_intent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_enum_oper;
        break;
      }

      // optional uint32 enum_oper = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enum_oper:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enum_oper_)));
          set_has_enum_oper();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_enum_attr;
        break;
      }

      // optional uint32 enum_attr = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enum_attr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enum_attr_)));
          set_has_enum_attr();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_attr_amount;
        break;
      }

      // optional uint32 attr_amount = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attr_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attr_amount_)));
          set_has_attr_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_item_amount;
        break;
      }

      // optional uint32 item_amount = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_amount_)));
          set_has_item_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_item_id;
        break;
      }

      // optional uint32 item_id = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_pre_amount;
        break;
      }

      // optional uint32 pre_amount = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pre_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pre_amount_)));
          set_has_pre_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_after_amount;
        break;
      }

      // optional uint32 after_amount = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_after_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &after_amount_)));
          set_has_after_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_char_name;
        break;
      }

      // optional bytes char_name = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_behavior_time;
        break;
      }

      // optional bytes behavior_time = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_behavior_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_behavior_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserBehaviorLogInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // optional uint32 server_id = 2;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->server_id(), output);
  }

  // optional uint32 enum_intent = 3;
  if (has_enum_intent()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->enum_intent(), output);
  }

  // optional uint32 enum_oper = 4;
  if (has_enum_oper()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->enum_oper(), output);
  }

  // optional uint32 enum_attr = 5;
  if (has_enum_attr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->enum_attr(), output);
  }

  // optional uint32 attr_amount = 6;
  if (has_attr_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->attr_amount(), output);
  }

  // optional uint32 item_amount = 7;
  if (has_item_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->item_amount(), output);
  }

  // optional uint32 item_id = 8;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->item_id(), output);
  }

  // optional uint32 pre_amount = 9;
  if (has_pre_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->pre_amount(), output);
  }

  // optional uint32 after_amount = 10;
  if (has_after_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->after_amount(), output);
  }

  // optional bytes char_name = 11;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->char_name(), output);
  }

  // optional bytes behavior_time = 12;
  if (has_behavior_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      12, this->behavior_time(), output);
  }

}

int UserBehaviorLogInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional uint32 server_id = 2;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 enum_intent = 3;
    if (has_enum_intent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enum_intent());
    }

    // optional uint32 enum_oper = 4;
    if (has_enum_oper()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enum_oper());
    }

    // optional uint32 enum_attr = 5;
    if (has_enum_attr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enum_attr());
    }

    // optional uint32 attr_amount = 6;
    if (has_attr_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->attr_amount());
    }

    // optional uint32 item_amount = 7;
    if (has_item_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_amount());
    }

    // optional uint32 item_id = 8;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 pre_amount = 9;
    if (has_pre_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pre_amount());
    }

    // optional uint32 after_amount = 10;
    if (has_after_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->after_amount());
    }

    // optional bytes char_name = 11;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // optional bytes behavior_time = 12;
    if (has_behavior_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->behavior_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserBehaviorLogInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserBehaviorLogInfo*>(&from));
}

void UserBehaviorLogInfo::MergeFrom(const UserBehaviorLogInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_enum_intent()) {
      set_enum_intent(from.enum_intent());
    }
    if (from.has_enum_oper()) {
      set_enum_oper(from.enum_oper());
    }
    if (from.has_enum_attr()) {
      set_enum_attr(from.enum_attr());
    }
    if (from.has_attr_amount()) {
      set_attr_amount(from.attr_amount());
    }
    if (from.has_item_amount()) {
      set_item_amount(from.item_amount());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_pre_amount()) {
      set_pre_amount(from.pre_amount());
    }
    if (from.has_after_amount()) {
      set_after_amount(from.after_amount());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_behavior_time()) {
      set_behavior_time(from.behavior_time());
    }
  }
}

void UserBehaviorLogInfo::CopyFrom(const UserBehaviorLogInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserBehaviorLogInfo::IsInitialized() const {

  return true;
}

void UserBehaviorLogInfo::Swap(UserBehaviorLogInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(server_id_, other->server_id_);
    std::swap(enum_intent_, other->enum_intent_);
    std::swap(enum_oper_, other->enum_oper_);
    std::swap(enum_attr_, other->enum_attr_);
    std::swap(attr_amount_, other->attr_amount_);
    std::swap(item_amount_, other->item_amount_);
    std::swap(item_id_, other->item_id_);
    std::swap(pre_amount_, other->pre_amount_);
    std::swap(after_amount_, other->after_amount_);
    std::swap(char_name_, other->char_name_);
    std::swap(behavior_time_, other->behavior_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserBehaviorLogInfo::GetTypeName() const {
  return "message.UserBehaviorLogInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int OnlineNumberInfo::kServerIdFieldNumber;
const int OnlineNumberInfo::kOnlineNumFieldNumber;
#endif  // !_MSC_VER

OnlineNumberInfo::OnlineNumberInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OnlineNumberInfo::InitAsDefaultInstance() {
}

OnlineNumberInfo::OnlineNumberInfo(const OnlineNumberInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OnlineNumberInfo::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0u;
  online_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OnlineNumberInfo::~OnlineNumberInfo() {
  SharedDtor();
}

void OnlineNumberInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OnlineNumberInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OnlineNumberInfo& OnlineNumberInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OnlineNumberInfo* OnlineNumberInfo::default_instance_ = NULL;

OnlineNumberInfo* OnlineNumberInfo::New() const {
  return new OnlineNumberInfo;
}

void OnlineNumberInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0u;
    online_num_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OnlineNumberInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_online_num;
        break;
      }

      // optional uint32 online_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_online_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_num_)));
          set_has_online_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OnlineNumberInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->server_id(), output);
  }

  // optional uint32 online_num = 2;
  if (has_online_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_num(), output);
  }

}

int OnlineNumberInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 online_num = 2;
    if (has_online_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OnlineNumberInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OnlineNumberInfo*>(&from));
}

void OnlineNumberInfo::MergeFrom(const OnlineNumberInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_online_num()) {
      set_online_num(from.online_num());
    }
  }
}

void OnlineNumberInfo::CopyFrom(const OnlineNumberInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnlineNumberInfo::IsInitialized() const {

  return true;
}

void OnlineNumberInfo::Swap(OnlineNumberInfo* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    std::swap(online_num_, other->online_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OnlineNumberInfo::GetTypeName() const {
  return "message.OnlineNumberInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqVIPOperation::kOperIdFieldNumber;
const int ReqVIPOperation::kOperValue1FieldNumber;
const int ReqVIPOperation::kOperValue2FieldNumber;
const int ReqVIPOperation::kOperValue3FieldNumber;
const int ReqVIPOperation::kOperValue4FieldNumber;
#endif  // !_MSC_VER

ReqVIPOperation::ReqVIPOperation()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqVIPOperation::InitAsDefaultInstance() {
}

ReqVIPOperation::ReqVIPOperation(const ReqVIPOperation& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqVIPOperation::SharedCtor() {
  _cached_size_ = 0;
  oper_id_ = 0u;
  oper_value1_ = 0u;
  oper_value2_ = 0u;
  oper_value3_ = 0u;
  oper_value4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqVIPOperation::~ReqVIPOperation() {
  SharedDtor();
}

void ReqVIPOperation::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqVIPOperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqVIPOperation& ReqVIPOperation::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqVIPOperation* ReqVIPOperation::default_instance_ = NULL;

ReqVIPOperation* ReqVIPOperation::New() const {
  return new ReqVIPOperation;
}

void ReqVIPOperation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    oper_id_ = 0u;
    oper_value1_ = 0u;
    oper_value2_ = 0u;
    oper_value3_ = 0u;
    oper_value4_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqVIPOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 oper_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_id_)));
          set_has_oper_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_oper_value1;
        break;
      }

      // optional uint32 oper_value1 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_value1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_value1_)));
          set_has_oper_value1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_oper_value2;
        break;
      }

      // optional uint32 oper_value2 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_value2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_value2_)));
          set_has_oper_value2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_oper_value3;
        break;
      }

      // optional uint32 oper_value3 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_value3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_value3_)));
          set_has_oper_value3();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_oper_value4;
        break;
      }

      // optional uint32 oper_value4 = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_value4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_value4_)));
          set_has_oper_value4();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqVIPOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 oper_id = 1;
  if (has_oper_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->oper_id(), output);
  }

  // optional uint32 oper_value1 = 2;
  if (has_oper_value1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->oper_value1(), output);
  }

  // optional uint32 oper_value2 = 3;
  if (has_oper_value2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->oper_value2(), output);
  }

  // optional uint32 oper_value3 = 4;
  if (has_oper_value3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->oper_value3(), output);
  }

  // optional uint32 oper_value4 = 5;
  if (has_oper_value4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->oper_value4(), output);
  }

}

int ReqVIPOperation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 oper_id = 1;
    if (has_oper_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_id());
    }

    // optional uint32 oper_value1 = 2;
    if (has_oper_value1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_value1());
    }

    // optional uint32 oper_value2 = 3;
    if (has_oper_value2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_value2());
    }

    // optional uint32 oper_value3 = 4;
    if (has_oper_value3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_value3());
    }

    // optional uint32 oper_value4 = 5;
    if (has_oper_value4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_value4());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqVIPOperation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqVIPOperation*>(&from));
}

void ReqVIPOperation::MergeFrom(const ReqVIPOperation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_oper_id()) {
      set_oper_id(from.oper_id());
    }
    if (from.has_oper_value1()) {
      set_oper_value1(from.oper_value1());
    }
    if (from.has_oper_value2()) {
      set_oper_value2(from.oper_value2());
    }
    if (from.has_oper_value3()) {
      set_oper_value3(from.oper_value3());
    }
    if (from.has_oper_value4()) {
      set_oper_value4(from.oper_value4());
    }
  }
}

void ReqVIPOperation::CopyFrom(const ReqVIPOperation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqVIPOperation::IsInitialized() const {

  return true;
}

void ReqVIPOperation::Swap(ReqVIPOperation* other) {
  if (other != this) {
    std::swap(oper_id_, other->oper_id_);
    std::swap(oper_value1_, other->oper_value1_);
    std::swap(oper_value2_, other->oper_value2_);
    std::swap(oper_value3_, other->oper_value3_);
    std::swap(oper_value4_, other->oper_value4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqVIPOperation::GetTypeName() const {
  return "message.ReqVIPOperation";
}


// ===================================================================

#ifndef _MSC_VER
const int UserFeedback_UserFeedbackInfo::kAccIdFieldNumber;
const int UserFeedback_UserFeedbackInfo::kFbIdFieldNumber;
const int UserFeedback_UserFeedbackInfo::kFbTypeFieldNumber;
const int UserFeedback_UserFeedbackInfo::kFinishFieldNumber;
const int UserFeedback_UserFeedbackInfo::kFbContentFieldNumber;
const int UserFeedback_UserFeedbackInfo::kFbReplyFieldNumber;
const int UserFeedback_UserFeedbackInfo::kCommitTimeFieldNumber;
const int UserFeedback_UserFeedbackInfo::kReplyTimeFieldNumber;
const int UserFeedback_UserFeedbackInfo::kAnswerIdFieldNumber;
const int UserFeedback_UserFeedbackInfo::kCharNameFieldNumber;
const int UserFeedback_UserFeedbackInfo::kLogIdFieldNumber;
const int UserFeedback_UserFeedbackInfo::kServerIdFieldNumber;
#endif  // !_MSC_VER

UserFeedback_UserFeedbackInfo::UserFeedback_UserFeedbackInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserFeedback_UserFeedbackInfo::InitAsDefaultInstance() {
}

UserFeedback_UserFeedbackInfo::UserFeedback_UserFeedbackInfo(const UserFeedback_UserFeedbackInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserFeedback_UserFeedbackInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  fb_id_ = 0u;
  fb_type_ = 0u;
  finish_ = 0u;
  fb_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fb_reply_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  commit_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  reply_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  answer_id_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  log_id_ = 0u;
  server_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserFeedback_UserFeedbackInfo::~UserFeedback_UserFeedbackInfo() {
  SharedDtor();
}

void UserFeedback_UserFeedbackInfo::SharedDtor() {
  if (fb_content_ != &::google::protobuf::internal::kEmptyString) {
    delete fb_content_;
  }
  if (fb_reply_ != &::google::protobuf::internal::kEmptyString) {
    delete fb_reply_;
  }
  if (commit_time_ != &::google::protobuf::internal::kEmptyString) {
    delete commit_time_;
  }
  if (reply_time_ != &::google::protobuf::internal::kEmptyString) {
    delete reply_time_;
  }
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserFeedback_UserFeedbackInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserFeedback_UserFeedbackInfo& UserFeedback_UserFeedbackInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UserFeedback_UserFeedbackInfo* UserFeedback_UserFeedbackInfo::default_instance_ = NULL;

UserFeedback_UserFeedbackInfo* UserFeedback_UserFeedbackInfo::New() const {
  return new UserFeedback_UserFeedbackInfo;
}

void UserFeedback_UserFeedbackInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    fb_id_ = 0u;
    fb_type_ = 0u;
    finish_ = 0u;
    if (has_fb_content()) {
      if (fb_content_ != &::google::protobuf::internal::kEmptyString) {
        fb_content_->clear();
      }
    }
    if (has_fb_reply()) {
      if (fb_reply_ != &::google::protobuf::internal::kEmptyString) {
        fb_reply_->clear();
      }
    }
    if (has_commit_time()) {
      if (commit_time_ != &::google::protobuf::internal::kEmptyString) {
        commit_time_->clear();
      }
    }
    if (has_reply_time()) {
      if (reply_time_ != &::google::protobuf::internal::kEmptyString) {
        reply_time_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    answer_id_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    log_id_ = 0u;
    server_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserFeedback_UserFeedbackInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fb_id;
        break;
      }

      // optional uint32 fb_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fb_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fb_id_)));
          set_has_fb_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fb_type;
        break;
      }

      // optional uint32 fb_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fb_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fb_type_)));
          set_has_fb_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_finish;
        break;
      }

      // optional uint32 finish = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_finish:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &finish_)));
          set_has_finish();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_fb_content;
        break;
      }

      // optional bytes fb_content = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fb_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fb_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_fb_reply;
        break;
      }

      // optional bytes fb_reply = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fb_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fb_reply()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_commit_time;
        break;
      }

      // optional bytes commit_time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_commit_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_commit_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_reply_time;
        break;
      }

      // optional bytes reply_time = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reply_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reply_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_answer_id;
        break;
      }

      // optional uint32 answer_id = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_answer_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &answer_id_)));
          set_has_answer_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_char_name;
        break;
      }

      // optional bytes char_name = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_log_id;
        break;
      }

      // optional uint32 log_id = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_log_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &log_id_)));
          set_has_log_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserFeedback_UserFeedbackInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // optional uint32 fb_id = 2;
  if (has_fb_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->fb_id(), output);
  }

  // optional uint32 fb_type = 3;
  if (has_fb_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->fb_type(), output);
  }

  // optional uint32 finish = 4;
  if (has_finish()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->finish(), output);
  }

  // optional bytes fb_content = 5;
  if (has_fb_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->fb_content(), output);
  }

  // optional bytes fb_reply = 6;
  if (has_fb_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->fb_reply(), output);
  }

  // optional bytes commit_time = 7;
  if (has_commit_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->commit_time(), output);
  }

  // optional bytes reply_time = 8;
  if (has_reply_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->reply_time(), output);
  }

  // optional uint32 answer_id = 9;
  if (has_answer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->answer_id(), output);
  }

  // optional bytes char_name = 10;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->char_name(), output);
  }

  // optional uint32 log_id = 11;
  if (has_log_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->log_id(), output);
  }

  // optional uint32 server_id = 12;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->server_id(), output);
  }

}

int UserFeedback_UserFeedbackInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional uint32 fb_id = 2;
    if (has_fb_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fb_id());
    }

    // optional uint32 fb_type = 3;
    if (has_fb_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fb_type());
    }

    // optional uint32 finish = 4;
    if (has_finish()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->finish());
    }

    // optional bytes fb_content = 5;
    if (has_fb_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->fb_content());
    }

    // optional bytes fb_reply = 6;
    if (has_fb_reply()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->fb_reply());
    }

    // optional bytes commit_time = 7;
    if (has_commit_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->commit_time());
    }

    // optional bytes reply_time = 8;
    if (has_reply_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reply_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 answer_id = 9;
    if (has_answer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->answer_id());
    }

    // optional bytes char_name = 10;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // optional uint32 log_id = 11;
    if (has_log_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->log_id());
    }

    // optional uint32 server_id = 12;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserFeedback_UserFeedbackInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserFeedback_UserFeedbackInfo*>(&from));
}

void UserFeedback_UserFeedbackInfo::MergeFrom(const UserFeedback_UserFeedbackInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_fb_id()) {
      set_fb_id(from.fb_id());
    }
    if (from.has_fb_type()) {
      set_fb_type(from.fb_type());
    }
    if (from.has_finish()) {
      set_finish(from.finish());
    }
    if (from.has_fb_content()) {
      set_fb_content(from.fb_content());
    }
    if (from.has_fb_reply()) {
      set_fb_reply(from.fb_reply());
    }
    if (from.has_commit_time()) {
      set_commit_time(from.commit_time());
    }
    if (from.has_reply_time()) {
      set_reply_time(from.reply_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_answer_id()) {
      set_answer_id(from.answer_id());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_log_id()) {
      set_log_id(from.log_id());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
  }
}

void UserFeedback_UserFeedbackInfo::CopyFrom(const UserFeedback_UserFeedbackInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserFeedback_UserFeedbackInfo::IsInitialized() const {

  return true;
}

void UserFeedback_UserFeedbackInfo::Swap(UserFeedback_UserFeedbackInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(fb_id_, other->fb_id_);
    std::swap(fb_type_, other->fb_type_);
    std::swap(finish_, other->finish_);
    std::swap(fb_content_, other->fb_content_);
    std::swap(fb_reply_, other->fb_reply_);
    std::swap(commit_time_, other->commit_time_);
    std::swap(reply_time_, other->reply_time_);
    std::swap(answer_id_, other->answer_id_);
    std::swap(char_name_, other->char_name_);
    std::swap(log_id_, other->log_id_);
    std::swap(server_id_, other->server_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserFeedback_UserFeedbackInfo::GetTypeName() const {
  return "message.UserFeedback.UserFeedbackInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UserFeedback::kUserFeedbackInfoFieldNumber;
const int UserFeedback::kGmComitTimeFieldNumber;
const int UserFeedback::kGmReplyTimeFieldNumber;
const int UserFeedback::kGmCharNameFieldNumber;
const int UserFeedback::kSendfbTypeFieldNumber;
const int UserFeedback::kGmTalkFieldNumber;
const int UserFeedback::kFbIdNewFieldNumber;
#endif  // !_MSC_VER

UserFeedback::UserFeedback()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserFeedback::InitAsDefaultInstance() {
}

UserFeedback::UserFeedback(const UserFeedback& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserFeedback::SharedCtor() {
  _cached_size_ = 0;
  gm_comit_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gm_reply_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gm_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sendfb_type_ = 0u;
  gm_talk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fb_id_new_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserFeedback::~UserFeedback() {
  SharedDtor();
}

void UserFeedback::SharedDtor() {
  if (gm_comit_time_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_comit_time_;
  }
  if (gm_reply_time_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_reply_time_;
  }
  if (gm_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_char_name_;
  }
  if (gm_talk_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_talk_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserFeedback::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserFeedback& UserFeedback::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UserFeedback* UserFeedback::default_instance_ = NULL;

UserFeedback* UserFeedback::New() const {
  return new UserFeedback;
}

void UserFeedback::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_gm_comit_time()) {
      if (gm_comit_time_ != &::google::protobuf::internal::kEmptyString) {
        gm_comit_time_->clear();
      }
    }
    if (has_gm_reply_time()) {
      if (gm_reply_time_ != &::google::protobuf::internal::kEmptyString) {
        gm_reply_time_->clear();
      }
    }
    if (has_gm_char_name()) {
      if (gm_char_name_ != &::google::protobuf::internal::kEmptyString) {
        gm_char_name_->clear();
      }
    }
    sendfb_type_ = 0u;
    if (has_gm_talk()) {
      if (gm_talk_ != &::google::protobuf::internal::kEmptyString) {
        gm_talk_->clear();
      }
    }
    fb_id_new_ = 0u;
  }
  user_feedback_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserFeedback::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.UserFeedback.UserFeedbackInfo user_feedback_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_feedback_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_feedback_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_user_feedback_info;
        if (input->ExpectTag(18)) goto parse_gm_comit_time;
        break;
      }

      // optional bytes gm_comit_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gm_comit_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gm_comit_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_gm_reply_time;
        break;
      }

      // optional bytes gm_reply_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gm_reply_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gm_reply_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_gm_char_name;
        break;
      }

      // optional bytes gm_char_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gm_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gm_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_sendfb_type;
        break;
      }

      // optional uint32 sendfb_type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sendfb_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sendfb_type_)));
          set_has_sendfb_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_gm_talk;
        break;
      }

      // optional bytes gm_talk = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gm_talk:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gm_talk()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_fb_id_new;
        break;
      }

      // optional uint32 fb_id_new = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fb_id_new:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fb_id_new_)));
          set_has_fb_id_new();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserFeedback::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.UserFeedback.UserFeedbackInfo user_feedback_info = 1;
  for (int i = 0; i < this->user_feedback_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user_feedback_info(i), output);
  }

  // optional bytes gm_comit_time = 2;
  if (has_gm_comit_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->gm_comit_time(), output);
  }

  // optional bytes gm_reply_time = 3;
  if (has_gm_reply_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->gm_reply_time(), output);
  }

  // optional bytes gm_char_name = 4;
  if (has_gm_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->gm_char_name(), output);
  }

  // optional uint32 sendfb_type = 5;
  if (has_sendfb_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sendfb_type(), output);
  }

  // optional bytes gm_talk = 6;
  if (has_gm_talk()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->gm_talk(), output);
  }

  // optional uint32 fb_id_new = 7;
  if (has_fb_id_new()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->fb_id_new(), output);
  }

}

int UserFeedback::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes gm_comit_time = 2;
    if (has_gm_comit_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gm_comit_time());
    }

    // optional bytes gm_reply_time = 3;
    if (has_gm_reply_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gm_reply_time());
    }

    // optional bytes gm_char_name = 4;
    if (has_gm_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gm_char_name());
    }

    // optional uint32 sendfb_type = 5;
    if (has_sendfb_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sendfb_type());
    }

    // optional bytes gm_talk = 6;
    if (has_gm_talk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gm_talk());
    }

    // optional uint32 fb_id_new = 7;
    if (has_fb_id_new()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fb_id_new());
    }

  }
  // repeated .message.UserFeedback.UserFeedbackInfo user_feedback_info = 1;
  total_size += 1 * this->user_feedback_info_size();
  for (int i = 0; i < this->user_feedback_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_feedback_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserFeedback::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserFeedback*>(&from));
}

void UserFeedback::MergeFrom(const UserFeedback& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_feedback_info_.MergeFrom(from.user_feedback_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_gm_comit_time()) {
      set_gm_comit_time(from.gm_comit_time());
    }
    if (from.has_gm_reply_time()) {
      set_gm_reply_time(from.gm_reply_time());
    }
    if (from.has_gm_char_name()) {
      set_gm_char_name(from.gm_char_name());
    }
    if (from.has_sendfb_type()) {
      set_sendfb_type(from.sendfb_type());
    }
    if (from.has_gm_talk()) {
      set_gm_talk(from.gm_talk());
    }
    if (from.has_fb_id_new()) {
      set_fb_id_new(from.fb_id_new());
    }
  }
}

void UserFeedback::CopyFrom(const UserFeedback& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserFeedback::IsInitialized() const {

  return true;
}

void UserFeedback::Swap(UserFeedback* other) {
  if (other != this) {
    user_feedback_info_.Swap(&other->user_feedback_info_);
    std::swap(gm_comit_time_, other->gm_comit_time_);
    std::swap(gm_reply_time_, other->gm_reply_time_);
    std::swap(gm_char_name_, other->gm_char_name_);
    std::swap(sendfb_type_, other->sendfb_type_);
    std::swap(gm_talk_, other->gm_talk_);
    std::swap(fb_id_new_, other->fb_id_new_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserFeedback::GetTypeName() const {
  return "message.UserFeedback";
}


// ===================================================================

#ifndef _MSC_VER
const int SystemReward::kOperIdFieldNumber;
const int SystemReward::kRewardItemFieldNumber;
const int SystemReward::kRewardItemNumFieldNumber;
const int SystemReward::kOperPosFieldNumber;
const int SystemReward::kSysMsgFieldNumber;
const int SystemReward::kSendTypeFieldNumber;
const int SystemReward::kGlassFieldNumber;
const int SystemReward::kNameFieldNumber;
const int SystemReward::kSdkFieldNumber;
const int SystemReward::kServerIdFieldNumber;
const int SystemReward::kGmAccidFieldNumber;
#endif  // !_MSC_VER

SystemReward::SystemReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SystemReward::InitAsDefaultInstance() {
}

SystemReward::SystemReward(const SystemReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SystemReward::SharedCtor() {
  _cached_size_ = 0;
  send_type_ = 0u;
  glass_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sdk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  server_id_ = 0u;
  gm_accid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemReward::~SystemReward() {
  SharedDtor();
}

void SystemReward::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (sdk_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SystemReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemReward& SystemReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SystemReward* SystemReward::default_instance_ = NULL;

SystemReward* SystemReward::New() const {
  return new SystemReward;
}

void SystemReward::Clear() {
  if (_has_bits_[5 / 32] & (0xffu << (5 % 32))) {
    send_type_ = 0u;
    glass_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_sdk()) {
      if (sdk_ != &::google::protobuf::internal::kEmptyString) {
        sdk_->clear();
      }
    }
    server_id_ = 0u;
    gm_accid_ = 0u;
  }
  oper_id_.Clear();
  reward_item_.Clear();
  reward_item_num_.Clear();
  oper_pos_.Clear();
  sys_msg_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SystemReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 oper_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_oper_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_oper_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_oper_id;
        if (input->ExpectTag(16)) goto parse_reward_item;
        break;
      }

      // repeated uint32 reward_item = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_item:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_reward_item())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_reward_item())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_reward_item;
        if (input->ExpectTag(24)) goto parse_reward_item_num;
        break;
      }

      // repeated uint32 reward_item_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_reward_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_reward_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_reward_item_num;
        if (input->ExpectTag(32)) goto parse_oper_pos;
        break;
      }

      // repeated uint32 oper_pos = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_oper_pos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_oper_pos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_oper_pos;
        if (input->ExpectTag(42)) goto parse_sys_msg;
        break;
      }

      // repeated bytes sys_msg = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sys_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_sys_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_sys_msg;
        if (input->ExpectTag(48)) goto parse_send_type;
        break;
      }

      // optional uint32 send_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_send_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &send_type_)));
          set_has_send_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_glass;
        break;
      }

      // optional uint32 glass = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_glass:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &glass_)));
          set_has_glass();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_name;
        break;
      }

      // optional bytes name = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_sdk;
        break;
      }

      // optional bytes sdk = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sdk:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sdk()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_gm_accid;
        break;
      }

      // optional uint32 gm_accid = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gm_accid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_accid_)));
          set_has_gm_accid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SystemReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 oper_id = 1;
  for (int i = 0; i < this->oper_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->oper_id(i), output);
  }

  // repeated uint32 reward_item = 2;
  for (int i = 0; i < this->reward_item_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->reward_item(i), output);
  }

  // repeated uint32 reward_item_num = 3;
  for (int i = 0; i < this->reward_item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->reward_item_num(i), output);
  }

  // repeated uint32 oper_pos = 4;
  for (int i = 0; i < this->oper_pos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->oper_pos(i), output);
  }

  // repeated bytes sys_msg = 5;
  for (int i = 0; i < this->sys_msg_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->sys_msg(i), output);
  }

  // optional uint32 send_type = 6;
  if (has_send_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->send_type(), output);
  }

  // optional uint32 glass = 7;
  if (has_glass()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->glass(), output);
  }

  // optional bytes name = 8;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->name(), output);
  }

  // optional bytes sdk = 9;
  if (has_sdk()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->sdk(), output);
  }

  // optional uint32 server_id = 10;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->server_id(), output);
  }

  // optional uint32 gm_accid = 11;
  if (has_gm_accid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->gm_accid(), output);
  }

}

int SystemReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[5 / 32] & (0xffu << (5 % 32))) {
    // optional uint32 send_type = 6;
    if (has_send_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->send_type());
    }

    // optional uint32 glass = 7;
    if (has_glass()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->glass());
    }

    // optional bytes name = 8;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes sdk = 9;
    if (has_sdk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sdk());
    }

    // optional uint32 server_id = 10;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 gm_accid = 11;
    if (has_gm_accid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_accid());
    }

  }
  // repeated uint32 oper_id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->oper_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->oper_id(i));
    }
    total_size += 1 * this->oper_id_size() + data_size;
  }

  // repeated uint32 reward_item = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->reward_item_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->reward_item(i));
    }
    total_size += 1 * this->reward_item_size() + data_size;
  }

  // repeated uint32 reward_item_num = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->reward_item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->reward_item_num(i));
    }
    total_size += 1 * this->reward_item_num_size() + data_size;
  }

  // repeated uint32 oper_pos = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->oper_pos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->oper_pos(i));
    }
    total_size += 1 * this->oper_pos_size() + data_size;
  }

  // repeated bytes sys_msg = 5;
  total_size += 1 * this->sys_msg_size();
  for (int i = 0; i < this->sys_msg_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->sys_msg(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemReward*>(&from));
}

void SystemReward::MergeFrom(const SystemReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  oper_id_.MergeFrom(from.oper_id_);
  reward_item_.MergeFrom(from.reward_item_);
  reward_item_num_.MergeFrom(from.reward_item_num_);
  oper_pos_.MergeFrom(from.oper_pos_);
  sys_msg_.MergeFrom(from.sys_msg_);
  if (from._has_bits_[5 / 32] & (0xffu << (5 % 32))) {
    if (from.has_send_type()) {
      set_send_type(from.send_type());
    }
    if (from.has_glass()) {
      set_glass(from.glass());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sdk()) {
      set_sdk(from.sdk());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_gm_accid()) {
      set_gm_accid(from.gm_accid());
    }
  }
}

void SystemReward::CopyFrom(const SystemReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemReward::IsInitialized() const {

  return true;
}

void SystemReward::Swap(SystemReward* other) {
  if (other != this) {
    oper_id_.Swap(&other->oper_id_);
    reward_item_.Swap(&other->reward_item_);
    reward_item_num_.Swap(&other->reward_item_num_);
    oper_pos_.Swap(&other->oper_pos_);
    sys_msg_.Swap(&other->sys_msg_);
    std::swap(send_type_, other->send_type_);
    std::swap(glass_, other->glass_);
    std::swap(name_, other->name_);
    std::swap(sdk_, other->sdk_);
    std::swap(server_id_, other->server_id_);
    std::swap(gm_accid_, other->gm_accid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SystemReward::GetTypeName() const {
  return "message.SystemReward";
}


// ===================================================================

#ifndef _MSC_VER
const int GMFreezeSystem_GMFreezeSystemInfo::kAccIdFieldNumber;
const int GMFreezeSystem_GMFreezeSystemInfo::kServerIdFieldNumber;
const int GMFreezeSystem_GMFreezeSystemInfo::kGmTypeFieldNumber;
const int GMFreezeSystem_GMFreezeSystemInfo::kHourFieldNumber;
const int GMFreezeSystem_GMFreezeSystemInfo::kReasonFieldNumber;
const int GMFreezeSystem_GMFreezeSystemInfo::kFreezeTimeFieldNumber;
const int GMFreezeSystem_GMFreezeSystemInfo::kEndTimeFieldNumber;
const int GMFreezeSystem_GMFreezeSystemInfo::kGmNameFieldNumber;
const int GMFreezeSystem_GMFreezeSystemInfo::kCharNameFieldNumber;
#endif  // !_MSC_VER

GMFreezeSystem_GMFreezeSystemInfo::GMFreezeSystem_GMFreezeSystemInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GMFreezeSystem_GMFreezeSystemInfo::InitAsDefaultInstance() {
}

GMFreezeSystem_GMFreezeSystemInfo::GMFreezeSystem_GMFreezeSystemInfo(const GMFreezeSystem_GMFreezeSystemInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GMFreezeSystem_GMFreezeSystemInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  server_id_ = 0u;
  gm_type_ = 0u;
  hour_ = 0u;
  reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  freeze_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gm_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GMFreezeSystem_GMFreezeSystemInfo::~GMFreezeSystem_GMFreezeSystemInfo() {
  SharedDtor();
}

void GMFreezeSystem_GMFreezeSystemInfo::SharedDtor() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (freeze_time_ != &::google::protobuf::internal::kEmptyString) {
    delete freeze_time_;
  }
  if (end_time_ != &::google::protobuf::internal::kEmptyString) {
    delete end_time_;
  }
  if (gm_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_name_;
  }
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GMFreezeSystem_GMFreezeSystemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GMFreezeSystem_GMFreezeSystemInfo& GMFreezeSystem_GMFreezeSystemInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GMFreezeSystem_GMFreezeSystemInfo* GMFreezeSystem_GMFreezeSystemInfo::default_instance_ = NULL;

GMFreezeSystem_GMFreezeSystemInfo* GMFreezeSystem_GMFreezeSystemInfo::New() const {
  return new GMFreezeSystem_GMFreezeSystemInfo;
}

void GMFreezeSystem_GMFreezeSystemInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    server_id_ = 0u;
    gm_type_ = 0u;
    hour_ = 0u;
    if (has_reason()) {
      if (reason_ != &::google::protobuf::internal::kEmptyString) {
        reason_->clear();
      }
    }
    if (has_freeze_time()) {
      if (freeze_time_ != &::google::protobuf::internal::kEmptyString) {
        freeze_time_->clear();
      }
    }
    if (has_end_time()) {
      if (end_time_ != &::google::protobuf::internal::kEmptyString) {
        end_time_->clear();
      }
    }
    if (has_gm_name()) {
      if (gm_name_ != &::google::protobuf::internal::kEmptyString) {
        gm_name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GMFreezeSystem_GMFreezeSystemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_gm_type;
        break;
      }

      // optional uint32 gm_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gm_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_type_)));
          set_has_gm_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_hour;
        break;
      }

      // optional uint32 hour = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hour_)));
          set_has_hour();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_reason;
        break;
      }

      // optional bytes reason = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reason:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reason()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_freeze_time;
        break;
      }

      // optional bytes freeze_time = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_freeze_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_freeze_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_end_time;
        break;
      }

      // optional bytes end_time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_end_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_end_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_gm_name;
        break;
      }

      // optional bytes gm_name = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gm_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gm_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_char_name;
        break;
      }

      // optional bytes char_name = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GMFreezeSystem_GMFreezeSystemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // optional uint32 server_id = 2;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->server_id(), output);
  }

  // optional uint32 gm_type = 3;
  if (has_gm_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->gm_type(), output);
  }

  // optional uint32 hour = 4;
  if (has_hour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->hour(), output);
  }

  // optional bytes reason = 5;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->reason(), output);
  }

  // optional bytes freeze_time = 6;
  if (has_freeze_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->freeze_time(), output);
  }

  // optional bytes end_time = 7;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->end_time(), output);
  }

  // optional bytes gm_name = 8;
  if (has_gm_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->gm_name(), output);
  }

  // optional bytes char_name = 9;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->char_name(), output);
  }

}

int GMFreezeSystem_GMFreezeSystemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional uint32 server_id = 2;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 gm_type = 3;
    if (has_gm_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_type());
    }

    // optional uint32 hour = 4;
    if (has_hour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hour());
    }

    // optional bytes reason = 5;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reason());
    }

    // optional bytes freeze_time = 6;
    if (has_freeze_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->freeze_time());
    }

    // optional bytes end_time = 7;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->end_time());
    }

    // optional bytes gm_name = 8;
    if (has_gm_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gm_name());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes char_name = 9;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GMFreezeSystem_GMFreezeSystemInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GMFreezeSystem_GMFreezeSystemInfo*>(&from));
}

void GMFreezeSystem_GMFreezeSystemInfo::MergeFrom(const GMFreezeSystem_GMFreezeSystemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_gm_type()) {
      set_gm_type(from.gm_type());
    }
    if (from.has_hour()) {
      set_hour(from.hour());
    }
    if (from.has_reason()) {
      set_reason(from.reason());
    }
    if (from.has_freeze_time()) {
      set_freeze_time(from.freeze_time());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
    if (from.has_gm_name()) {
      set_gm_name(from.gm_name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
  }
}

void GMFreezeSystem_GMFreezeSystemInfo::CopyFrom(const GMFreezeSystem_GMFreezeSystemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GMFreezeSystem_GMFreezeSystemInfo::IsInitialized() const {

  return true;
}

void GMFreezeSystem_GMFreezeSystemInfo::Swap(GMFreezeSystem_GMFreezeSystemInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(server_id_, other->server_id_);
    std::swap(gm_type_, other->gm_type_);
    std::swap(hour_, other->hour_);
    std::swap(reason_, other->reason_);
    std::swap(freeze_time_, other->freeze_time_);
    std::swap(end_time_, other->end_time_);
    std::swap(gm_name_, other->gm_name_);
    std::swap(char_name_, other->char_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GMFreezeSystem_GMFreezeSystemInfo::GetTypeName() const {
  return "message.GMFreezeSystem.GMFreezeSystemInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GMFreezeSystem::kGmFreezeInfoFieldNumber;
const int GMFreezeSystem::kGmAccIdFieldNumber;
const int GMFreezeSystem::kSendTypeFieldNumber;
const int GMFreezeSystem::kGmCheckTimeFieldNumber;
const int GMFreezeSystem::kGmCharNameFieldNumber;
#endif  // !_MSC_VER

GMFreezeSystem::GMFreezeSystem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GMFreezeSystem::InitAsDefaultInstance() {
}

GMFreezeSystem::GMFreezeSystem(const GMFreezeSystem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GMFreezeSystem::SharedCtor() {
  _cached_size_ = 0;
  gm_acc_id_ = 0u;
  send_type_ = 0u;
  gm_check_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gm_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GMFreezeSystem::~GMFreezeSystem() {
  SharedDtor();
}

void GMFreezeSystem::SharedDtor() {
  if (gm_check_time_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_check_time_;
  }
  if (gm_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_char_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GMFreezeSystem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GMFreezeSystem& GMFreezeSystem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GMFreezeSystem* GMFreezeSystem::default_instance_ = NULL;

GMFreezeSystem* GMFreezeSystem::New() const {
  return new GMFreezeSystem;
}

void GMFreezeSystem::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    gm_acc_id_ = 0u;
    send_type_ = 0u;
    if (has_gm_check_time()) {
      if (gm_check_time_ != &::google::protobuf::internal::kEmptyString) {
        gm_check_time_->clear();
      }
    }
    if (has_gm_char_name()) {
      if (gm_char_name_ != &::google::protobuf::internal::kEmptyString) {
        gm_char_name_->clear();
      }
    }
  }
  gm_freeze_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GMFreezeSystem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.GMFreezeSystem.GMFreezeSystemInfo gm_freeze_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gm_freeze_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gm_freeze_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_gm_freeze_info;
        if (input->ExpectTag(16)) goto parse_gm_acc_id;
        break;
      }

      // optional uint32 gm_acc_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gm_acc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_acc_id_)));
          set_has_gm_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_send_type;
        break;
      }

      // optional uint32 send_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_send_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &send_type_)));
          set_has_send_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_gm_check_time;
        break;
      }

      // optional bytes gm_check_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gm_check_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gm_check_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_gm_char_name;
        break;
      }

      // optional bytes gm_char_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gm_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gm_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GMFreezeSystem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.GMFreezeSystem.GMFreezeSystemInfo gm_freeze_info = 1;
  for (int i = 0; i < this->gm_freeze_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->gm_freeze_info(i), output);
  }

  // optional uint32 gm_acc_id = 2;
  if (has_gm_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->gm_acc_id(), output);
  }

  // optional uint32 send_type = 3;
  if (has_send_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->send_type(), output);
  }

  // optional bytes gm_check_time = 4;
  if (has_gm_check_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->gm_check_time(), output);
  }

  // optional bytes gm_char_name = 5;
  if (has_gm_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->gm_char_name(), output);
  }

}

int GMFreezeSystem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 gm_acc_id = 2;
    if (has_gm_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_acc_id());
    }

    // optional uint32 send_type = 3;
    if (has_send_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->send_type());
    }

    // optional bytes gm_check_time = 4;
    if (has_gm_check_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gm_check_time());
    }

    // optional bytes gm_char_name = 5;
    if (has_gm_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gm_char_name());
    }

  }
  // repeated .message.GMFreezeSystem.GMFreezeSystemInfo gm_freeze_info = 1;
  total_size += 1 * this->gm_freeze_info_size();
  for (int i = 0; i < this->gm_freeze_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gm_freeze_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GMFreezeSystem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GMFreezeSystem*>(&from));
}

void GMFreezeSystem::MergeFrom(const GMFreezeSystem& from) {
  GOOGLE_CHECK_NE(&from, this);
  gm_freeze_info_.MergeFrom(from.gm_freeze_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_gm_acc_id()) {
      set_gm_acc_id(from.gm_acc_id());
    }
    if (from.has_send_type()) {
      set_send_type(from.send_type());
    }
    if (from.has_gm_check_time()) {
      set_gm_check_time(from.gm_check_time());
    }
    if (from.has_gm_char_name()) {
      set_gm_char_name(from.gm_char_name());
    }
  }
}

void GMFreezeSystem::CopyFrom(const GMFreezeSystem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GMFreezeSystem::IsInitialized() const {

  return true;
}

void GMFreezeSystem::Swap(GMFreezeSystem* other) {
  if (other != this) {
    gm_freeze_info_.Swap(&other->gm_freeze_info_);
    std::swap(gm_acc_id_, other->gm_acc_id_);
    std::swap(send_type_, other->send_type_);
    std::swap(gm_check_time_, other->gm_check_time_);
    std::swap(gm_char_name_, other->gm_char_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GMFreezeSystem::GetTypeName() const {
  return "message.GMFreezeSystem";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginSystemNotice::kNoticeTypeFieldNumber;
const int LoginSystemNotice::kAccIdFieldNumber;
const int LoginSystemNotice::kNoticeFieldNumber;
const int LoginSystemNotice::kNoticeTimeFieldNumber;
const int LoginSystemNotice::kSdkFieldNumber;
#endif  // !_MSC_VER

LoginSystemNotice::LoginSystemNotice()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginSystemNotice::InitAsDefaultInstance() {
}

LoginSystemNotice::LoginSystemNotice(const LoginSystemNotice& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginSystemNotice::SharedCtor() {
  _cached_size_ = 0;
  notice_type_ = 0u;
  acc_id_ = 0u;
  notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  notice_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sdk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginSystemNotice::~LoginSystemNotice() {
  SharedDtor();
}

void LoginSystemNotice::SharedDtor() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice_time_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_time_;
  }
  if (sdk_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginSystemNotice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginSystemNotice& LoginSystemNotice::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoginSystemNotice* LoginSystemNotice::default_instance_ = NULL;

LoginSystemNotice* LoginSystemNotice::New() const {
  return new LoginSystemNotice;
}

void LoginSystemNotice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    notice_type_ = 0u;
    acc_id_ = 0u;
    if (has_notice()) {
      if (notice_ != &::google::protobuf::internal::kEmptyString) {
        notice_->clear();
      }
    }
    if (has_notice_time()) {
      if (notice_time_ != &::google::protobuf::internal::kEmptyString) {
        notice_time_->clear();
      }
    }
    if (has_sdk()) {
      if (sdk_ != &::google::protobuf::internal::kEmptyString) {
        sdk_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginSystemNotice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 notice_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &notice_type_)));
          set_has_notice_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_acc_id;
        break;
      }

      // optional uint32 acc_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_notice;
        break;
      }

      // optional bytes notice = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_notice()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_notice_time;
        break;
      }

      // optional bytes notice_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notice_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_notice_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_sdk;
        break;
      }

      // optional bytes sdk = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sdk:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sdk()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginSystemNotice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 notice_type = 1;
  if (has_notice_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->notice_type(), output);
  }

  // optional uint32 acc_id = 2;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->acc_id(), output);
  }

  // optional bytes notice = 3;
  if (has_notice()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->notice(), output);
  }

  // optional bytes notice_time = 4;
  if (has_notice_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->notice_time(), output);
  }

  // optional bytes sdk = 5;
  if (has_sdk()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->sdk(), output);
  }

}

int LoginSystemNotice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 notice_type = 1;
    if (has_notice_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->notice_type());
    }

    // optional uint32 acc_id = 2;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional bytes notice = 3;
    if (has_notice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->notice());
    }

    // optional bytes notice_time = 4;
    if (has_notice_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->notice_time());
    }

    // optional bytes sdk = 5;
    if (has_sdk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sdk());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginSystemNotice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginSystemNotice*>(&from));
}

void LoginSystemNotice::MergeFrom(const LoginSystemNotice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_notice_type()) {
      set_notice_type(from.notice_type());
    }
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_notice()) {
      set_notice(from.notice());
    }
    if (from.has_notice_time()) {
      set_notice_time(from.notice_time());
    }
    if (from.has_sdk()) {
      set_sdk(from.sdk());
    }
  }
}

void LoginSystemNotice::CopyFrom(const LoginSystemNotice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginSystemNotice::IsInitialized() const {

  return true;
}

void LoginSystemNotice::Swap(LoginSystemNotice* other) {
  if (other != this) {
    std::swap(notice_type_, other->notice_type_);
    std::swap(acc_id_, other->acc_id_);
    std::swap(notice_, other->notice_);
    std::swap(notice_time_, other->notice_time_);
    std::swap(sdk_, other->sdk_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginSystemNotice::GetTypeName() const {
  return "message.LoginSystemNotice";
}


// ===================================================================

#ifndef _MSC_VER
const int GMOperationResult::kGmAccidFieldNumber;
const int GMOperationResult::kGmOptypeFieldNumber;
const int GMOperationResult::kRolenameFieldNumber;
const int GMOperationResult::kFailReasonFieldNumber;
#endif  // !_MSC_VER

GMOperationResult::GMOperationResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GMOperationResult::InitAsDefaultInstance() {
}

GMOperationResult::GMOperationResult(const GMOperationResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GMOperationResult::SharedCtor() {
  _cached_size_ = 0;
  gm_accid_ = 0u;
  gm_optype_ = 0u;
  rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fail_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GMOperationResult::~GMOperationResult() {
  SharedDtor();
}

void GMOperationResult::SharedDtor() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (fail_reason_ != &::google::protobuf::internal::kEmptyString) {
    delete fail_reason_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GMOperationResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GMOperationResult& GMOperationResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GMOperationResult* GMOperationResult::default_instance_ = NULL;

GMOperationResult* GMOperationResult::New() const {
  return new GMOperationResult;
}

void GMOperationResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gm_accid_ = 0u;
    gm_optype_ = 0u;
    if (has_rolename()) {
      if (rolename_ != &::google::protobuf::internal::kEmptyString) {
        rolename_->clear();
      }
    }
    if (has_fail_reason()) {
      if (fail_reason_ != &::google::protobuf::internal::kEmptyString) {
        fail_reason_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GMOperationResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gm_accid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_accid_)));
          set_has_gm_accid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gm_optype;
        break;
      }

      // optional uint32 gm_optype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gm_optype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gm_optype_)));
          set_has_gm_optype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_rolename;
        break;
      }

      // optional bytes rolename = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rolename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_rolename()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_fail_reason;
        break;
      }

      // optional bytes fail_reason = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fail_reason:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fail_reason()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GMOperationResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 gm_accid = 1;
  if (has_gm_accid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->gm_accid(), output);
  }

  // optional uint32 gm_optype = 2;
  if (has_gm_optype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->gm_optype(), output);
  }

  // optional bytes rolename = 3;
  if (has_rolename()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->rolename(), output);
  }

  // optional bytes fail_reason = 4;
  if (has_fail_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->fail_reason(), output);
  }

}

int GMOperationResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 gm_accid = 1;
    if (has_gm_accid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_accid());
    }

    // optional uint32 gm_optype = 2;
    if (has_gm_optype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gm_optype());
    }

    // optional bytes rolename = 3;
    if (has_rolename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->rolename());
    }

    // optional bytes fail_reason = 4;
    if (has_fail_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->fail_reason());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GMOperationResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GMOperationResult*>(&from));
}

void GMOperationResult::MergeFrom(const GMOperationResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gm_accid()) {
      set_gm_accid(from.gm_accid());
    }
    if (from.has_gm_optype()) {
      set_gm_optype(from.gm_optype());
    }
    if (from.has_rolename()) {
      set_rolename(from.rolename());
    }
    if (from.has_fail_reason()) {
      set_fail_reason(from.fail_reason());
    }
  }
}

void GMOperationResult::CopyFrom(const GMOperationResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GMOperationResult::IsInitialized() const {

  return true;
}

void GMOperationResult::Swap(GMOperationResult* other) {
  if (other != this) {
    std::swap(gm_accid_, other->gm_accid_);
    std::swap(gm_optype_, other->gm_optype_);
    std::swap(rolename_, other->rolename_);
    std::swap(fail_reason_, other->fail_reason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GMOperationResult::GetTypeName() const {
  return "message.GMOperationResult";
}


// ===================================================================

#ifndef _MSC_VER
const int AckGetInviteCode::kValueFieldNumber;
#endif  // !_MSC_VER

AckGetInviteCode::AckGetInviteCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckGetInviteCode::InitAsDefaultInstance() {
}

AckGetInviteCode::AckGetInviteCode(const AckGetInviteCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckGetInviteCode::SharedCtor() {
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckGetInviteCode::~AckGetInviteCode() {
  SharedDtor();
}

void AckGetInviteCode::SharedDtor() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckGetInviteCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckGetInviteCode& AckGetInviteCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckGetInviteCode* AckGetInviteCode::default_instance_ = NULL;

AckGetInviteCode* AckGetInviteCode::New() const {
  return new AckGetInviteCode;
}

void AckGetInviteCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckGetInviteCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckGetInviteCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->value(), output);
  }

}

int AckGetInviteCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckGetInviteCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckGetInviteCode*>(&from));
}

void AckGetInviteCode::MergeFrom(const AckGetInviteCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void AckGetInviteCode::CopyFrom(const AckGetInviteCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckGetInviteCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckGetInviteCode::Swap(AckGetInviteCode* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckGetInviteCode::GetTypeName() const {
  return "message.AckGetInviteCode";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqDrawLottery::kValueFieldNumber;
#endif  // !_MSC_VER

ReqDrawLottery::ReqDrawLottery()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqDrawLottery::InitAsDefaultInstance() {
}

ReqDrawLottery::ReqDrawLottery(const ReqDrawLottery& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqDrawLottery::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqDrawLottery::~ReqDrawLottery() {
  SharedDtor();
}

void ReqDrawLottery::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqDrawLottery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqDrawLottery& ReqDrawLottery::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqDrawLottery* ReqDrawLottery::default_instance_ = NULL;

ReqDrawLottery* ReqDrawLottery::New() const {
  return new ReqDrawLottery;
}

void ReqDrawLottery::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqDrawLottery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqDrawLottery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqDrawLottery::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqDrawLottery::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqDrawLottery*>(&from));
}

void ReqDrawLottery::MergeFrom(const ReqDrawLottery& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqDrawLottery::CopyFrom(const ReqDrawLottery& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqDrawLottery::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqDrawLottery::Swap(ReqDrawLottery* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqDrawLottery::GetTypeName() const {
  return "message.ReqDrawLottery";
}


// ===================================================================

#ifndef _MSC_VER
const int GetLotteryReward::kValueFieldNumber;
#endif  // !_MSC_VER

GetLotteryReward::GetLotteryReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetLotteryReward::InitAsDefaultInstance() {
}

GetLotteryReward::GetLotteryReward(const GetLotteryReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetLotteryReward::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetLotteryReward::~GetLotteryReward() {
  SharedDtor();
}

void GetLotteryReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetLotteryReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetLotteryReward& GetLotteryReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetLotteryReward* GetLotteryReward::default_instance_ = NULL;

GetLotteryReward* GetLotteryReward::New() const {
  return new GetLotteryReward;
}

void GetLotteryReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetLotteryReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetLotteryReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int GetLotteryReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetLotteryReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetLotteryReward*>(&from));
}

void GetLotteryReward::MergeFrom(const GetLotteryReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void GetLotteryReward::CopyFrom(const GetLotteryReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLotteryReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetLotteryReward::Swap(GetLotteryReward* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetLotteryReward::GetTypeName() const {
  return "message.GetLotteryReward";
}


// ===================================================================

#ifndef _MSC_VER
const int GiveUpHighGradeDrawLottery::kValueFieldNumber;
#endif  // !_MSC_VER

GiveUpHighGradeDrawLottery::GiveUpHighGradeDrawLottery()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GiveUpHighGradeDrawLottery::InitAsDefaultInstance() {
}

GiveUpHighGradeDrawLottery::GiveUpHighGradeDrawLottery(const GiveUpHighGradeDrawLottery& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GiveUpHighGradeDrawLottery::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GiveUpHighGradeDrawLottery::~GiveUpHighGradeDrawLottery() {
  SharedDtor();
}

void GiveUpHighGradeDrawLottery::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GiveUpHighGradeDrawLottery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GiveUpHighGradeDrawLottery& GiveUpHighGradeDrawLottery::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GiveUpHighGradeDrawLottery* GiveUpHighGradeDrawLottery::default_instance_ = NULL;

GiveUpHighGradeDrawLottery* GiveUpHighGradeDrawLottery::New() const {
  return new GiveUpHighGradeDrawLottery;
}

void GiveUpHighGradeDrawLottery::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GiveUpHighGradeDrawLottery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GiveUpHighGradeDrawLottery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int GiveUpHighGradeDrawLottery::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GiveUpHighGradeDrawLottery::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GiveUpHighGradeDrawLottery*>(&from));
}

void GiveUpHighGradeDrawLottery::MergeFrom(const GiveUpHighGradeDrawLottery& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void GiveUpHighGradeDrawLottery::CopyFrom(const GiveUpHighGradeDrawLottery& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GiveUpHighGradeDrawLottery::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GiveUpHighGradeDrawLottery::Swap(GiveUpHighGradeDrawLottery* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GiveUpHighGradeDrawLottery::GetTypeName() const {
  return "message.GiveUpHighGradeDrawLottery";
}


// ===================================================================

#ifndef _MSC_VER
const int LotteryReward::kItemIdFieldNumber;
const int LotteryReward::kItemNumFieldNumber;
const int LotteryReward::kManQualityFieldNumber;
#endif  // !_MSC_VER

LotteryReward::LotteryReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LotteryReward::InitAsDefaultInstance() {
}

LotteryReward::LotteryReward(const LotteryReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LotteryReward::SharedCtor() {
  _cached_size_ = 0;
  item_id_ = 0u;
  item_num_ = 0u;
  man_quality_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LotteryReward::~LotteryReward() {
  SharedDtor();
}

void LotteryReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LotteryReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LotteryReward& LotteryReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LotteryReward* LotteryReward::default_instance_ = NULL;

LotteryReward* LotteryReward::New() const {
  return new LotteryReward;
}

void LotteryReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_id_ = 0u;
    item_num_ = 0u;
    man_quality_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LotteryReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 item_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_num;
        break;
      }

      // required uint32 item_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_man_quality;
        break;
      }

      // required uint32 man_quality = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_man_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &man_quality_)));
          set_has_man_quality();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LotteryReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 item_id = 1;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->item_id(), output);
  }

  // required uint32 item_num = 2;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_num(), output);
  }

  // required uint32 man_quality = 3;
  if (has_man_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->man_quality(), output);
  }

}

int LotteryReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 item_id = 1;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // required uint32 item_num = 2;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_num());
    }

    // required uint32 man_quality = 3;
    if (has_man_quality()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->man_quality());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LotteryReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LotteryReward*>(&from));
}

void LotteryReward::MergeFrom(const LotteryReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
    if (from.has_man_quality()) {
      set_man_quality(from.man_quality());
    }
  }
}

void LotteryReward::CopyFrom(const LotteryReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LotteryReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void LotteryReward::Swap(LotteryReward* other) {
  if (other != this) {
    std::swap(item_id_, other->item_id_);
    std::swap(item_num_, other->item_num_);
    std::swap(man_quality_, other->man_quality_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LotteryReward::GetTypeName() const {
  return "message.LotteryReward";
}


// ===================================================================

#ifndef _MSC_VER
const int LotteryRewardData::kValueFieldNumber;
#endif  // !_MSC_VER

LotteryRewardData::LotteryRewardData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LotteryRewardData::InitAsDefaultInstance() {
}

LotteryRewardData::LotteryRewardData(const LotteryRewardData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LotteryRewardData::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LotteryRewardData::~LotteryRewardData() {
  SharedDtor();
}

void LotteryRewardData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LotteryRewardData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LotteryRewardData& LotteryRewardData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LotteryRewardData* LotteryRewardData::default_instance_ = NULL;

LotteryRewardData* LotteryRewardData::New() const {
  return new LotteryRewardData;
}

void LotteryRewardData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LotteryRewardData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LotteryRewardData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int LotteryRewardData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LotteryRewardData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LotteryRewardData*>(&from));
}

void LotteryRewardData::MergeFrom(const LotteryRewardData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void LotteryRewardData::CopyFrom(const LotteryRewardData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LotteryRewardData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LotteryRewardData::Swap(LotteryRewardData* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LotteryRewardData::GetTypeName() const {
  return "message.LotteryRewardData";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqQuickDrawLottery::kValueFieldNumber;
#endif  // !_MSC_VER

ReqQuickDrawLottery::ReqQuickDrawLottery()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqQuickDrawLottery::InitAsDefaultInstance() {
}

ReqQuickDrawLottery::ReqQuickDrawLottery(const ReqQuickDrawLottery& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqQuickDrawLottery::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqQuickDrawLottery::~ReqQuickDrawLottery() {
  SharedDtor();
}

void ReqQuickDrawLottery::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqQuickDrawLottery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqQuickDrawLottery& ReqQuickDrawLottery::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqQuickDrawLottery* ReqQuickDrawLottery::default_instance_ = NULL;

ReqQuickDrawLottery* ReqQuickDrawLottery::New() const {
  return new ReqQuickDrawLottery;
}

void ReqQuickDrawLottery::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqQuickDrawLottery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqQuickDrawLottery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqQuickDrawLottery::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqQuickDrawLottery::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqQuickDrawLottery*>(&from));
}

void ReqQuickDrawLottery::MergeFrom(const ReqQuickDrawLottery& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqQuickDrawLottery::CopyFrom(const ReqQuickDrawLottery& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqQuickDrawLottery::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqQuickDrawLottery::Swap(ReqQuickDrawLottery* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqQuickDrawLottery::GetTypeName() const {
  return "message.ReqQuickDrawLottery";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGetInviteReward::kValueFieldNumber;
#endif  // !_MSC_VER

ReqGetInviteReward::ReqGetInviteReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqGetInviteReward::InitAsDefaultInstance() {
}

ReqGetInviteReward::ReqGetInviteReward(const ReqGetInviteReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqGetInviteReward::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGetInviteReward::~ReqGetInviteReward() {
  SharedDtor();
}

void ReqGetInviteReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqGetInviteReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqGetInviteReward& ReqGetInviteReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqGetInviteReward* ReqGetInviteReward::default_instance_ = NULL;

ReqGetInviteReward* ReqGetInviteReward::New() const {
  return new ReqGetInviteReward;
}

void ReqGetInviteReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqGetInviteReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqGetInviteReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqGetInviteReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGetInviteReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqGetInviteReward*>(&from));
}

void ReqGetInviteReward::MergeFrom(const ReqGetInviteReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqGetInviteReward::CopyFrom(const ReqGetInviteReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGetInviteReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqGetInviteReward::Swap(ReqGetInviteReward* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqGetInviteReward::GetTypeName() const {
  return "message.ReqGetInviteReward";
}


// ===================================================================

#ifndef _MSC_VER
const int AckGetInviteNum::kValueFieldNumber;
const int AckGetInviteNum::kCodeFieldNumber;
#endif  // !_MSC_VER

AckGetInviteNum::AckGetInviteNum()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckGetInviteNum::InitAsDefaultInstance() {
}

AckGetInviteNum::AckGetInviteNum(const AckGetInviteNum& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckGetInviteNum::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckGetInviteNum::~AckGetInviteNum() {
  SharedDtor();
}

void AckGetInviteNum::SharedDtor() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckGetInviteNum::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckGetInviteNum& AckGetInviteNum::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckGetInviteNum* AckGetInviteNum::default_instance_ = NULL;

AckGetInviteNum* AckGetInviteNum::New() const {
  return new AckGetInviteNum;
}

void AckGetInviteNum::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
    if (has_code()) {
      if (code_ != &::google::protobuf::internal::kEmptyString) {
        code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckGetInviteNum::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_code;
        break;
      }

      // optional bytes code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckGetInviteNum::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

  // optional bytes code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->code(), output);
  }

}

int AckGetInviteNum::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

    // optional bytes code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckGetInviteNum::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckGetInviteNum*>(&from));
}

void AckGetInviteNum::MergeFrom(const AckGetInviteNum& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void AckGetInviteNum::CopyFrom(const AckGetInviteNum& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckGetInviteNum::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckGetInviteNum::Swap(AckGetInviteNum* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckGetInviteNum::GetTypeName() const {
  return "message.AckGetInviteNum";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGetInviteNum::kValueFieldNumber;
#endif  // !_MSC_VER

ReqGetInviteNum::ReqGetInviteNum()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqGetInviteNum::InitAsDefaultInstance() {
}

ReqGetInviteNum::ReqGetInviteNum(const ReqGetInviteNum& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqGetInviteNum::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGetInviteNum::~ReqGetInviteNum() {
  SharedDtor();
}

void ReqGetInviteNum::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqGetInviteNum::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqGetInviteNum& ReqGetInviteNum::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqGetInviteNum* ReqGetInviteNum::default_instance_ = NULL;

ReqGetInviteNum* ReqGetInviteNum::New() const {
  return new ReqGetInviteNum;
}

void ReqGetInviteNum::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqGetInviteNum::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqGetInviteNum::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqGetInviteNum::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGetInviteNum::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqGetInviteNum*>(&from));
}

void ReqGetInviteNum::MergeFrom(const ReqGetInviteNum& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqGetInviteNum::CopyFrom(const ReqGetInviteNum& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGetInviteNum::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqGetInviteNum::Swap(ReqGetInviteNum* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqGetInviteNum::GetTypeName() const {
  return "message.ReqGetInviteNum";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqAddMoney::kValueFieldNumber;
#endif  // !_MSC_VER

ReqAddMoney::ReqAddMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqAddMoney::InitAsDefaultInstance() {
}

ReqAddMoney::ReqAddMoney(const ReqAddMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqAddMoney::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqAddMoney::~ReqAddMoney() {
  SharedDtor();
}

void ReqAddMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqAddMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqAddMoney& ReqAddMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqAddMoney* ReqAddMoney::default_instance_ = NULL;

ReqAddMoney* ReqAddMoney::New() const {
  return new ReqAddMoney;
}

void ReqAddMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqAddMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqAddMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqAddMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqAddMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqAddMoney*>(&from));
}

void ReqAddMoney::MergeFrom(const ReqAddMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqAddMoney::CopyFrom(const ReqAddMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqAddMoney::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqAddMoney::Swap(ReqAddMoney* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqAddMoney::GetTypeName() const {
  return "message.ReqAddMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int AddMoneyCost::kCostFieldNumber;
#endif  // !_MSC_VER

AddMoneyCost::AddMoneyCost()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddMoneyCost::InitAsDefaultInstance() {
}

AddMoneyCost::AddMoneyCost(const AddMoneyCost& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddMoneyCost::SharedCtor() {
  _cached_size_ = 0;
  cost_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddMoneyCost::~AddMoneyCost() {
  SharedDtor();
}

void AddMoneyCost::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddMoneyCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddMoneyCost& AddMoneyCost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddMoneyCost* AddMoneyCost::default_instance_ = NULL;

AddMoneyCost* AddMoneyCost::New() const {
  return new AddMoneyCost;
}

void AddMoneyCost::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cost_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddMoneyCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 cost = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_)));
          set_has_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddMoneyCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 cost = 1;
  if (has_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->cost(), output);
  }

}

int AddMoneyCost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 cost = 1;
    if (has_cost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cost());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddMoneyCost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddMoneyCost*>(&from));
}

void AddMoneyCost::MergeFrom(const AddMoneyCost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cost()) {
      set_cost(from.cost());
    }
  }
}

void AddMoneyCost::CopyFrom(const AddMoneyCost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddMoneyCost::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AddMoneyCost::Swap(AddMoneyCost* other) {
  if (other != this) {
    std::swap(cost_, other->cost_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddMoneyCost::GetTypeName() const {
  return "message.AddMoneyCost";
}


// ===================================================================

#ifndef _MSC_VER
const int ChooseAddMoney::kValueFieldNumber;
#endif  // !_MSC_VER

ChooseAddMoney::ChooseAddMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChooseAddMoney::InitAsDefaultInstance() {
}

ChooseAddMoney::ChooseAddMoney(const ChooseAddMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChooseAddMoney::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChooseAddMoney::~ChooseAddMoney() {
  SharedDtor();
}

void ChooseAddMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChooseAddMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChooseAddMoney& ChooseAddMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ChooseAddMoney* ChooseAddMoney::default_instance_ = NULL;

ChooseAddMoney* ChooseAddMoney::New() const {
  return new ChooseAddMoney;
}

void ChooseAddMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChooseAddMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChooseAddMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ChooseAddMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChooseAddMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChooseAddMoney*>(&from));
}

void ChooseAddMoney::MergeFrom(const ChooseAddMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ChooseAddMoney::CopyFrom(const ChooseAddMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChooseAddMoney::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ChooseAddMoney::Swap(ChooseAddMoney* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChooseAddMoney::GetTypeName() const {
  return "message.ChooseAddMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int RightPosition::kValueFieldNumber;
#endif  // !_MSC_VER

RightPosition::RightPosition()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RightPosition::InitAsDefaultInstance() {
}

RightPosition::RightPosition(const RightPosition& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RightPosition::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RightPosition::~RightPosition() {
  SharedDtor();
}

void RightPosition::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RightPosition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RightPosition& RightPosition::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

RightPosition* RightPosition::default_instance_ = NULL;

RightPosition* RightPosition::New() const {
  return new RightPosition;
}

void RightPosition::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RightPosition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RightPosition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int RightPosition::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RightPosition::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RightPosition*>(&from));
}

void RightPosition::MergeFrom(const RightPosition& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void RightPosition::CopyFrom(const RightPosition& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RightPosition::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RightPosition::Swap(RightPosition* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RightPosition::GetTypeName() const {
  return "message.RightPosition";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenBowl::kPosFieldNumber;
#endif  // !_MSC_VER

OpenBowl::OpenBowl()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OpenBowl::InitAsDefaultInstance() {
}

OpenBowl::OpenBowl(const OpenBowl& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OpenBowl::SharedCtor() {
  _cached_size_ = 0;
  pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenBowl::~OpenBowl() {
  SharedDtor();
}

void OpenBowl::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenBowl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenBowl& OpenBowl::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OpenBowl* OpenBowl::default_instance_ = NULL;

OpenBowl* OpenBowl::New() const {
  return new OpenBowl;
}

void OpenBowl::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OpenBowl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenBowl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pos(), output);
  }

}

int OpenBowl::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenBowl::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenBowl*>(&from));
}

void OpenBowl::MergeFrom(const OpenBowl& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      set_pos(from.pos());
    }
  }
}

void OpenBowl::CopyFrom(const OpenBowl& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenBowl::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void OpenBowl::Swap(OpenBowl* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenBowl::GetTypeName() const {
  return "message.OpenBowl";
}


// ===================================================================

#ifndef _MSC_VER
const int AddMoneyReward::kResultFieldNumber;
const int AddMoneyReward::kMoneyFieldNumber;
#endif  // !_MSC_VER

AddMoneyReward::AddMoneyReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddMoneyReward::InitAsDefaultInstance() {
}

AddMoneyReward::AddMoneyReward(const AddMoneyReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddMoneyReward::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0u;
  money_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddMoneyReward::~AddMoneyReward() {
  SharedDtor();
}

void AddMoneyReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddMoneyReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddMoneyReward& AddMoneyReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddMoneyReward* AddMoneyReward::default_instance_ = NULL;

AddMoneyReward* AddMoneyReward::New() const {
  return new AddMoneyReward;
}

void AddMoneyReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0u;
    money_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddMoneyReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_money;
        break;
      }

      // required uint32 money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddMoneyReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result(), output);
  }

  // required uint32 money = 2;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->money(), output);
  }

}

int AddMoneyReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // required uint32 money = 2;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddMoneyReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddMoneyReward*>(&from));
}

void AddMoneyReward::MergeFrom(const AddMoneyReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
}

void AddMoneyReward::CopyFrom(const AddMoneyReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddMoneyReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AddMoneyReward::Swap(AddMoneyReward* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddMoneyReward::GetTypeName() const {
  return "message.AddMoneyReward";
}


// ===================================================================

#ifndef _MSC_VER
const int GetFirstRechargeGift::kValueFieldNumber;
#endif  // !_MSC_VER

GetFirstRechargeGift::GetFirstRechargeGift()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetFirstRechargeGift::InitAsDefaultInstance() {
}

GetFirstRechargeGift::GetFirstRechargeGift(const GetFirstRechargeGift& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetFirstRechargeGift::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetFirstRechargeGift::~GetFirstRechargeGift() {
  SharedDtor();
}

void GetFirstRechargeGift::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetFirstRechargeGift::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetFirstRechargeGift& GetFirstRechargeGift::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetFirstRechargeGift* GetFirstRechargeGift::default_instance_ = NULL;

GetFirstRechargeGift* GetFirstRechargeGift::New() const {
  return new GetFirstRechargeGift;
}

void GetFirstRechargeGift::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetFirstRechargeGift::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetFirstRechargeGift::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int GetFirstRechargeGift::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetFirstRechargeGift::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetFirstRechargeGift*>(&from));
}

void GetFirstRechargeGift::MergeFrom(const GetFirstRechargeGift& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void GetFirstRechargeGift::CopyFrom(const GetFirstRechargeGift& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFirstRechargeGift::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetFirstRechargeGift::Swap(GetFirstRechargeGift* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetFirstRechargeGift::GetTypeName() const {
  return "message.GetFirstRechargeGift";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqAccelerateAction::kActionIdFieldNumber;
const int ReqAccelerateAction::kActionValueFieldNumber;
#endif  // !_MSC_VER

ReqAccelerateAction::ReqAccelerateAction()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqAccelerateAction::InitAsDefaultInstance() {
}

ReqAccelerateAction::ReqAccelerateAction(const ReqAccelerateAction& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqAccelerateAction::SharedCtor() {
  _cached_size_ = 0;
  action_id_ = 0u;
  action_value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqAccelerateAction::~ReqAccelerateAction() {
  SharedDtor();
}

void ReqAccelerateAction::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqAccelerateAction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqAccelerateAction& ReqAccelerateAction::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqAccelerateAction* ReqAccelerateAction::default_instance_ = NULL;

ReqAccelerateAction* ReqAccelerateAction::New() const {
  return new ReqAccelerateAction;
}

void ReqAccelerateAction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    action_id_ = 0u;
    action_value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqAccelerateAction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 action_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &action_id_)));
          set_has_action_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_action_value;
        break;
      }

      // optional uint32 action_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &action_value_)));
          set_has_action_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqAccelerateAction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 action_id = 1;
  if (has_action_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->action_id(), output);
  }

  // optional uint32 action_value = 2;
  if (has_action_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->action_value(), output);
  }

}

int ReqAccelerateAction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 action_id = 1;
    if (has_action_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->action_id());
    }

    // optional uint32 action_value = 2;
    if (has_action_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->action_value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqAccelerateAction::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqAccelerateAction*>(&from));
}

void ReqAccelerateAction::MergeFrom(const ReqAccelerateAction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_action_id()) {
      set_action_id(from.action_id());
    }
    if (from.has_action_value()) {
      set_action_value(from.action_value());
    }
  }
}

void ReqAccelerateAction::CopyFrom(const ReqAccelerateAction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqAccelerateAction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqAccelerateAction::Swap(ReqAccelerateAction* other) {
  if (other != this) {
    std::swap(action_id_, other->action_id_);
    std::swap(action_value_, other->action_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqAccelerateAction::GetTypeName() const {
  return "message.ReqAccelerateAction";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqBuyTimesAction::kActionIdFieldNumber;
const int ReqBuyTimesAction::kActionValueFieldNumber;
#endif  // !_MSC_VER

ReqBuyTimesAction::ReqBuyTimesAction()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqBuyTimesAction::InitAsDefaultInstance() {
}

ReqBuyTimesAction::ReqBuyTimesAction(const ReqBuyTimesAction& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqBuyTimesAction::SharedCtor() {
  _cached_size_ = 0;
  action_id_ = 0u;
  action_value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqBuyTimesAction::~ReqBuyTimesAction() {
  SharedDtor();
}

void ReqBuyTimesAction::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqBuyTimesAction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqBuyTimesAction& ReqBuyTimesAction::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqBuyTimesAction* ReqBuyTimesAction::default_instance_ = NULL;

ReqBuyTimesAction* ReqBuyTimesAction::New() const {
  return new ReqBuyTimesAction;
}

void ReqBuyTimesAction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    action_id_ = 0u;
    action_value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqBuyTimesAction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 action_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &action_id_)));
          set_has_action_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_action_value;
        break;
      }

      // optional uint32 action_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &action_value_)));
          set_has_action_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqBuyTimesAction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 action_id = 1;
  if (has_action_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->action_id(), output);
  }

  // optional uint32 action_value = 2;
  if (has_action_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->action_value(), output);
  }

}

int ReqBuyTimesAction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 action_id = 1;
    if (has_action_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->action_id());
    }

    // optional uint32 action_value = 2;
    if (has_action_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->action_value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqBuyTimesAction::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqBuyTimesAction*>(&from));
}

void ReqBuyTimesAction::MergeFrom(const ReqBuyTimesAction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_action_id()) {
      set_action_id(from.action_id());
    }
    if (from.has_action_value()) {
      set_action_value(from.action_value());
    }
  }
}

void ReqBuyTimesAction::CopyFrom(const ReqBuyTimesAction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqBuyTimesAction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqBuyTimesAction::Swap(ReqBuyTimesAction* other) {
  if (other != this) {
    std::swap(action_id_, other->action_id_);
    std::swap(action_value_, other->action_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqBuyTimesAction::GetTypeName() const {
  return "message.ReqBuyTimesAction";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqIsMercTraining::kMercPosFieldNumber;
#endif  // !_MSC_VER

ReqIsMercTraining::ReqIsMercTraining()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqIsMercTraining::InitAsDefaultInstance() {
}

ReqIsMercTraining::ReqIsMercTraining(const ReqIsMercTraining& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqIsMercTraining::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqIsMercTraining::~ReqIsMercTraining() {
  SharedDtor();
}

void ReqIsMercTraining::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqIsMercTraining::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqIsMercTraining& ReqIsMercTraining::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqIsMercTraining* ReqIsMercTraining::default_instance_ = NULL;

ReqIsMercTraining* ReqIsMercTraining::New() const {
  return new ReqIsMercTraining;
}

void ReqIsMercTraining::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqIsMercTraining::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqIsMercTraining::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

}

int ReqIsMercTraining::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqIsMercTraining::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqIsMercTraining*>(&from));
}

void ReqIsMercTraining::MergeFrom(const ReqIsMercTraining& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
  }
}

void ReqIsMercTraining::CopyFrom(const ReqIsMercTraining& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqIsMercTraining::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqIsMercTraining::Swap(ReqIsMercTraining* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqIsMercTraining::GetTypeName() const {
  return "message.ReqIsMercTraining";
}


// ===================================================================

#ifndef _MSC_VER
const int AckOtherLevelUp::kCharIdFieldNumber;
#endif  // !_MSC_VER

AckOtherLevelUp::AckOtherLevelUp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckOtherLevelUp::InitAsDefaultInstance() {
}

AckOtherLevelUp::AckOtherLevelUp(const AckOtherLevelUp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckOtherLevelUp::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckOtherLevelUp::~AckOtherLevelUp() {
  SharedDtor();
}

void AckOtherLevelUp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckOtherLevelUp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckOtherLevelUp& AckOtherLevelUp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckOtherLevelUp* AckOtherLevelUp::default_instance_ = NULL;

AckOtherLevelUp* AckOtherLevelUp::New() const {
  return new AckOtherLevelUp;
}

void AckOtherLevelUp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckOtherLevelUp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckOtherLevelUp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->char_id(), output);
  }

}

int AckOtherLevelUp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckOtherLevelUp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckOtherLevelUp*>(&from));
}

void AckOtherLevelUp::MergeFrom(const AckOtherLevelUp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
  }
}

void AckOtherLevelUp::CopyFrom(const AckOtherLevelUp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckOtherLevelUp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckOtherLevelUp::Swap(AckOtherLevelUp* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckOtherLevelUp::GetTypeName() const {
  return "message.AckOtherLevelUp";
}


// ===================================================================

#ifndef _MSC_VER
const int SendHeartBeatMsg::kValueFieldNumber;
#endif  // !_MSC_VER

SendHeartBeatMsg::SendHeartBeatMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SendHeartBeatMsg::InitAsDefaultInstance() {
}

SendHeartBeatMsg::SendHeartBeatMsg(const SendHeartBeatMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SendHeartBeatMsg::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendHeartBeatMsg::~SendHeartBeatMsg() {
  SharedDtor();
}

void SendHeartBeatMsg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SendHeartBeatMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendHeartBeatMsg& SendHeartBeatMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SendHeartBeatMsg* SendHeartBeatMsg::default_instance_ = NULL;

SendHeartBeatMsg* SendHeartBeatMsg::New() const {
  return new SendHeartBeatMsg;
}

void SendHeartBeatMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SendHeartBeatMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendHeartBeatMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int SendHeartBeatMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendHeartBeatMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendHeartBeatMsg*>(&from));
}

void SendHeartBeatMsg::MergeFrom(const SendHeartBeatMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void SendHeartBeatMsg::CopyFrom(const SendHeartBeatMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendHeartBeatMsg::IsInitialized() const {

  return true;
}

void SendHeartBeatMsg::Swap(SendHeartBeatMsg* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SendHeartBeatMsg::GetTypeName() const {
  return "message.SendHeartBeatMsg";
}


// ===================================================================

#ifndef _MSC_VER
const int SendStoneMsg::kMercPosFieldNumber;
const int SendStoneMsg::kOperPosFieldNumber;
const int SendStoneMsg::kItemPosFieldNumber;
const int SendStoneMsg::kOperIdFieldNumber;
#endif  // !_MSC_VER

SendStoneMsg::SendStoneMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SendStoneMsg::InitAsDefaultInstance() {
}

SendStoneMsg::SendStoneMsg(const SendStoneMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SendStoneMsg::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  oper_pos_ = GOOGLE_ULONGLONG(0);
  item_pos_ = GOOGLE_ULONGLONG(0);
  oper_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendStoneMsg::~SendStoneMsg() {
  SharedDtor();
}

void SendStoneMsg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SendStoneMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendStoneMsg& SendStoneMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SendStoneMsg* SendStoneMsg::default_instance_ = NULL;

SendStoneMsg* SendStoneMsg::New() const {
  return new SendStoneMsg;
}

void SendStoneMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
    oper_pos_ = GOOGLE_ULONGLONG(0);
    item_pos_ = GOOGLE_ULONGLONG(0);
    oper_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SendStoneMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_oper_pos;
        break;
      }

      // optional uint64 oper_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &oper_pos_)));
          set_has_oper_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_pos;
        break;
      }

      // optional uint64 item_pos = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &item_pos_)));
          set_has_item_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_oper_id;
        break;
      }

      // optional uint32 oper_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_id_)));
          set_has_oper_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendStoneMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

  // optional uint64 oper_pos = 2;
  if (has_oper_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->oper_pos(), output);
  }

  // optional uint64 item_pos = 3;
  if (has_item_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->item_pos(), output);
  }

  // optional uint32 oper_id = 4;
  if (has_oper_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->oper_id(), output);
  }

}

int SendStoneMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

    // optional uint64 oper_pos = 2;
    if (has_oper_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->oper_pos());
    }

    // optional uint64 item_pos = 3;
    if (has_item_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->item_pos());
    }

    // optional uint32 oper_id = 4;
    if (has_oper_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendStoneMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendStoneMsg*>(&from));
}

void SendStoneMsg::MergeFrom(const SendStoneMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
    if (from.has_oper_pos()) {
      set_oper_pos(from.oper_pos());
    }
    if (from.has_item_pos()) {
      set_item_pos(from.item_pos());
    }
    if (from.has_oper_id()) {
      set_oper_id(from.oper_id());
    }
  }
}

void SendStoneMsg::CopyFrom(const SendStoneMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendStoneMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SendStoneMsg::Swap(SendStoneMsg* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(oper_pos_, other->oper_pos_);
    std::swap(item_pos_, other->item_pos_);
    std::swap(oper_id_, other->oper_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SendStoneMsg::GetTypeName() const {
  return "message.SendStoneMsg";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqWorldBossInfo::kValueFieldNumber;
#endif  // !_MSC_VER

ReqWorldBossInfo::ReqWorldBossInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqWorldBossInfo::InitAsDefaultInstance() {
}

ReqWorldBossInfo::ReqWorldBossInfo(const ReqWorldBossInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqWorldBossInfo::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqWorldBossInfo::~ReqWorldBossInfo() {
  SharedDtor();
}

void ReqWorldBossInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqWorldBossInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqWorldBossInfo& ReqWorldBossInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqWorldBossInfo* ReqWorldBossInfo::default_instance_ = NULL;

ReqWorldBossInfo* ReqWorldBossInfo::New() const {
  return new ReqWorldBossInfo;
}

void ReqWorldBossInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqWorldBossInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqWorldBossInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqWorldBossInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqWorldBossInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqWorldBossInfo*>(&from));
}

void ReqWorldBossInfo::MergeFrom(const ReqWorldBossInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqWorldBossInfo::CopyFrom(const ReqWorldBossInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqWorldBossInfo::IsInitialized() const {

  return true;
}

void ReqWorldBossInfo::Swap(ReqWorldBossInfo* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqWorldBossInfo::GetTypeName() const {
  return "message.ReqWorldBossInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int AckWorldBossInfo::kBossIdFieldNumber;
const int AckWorldBossInfo::kBossHpFieldNumber;
const int AckWorldBossInfo::kIfUsedFieldNumber;
const int AckWorldBossInfo::kServerIdFieldNumber;
#endif  // !_MSC_VER

AckWorldBossInfo::AckWorldBossInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AckWorldBossInfo::InitAsDefaultInstance() {
}

AckWorldBossInfo::AckWorldBossInfo(const AckWorldBossInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AckWorldBossInfo::SharedCtor() {
  _cached_size_ = 0;
  boss_id_ = 0u;
  boss_hp_ = 0u;
  if_used_ = 0u;
  server_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckWorldBossInfo::~AckWorldBossInfo() {
  SharedDtor();
}

void AckWorldBossInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AckWorldBossInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AckWorldBossInfo& AckWorldBossInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AckWorldBossInfo* AckWorldBossInfo::default_instance_ = NULL;

AckWorldBossInfo* AckWorldBossInfo::New() const {
  return new AckWorldBossInfo;
}

void AckWorldBossInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    boss_id_ = 0u;
    boss_hp_ = 0u;
    if_used_ = 0u;
    server_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AckWorldBossInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 boss_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &boss_id_)));
          set_has_boss_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_boss_hp;
        break;
      }

      // required uint32 boss_hp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_boss_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &boss_hp_)));
          set_has_boss_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_if_used;
        break;
      }

      // required uint32 if_used = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_if_used:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &if_used_)));
          set_has_if_used();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_server_id;
        break;
      }

      // required uint32 server_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckWorldBossInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 boss_id = 1;
  if (has_boss_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->boss_id(), output);
  }

  // required uint32 boss_hp = 2;
  if (has_boss_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->boss_hp(), output);
  }

  // required uint32 if_used = 3;
  if (has_if_used()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->if_used(), output);
  }

  // required uint32 server_id = 4;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->server_id(), output);
  }

}

int AckWorldBossInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 boss_id = 1;
    if (has_boss_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->boss_id());
    }

    // required uint32 boss_hp = 2;
    if (has_boss_hp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->boss_hp());
    }

    // required uint32 if_used = 3;
    if (has_if_used()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->if_used());
    }

    // required uint32 server_id = 4;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckWorldBossInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AckWorldBossInfo*>(&from));
}

void AckWorldBossInfo::MergeFrom(const AckWorldBossInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_boss_id()) {
      set_boss_id(from.boss_id());
    }
    if (from.has_boss_hp()) {
      set_boss_hp(from.boss_hp());
    }
    if (from.has_if_used()) {
      set_if_used(from.if_used());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
  }
}

void AckWorldBossInfo::CopyFrom(const AckWorldBossInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckWorldBossInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void AckWorldBossInfo::Swap(AckWorldBossInfo* other) {
  if (other != this) {
    std::swap(boss_id_, other->boss_id_);
    std::swap(boss_hp_, other->boss_hp_);
    std::swap(if_used_, other->if_used_);
    std::swap(server_id_, other->server_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AckWorldBossInfo::GetTypeName() const {
  return "message.AckWorldBossInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ExecuteSQL::kSqlFieldNumber;
const int ExecuteSQL::kIfReturnFieldNumber;
const int ExecuteSQL::kAccIdFieldNumber;
#endif  // !_MSC_VER

ExecuteSQL::ExecuteSQL()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ExecuteSQL::InitAsDefaultInstance() {
}

ExecuteSQL::ExecuteSQL(const ExecuteSQL& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ExecuteSQL::SharedCtor() {
  _cached_size_ = 0;
  sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  if_return_ = 0u;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecuteSQL::~ExecuteSQL() {
  SharedDtor();
}

void ExecuteSQL::SharedDtor() {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    delete sql_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExecuteSQL::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExecuteSQL& ExecuteSQL::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ExecuteSQL* ExecuteSQL::default_instance_ = NULL;

ExecuteSQL* ExecuteSQL::New() const {
  return new ExecuteSQL;
}

void ExecuteSQL::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_sql()) {
      if (sql_ != &::google::protobuf::internal::kEmptyString) {
        sql_->clear();
      }
    }
    if_return_ = 0u;
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ExecuteSQL::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes sql = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sql()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_if_return;
        break;
      }

      // optional uint32 if_return = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_if_return:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &if_return_)));
          set_has_if_return();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_acc_id;
        break;
      }

      // optional uint32 acc_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExecuteSQL::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes sql = 1;
  if (has_sql()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->sql(), output);
  }

  // optional uint32 if_return = 2;
  if (has_if_return()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->if_return(), output);
  }

  // optional uint32 acc_id = 3;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->acc_id(), output);
  }

}

int ExecuteSQL::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes sql = 1;
    if (has_sql()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sql());
    }

    // optional uint32 if_return = 2;
    if (has_if_return()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->if_return());
    }

    // optional uint32 acc_id = 3;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecuteSQL::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExecuteSQL*>(&from));
}

void ExecuteSQL::MergeFrom(const ExecuteSQL& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sql()) {
      set_sql(from.sql());
    }
    if (from.has_if_return()) {
      set_if_return(from.if_return());
    }
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void ExecuteSQL::CopyFrom(const ExecuteSQL& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecuteSQL::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExecuteSQL::Swap(ExecuteSQL* other) {
  if (other != this) {
    std::swap(sql_, other->sql_);
    std::swap(if_return_, other->if_return_);
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExecuteSQL::GetTypeName() const {
  return "message.ExecuteSQL";
}


// ===================================================================

#ifndef _MSC_VER
const int LoadAllActivityDataReq::kValueFieldNumber;
#endif  // !_MSC_VER

LoadAllActivityDataReq::LoadAllActivityDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoadAllActivityDataReq::InitAsDefaultInstance() {
}

LoadAllActivityDataReq::LoadAllActivityDataReq(const LoadAllActivityDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoadAllActivityDataReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadAllActivityDataReq::~LoadAllActivityDataReq() {
  SharedDtor();
}

void LoadAllActivityDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoadAllActivityDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoadAllActivityDataReq& LoadAllActivityDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoadAllActivityDataReq* LoadAllActivityDataReq::default_instance_ = NULL;

LoadAllActivityDataReq* LoadAllActivityDataReq::New() const {
  return new LoadAllActivityDataReq;
}

void LoadAllActivityDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoadAllActivityDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadAllActivityDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int LoadAllActivityDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadAllActivityDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoadAllActivityDataReq*>(&from));
}

void LoadAllActivityDataReq::MergeFrom(const LoadAllActivityDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void LoadAllActivityDataReq::CopyFrom(const LoadAllActivityDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAllActivityDataReq::IsInitialized() const {

  return true;
}

void LoadAllActivityDataReq::Swap(LoadAllActivityDataReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoadAllActivityDataReq::GetTypeName() const {
  return "message.LoadAllActivityDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int LoadAllActivityDataAck_ActivityData::kIdFieldNumber;
const int LoadAllActivityDataAck_ActivityData::kBeginTimeFieldNumber;
const int LoadAllActivityDataAck_ActivityData::kEndTimeFieldNumber;
const int LoadAllActivityDataAck_ActivityData::kOpenFieldNumber;
#endif  // !_MSC_VER

LoadAllActivityDataAck_ActivityData::LoadAllActivityDataAck_ActivityData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoadAllActivityDataAck_ActivityData::InitAsDefaultInstance() {
}

LoadAllActivityDataAck_ActivityData::LoadAllActivityDataAck_ActivityData(const LoadAllActivityDataAck_ActivityData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoadAllActivityDataAck_ActivityData::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  begin_time_ = 0u;
  end_time_ = 0u;
  open_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadAllActivityDataAck_ActivityData::~LoadAllActivityDataAck_ActivityData() {
  SharedDtor();
}

void LoadAllActivityDataAck_ActivityData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoadAllActivityDataAck_ActivityData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoadAllActivityDataAck_ActivityData& LoadAllActivityDataAck_ActivityData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoadAllActivityDataAck_ActivityData* LoadAllActivityDataAck_ActivityData::default_instance_ = NULL;

LoadAllActivityDataAck_ActivityData* LoadAllActivityDataAck_ActivityData::New() const {
  return new LoadAllActivityDataAck_ActivityData;
}

void LoadAllActivityDataAck_ActivityData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    begin_time_ = 0u;
    end_time_ = 0u;
    open_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoadAllActivityDataAck_ActivityData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_begin_time;
        break;
      }

      // required uint32 begin_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_begin_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_time_)));
          set_has_begin_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_end_time;
        break;
      }

      // required uint32 end_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_open;
        break;
      }

      // required uint32 open = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_open:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &open_)));
          set_has_open();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadAllActivityDataAck_ActivityData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 begin_time = 2;
  if (has_begin_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->begin_time(), output);
  }

  // required uint32 end_time = 3;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->end_time(), output);
  }

  // required uint32 open = 4;
  if (has_open()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->open(), output);
  }

}

int LoadAllActivityDataAck_ActivityData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 begin_time = 2;
    if (has_begin_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_time());
    }

    // required uint32 end_time = 3;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_time());
    }

    // required uint32 open = 4;
    if (has_open()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->open());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadAllActivityDataAck_ActivityData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoadAllActivityDataAck_ActivityData*>(&from));
}

void LoadAllActivityDataAck_ActivityData::MergeFrom(const LoadAllActivityDataAck_ActivityData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_begin_time()) {
      set_begin_time(from.begin_time());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
    if (from.has_open()) {
      set_open(from.open());
    }
  }
}

void LoadAllActivityDataAck_ActivityData::CopyFrom(const LoadAllActivityDataAck_ActivityData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAllActivityDataAck_ActivityData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void LoadAllActivityDataAck_ActivityData::Swap(LoadAllActivityDataAck_ActivityData* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(begin_time_, other->begin_time_);
    std::swap(end_time_, other->end_time_);
    std::swap(open_, other->open_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoadAllActivityDataAck_ActivityData::GetTypeName() const {
  return "message.LoadAllActivityDataAck.ActivityData";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LoadAllActivityDataAck::kDataFieldNumber;
#endif  // !_MSC_VER

LoadAllActivityDataAck::LoadAllActivityDataAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoadAllActivityDataAck::InitAsDefaultInstance() {
}

LoadAllActivityDataAck::LoadAllActivityDataAck(const LoadAllActivityDataAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoadAllActivityDataAck::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadAllActivityDataAck::~LoadAllActivityDataAck() {
  SharedDtor();
}

void LoadAllActivityDataAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoadAllActivityDataAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoadAllActivityDataAck& LoadAllActivityDataAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoadAllActivityDataAck* LoadAllActivityDataAck::default_instance_ = NULL;

LoadAllActivityDataAck* LoadAllActivityDataAck::New() const {
  return new LoadAllActivityDataAck;
}

void LoadAllActivityDataAck::Clear() {
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoadAllActivityDataAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.LoadAllActivityDataAck.ActivityData data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadAllActivityDataAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.LoadAllActivityDataAck.ActivityData data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(i), output);
  }

}

int LoadAllActivityDataAck::ByteSize() const {
  int total_size = 0;

  // repeated .message.LoadAllActivityDataAck.ActivityData data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadAllActivityDataAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoadAllActivityDataAck*>(&from));
}

void LoadAllActivityDataAck::MergeFrom(const LoadAllActivityDataAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
}

void LoadAllActivityDataAck::CopyFrom(const LoadAllActivityDataAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAllActivityDataAck::IsInitialized() const {

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void LoadAllActivityDataAck::Swap(LoadAllActivityDataAck* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoadAllActivityDataAck::GetTypeName() const {
  return "message.LoadAllActivityDataAck";
}


// ===================================================================

#ifndef _MSC_VER
const int CanGetFirstRechargeReward::kValueFieldNumber;
#endif  // !_MSC_VER

CanGetFirstRechargeReward::CanGetFirstRechargeReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CanGetFirstRechargeReward::InitAsDefaultInstance() {
}

CanGetFirstRechargeReward::CanGetFirstRechargeReward(const CanGetFirstRechargeReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CanGetFirstRechargeReward::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CanGetFirstRechargeReward::~CanGetFirstRechargeReward() {
  SharedDtor();
}

void CanGetFirstRechargeReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CanGetFirstRechargeReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CanGetFirstRechargeReward& CanGetFirstRechargeReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

CanGetFirstRechargeReward* CanGetFirstRechargeReward::default_instance_ = NULL;

CanGetFirstRechargeReward* CanGetFirstRechargeReward::New() const {
  return new CanGetFirstRechargeReward;
}

void CanGetFirstRechargeReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CanGetFirstRechargeReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CanGetFirstRechargeReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int CanGetFirstRechargeReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CanGetFirstRechargeReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CanGetFirstRechargeReward*>(&from));
}

void CanGetFirstRechargeReward::MergeFrom(const CanGetFirstRechargeReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void CanGetFirstRechargeReward::CopyFrom(const CanGetFirstRechargeReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CanGetFirstRechargeReward::IsInitialized() const {

  return true;
}

void CanGetFirstRechargeReward::Swap(CanGetFirstRechargeReward* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CanGetFirstRechargeReward::GetTypeName() const {
  return "message.CanGetFirstRechargeReward";
}


// ===================================================================

#ifndef _MSC_VER
const int LoadAllSysBroadcastDataReq::kValueFieldNumber;
#endif  // !_MSC_VER

LoadAllSysBroadcastDataReq::LoadAllSysBroadcastDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoadAllSysBroadcastDataReq::InitAsDefaultInstance() {
}

LoadAllSysBroadcastDataReq::LoadAllSysBroadcastDataReq(const LoadAllSysBroadcastDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoadAllSysBroadcastDataReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadAllSysBroadcastDataReq::~LoadAllSysBroadcastDataReq() {
  SharedDtor();
}

void LoadAllSysBroadcastDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoadAllSysBroadcastDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoadAllSysBroadcastDataReq& LoadAllSysBroadcastDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoadAllSysBroadcastDataReq* LoadAllSysBroadcastDataReq::default_instance_ = NULL;

LoadAllSysBroadcastDataReq* LoadAllSysBroadcastDataReq::New() const {
  return new LoadAllSysBroadcastDataReq;
}

void LoadAllSysBroadcastDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoadAllSysBroadcastDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadAllSysBroadcastDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int LoadAllSysBroadcastDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadAllSysBroadcastDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoadAllSysBroadcastDataReq*>(&from));
}

void LoadAllSysBroadcastDataReq::MergeFrom(const LoadAllSysBroadcastDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void LoadAllSysBroadcastDataReq::CopyFrom(const LoadAllSysBroadcastDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAllSysBroadcastDataReq::IsInitialized() const {

  return true;
}

void LoadAllSysBroadcastDataReq::Swap(LoadAllSysBroadcastDataReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoadAllSysBroadcastDataReq::GetTypeName() const {
  return "message.LoadAllSysBroadcastDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int LoadAllSysBroadcastDataAck_SysBroadcastData::kTypeFieldNumber;
const int LoadAllSysBroadcastDataAck_SysBroadcastData::kBeginTimeFieldNumber;
const int LoadAllSysBroadcastDataAck_SysBroadcastData::kEndTimeFieldNumber;
const int LoadAllSysBroadcastDataAck_SysBroadcastData::kNextTimeFieldNumber;
const int LoadAllSysBroadcastDataAck_SysBroadcastData::kMinutesFieldNumber;
const int LoadAllSysBroadcastDataAck_SysBroadcastData::kTextFieldNumber;
#endif  // !_MSC_VER

LoadAllSysBroadcastDataAck_SysBroadcastData::LoadAllSysBroadcastDataAck_SysBroadcastData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::InitAsDefaultInstance() {
}

LoadAllSysBroadcastDataAck_SysBroadcastData::LoadAllSysBroadcastDataAck_SysBroadcastData(const LoadAllSysBroadcastDataAck_SysBroadcastData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  begin_time_ = 0u;
  end_time_ = 0u;
  next_time_ = 0u;
  minutes_ = 0u;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadAllSysBroadcastDataAck_SysBroadcastData::~LoadAllSysBroadcastDataAck_SysBroadcastData() {
  SharedDtor();
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoadAllSysBroadcastDataAck_SysBroadcastData& LoadAllSysBroadcastDataAck_SysBroadcastData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoadAllSysBroadcastDataAck_SysBroadcastData* LoadAllSysBroadcastDataAck_SysBroadcastData::default_instance_ = NULL;

LoadAllSysBroadcastDataAck_SysBroadcastData* LoadAllSysBroadcastDataAck_SysBroadcastData::New() const {
  return new LoadAllSysBroadcastDataAck_SysBroadcastData;
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0u;
    begin_time_ = 0u;
    end_time_ = 0u;
    next_time_ = 0u;
    minutes_ = 0u;
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoadAllSysBroadcastDataAck_SysBroadcastData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_begin_time;
        break;
      }

      // required uint32 begin_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_begin_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_time_)));
          set_has_begin_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_end_time;
        break;
      }

      // required uint32 end_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_next_time;
        break;
      }

      // required uint32 next_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_next_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &next_time_)));
          set_has_next_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_minutes;
        break;
      }

      // required uint32 minutes = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minutes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minutes_)));
          set_has_minutes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_text;
        break;
      }

      // required bytes text = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required uint32 begin_time = 2;
  if (has_begin_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->begin_time(), output);
  }

  // required uint32 end_time = 3;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->end_time(), output);
  }

  // required uint32 next_time = 4;
  if (has_next_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->next_time(), output);
  }

  // required uint32 minutes = 5;
  if (has_minutes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->minutes(), output);
  }

  // required bytes text = 6;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->text(), output);
  }

}

int LoadAllSysBroadcastDataAck_SysBroadcastData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 begin_time = 2;
    if (has_begin_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_time());
    }

    // required uint32 end_time = 3;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_time());
    }

    // required uint32 next_time = 4;
    if (has_next_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->next_time());
    }

    // required uint32 minutes = 5;
    if (has_minutes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->minutes());
    }

    // required bytes text = 6;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->text());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoadAllSysBroadcastDataAck_SysBroadcastData*>(&from));
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::MergeFrom(const LoadAllSysBroadcastDataAck_SysBroadcastData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_begin_time()) {
      set_begin_time(from.begin_time());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
    if (from.has_next_time()) {
      set_next_time(from.next_time());
    }
    if (from.has_minutes()) {
      set_minutes(from.minutes());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
  }
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::CopyFrom(const LoadAllSysBroadcastDataAck_SysBroadcastData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAllSysBroadcastDataAck_SysBroadcastData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void LoadAllSysBroadcastDataAck_SysBroadcastData::Swap(LoadAllSysBroadcastDataAck_SysBroadcastData* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(begin_time_, other->begin_time_);
    std::swap(end_time_, other->end_time_);
    std::swap(next_time_, other->next_time_);
    std::swap(minutes_, other->minutes_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoadAllSysBroadcastDataAck_SysBroadcastData::GetTypeName() const {
  return "message.LoadAllSysBroadcastDataAck.SysBroadcastData";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LoadAllSysBroadcastDataAck::kDataFieldNumber;
#endif  // !_MSC_VER

LoadAllSysBroadcastDataAck::LoadAllSysBroadcastDataAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoadAllSysBroadcastDataAck::InitAsDefaultInstance() {
}

LoadAllSysBroadcastDataAck::LoadAllSysBroadcastDataAck(const LoadAllSysBroadcastDataAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoadAllSysBroadcastDataAck::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadAllSysBroadcastDataAck::~LoadAllSysBroadcastDataAck() {
  SharedDtor();
}

void LoadAllSysBroadcastDataAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoadAllSysBroadcastDataAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoadAllSysBroadcastDataAck& LoadAllSysBroadcastDataAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoadAllSysBroadcastDataAck* LoadAllSysBroadcastDataAck::default_instance_ = NULL;

LoadAllSysBroadcastDataAck* LoadAllSysBroadcastDataAck::New() const {
  return new LoadAllSysBroadcastDataAck;
}

void LoadAllSysBroadcastDataAck::Clear() {
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoadAllSysBroadcastDataAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.LoadAllSysBroadcastDataAck.SysBroadcastData data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadAllSysBroadcastDataAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.LoadAllSysBroadcastDataAck.SysBroadcastData data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(i), output);
  }

}

int LoadAllSysBroadcastDataAck::ByteSize() const {
  int total_size = 0;

  // repeated .message.LoadAllSysBroadcastDataAck.SysBroadcastData data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadAllSysBroadcastDataAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoadAllSysBroadcastDataAck*>(&from));
}

void LoadAllSysBroadcastDataAck::MergeFrom(const LoadAllSysBroadcastDataAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
}

void LoadAllSysBroadcastDataAck::CopyFrom(const LoadAllSysBroadcastDataAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAllSysBroadcastDataAck::IsInitialized() const {

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void LoadAllSysBroadcastDataAck::Swap(LoadAllSysBroadcastDataAck* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoadAllSysBroadcastDataAck::GetTypeName() const {
  return "message.LoadAllSysBroadcastDataAck";
}


// ===================================================================

#ifndef _MSC_VER
const int QueryAccidByAccnameReq::kAccNameFieldNumber;
const int QueryAccidByAccnameReq::kSerialIdFieldNumber;
#endif  // !_MSC_VER

QueryAccidByAccnameReq::QueryAccidByAccnameReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void QueryAccidByAccnameReq::InitAsDefaultInstance() {
}

QueryAccidByAccnameReq::QueryAccidByAccnameReq(const QueryAccidByAccnameReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void QueryAccidByAccnameReq::SharedCtor() {
  _cached_size_ = 0;
  acc_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serial_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryAccidByAccnameReq::~QueryAccidByAccnameReq() {
  SharedDtor();
}

void QueryAccidByAccnameReq::SharedDtor() {
  if (acc_name_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QueryAccidByAccnameReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QueryAccidByAccnameReq& QueryAccidByAccnameReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

QueryAccidByAccnameReq* QueryAccidByAccnameReq::default_instance_ = NULL;

QueryAccidByAccnameReq* QueryAccidByAccnameReq::New() const {
  return new QueryAccidByAccnameReq;
}

void QueryAccidByAccnameReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_acc_name()) {
      if (acc_name_ != &::google::protobuf::internal::kEmptyString) {
        acc_name_->clear();
      }
    }
    serial_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool QueryAccidByAccnameReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes acc_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_acc_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_serial_id;
        break;
      }

      // required uint32 serial_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_serial_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_id_)));
          set_has_serial_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QueryAccidByAccnameReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes acc_name = 1;
  if (has_acc_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->acc_name(), output);
  }

  // required uint32 serial_id = 2;
  if (has_serial_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->serial_id(), output);
  }

}

int QueryAccidByAccnameReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes acc_name = 1;
    if (has_acc_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->acc_name());
    }

    // required uint32 serial_id = 2;
    if (has_serial_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryAccidByAccnameReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QueryAccidByAccnameReq*>(&from));
}

void QueryAccidByAccnameReq::MergeFrom(const QueryAccidByAccnameReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_name()) {
      set_acc_name(from.acc_name());
    }
    if (from.has_serial_id()) {
      set_serial_id(from.serial_id());
    }
  }
}

void QueryAccidByAccnameReq::CopyFrom(const QueryAccidByAccnameReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryAccidByAccnameReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void QueryAccidByAccnameReq::Swap(QueryAccidByAccnameReq* other) {
  if (other != this) {
    std::swap(acc_name_, other->acc_name_);
    std::swap(serial_id_, other->serial_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QueryAccidByAccnameReq::GetTypeName() const {
  return "message.QueryAccidByAccnameReq";
}


// ===================================================================

#ifndef _MSC_VER
const int QueryAccidByAccnameAck::kAccIdFieldNumber;
const int QueryAccidByAccnameAck::kSerialIdFieldNumber;
#endif  // !_MSC_VER

QueryAccidByAccnameAck::QueryAccidByAccnameAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void QueryAccidByAccnameAck::InitAsDefaultInstance() {
}

QueryAccidByAccnameAck::QueryAccidByAccnameAck(const QueryAccidByAccnameAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void QueryAccidByAccnameAck::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  serial_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryAccidByAccnameAck::~QueryAccidByAccnameAck() {
  SharedDtor();
}

void QueryAccidByAccnameAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QueryAccidByAccnameAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QueryAccidByAccnameAck& QueryAccidByAccnameAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

QueryAccidByAccnameAck* QueryAccidByAccnameAck::default_instance_ = NULL;

QueryAccidByAccnameAck* QueryAccidByAccnameAck::New() const {
  return new QueryAccidByAccnameAck;
}

void QueryAccidByAccnameAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    serial_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool QueryAccidByAccnameAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_serial_id;
        break;
      }

      // required uint32 serial_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_serial_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_id_)));
          set_has_serial_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QueryAccidByAccnameAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 serial_id = 2;
  if (has_serial_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->serial_id(), output);
  }

}

int QueryAccidByAccnameAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 serial_id = 2;
    if (has_serial_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryAccidByAccnameAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QueryAccidByAccnameAck*>(&from));
}

void QueryAccidByAccnameAck::MergeFrom(const QueryAccidByAccnameAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_serial_id()) {
      set_serial_id(from.serial_id());
    }
  }
}

void QueryAccidByAccnameAck::CopyFrom(const QueryAccidByAccnameAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryAccidByAccnameAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void QueryAccidByAccnameAck::Swap(QueryAccidByAccnameAck* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(serial_id_, other->serial_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QueryAccidByAccnameAck::GetTypeName() const {
  return "message.QueryAccidByAccnameAck";
}


// ===================================================================

#ifndef _MSC_VER
const int PkBattle::kTargetIdFieldNumber;
#endif  // !_MSC_VER

PkBattle::PkBattle()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PkBattle::InitAsDefaultInstance() {
}

PkBattle::PkBattle(const PkBattle& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PkBattle::SharedCtor() {
  _cached_size_ = 0;
  target_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PkBattle::~PkBattle() {
  SharedDtor();
}

void PkBattle::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PkBattle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PkBattle& PkBattle::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PkBattle* PkBattle::default_instance_ = NULL;

PkBattle* PkBattle::New() const {
  return new PkBattle;
}

void PkBattle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    target_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PkBattle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 target_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_id_)));
          set_has_target_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PkBattle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 target_id = 1;
  if (has_target_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->target_id(), output);
  }

}

int PkBattle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 target_id = 1;
    if (has_target_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PkBattle::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PkBattle*>(&from));
}

void PkBattle::MergeFrom(const PkBattle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_id()) {
      set_target_id(from.target_id());
    }
  }
}

void PkBattle::CopyFrom(const PkBattle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PkBattle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PkBattle::Swap(PkBattle* other) {
  if (other != this) {
    std::swap(target_id_, other->target_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PkBattle::GetTypeName() const {
  return "message.PkBattle";
}


// ===================================================================

#ifndef _MSC_VER
const int HorseData_HorseAttr::kIdFieldNumber;
const int HorseData_HorseAttr::kValueFieldNumber;
#endif  // !_MSC_VER

HorseData_HorseAttr::HorseData_HorseAttr()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HorseData_HorseAttr::InitAsDefaultInstance() {
}

HorseData_HorseAttr::HorseData_HorseAttr(const HorseData_HorseAttr& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HorseData_HorseAttr::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HorseData_HorseAttr::~HorseData_HorseAttr() {
  SharedDtor();
}

void HorseData_HorseAttr::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HorseData_HorseAttr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HorseData_HorseAttr& HorseData_HorseAttr::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

HorseData_HorseAttr* HorseData_HorseAttr::default_instance_ = NULL;

HorseData_HorseAttr* HorseData_HorseAttr::New() const {
  return new HorseData_HorseAttr;
}

void HorseData_HorseAttr::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HorseData_HorseAttr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // required uint32 value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HorseData_HorseAttr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->value(), output);
  }

}

int HorseData_HorseAttr::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HorseData_HorseAttr::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HorseData_HorseAttr*>(&from));
}

void HorseData_HorseAttr::MergeFrom(const HorseData_HorseAttr& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void HorseData_HorseAttr::CopyFrom(const HorseData_HorseAttr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HorseData_HorseAttr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void HorseData_HorseAttr::Swap(HorseData_HorseAttr* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HorseData_HorseAttr::GetTypeName() const {
  return "message.HorseData.HorseAttr";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int HorseData::kAccIdFieldNumber;
const int HorseData::kIdFieldNumber;
const int HorseData::kChangeNameFieldNumber;
const int HorseData::kImageFieldNumber;
const int HorseData::kHighLevelFieldNumber;
const int HorseData::kLowLevelFieldNumber;
const int HorseData::kExpFieldNumber;
const int HorseData::kTrainFieldNumber;
const int HorseData::kBlessFieldNumber;
const int HorseData::kAttrFieldNumber;
const int HorseData::kSkillIdFieldNumber;
const int HorseData::kIsShowFieldNumber;
const int HorseData::kCardTypeFieldNumber;
const int HorseData::kCardIdFieldNumber;
#endif  // !_MSC_VER

HorseData::HorseData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HorseData::InitAsDefaultInstance() {
}

HorseData::HorseData(const HorseData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HorseData::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  id_ = 0u;
  change_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  image_ = 0u;
  high_level_ = 0u;
  low_level_ = 0u;
  exp_ = 0u;
  train_ = 0u;
  bless_ = 0u;
  is_show_ = 0u;
  card_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HorseData::~HorseData() {
  SharedDtor();
}

void HorseData::SharedDtor() {
  if (change_name_ != &::google::protobuf::internal::kEmptyString) {
    delete change_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HorseData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HorseData& HorseData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

HorseData* HorseData::default_instance_ = NULL;

HorseData* HorseData::New() const {
  return new HorseData;
}

void HorseData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    id_ = 0u;
    if (has_change_name()) {
      if (change_name_ != &::google::protobuf::internal::kEmptyString) {
        change_name_->clear();
      }
    }
    image_ = 0u;
    high_level_ = 0u;
    low_level_ = 0u;
    exp_ = 0u;
    train_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    bless_ = 0u;
    is_show_ = 0u;
    card_type_ = 0u;
  }
  attr_.Clear();
  skill_id_.Clear();
  card_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HorseData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // required uint32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_change_name;
        break;
      }

      // required bytes change_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_change_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_change_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_image;
        break;
      }

      // required uint32 image = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_image:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &image_)));
          set_has_image();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_high_level;
        break;
      }

      // required uint32 high_level = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_high_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &high_level_)));
          set_has_high_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_low_level;
        break;
      }

      // required uint32 low_level = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_low_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &low_level_)));
          set_has_low_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_exp;
        break;
      }

      // required uint32 exp = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_train;
        break;
      }

      // required uint32 train = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_train:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &train_)));
          set_has_train();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_bless;
        break;
      }

      // required uint32 bless = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bless:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bless_)));
          set_has_bless();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_attr;
        break;
      }

      // repeated .message.HorseData.HorseAttr attr = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_attr;
        if (input->ExpectTag(88)) goto parse_skill_id;
        break;
      }

      // repeated uint32 skill_id = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 88, input, this->mutable_skill_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_skill_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_skill_id;
        if (input->ExpectTag(96)) goto parse_is_show;
        break;
      }

      // required uint32 is_show = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_show:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_show_)));
          set_has_is_show();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_card_type;
        break;
      }

      // required uint32 card_type = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_card_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &card_type_)));
          set_has_card_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_card_id;
        break;
      }

      // repeated uint32 card_id = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_card_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 112, input, this->mutable_card_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_card_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_card_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HorseData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // required bytes change_name = 3;
  if (has_change_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->change_name(), output);
  }

  // required uint32 image = 4;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->image(), output);
  }

  // required uint32 high_level = 5;
  if (has_high_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->high_level(), output);
  }

  // required uint32 low_level = 6;
  if (has_low_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->low_level(), output);
  }

  // required uint32 exp = 7;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->exp(), output);
  }

  // required uint32 train = 8;
  if (has_train()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->train(), output);
  }

  // required uint32 bless = 9;
  if (has_bless()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->bless(), output);
  }

  // repeated .message.HorseData.HorseAttr attr = 10;
  for (int i = 0; i < this->attr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->attr(i), output);
  }

  // repeated uint32 skill_id = 11;
  for (int i = 0; i < this->skill_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      11, this->skill_id(i), output);
  }

  // required uint32 is_show = 12;
  if (has_is_show()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->is_show(), output);
  }

  // required uint32 card_type = 13;
  if (has_card_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->card_type(), output);
  }

  // repeated uint32 card_id = 14;
  for (int i = 0; i < this->card_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      14, this->card_id(i), output);
  }

}

int HorseData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required bytes change_name = 3;
    if (has_change_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->change_name());
    }

    // required uint32 image = 4;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->image());
    }

    // required uint32 high_level = 5;
    if (has_high_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->high_level());
    }

    // required uint32 low_level = 6;
    if (has_low_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->low_level());
    }

    // required uint32 exp = 7;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp());
    }

    // required uint32 train = 8;
    if (has_train()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->train());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 bless = 9;
    if (has_bless()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bless());
    }

    // required uint32 is_show = 12;
    if (has_is_show()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_show());
    }

    // required uint32 card_type = 13;
    if (has_card_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->card_type());
    }

  }
  // repeated .message.HorseData.HorseAttr attr = 10;
  total_size += 1 * this->attr_size();
  for (int i = 0; i < this->attr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attr(i));
  }

  // repeated uint32 skill_id = 11;
  {
    int data_size = 0;
    for (int i = 0; i < this->skill_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->skill_id(i));
    }
    total_size += 1 * this->skill_id_size() + data_size;
  }

  // repeated uint32 card_id = 14;
  {
    int data_size = 0;
    for (int i = 0; i < this->card_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->card_id(i));
    }
    total_size += 1 * this->card_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HorseData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HorseData*>(&from));
}

void HorseData::MergeFrom(const HorseData& from) {
  GOOGLE_CHECK_NE(&from, this);
  attr_.MergeFrom(from.attr_);
  skill_id_.MergeFrom(from.skill_id_);
  card_id_.MergeFrom(from.card_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_change_name()) {
      set_change_name(from.change_name());
    }
    if (from.has_image()) {
      set_image(from.image());
    }
    if (from.has_high_level()) {
      set_high_level(from.high_level());
    }
    if (from.has_low_level()) {
      set_low_level(from.low_level());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_train()) {
      set_train(from.train());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_bless()) {
      set_bless(from.bless());
    }
    if (from.has_is_show()) {
      set_is_show(from.is_show());
    }
    if (from.has_card_type()) {
      set_card_type(from.card_type());
    }
  }
}

void HorseData::CopyFrom(const HorseData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HorseData::IsInitialized() const {
  if ((_has_bits_[0] & 0x000019ff) != 0x000019ff) return false;

  for (int i = 0; i < attr_size(); i++) {
    if (!this->attr(i).IsInitialized()) return false;
  }
  return true;
}

void HorseData::Swap(HorseData* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(id_, other->id_);
    std::swap(change_name_, other->change_name_);
    std::swap(image_, other->image_);
    std::swap(high_level_, other->high_level_);
    std::swap(low_level_, other->low_level_);
    std::swap(exp_, other->exp_);
    std::swap(train_, other->train_);
    std::swap(bless_, other->bless_);
    attr_.Swap(&other->attr_);
    skill_id_.Swap(&other->skill_id_);
    std::swap(is_show_, other->is_show_);
    std::swap(card_type_, other->card_type_);
    card_id_.Swap(&other->card_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HorseData::GetTypeName() const {
  return "message.HorseData";
}


// ===================================================================

#ifndef _MSC_VER
const int GetHorseDataReq::kTypeFieldNumber;
#endif  // !_MSC_VER

GetHorseDataReq::GetHorseDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetHorseDataReq::InitAsDefaultInstance() {
}

GetHorseDataReq::GetHorseDataReq(const GetHorseDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetHorseDataReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetHorseDataReq::~GetHorseDataReq() {
  SharedDtor();
}

void GetHorseDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetHorseDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetHorseDataReq& GetHorseDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetHorseDataReq* GetHorseDataReq::default_instance_ = NULL;

GetHorseDataReq* GetHorseDataReq::New() const {
  return new GetHorseDataReq;
}

void GetHorseDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetHorseDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetHorseDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

}

int GetHorseDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetHorseDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetHorseDataReq*>(&from));
}

void GetHorseDataReq::MergeFrom(const GetHorseDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void GetHorseDataReq::CopyFrom(const GetHorseDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHorseDataReq::IsInitialized() const {

  return true;
}

void GetHorseDataReq::Swap(GetHorseDataReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetHorseDataReq::GetTypeName() const {
  return "message.GetHorseDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetHorseDataAck::kHorseDataFieldNumber;
const int GetHorseDataAck::kCountFieldNumber;
#endif  // !_MSC_VER

GetHorseDataAck::GetHorseDataAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetHorseDataAck::InitAsDefaultInstance() {
}

GetHorseDataAck::GetHorseDataAck(const GetHorseDataAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetHorseDataAck::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetHorseDataAck::~GetHorseDataAck() {
  SharedDtor();
}

void GetHorseDataAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetHorseDataAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetHorseDataAck& GetHorseDataAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetHorseDataAck* GetHorseDataAck::default_instance_ = NULL;

GetHorseDataAck* GetHorseDataAck::New() const {
  return new GetHorseDataAck;
}

void GetHorseDataAck::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    count_ = 0u;
  }
  horse_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetHorseDataAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.HorseData horse_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_horse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_horse_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_horse_data;
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // required uint32 count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetHorseDataAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.HorseData horse_data = 1;
  for (int i = 0; i < this->horse_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->horse_data(i), output);
  }

  // required uint32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

}

int GetHorseDataAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  // repeated .message.HorseData horse_data = 1;
  total_size += 1 * this->horse_data_size();
  for (int i = 0; i < this->horse_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->horse_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetHorseDataAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetHorseDataAck*>(&from));
}

void GetHorseDataAck::MergeFrom(const GetHorseDataAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  horse_data_.MergeFrom(from.horse_data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
}

void GetHorseDataAck::CopyFrom(const GetHorseDataAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHorseDataAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  for (int i = 0; i < horse_data_size(); i++) {
    if (!this->horse_data(i).IsInitialized()) return false;
  }
  return true;
}

void GetHorseDataAck::Swap(GetHorseDataAck* other) {
  if (other != this) {
    horse_data_.Swap(&other->horse_data_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetHorseDataAck::GetTypeName() const {
  return "message.GetHorseDataAck";
}


// ===================================================================

#ifndef _MSC_VER
const int HorseGroomReq::kIdFieldNumber;
const int HorseGroomReq::kTypeFieldNumber;
const int HorseGroomReq::kValueFieldNumber;
#endif  // !_MSC_VER

HorseGroomReq::HorseGroomReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HorseGroomReq::InitAsDefaultInstance() {
}

HorseGroomReq::HorseGroomReq(const HorseGroomReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HorseGroomReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HorseGroomReq::~HorseGroomReq() {
  SharedDtor();
}

void HorseGroomReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HorseGroomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HorseGroomReq& HorseGroomReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

HorseGroomReq* HorseGroomReq::default_instance_ = NULL;

HorseGroomReq* HorseGroomReq::New() const {
  return new HorseGroomReq;
}

void HorseGroomReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    type_ = 0u;
  }
  value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HorseGroomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required uint32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_value;
        break;
      }

      // repeated uint32 value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_value())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_value())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_value;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HorseGroomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  // repeated uint32 value = 3;
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->value(i), output);
  }

}

int HorseGroomReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  // repeated uint32 value = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->value_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->value(i));
    }
    total_size += 1 * this->value_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HorseGroomReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HorseGroomReq*>(&from));
}

void HorseGroomReq::MergeFrom(const HorseGroomReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  value_.MergeFrom(from.value_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void HorseGroomReq::CopyFrom(const HorseGroomReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HorseGroomReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void HorseGroomReq::Swap(HorseGroomReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    value_.Swap(&other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HorseGroomReq::GetTypeName() const {
  return "message.HorseGroomReq";
}


// ===================================================================

#ifndef _MSC_VER
const int HorseGroomAck::kHorseDataFieldNumber;
const int HorseGroomAck::kCountFieldNumber;
const int HorseGroomAck::kTypeFieldNumber;
const int HorseGroomAck::kValueFieldNumber;
#endif  // !_MSC_VER

HorseGroomAck::HorseGroomAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HorseGroomAck::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  horse_data_ = const_cast< ::message::HorseData*>(
      ::message::HorseData::internal_default_instance());
#else
  horse_data_ = const_cast< ::message::HorseData*>(&::message::HorseData::default_instance());
#endif
}

HorseGroomAck::HorseGroomAck(const HorseGroomAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HorseGroomAck::SharedCtor() {
  _cached_size_ = 0;
  horse_data_ = NULL;
  count_ = 0u;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HorseGroomAck::~HorseGroomAck() {
  SharedDtor();
}

void HorseGroomAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete horse_data_;
  }
}

void HorseGroomAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HorseGroomAck& HorseGroomAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

HorseGroomAck* HorseGroomAck::default_instance_ = NULL;

HorseGroomAck* HorseGroomAck::New() const {
  return new HorseGroomAck;
}

void HorseGroomAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_horse_data()) {
      if (horse_data_ != NULL) horse_data_->::message::HorseData::Clear();
    }
    count_ = 0u;
    type_ = 0u;
  }
  value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HorseGroomAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .message.HorseData horse_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_horse_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // required uint32 count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional uint32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_value;
        break;
      }

      // repeated uint32 value = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_value())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_value())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_value;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HorseGroomAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .message.HorseData horse_data = 1;
  if (has_horse_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->horse_data(), output);
  }

  // required uint32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

  // optional uint32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  // repeated uint32 value = 4;
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->value(i), output);
  }

}

int HorseGroomAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .message.HorseData horse_data = 1;
    if (has_horse_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->horse_data());
    }

    // required uint32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional uint32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  // repeated uint32 value = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->value_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->value(i));
    }
    total_size += 1 * this->value_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HorseGroomAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HorseGroomAck*>(&from));
}

void HorseGroomAck::MergeFrom(const HorseGroomAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  value_.MergeFrom(from.value_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_horse_data()) {
      mutable_horse_data()->::message::HorseData::MergeFrom(from.horse_data());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void HorseGroomAck::CopyFrom(const HorseGroomAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HorseGroomAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_horse_data()) {
    if (!this->horse_data().IsInitialized()) return false;
  }
  return true;
}

void HorseGroomAck::Swap(HorseGroomAck* other) {
  if (other != this) {
    std::swap(horse_data_, other->horse_data_);
    std::swap(count_, other->count_);
    std::swap(type_, other->type_);
    value_.Swap(&other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HorseGroomAck::GetTypeName() const {
  return "message.HorseGroomAck";
}


// ===================================================================

#ifndef _MSC_VER
const int BuyHorseFeedCountReq::kValueFieldNumber;
#endif  // !_MSC_VER

BuyHorseFeedCountReq::BuyHorseFeedCountReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BuyHorseFeedCountReq::InitAsDefaultInstance() {
}

BuyHorseFeedCountReq::BuyHorseFeedCountReq(const BuyHorseFeedCountReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BuyHorseFeedCountReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuyHorseFeedCountReq::~BuyHorseFeedCountReq() {
  SharedDtor();
}

void BuyHorseFeedCountReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BuyHorseFeedCountReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BuyHorseFeedCountReq& BuyHorseFeedCountReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BuyHorseFeedCountReq* BuyHorseFeedCountReq::default_instance_ = NULL;

BuyHorseFeedCountReq* BuyHorseFeedCountReq::New() const {
  return new BuyHorseFeedCountReq;
}

void BuyHorseFeedCountReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BuyHorseFeedCountReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuyHorseFeedCountReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int BuyHorseFeedCountReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuyHorseFeedCountReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BuyHorseFeedCountReq*>(&from));
}

void BuyHorseFeedCountReq::MergeFrom(const BuyHorseFeedCountReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void BuyHorseFeedCountReq::CopyFrom(const BuyHorseFeedCountReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuyHorseFeedCountReq::IsInitialized() const {

  return true;
}

void BuyHorseFeedCountReq::Swap(BuyHorseFeedCountReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BuyHorseFeedCountReq::GetTypeName() const {
  return "message.BuyHorseFeedCountReq";
}


// ===================================================================

#ifndef _MSC_VER
const int BuyHorseFeedCountAck::kCountFieldNumber;
#endif  // !_MSC_VER

BuyHorseFeedCountAck::BuyHorseFeedCountAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BuyHorseFeedCountAck::InitAsDefaultInstance() {
}

BuyHorseFeedCountAck::BuyHorseFeedCountAck(const BuyHorseFeedCountAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BuyHorseFeedCountAck::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuyHorseFeedCountAck::~BuyHorseFeedCountAck() {
  SharedDtor();
}

void BuyHorseFeedCountAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BuyHorseFeedCountAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BuyHorseFeedCountAck& BuyHorseFeedCountAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BuyHorseFeedCountAck* BuyHorseFeedCountAck::default_instance_ = NULL;

BuyHorseFeedCountAck* BuyHorseFeedCountAck::New() const {
  return new BuyHorseFeedCountAck;
}

void BuyHorseFeedCountAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BuyHorseFeedCountAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuyHorseFeedCountAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->count(), output);
  }

}

int BuyHorseFeedCountAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuyHorseFeedCountAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BuyHorseFeedCountAck*>(&from));
}

void BuyHorseFeedCountAck::MergeFrom(const BuyHorseFeedCountAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
}

void BuyHorseFeedCountAck::CopyFrom(const BuyHorseFeedCountAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuyHorseFeedCountAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BuyHorseFeedCountAck::Swap(BuyHorseFeedCountAck* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BuyHorseFeedCountAck::GetTypeName() const {
  return "message.BuyHorseFeedCountAck";
}


// ===================================================================

#ifndef _MSC_VER
const int HorseShowChangeReq::kIdFieldNumber;
const int HorseShowChangeReq::kTypeFieldNumber;
#endif  // !_MSC_VER

HorseShowChangeReq::HorseShowChangeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HorseShowChangeReq::InitAsDefaultInstance() {
}

HorseShowChangeReq::HorseShowChangeReq(const HorseShowChangeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HorseShowChangeReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HorseShowChangeReq::~HorseShowChangeReq() {
  SharedDtor();
}

void HorseShowChangeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HorseShowChangeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HorseShowChangeReq& HorseShowChangeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

HorseShowChangeReq* HorseShowChangeReq::default_instance_ = NULL;

HorseShowChangeReq* HorseShowChangeReq::New() const {
  return new HorseShowChangeReq;
}

void HorseShowChangeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HorseShowChangeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required uint32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HorseShowChangeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

}

int HorseShowChangeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HorseShowChangeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HorseShowChangeReq*>(&from));
}

void HorseShowChangeReq::MergeFrom(const HorseShowChangeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void HorseShowChangeReq::CopyFrom(const HorseShowChangeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HorseShowChangeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void HorseShowChangeReq::Swap(HorseShowChangeReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HorseShowChangeReq::GetTypeName() const {
  return "message.HorseShowChangeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int HorseShowChangeAck::kRetFieldNumber;
const int HorseShowChangeAck::kIdFieldNumber;
const int HorseShowChangeAck::kTypeFieldNumber;
#endif  // !_MSC_VER

HorseShowChangeAck::HorseShowChangeAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HorseShowChangeAck::InitAsDefaultInstance() {
}

HorseShowChangeAck::HorseShowChangeAck(const HorseShowChangeAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HorseShowChangeAck::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0u;
  id_ = 0u;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HorseShowChangeAck::~HorseShowChangeAck() {
  SharedDtor();
}

void HorseShowChangeAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HorseShowChangeAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HorseShowChangeAck& HorseShowChangeAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

HorseShowChangeAck* HorseShowChangeAck::default_instance_ = NULL;

HorseShowChangeAck* HorseShowChangeAck::New() const {
  return new HorseShowChangeAck;
}

void HorseShowChangeAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0u;
    id_ = 0u;
    type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HorseShowChangeAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // required uint32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // required uint32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HorseShowChangeAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ret(), output);
  }

  // required uint32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // required uint32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

}

int HorseShowChangeAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HorseShowChangeAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HorseShowChangeAck*>(&from));
}

void HorseShowChangeAck::MergeFrom(const HorseShowChangeAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void HorseShowChangeAck::CopyFrom(const HorseShowChangeAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HorseShowChangeAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void HorseShowChangeAck::Swap(HorseShowChangeAck* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HorseShowChangeAck::GetTypeName() const {
  return "message.HorseShowChangeAck";
}


// ===================================================================

#ifndef _MSC_VER
const int HorseChangeSys::kAccIdFieldNumber;
const int HorseChangeSys::kHorseIdFieldNumber;
const int HorseChangeSys::kHorseImageFieldNumber;
const int HorseChangeSys::kHorseNameFieldNumber;
#endif  // !_MSC_VER

HorseChangeSys::HorseChangeSys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HorseChangeSys::InitAsDefaultInstance() {
}

HorseChangeSys::HorseChangeSys(const HorseChangeSys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HorseChangeSys::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  horse_id_ = 0u;
  horse_image_ = 0u;
  horse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HorseChangeSys::~HorseChangeSys() {
  SharedDtor();
}

void HorseChangeSys::SharedDtor() {
  if (horse_name_ != &::google::protobuf::internal::kEmptyString) {
    delete horse_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HorseChangeSys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HorseChangeSys& HorseChangeSys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

HorseChangeSys* HorseChangeSys::default_instance_ = NULL;

HorseChangeSys* HorseChangeSys::New() const {
  return new HorseChangeSys;
}

void HorseChangeSys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    horse_id_ = 0u;
    horse_image_ = 0u;
    if (has_horse_name()) {
      if (horse_name_ != &::google::protobuf::internal::kEmptyString) {
        horse_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HorseChangeSys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_horse_id;
        break;
      }

      // required uint32 horse_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_horse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &horse_id_)));
          set_has_horse_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_horse_image;
        break;
      }

      // optional uint32 horse_image = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_horse_image:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &horse_image_)));
          set_has_horse_image();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_horse_name;
        break;
      }

      // optional bytes horse_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_horse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_horse_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HorseChangeSys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 horse_id = 2;
  if (has_horse_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->horse_id(), output);
  }

  // optional uint32 horse_image = 3;
  if (has_horse_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->horse_image(), output);
  }

  // optional bytes horse_name = 4;
  if (has_horse_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->horse_name(), output);
  }

}

int HorseChangeSys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 horse_id = 2;
    if (has_horse_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->horse_id());
    }

    // optional uint32 horse_image = 3;
    if (has_horse_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->horse_image());
    }

    // optional bytes horse_name = 4;
    if (has_horse_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->horse_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HorseChangeSys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HorseChangeSys*>(&from));
}

void HorseChangeSys::MergeFrom(const HorseChangeSys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_horse_id()) {
      set_horse_id(from.horse_id());
    }
    if (from.has_horse_image()) {
      set_horse_image(from.horse_image());
    }
    if (from.has_horse_name()) {
      set_horse_name(from.horse_name());
    }
  }
}

void HorseChangeSys::CopyFrom(const HorseChangeSys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HorseChangeSys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void HorseChangeSys::Swap(HorseChangeSys* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(horse_id_, other->horse_id_);
    std::swap(horse_image_, other->horse_image_);
    std::swap(horse_name_, other->horse_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HorseChangeSys::GetTypeName() const {
  return "message.HorseChangeSys";
}


// ===================================================================

#ifndef _MSC_VER
const int LoadAllHorseDataReq::kValueFieldNumber;
#endif  // !_MSC_VER

LoadAllHorseDataReq::LoadAllHorseDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoadAllHorseDataReq::InitAsDefaultInstance() {
}

LoadAllHorseDataReq::LoadAllHorseDataReq(const LoadAllHorseDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoadAllHorseDataReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadAllHorseDataReq::~LoadAllHorseDataReq() {
  SharedDtor();
}

void LoadAllHorseDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoadAllHorseDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoadAllHorseDataReq& LoadAllHorseDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoadAllHorseDataReq* LoadAllHorseDataReq::default_instance_ = NULL;

LoadAllHorseDataReq* LoadAllHorseDataReq::New() const {
  return new LoadAllHorseDataReq;
}

void LoadAllHorseDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoadAllHorseDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadAllHorseDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int LoadAllHorseDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadAllHorseDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoadAllHorseDataReq*>(&from));
}

void LoadAllHorseDataReq::MergeFrom(const LoadAllHorseDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void LoadAllHorseDataReq::CopyFrom(const LoadAllHorseDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAllHorseDataReq::IsInitialized() const {

  return true;
}

void LoadAllHorseDataReq::Swap(LoadAllHorseDataReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoadAllHorseDataReq::GetTypeName() const {
  return "message.LoadAllHorseDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int LoadAllHorseDataAck::kDataFieldNumber;
#endif  // !_MSC_VER

LoadAllHorseDataAck::LoadAllHorseDataAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoadAllHorseDataAck::InitAsDefaultInstance() {
}

LoadAllHorseDataAck::LoadAllHorseDataAck(const LoadAllHorseDataAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoadAllHorseDataAck::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadAllHorseDataAck::~LoadAllHorseDataAck() {
  SharedDtor();
}

void LoadAllHorseDataAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoadAllHorseDataAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoadAllHorseDataAck& LoadAllHorseDataAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

LoadAllHorseDataAck* LoadAllHorseDataAck::default_instance_ = NULL;

LoadAllHorseDataAck* LoadAllHorseDataAck::New() const {
  return new LoadAllHorseDataAck;
}

void LoadAllHorseDataAck::Clear() {
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoadAllHorseDataAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .message.HorseData data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadAllHorseDataAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .message.HorseData data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(i), output);
  }

}

int LoadAllHorseDataAck::ByteSize() const {
  int total_size = 0;

  // repeated .message.HorseData data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadAllHorseDataAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoadAllHorseDataAck*>(&from));
}

void LoadAllHorseDataAck::MergeFrom(const LoadAllHorseDataAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
}

void LoadAllHorseDataAck::CopyFrom(const LoadAllHorseDataAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAllHorseDataAck::IsInitialized() const {

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void LoadAllHorseDataAck::Swap(LoadAllHorseDataAck* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoadAllHorseDataAck::GetTypeName() const {
  return "message.LoadAllHorseDataAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqStopQuickDestiny::kValueFieldNumber;
#endif  // !_MSC_VER

ReqStopQuickDestiny::ReqStopQuickDestiny()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqStopQuickDestiny::InitAsDefaultInstance() {
}

ReqStopQuickDestiny::ReqStopQuickDestiny(const ReqStopQuickDestiny& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqStopQuickDestiny::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqStopQuickDestiny::~ReqStopQuickDestiny() {
  SharedDtor();
}

void ReqStopQuickDestiny::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqStopQuickDestiny::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqStopQuickDestiny& ReqStopQuickDestiny::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqStopQuickDestiny* ReqStopQuickDestiny::default_instance_ = NULL;

ReqStopQuickDestiny* ReqStopQuickDestiny::New() const {
  return new ReqStopQuickDestiny;
}

void ReqStopQuickDestiny::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqStopQuickDestiny::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqStopQuickDestiny::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqStopQuickDestiny::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqStopQuickDestiny::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqStopQuickDestiny*>(&from));
}

void ReqStopQuickDestiny::MergeFrom(const ReqStopQuickDestiny& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqStopQuickDestiny::CopyFrom(const ReqStopQuickDestiny& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqStopQuickDestiny::IsInitialized() const {

  return true;
}

void ReqStopQuickDestiny::Swap(ReqStopQuickDestiny* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqStopQuickDestiny::GetTypeName() const {
  return "message.ReqStopQuickDestiny";
}


// ===================================================================

#ifndef _MSC_VER
const int PlatScrollReq::kIdFieldNumber;
#endif  // !_MSC_VER

PlatScrollReq::PlatScrollReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlatScrollReq::InitAsDefaultInstance() {
}

PlatScrollReq::PlatScrollReq(const PlatScrollReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlatScrollReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlatScrollReq::~PlatScrollReq() {
  SharedDtor();
}

void PlatScrollReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlatScrollReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlatScrollReq& PlatScrollReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PlatScrollReq* PlatScrollReq::default_instance_ = NULL;

PlatScrollReq* PlatScrollReq::New() const {
  return new PlatScrollReq;
}

void PlatScrollReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlatScrollReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlatScrollReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

}

int PlatScrollReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlatScrollReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlatScrollReq*>(&from));
}

void PlatScrollReq::MergeFrom(const PlatScrollReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void PlatScrollReq::CopyFrom(const PlatScrollReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlatScrollReq::IsInitialized() const {

  return true;
}

void PlatScrollReq::Swap(PlatScrollReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlatScrollReq::GetTypeName() const {
  return "message.PlatScrollReq";
}


// ===================================================================

#ifndef _MSC_VER
const int PlatScrollAck::kOrderIdFieldNumber;
const int PlatScrollAck::kServerUrlFieldNumber;
#endif  // !_MSC_VER

PlatScrollAck::PlatScrollAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlatScrollAck::InitAsDefaultInstance() {
}

PlatScrollAck::PlatScrollAck(const PlatScrollAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlatScrollAck::SharedCtor() {
  _cached_size_ = 0;
  order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlatScrollAck::~PlatScrollAck() {
  SharedDtor();
}

void PlatScrollAck::SharedDtor() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (server_url_ != &::google::protobuf::internal::kEmptyString) {
    delete server_url_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlatScrollAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlatScrollAck& PlatScrollAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PlatScrollAck* PlatScrollAck::default_instance_ = NULL;

PlatScrollAck* PlatScrollAck::New() const {
  return new PlatScrollAck;
}

void PlatScrollAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_order_id()) {
      if (order_id_ != &::google::protobuf::internal::kEmptyString) {
        order_id_->clear();
      }
    }
    if (has_server_url()) {
      if (server_url_ != &::google::protobuf::internal::kEmptyString) {
        server_url_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlatScrollAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes order_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_order_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_server_url;
        break;
      }

      // required bytes server_url = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_server_url()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlatScrollAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes order_id = 1;
  if (has_order_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->order_id(), output);
  }

  // required bytes server_url = 2;
  if (has_server_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->server_url(), output);
  }

}

int PlatScrollAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes order_id = 1;
    if (has_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->order_id());
    }

    // required bytes server_url = 2;
    if (has_server_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->server_url());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlatScrollAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlatScrollAck*>(&from));
}

void PlatScrollAck::MergeFrom(const PlatScrollAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_order_id()) {
      set_order_id(from.order_id());
    }
    if (from.has_server_url()) {
      set_server_url(from.server_url());
    }
  }
}

void PlatScrollAck::CopyFrom(const PlatScrollAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlatScrollAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PlatScrollAck::Swap(PlatScrollAck* other) {
  if (other != this) {
    std::swap(order_id_, other->order_id_);
    std::swap(server_url_, other->server_url_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlatScrollAck::GetTypeName() const {
  return "message.PlatScrollAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGetVipLevelReward::kVipLvFieldNumber;
#endif  // !_MSC_VER

ReqGetVipLevelReward::ReqGetVipLevelReward()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqGetVipLevelReward::InitAsDefaultInstance() {
}

ReqGetVipLevelReward::ReqGetVipLevelReward(const ReqGetVipLevelReward& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqGetVipLevelReward::SharedCtor() {
  _cached_size_ = 0;
  vip_lv_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGetVipLevelReward::~ReqGetVipLevelReward() {
  SharedDtor();
}

void ReqGetVipLevelReward::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqGetVipLevelReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqGetVipLevelReward& ReqGetVipLevelReward::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqGetVipLevelReward* ReqGetVipLevelReward::default_instance_ = NULL;

ReqGetVipLevelReward* ReqGetVipLevelReward::New() const {
  return new ReqGetVipLevelReward;
}

void ReqGetVipLevelReward::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    vip_lv_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqGetVipLevelReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 vip_lv = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vip_lv_)));
          set_has_vip_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqGetVipLevelReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 vip_lv = 1;
  if (has_vip_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->vip_lv(), output);
  }

}

int ReqGetVipLevelReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 vip_lv = 1;
    if (has_vip_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->vip_lv());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGetVipLevelReward::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqGetVipLevelReward*>(&from));
}

void ReqGetVipLevelReward::MergeFrom(const ReqGetVipLevelReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_vip_lv()) {
      set_vip_lv(from.vip_lv());
    }
  }
}

void ReqGetVipLevelReward::CopyFrom(const ReqGetVipLevelReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGetVipLevelReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqGetVipLevelReward::Swap(ReqGetVipLevelReward* other) {
  if (other != this) {
    std::swap(vip_lv_, other->vip_lv_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqGetVipLevelReward::GetTypeName() const {
  return "message.ReqGetVipLevelReward";
}


// ===================================================================

#ifndef _MSC_VER
const int SaveBattleInfo::kAccIdFieldNumber;
const int SaveBattleInfo::kBattleDataFieldNumber;
const int SaveBattleInfo::kSequenceIdFieldNumber;
#endif  // !_MSC_VER

SaveBattleInfo::SaveBattleInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SaveBattleInfo::InitAsDefaultInstance() {
}

SaveBattleInfo::SaveBattleInfo(const SaveBattleInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SaveBattleInfo::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  sequence_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaveBattleInfo::~SaveBattleInfo() {
  SharedDtor();
}

void SaveBattleInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SaveBattleInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SaveBattleInfo& SaveBattleInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SaveBattleInfo* SaveBattleInfo::default_instance_ = NULL;

SaveBattleInfo* SaveBattleInfo::New() const {
  return new SaveBattleInfo;
}

void SaveBattleInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    sequence_id_ = 0u;
  }
  battle_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SaveBattleInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_battle_data;
        break;
      }

      // repeated bytes battle_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_battle_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_battle_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_battle_data;
        if (input->ExpectTag(24)) goto parse_sequence_id;
        break;
      }

      // optional uint32 sequence_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_id_)));
          set_has_sequence_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SaveBattleInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // repeated bytes battle_data = 2;
  for (int i = 0; i < this->battle_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->battle_data(i), output);
  }

  // optional uint32 sequence_id = 3;
  if (has_sequence_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sequence_id(), output);
  }

}

int SaveBattleInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // optional uint32 sequence_id = 3;
    if (has_sequence_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence_id());
    }

  }
  // repeated bytes battle_data = 2;
  total_size += 1 * this->battle_data_size();
  for (int i = 0; i < this->battle_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->battle_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaveBattleInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SaveBattleInfo*>(&from));
}

void SaveBattleInfo::MergeFrom(const SaveBattleInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  battle_data_.MergeFrom(from.battle_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_sequence_id()) {
      set_sequence_id(from.sequence_id());
    }
  }
}

void SaveBattleInfo::CopyFrom(const SaveBattleInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveBattleInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SaveBattleInfo::Swap(SaveBattleInfo* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    battle_data_.Swap(&other->battle_data_);
    std::swap(sequence_id_, other->sequence_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SaveBattleInfo::GetTypeName() const {
  return "message.SaveBattleInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqViewBattleHistory::kValueFieldNumber;
#endif  // !_MSC_VER

ReqViewBattleHistory::ReqViewBattleHistory()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqViewBattleHistory::InitAsDefaultInstance() {
}

ReqViewBattleHistory::ReqViewBattleHistory(const ReqViewBattleHistory& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqViewBattleHistory::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqViewBattleHistory::~ReqViewBattleHistory() {
  SharedDtor();
}

void ReqViewBattleHistory::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqViewBattleHistory::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqViewBattleHistory& ReqViewBattleHistory::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqViewBattleHistory* ReqViewBattleHistory::default_instance_ = NULL;

ReqViewBattleHistory* ReqViewBattleHistory::New() const {
  return new ReqViewBattleHistory;
}

void ReqViewBattleHistory::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqViewBattleHistory::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqViewBattleHistory::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqViewBattleHistory::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqViewBattleHistory::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqViewBattleHistory*>(&from));
}

void ReqViewBattleHistory::MergeFrom(const ReqViewBattleHistory& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqViewBattleHistory::CopyFrom(const ReqViewBattleHistory& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqViewBattleHistory::IsInitialized() const {

  return true;
}

void ReqViewBattleHistory::Swap(ReqViewBattleHistory* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqViewBattleHistory::GetTypeName() const {
  return "message.ReqViewBattleHistory";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGetBattleHistoryData::kAccIdFieldNumber;
const int ReqGetBattleHistoryData::kServerIdFieldNumber;
#endif  // !_MSC_VER

ReqGetBattleHistoryData::ReqGetBattleHistoryData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqGetBattleHistoryData::InitAsDefaultInstance() {
}

ReqGetBattleHistoryData::ReqGetBattleHistoryData(const ReqGetBattleHistoryData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqGetBattleHistoryData::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = 0u;
  server_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGetBattleHistoryData::~ReqGetBattleHistoryData() {
  SharedDtor();
}

void ReqGetBattleHistoryData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqGetBattleHistoryData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqGetBattleHistoryData& ReqGetBattleHistoryData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqGetBattleHistoryData* ReqGetBattleHistoryData::default_instance_ = NULL;

ReqGetBattleHistoryData* ReqGetBattleHistoryData::New() const {
  return new ReqGetBattleHistoryData;
}

void ReqGetBattleHistoryData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    acc_id_ = 0u;
    server_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqGetBattleHistoryData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_server_id;
        break;
      }

      // required uint32 server_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqGetBattleHistoryData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->acc_id(), output);
  }

  // required uint32 server_id = 2;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->server_id(), output);
  }

}

int ReqGetBattleHistoryData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 acc_id = 1;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

    // required uint32 server_id = 2;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGetBattleHistoryData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqGetBattleHistoryData*>(&from));
}

void ReqGetBattleHistoryData::MergeFrom(const ReqGetBattleHistoryData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
  }
}

void ReqGetBattleHistoryData::CopyFrom(const ReqGetBattleHistoryData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGetBattleHistoryData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ReqGetBattleHistoryData::Swap(ReqGetBattleHistoryData* other) {
  if (other != this) {
    std::swap(acc_id_, other->acc_id_);
    std::swap(server_id_, other->server_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqGetBattleHistoryData::GetTypeName() const {
  return "message.ReqGetBattleHistoryData";
}


// ===================================================================

#ifndef _MSC_VER
const int BattleHistoryInfo::kBattleDataFieldNumber;
const int BattleHistoryInfo::kNoBattleHistoryFieldNumber;
const int BattleHistoryInfo::kIsLastOneFieldNumber;
#endif  // !_MSC_VER

BattleHistoryInfo::BattleHistoryInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BattleHistoryInfo::InitAsDefaultInstance() {
}

BattleHistoryInfo::BattleHistoryInfo(const BattleHistoryInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BattleHistoryInfo::SharedCtor() {
  _cached_size_ = 0;
  no_battle_history_ = 0u;
  is_last_one_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BattleHistoryInfo::~BattleHistoryInfo() {
  SharedDtor();
}

void BattleHistoryInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BattleHistoryInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BattleHistoryInfo& BattleHistoryInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

BattleHistoryInfo* BattleHistoryInfo::default_instance_ = NULL;

BattleHistoryInfo* BattleHistoryInfo::New() const {
  return new BattleHistoryInfo;
}

void BattleHistoryInfo::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    no_battle_history_ = 0u;
    is_last_one_ = 0u;
  }
  battle_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BattleHistoryInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes battle_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_battle_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_battle_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_battle_data;
        if (input->ExpectTag(16)) goto parse_no_battle_history;
        break;
      }

      // optional uint32 no_battle_history = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_no_battle_history:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &no_battle_history_)));
          set_has_no_battle_history();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_last_one;
        break;
      }

      // optional uint32 is_last_one = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_last_one:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_last_one_)));
          set_has_is_last_one();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BattleHistoryInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes battle_data = 1;
  for (int i = 0; i < this->battle_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->battle_data(i), output);
  }

  // optional uint32 no_battle_history = 2;
  if (has_no_battle_history()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->no_battle_history(), output);
  }

  // optional uint32 is_last_one = 3;
  if (has_is_last_one()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->is_last_one(), output);
  }

}

int BattleHistoryInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 no_battle_history = 2;
    if (has_no_battle_history()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->no_battle_history());
    }

    // optional uint32 is_last_one = 3;
    if (has_is_last_one()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_last_one());
    }

  }
  // repeated bytes battle_data = 1;
  total_size += 1 * this->battle_data_size();
  for (int i = 0; i < this->battle_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->battle_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BattleHistoryInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BattleHistoryInfo*>(&from));
}

void BattleHistoryInfo::MergeFrom(const BattleHistoryInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  battle_data_.MergeFrom(from.battle_data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_no_battle_history()) {
      set_no_battle_history(from.no_battle_history());
    }
    if (from.has_is_last_one()) {
      set_is_last_one(from.is_last_one());
    }
  }
}

void BattleHistoryInfo::CopyFrom(const BattleHistoryInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BattleHistoryInfo::IsInitialized() const {

  return true;
}

void BattleHistoryInfo::Swap(BattleHistoryInfo* other) {
  if (other != this) {
    battle_data_.Swap(&other->battle_data_);
    std::swap(no_battle_history_, other->no_battle_history_);
    std::swap(is_last_one_, other->is_last_one_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BattleHistoryInfo::GetTypeName() const {
  return "message.BattleHistoryInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterActiveReq::kActiveIdFieldNumber;
#endif  // !_MSC_VER

EnterActiveReq::EnterActiveReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterActiveReq::InitAsDefaultInstance() {
}

EnterActiveReq::EnterActiveReq(const EnterActiveReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterActiveReq::SharedCtor() {
  _cached_size_ = 0;
  active_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterActiveReq::~EnterActiveReq() {
  SharedDtor();
}

void EnterActiveReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterActiveReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterActiveReq& EnterActiveReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EnterActiveReq* EnterActiveReq::default_instance_ = NULL;

EnterActiveReq* EnterActiveReq::New() const {
  return new EnterActiveReq;
}

void EnterActiveReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    active_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterActiveReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 active_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &active_id_)));
          set_has_active_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterActiveReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 active_id = 1;
  if (has_active_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->active_id(), output);
  }

}

int EnterActiveReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 active_id = 1;
    if (has_active_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->active_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterActiveReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterActiveReq*>(&from));
}

void EnterActiveReq::MergeFrom(const EnterActiveReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_active_id()) {
      set_active_id(from.active_id());
    }
  }
}

void EnterActiveReq::CopyFrom(const EnterActiveReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterActiveReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EnterActiveReq::Swap(EnterActiveReq* other) {
  if (other != this) {
    std::swap(active_id_, other->active_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterActiveReq::GetTypeName() const {
  return "message.EnterActiveReq";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterActiveAck::kActiveIdFieldNumber;
const int EnterActiveAck::kErrorCodeFieldNumber;
const int EnterActiveAck::kRemainTimeFieldNumber;
const int EnterActiveAck::kRemainBattleTimesFieldNumber;
#endif  // !_MSC_VER

EnterActiveAck::EnterActiveAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterActiveAck::InitAsDefaultInstance() {
}

EnterActiveAck::EnterActiveAck(const EnterActiveAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterActiveAck::SharedCtor() {
  _cached_size_ = 0;
  active_id_ = 0u;
  error_code_ = 0u;
  remain_time_ = 0u;
  remain_battle_times_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterActiveAck::~EnterActiveAck() {
  SharedDtor();
}

void EnterActiveAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterActiveAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterActiveAck& EnterActiveAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EnterActiveAck* EnterActiveAck::default_instance_ = NULL;

EnterActiveAck* EnterActiveAck::New() const {
  return new EnterActiveAck;
}

void EnterActiveAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    active_id_ = 0u;
    error_code_ = 0u;
    remain_time_ = 0u;
    remain_battle_times_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterActiveAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 active_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &active_id_)));
          set_has_active_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_error_code;
        break;
      }

      // optional uint32 error_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_remain_time;
        break;
      }

      // optional uint32 remain_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remain_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remain_time_)));
          set_has_remain_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_remain_battle_times;
        break;
      }

      // optional uint32 remain_battle_times = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remain_battle_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remain_battle_times_)));
          set_has_remain_battle_times();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterActiveAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 active_id = 1;
  if (has_active_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->active_id(), output);
  }

  // optional uint32 error_code = 2;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->error_code(), output);
  }

  // optional uint32 remain_time = 3;
  if (has_remain_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->remain_time(), output);
  }

  // optional uint32 remain_battle_times = 4;
  if (has_remain_battle_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->remain_battle_times(), output);
  }

}

int EnterActiveAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 active_id = 1;
    if (has_active_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->active_id());
    }

    // optional uint32 error_code = 2;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // optional uint32 remain_time = 3;
    if (has_remain_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remain_time());
    }

    // optional uint32 remain_battle_times = 4;
    if (has_remain_battle_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remain_battle_times());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterActiveAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterActiveAck*>(&from));
}

void EnterActiveAck::MergeFrom(const EnterActiveAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_active_id()) {
      set_active_id(from.active_id());
    }
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_remain_time()) {
      set_remain_time(from.remain_time());
    }
    if (from.has_remain_battle_times()) {
      set_remain_battle_times(from.remain_battle_times());
    }
  }
}

void EnterActiveAck::CopyFrom(const EnterActiveAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterActiveAck::IsInitialized() const {

  return true;
}

void EnterActiveAck::Swap(EnterActiveAck* other) {
  if (other != this) {
    std::swap(active_id_, other->active_id_);
    std::swap(error_code_, other->error_code_);
    std::swap(remain_time_, other->remain_time_);
    std::swap(remain_battle_times_, other->remain_battle_times_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterActiveAck::GetTypeName() const {
  return "message.EnterActiveAck";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenTreasureUIReq::kValueFieldNumber;
#endif  // !_MSC_VER

OpenTreasureUIReq::OpenTreasureUIReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OpenTreasureUIReq::InitAsDefaultInstance() {
}

OpenTreasureUIReq::OpenTreasureUIReq(const OpenTreasureUIReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OpenTreasureUIReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenTreasureUIReq::~OpenTreasureUIReq() {
  SharedDtor();
}

void OpenTreasureUIReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenTreasureUIReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenTreasureUIReq& OpenTreasureUIReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OpenTreasureUIReq* OpenTreasureUIReq::default_instance_ = NULL;

OpenTreasureUIReq* OpenTreasureUIReq::New() const {
  return new OpenTreasureUIReq;
}

void OpenTreasureUIReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OpenTreasureUIReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenTreasureUIReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int OpenTreasureUIReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenTreasureUIReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenTreasureUIReq*>(&from));
}

void OpenTreasureUIReq::MergeFrom(const OpenTreasureUIReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void OpenTreasureUIReq::CopyFrom(const OpenTreasureUIReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenTreasureUIReq::IsInitialized() const {

  return true;
}

void OpenTreasureUIReq::Swap(OpenTreasureUIReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenTreasureUIReq::GetTypeName() const {
  return "message.OpenTreasureUIReq";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenTreasureUIAck::kFreeTimesFieldNumber;
const int OpenTreasureUIAck::kCoinNextFreeTimeFieldNumber;
const int OpenTreasureUIAck::kScrollNextFreeTimeFieldNumber;
#endif  // !_MSC_VER

OpenTreasureUIAck::OpenTreasureUIAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OpenTreasureUIAck::InitAsDefaultInstance() {
}

OpenTreasureUIAck::OpenTreasureUIAck(const OpenTreasureUIAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OpenTreasureUIAck::SharedCtor() {
  _cached_size_ = 0;
  free_times_ = 0u;
  coin_next_free_time_ = 0u;
  scroll_next_free_time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenTreasureUIAck::~OpenTreasureUIAck() {
  SharedDtor();
}

void OpenTreasureUIAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenTreasureUIAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenTreasureUIAck& OpenTreasureUIAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

OpenTreasureUIAck* OpenTreasureUIAck::default_instance_ = NULL;

OpenTreasureUIAck* OpenTreasureUIAck::New() const {
  return new OpenTreasureUIAck;
}

void OpenTreasureUIAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    free_times_ = 0u;
    coin_next_free_time_ = 0u;
    scroll_next_free_time_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OpenTreasureUIAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 free_times = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &free_times_)));
          set_has_free_times();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_coin_next_free_time;
        break;
      }

      // optional uint32 coin_next_free_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_coin_next_free_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &coin_next_free_time_)));
          set_has_coin_next_free_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_scroll_next_free_time;
        break;
      }

      // optional uint32 scroll_next_free_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_scroll_next_free_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &scroll_next_free_time_)));
          set_has_scroll_next_free_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenTreasureUIAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 free_times = 1;
  if (has_free_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->free_times(), output);
  }

  // optional uint32 coin_next_free_time = 2;
  if (has_coin_next_free_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->coin_next_free_time(), output);
  }

  // optional uint32 scroll_next_free_time = 3;
  if (has_scroll_next_free_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->scroll_next_free_time(), output);
  }

}

int OpenTreasureUIAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 free_times = 1;
    if (has_free_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->free_times());
    }

    // optional uint32 coin_next_free_time = 2;
    if (has_coin_next_free_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->coin_next_free_time());
    }

    // optional uint32 scroll_next_free_time = 3;
    if (has_scroll_next_free_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->scroll_next_free_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenTreasureUIAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenTreasureUIAck*>(&from));
}

void OpenTreasureUIAck::MergeFrom(const OpenTreasureUIAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_free_times()) {
      set_free_times(from.free_times());
    }
    if (from.has_coin_next_free_time()) {
      set_coin_next_free_time(from.coin_next_free_time());
    }
    if (from.has_scroll_next_free_time()) {
      set_scroll_next_free_time(from.scroll_next_free_time());
    }
  }
}

void OpenTreasureUIAck::CopyFrom(const OpenTreasureUIAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenTreasureUIAck::IsInitialized() const {

  return true;
}

void OpenTreasureUIAck::Swap(OpenTreasureUIAck* other) {
  if (other != this) {
    std::swap(free_times_, other->free_times_);
    std::swap(coin_next_free_time_, other->coin_next_free_time_);
    std::swap(scroll_next_free_time_, other->scroll_next_free_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenTreasureUIAck::GetTypeName() const {
  return "message.OpenTreasureUIAck";
}


// ===================================================================

#ifndef _MSC_VER
const int GetTreasureReq::kTreaModeFieldNumber;
const int GetTreasureReq::kCostTypeFieldNumber;
#endif  // !_MSC_VER

GetTreasureReq::GetTreasureReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetTreasureReq::InitAsDefaultInstance() {
}

GetTreasureReq::GetTreasureReq(const GetTreasureReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetTreasureReq::SharedCtor() {
  _cached_size_ = 0;
  trea_mode_ = 0u;
  cost_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTreasureReq::~GetTreasureReq() {
  SharedDtor();
}

void GetTreasureReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetTreasureReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetTreasureReq& GetTreasureReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetTreasureReq* GetTreasureReq::default_instance_ = NULL;

GetTreasureReq* GetTreasureReq::New() const {
  return new GetTreasureReq;
}

void GetTreasureReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    trea_mode_ = 0u;
    cost_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetTreasureReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 trea_mode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trea_mode_)));
          set_has_trea_mode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_cost_type;
        break;
      }

      // optional uint32 cost_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cost_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_type_)));
          set_has_cost_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetTreasureReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 trea_mode = 1;
  if (has_trea_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->trea_mode(), output);
  }

  // optional uint32 cost_type = 2;
  if (has_cost_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cost_type(), output);
  }

}

int GetTreasureReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 trea_mode = 1;
    if (has_trea_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->trea_mode());
    }

    // optional uint32 cost_type = 2;
    if (has_cost_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cost_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTreasureReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetTreasureReq*>(&from));
}

void GetTreasureReq::MergeFrom(const GetTreasureReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trea_mode()) {
      set_trea_mode(from.trea_mode());
    }
    if (from.has_cost_type()) {
      set_cost_type(from.cost_type());
    }
  }
}

void GetTreasureReq::CopyFrom(const GetTreasureReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTreasureReq::IsInitialized() const {

  return true;
}

void GetTreasureReq::Swap(GetTreasureReq* other) {
  if (other != this) {
    std::swap(trea_mode_, other->trea_mode_);
    std::swap(cost_type_, other->cost_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetTreasureReq::GetTypeName() const {
  return "message.GetTreasureReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetTreasureAck::kErrorCodeFieldNumber;
const int GetTreasureAck::kItemIdFieldNumber;
const int GetTreasureAck::kItemNumFieldNumber;
const int GetTreasureAck::kItemTypeFieldNumber;
#endif  // !_MSC_VER

GetTreasureAck::GetTreasureAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetTreasureAck::InitAsDefaultInstance() {
}

GetTreasureAck::GetTreasureAck(const GetTreasureAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetTreasureAck::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTreasureAck::~GetTreasureAck() {
  SharedDtor();
}

void GetTreasureAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetTreasureAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetTreasureAck& GetTreasureAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetTreasureAck* GetTreasureAck::default_instance_ = NULL;

GetTreasureAck* GetTreasureAck::New() const {
  return new GetTreasureAck;
}

void GetTreasureAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
  }
  item_id_.Clear();
  item_num_.Clear();
  item_type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetTreasureAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_id;
        break;
      }

      // repeated uint32 item_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_item_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_id;
        if (input->ExpectTag(24)) goto parse_item_num;
        break;
      }

      // repeated uint32 item_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_num;
        if (input->ExpectTag(32)) goto parse_item_type;
        break;
      }

      // repeated uint32 item_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_item_type())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_type())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_type;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetTreasureAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // repeated uint32 item_id = 2;
  for (int i = 0; i < this->item_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->item_id(i), output);
  }

  // repeated uint32 item_num = 3;
  for (int i = 0; i < this->item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->item_num(i), output);
  }

  // repeated uint32 item_type = 4;
  for (int i = 0; i < this->item_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->item_type(i), output);
  }

}

int GetTreasureAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

  }
  // repeated uint32 item_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_id(i));
    }
    total_size += 1 * this->item_id_size() + data_size;
  }

  // repeated uint32 item_num = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_num(i));
    }
    total_size += 1 * this->item_num_size() + data_size;
  }

  // repeated uint32 item_type = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_type(i));
    }
    total_size += 1 * this->item_type_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTreasureAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetTreasureAck*>(&from));
}

void GetTreasureAck::MergeFrom(const GetTreasureAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_id_.MergeFrom(from.item_id_);
  item_num_.MergeFrom(from.item_num_);
  item_type_.MergeFrom(from.item_type_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void GetTreasureAck::CopyFrom(const GetTreasureAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTreasureAck::IsInitialized() const {

  return true;
}

void GetTreasureAck::Swap(GetTreasureAck* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    item_id_.Swap(&other->item_id_);
    item_num_.Swap(&other->item_num_);
    item_type_.Swap(&other->item_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetTreasureAck::GetTypeName() const {
  return "message.GetTreasureAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ResetAck::kValueFieldNumber;
const int ResetAck::kActiveIdFieldNumber;
#endif  // !_MSC_VER

ResetAck::ResetAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResetAck::InitAsDefaultInstance() {
}

ResetAck::ResetAck(const ResetAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResetAck::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  active_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetAck::~ResetAck() {
  SharedDtor();
}

void ResetAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResetAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResetAck& ResetAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ResetAck* ResetAck::default_instance_ = NULL;

ResetAck* ResetAck::New() const {
  return new ResetAck;
}

void ResetAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
    active_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResetAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_active_id;
        break;
      }

      // optional uint32 active_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_active_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &active_id_)));
          set_has_active_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResetAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

  // optional uint32 active_id = 2;
  if (has_active_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->active_id(), output);
  }

}

int ResetAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

    // optional uint32 active_id = 2;
    if (has_active_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->active_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResetAck*>(&from));
}

void ResetAck::MergeFrom(const ResetAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_active_id()) {
      set_active_id(from.active_id());
    }
  }
}

void ResetAck::CopyFrom(const ResetAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetAck::IsInitialized() const {

  return true;
}

void ResetAck::Swap(ResetAck* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(active_id_, other->active_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResetAck::GetTypeName() const {
  return "message.ResetAck";
}


// ===================================================================

#ifndef _MSC_VER
const int AddEquipStarReq::kOnlyIdFieldNumber;
const int AddEquipStarReq::kIfEquipFieldNumber;
#endif  // !_MSC_VER

AddEquipStarReq::AddEquipStarReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddEquipStarReq::InitAsDefaultInstance() {
}

AddEquipStarReq::AddEquipStarReq(const AddEquipStarReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddEquipStarReq::SharedCtor() {
  _cached_size_ = 0;
  only_id_ = 0u;
  if_equip_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddEquipStarReq::~AddEquipStarReq() {
  SharedDtor();
}

void AddEquipStarReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddEquipStarReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddEquipStarReq& AddEquipStarReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddEquipStarReq* AddEquipStarReq::default_instance_ = NULL;

AddEquipStarReq* AddEquipStarReq::New() const {
  return new AddEquipStarReq;
}

void AddEquipStarReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    only_id_ = 0u;
    if_equip_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddEquipStarReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 only_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &only_id_)));
          set_has_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_if_equip;
        break;
      }

      // optional bool if_equip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_if_equip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &if_equip_)));
          set_has_if_equip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddEquipStarReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 only_id = 1;
  if (has_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->only_id(), output);
  }

  // optional bool if_equip = 2;
  if (has_if_equip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->if_equip(), output);
  }

}

int AddEquipStarReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 only_id = 1;
    if (has_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->only_id());
    }

    // optional bool if_equip = 2;
    if (has_if_equip()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddEquipStarReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddEquipStarReq*>(&from));
}

void AddEquipStarReq::MergeFrom(const AddEquipStarReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_only_id()) {
      set_only_id(from.only_id());
    }
    if (from.has_if_equip()) {
      set_if_equip(from.if_equip());
    }
  }
}

void AddEquipStarReq::CopyFrom(const AddEquipStarReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddEquipStarReq::IsInitialized() const {

  return true;
}

void AddEquipStarReq::Swap(AddEquipStarReq* other) {
  if (other != this) {
    std::swap(only_id_, other->only_id_);
    std::swap(if_equip_, other->if_equip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddEquipStarReq::GetTypeName() const {
  return "message.AddEquipStarReq";
}


// ===================================================================

#ifndef _MSC_VER
const int AddEquipStarAck::kOnlyIdFieldNumber;
const int AddEquipStarAck::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

AddEquipStarAck::AddEquipStarAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddEquipStarAck::InitAsDefaultInstance() {
}

AddEquipStarAck::AddEquipStarAck(const AddEquipStarAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddEquipStarAck::SharedCtor() {
  _cached_size_ = 0;
  only_id_ = 0u;
  error_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddEquipStarAck::~AddEquipStarAck() {
  SharedDtor();
}

void AddEquipStarAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddEquipStarAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddEquipStarAck& AddEquipStarAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

AddEquipStarAck* AddEquipStarAck::default_instance_ = NULL;

AddEquipStarAck* AddEquipStarAck::New() const {
  return new AddEquipStarAck;
}

void AddEquipStarAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    only_id_ = 0u;
    error_code_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddEquipStarAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 only_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &only_id_)));
          set_has_only_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_error_code;
        break;
      }

      // optional uint32 error_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddEquipStarAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 only_id = 1;
  if (has_only_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->only_id(), output);
  }

  // optional uint32 error_code = 2;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->error_code(), output);
  }

}

int AddEquipStarAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 only_id = 1;
    if (has_only_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->only_id());
    }

    // optional uint32 error_code = 2;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddEquipStarAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddEquipStarAck*>(&from));
}

void AddEquipStarAck::MergeFrom(const AddEquipStarAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_only_id()) {
      set_only_id(from.only_id());
    }
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
}

void AddEquipStarAck::CopyFrom(const AddEquipStarAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddEquipStarAck::IsInitialized() const {

  return true;
}

void AddEquipStarAck::Swap(AddEquipStarAck* other) {
  if (other != this) {
    std::swap(only_id_, other->only_id_);
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddEquipStarAck::GetTypeName() const {
  return "message.AddEquipStarAck";
}


// ===================================================================

#ifndef _MSC_VER
const int GetRoleMailInfoReq::kValueFieldNumber;
#endif  // !_MSC_VER

GetRoleMailInfoReq::GetRoleMailInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetRoleMailInfoReq::InitAsDefaultInstance() {
}

GetRoleMailInfoReq::GetRoleMailInfoReq(const GetRoleMailInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetRoleMailInfoReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetRoleMailInfoReq::~GetRoleMailInfoReq() {
  SharedDtor();
}

void GetRoleMailInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetRoleMailInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetRoleMailInfoReq& GetRoleMailInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetRoleMailInfoReq* GetRoleMailInfoReq::default_instance_ = NULL;

GetRoleMailInfoReq* GetRoleMailInfoReq::New() const {
  return new GetRoleMailInfoReq;
}

void GetRoleMailInfoReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetRoleMailInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetRoleMailInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int GetRoleMailInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetRoleMailInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetRoleMailInfoReq*>(&from));
}

void GetRoleMailInfoReq::MergeFrom(const GetRoleMailInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void GetRoleMailInfoReq::CopyFrom(const GetRoleMailInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetRoleMailInfoReq::IsInitialized() const {

  return true;
}

void GetRoleMailInfoReq::Swap(GetRoleMailInfoReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetRoleMailInfoReq::GetTypeName() const {
  return "message.GetRoleMailInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int SelectMailInfoReq::kServerIdFieldNumber;
const int SelectMailInfoReq::kAccIdFieldNumber;
#endif  // !_MSC_VER

SelectMailInfoReq::SelectMailInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SelectMailInfoReq::InitAsDefaultInstance() {
}

SelectMailInfoReq::SelectMailInfoReq(const SelectMailInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SelectMailInfoReq::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0u;
  acc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SelectMailInfoReq::~SelectMailInfoReq() {
  SharedDtor();
}

void SelectMailInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SelectMailInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SelectMailInfoReq& SelectMailInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SelectMailInfoReq* SelectMailInfoReq::default_instance_ = NULL;

SelectMailInfoReq* SelectMailInfoReq::New() const {
  return new SelectMailInfoReq;
}

void SelectMailInfoReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0u;
    acc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SelectMailInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_acc_id;
        break;
      }

      // optional uint32 acc_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acc_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SelectMailInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->server_id(), output);
  }

  // optional uint32 acc_id = 2;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->acc_id(), output);
  }

}

int SelectMailInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 acc_id = 2;
    if (has_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SelectMailInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SelectMailInfoReq*>(&from));
}

void SelectMailInfoReq::MergeFrom(const SelectMailInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
  }
}

void SelectMailInfoReq::CopyFrom(const SelectMailInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectMailInfoReq::IsInitialized() const {

  return true;
}

void SelectMailInfoReq::Swap(SelectMailInfoReq* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    std::swap(acc_id_, other->acc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SelectMailInfoReq::GetTypeName() const {
  return "message.SelectMailInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RoleMailInfo::kMailIdFieldNumber;
const int RoleMailInfo::kMailTypeFieldNumber;
const int RoleMailInfo::kHasReadFieldNumber;
const int RoleMailInfo::kItemIdFieldNumber;
const int RoleMailInfo::kItemNumFieldNumber;
const int RoleMailInfo::kMailTitleFieldNumber;
const int RoleMailInfo::kMailContentFieldNumber;
const int RoleMailInfo::kMailTimeFieldNumber;
const int RoleMailInfo::kEndTimeFieldNumber;
const int RoleMailInfo::kIsLastOneFieldNumber;
#endif  // !_MSC_VER

RoleMailInfo::RoleMailInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoleMailInfo::InitAsDefaultInstance() {
}

RoleMailInfo::RoleMailInfo(const RoleMailInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoleMailInfo::SharedCtor() {
  _cached_size_ = 0;
  mail_id_ = 0u;
  mail_type_ = 0u;
  has_read_ = 0u;
  mail_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mail_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mail_time_ = 0u;
  end_time_ = 0u;
  is_last_one_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoleMailInfo::~RoleMailInfo() {
  SharedDtor();
}

void RoleMailInfo::SharedDtor() {
  if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_title_;
  }
  if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_content_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RoleMailInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoleMailInfo& RoleMailInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

RoleMailInfo* RoleMailInfo::default_instance_ = NULL;

RoleMailInfo* RoleMailInfo::New() const {
  return new RoleMailInfo;
}

void RoleMailInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mail_id_ = 0u;
    mail_type_ = 0u;
    has_read_ = 0u;
    if (has_mail_title()) {
      if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
        mail_title_->clear();
      }
    }
    if (has_mail_content()) {
      if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
        mail_content_->clear();
      }
    }
    mail_time_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    end_time_ = 0u;
    is_last_one_ = 0u;
  }
  item_id_.Clear();
  item_num_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoleMailInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 mail_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mail_id_)));
          set_has_mail_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mail_type;
        break;
      }

      // optional uint32 mail_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mail_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mail_type_)));
          set_has_mail_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_has_read;
        break;
      }

      // optional uint32 has_read = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_read:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_read_)));
          set_has_has_read();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_id;
        break;
      }

      // repeated uint32 item_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_item_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_id;
        if (input->ExpectTag(40)) goto parse_item_num;
        break;
      }

      // repeated uint32 item_num = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_num;
        if (input->ExpectTag(50)) goto parse_mail_title;
        break;
      }

      // optional bytes mail_title = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mail_title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mail_title()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_mail_content;
        break;
      }

      // optional bytes mail_content = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mail_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mail_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_mail_time;
        break;
      }

      // optional uint32 mail_time = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mail_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mail_time_)));
          set_has_mail_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_end_time;
        break;
      }

      // optional uint32 end_time = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_is_last_one;
        break;
      }

      // optional uint32 is_last_one = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_last_one:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_last_one_)));
          set_has_is_last_one();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoleMailInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 mail_id = 1;
  if (has_mail_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mail_id(), output);
  }

  // optional uint32 mail_type = 2;
  if (has_mail_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->mail_type(), output);
  }

  // optional uint32 has_read = 3;
  if (has_has_read()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->has_read(), output);
  }

  // repeated uint32 item_id = 4;
  for (int i = 0; i < this->item_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->item_id(i), output);
  }

  // repeated uint32 item_num = 5;
  for (int i = 0; i < this->item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->item_num(i), output);
  }

  // optional bytes mail_title = 6;
  if (has_mail_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->mail_title(), output);
  }

  // optional bytes mail_content = 7;
  if (has_mail_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->mail_content(), output);
  }

  // optional uint32 mail_time = 9;
  if (has_mail_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->mail_time(), output);
  }

  // optional uint32 end_time = 10;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->end_time(), output);
  }

  // optional uint32 is_last_one = 11;
  if (has_is_last_one()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->is_last_one(), output);
  }

}

int RoleMailInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 mail_id = 1;
    if (has_mail_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mail_id());
    }

    // optional uint32 mail_type = 2;
    if (has_mail_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mail_type());
    }

    // optional uint32 has_read = 3;
    if (has_has_read()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->has_read());
    }

    // optional bytes mail_title = 6;
    if (has_mail_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mail_title());
    }

    // optional bytes mail_content = 7;
    if (has_mail_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mail_content());
    }

    // optional uint32 mail_time = 9;
    if (has_mail_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mail_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 end_time = 10;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_time());
    }

    // optional uint32 is_last_one = 11;
    if (has_is_last_one()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_last_one());
    }

  }
  // repeated uint32 item_id = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_id(i));
    }
    total_size += 1 * this->item_id_size() + data_size;
  }

  // repeated uint32 item_num = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_num(i));
    }
    total_size += 1 * this->item_num_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoleMailInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoleMailInfo*>(&from));
}

void RoleMailInfo::MergeFrom(const RoleMailInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_id_.MergeFrom(from.item_id_);
  item_num_.MergeFrom(from.item_num_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mail_id()) {
      set_mail_id(from.mail_id());
    }
    if (from.has_mail_type()) {
      set_mail_type(from.mail_type());
    }
    if (from.has_has_read()) {
      set_has_read(from.has_read());
    }
    if (from.has_mail_title()) {
      set_mail_title(from.mail_title());
    }
    if (from.has_mail_content()) {
      set_mail_content(from.mail_content());
    }
    if (from.has_mail_time()) {
      set_mail_time(from.mail_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
    if (from.has_is_last_one()) {
      set_is_last_one(from.is_last_one());
    }
  }
}

void RoleMailInfo::CopyFrom(const RoleMailInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoleMailInfo::IsInitialized() const {

  return true;
}

void RoleMailInfo::Swap(RoleMailInfo* other) {
  if (other != this) {
    std::swap(mail_id_, other->mail_id_);
    std::swap(mail_type_, other->mail_type_);
    std::swap(has_read_, other->has_read_);
    item_id_.Swap(&other->item_id_);
    item_num_.Swap(&other->item_num_);
    std::swap(mail_title_, other->mail_title_);
    std::swap(mail_content_, other->mail_content_);
    std::swap(mail_time_, other->mail_time_);
    std::swap(end_time_, other->end_time_);
    std::swap(is_last_one_, other->is_last_one_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoleMailInfo::GetTypeName() const {
  return "message.RoleMailInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ReadMailReq::kMailIdFieldNumber;
#endif  // !_MSC_VER

ReadMailReq::ReadMailReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReadMailReq::InitAsDefaultInstance() {
}

ReadMailReq::ReadMailReq(const ReadMailReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReadMailReq::SharedCtor() {
  _cached_size_ = 0;
  mail_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadMailReq::~ReadMailReq() {
  SharedDtor();
}

void ReadMailReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReadMailReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadMailReq& ReadMailReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReadMailReq* ReadMailReq::default_instance_ = NULL;

ReadMailReq* ReadMailReq::New() const {
  return new ReadMailReq;
}

void ReadMailReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mail_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReadMailReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 mail_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mail_id_)));
          set_has_mail_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReadMailReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 mail_id = 1;
  if (has_mail_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mail_id(), output);
  }

}

int ReadMailReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 mail_id = 1;
    if (has_mail_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mail_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadMailReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadMailReq*>(&from));
}

void ReadMailReq::MergeFrom(const ReadMailReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mail_id()) {
      set_mail_id(from.mail_id());
    }
  }
}

void ReadMailReq::CopyFrom(const ReadMailReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadMailReq::IsInitialized() const {

  return true;
}

void ReadMailReq::Swap(ReadMailReq* other) {
  if (other != this) {
    std::swap(mail_id_, other->mail_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReadMailReq::GetTypeName() const {
  return "message.ReadMailReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ReadMailAck::kMailIdFieldNumber;
const int ReadMailAck::kResultFieldNumber;
#endif  // !_MSC_VER

ReadMailAck::ReadMailAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReadMailAck::InitAsDefaultInstance() {
}

ReadMailAck::ReadMailAck(const ReadMailAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReadMailAck::SharedCtor() {
  _cached_size_ = 0;
  mail_id_ = 0u;
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadMailAck::~ReadMailAck() {
  SharedDtor();
}

void ReadMailAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReadMailAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadMailAck& ReadMailAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReadMailAck* ReadMailAck::default_instance_ = NULL;

ReadMailAck* ReadMailAck::New() const {
  return new ReadMailAck;
}

void ReadMailAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mail_id_ = 0u;
    result_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReadMailAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 mail_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mail_id_)));
          set_has_mail_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // optional uint32 result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReadMailAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 mail_id = 1;
  if (has_mail_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mail_id(), output);
  }

  // optional uint32 result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result(), output);
  }

}

int ReadMailAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 mail_id = 1;
    if (has_mail_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mail_id());
    }

    // optional uint32 result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadMailAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadMailAck*>(&from));
}

void ReadMailAck::MergeFrom(const ReadMailAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mail_id()) {
      set_mail_id(from.mail_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ReadMailAck::CopyFrom(const ReadMailAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadMailAck::IsInitialized() const {

  return true;
}

void ReadMailAck::Swap(ReadMailAck* other) {
  if (other != this) {
    std::swap(mail_id_, other->mail_id_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReadMailAck::GetTypeName() const {
  return "message.ReadMailAck";
}


// ===================================================================

#ifndef _MSC_VER
const int GetMailRewardReq::kMailIdFieldNumber;
#endif  // !_MSC_VER

GetMailRewardReq::GetMailRewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetMailRewardReq::InitAsDefaultInstance() {
}

GetMailRewardReq::GetMailRewardReq(const GetMailRewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetMailRewardReq::SharedCtor() {
  _cached_size_ = 0;
  mail_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMailRewardReq::~GetMailRewardReq() {
  SharedDtor();
}

void GetMailRewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetMailRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetMailRewardReq& GetMailRewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetMailRewardReq* GetMailRewardReq::default_instance_ = NULL;

GetMailRewardReq* GetMailRewardReq::New() const {
  return new GetMailRewardReq;
}

void GetMailRewardReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mail_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetMailRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 mail_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mail_id_)));
          set_has_mail_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetMailRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 mail_id = 1;
  if (has_mail_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mail_id(), output);
  }

}

int GetMailRewardReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 mail_id = 1;
    if (has_mail_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mail_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMailRewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetMailRewardReq*>(&from));
}

void GetMailRewardReq::MergeFrom(const GetMailRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mail_id()) {
      set_mail_id(from.mail_id());
    }
  }
}

void GetMailRewardReq::CopyFrom(const GetMailRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMailRewardReq::IsInitialized() const {

  return true;
}

void GetMailRewardReq::Swap(GetMailRewardReq* other) {
  if (other != this) {
    std::swap(mail_id_, other->mail_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetMailRewardReq::GetTypeName() const {
  return "message.GetMailRewardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetMailRewardAck::kMailIdFieldNumber;
const int GetMailRewardAck::kResultFieldNumber;
#endif  // !_MSC_VER

GetMailRewardAck::GetMailRewardAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetMailRewardAck::InitAsDefaultInstance() {
}

GetMailRewardAck::GetMailRewardAck(const GetMailRewardAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetMailRewardAck::SharedCtor() {
  _cached_size_ = 0;
  mail_id_ = 0u;
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMailRewardAck::~GetMailRewardAck() {
  SharedDtor();
}

void GetMailRewardAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetMailRewardAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetMailRewardAck& GetMailRewardAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetMailRewardAck* GetMailRewardAck::default_instance_ = NULL;

GetMailRewardAck* GetMailRewardAck::New() const {
  return new GetMailRewardAck;
}

void GetMailRewardAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mail_id_ = 0u;
    result_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetMailRewardAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 mail_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mail_id_)));
          set_has_mail_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // optional uint32 result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetMailRewardAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 mail_id = 1;
  if (has_mail_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mail_id(), output);
  }

  // optional uint32 result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result(), output);
  }

}

int GetMailRewardAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 mail_id = 1;
    if (has_mail_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mail_id());
    }

    // optional uint32 result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMailRewardAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetMailRewardAck*>(&from));
}

void GetMailRewardAck::MergeFrom(const GetMailRewardAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mail_id()) {
      set_mail_id(from.mail_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void GetMailRewardAck::CopyFrom(const GetMailRewardAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMailRewardAck::IsInitialized() const {

  return true;
}

void GetMailRewardAck::Swap(GetMailRewardAck* other) {
  if (other != this) {
    std::swap(mail_id_, other->mail_id_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetMailRewardAck::GetTypeName() const {
  return "message.GetMailRewardAck";
}


// ===================================================================

#ifndef _MSC_VER
const int SendGMMailReq::kToAccIdFieldNumber;
const int SendGMMailReq::kToCharIdFieldNumber;
const int SendGMMailReq::kToLvLowFieldNumber;
const int SendGMMailReq::kToLvHighFieldNumber;
const int SendGMMailReq::kItemIdFieldNumber;
const int SendGMMailReq::kItemNumFieldNumber;
const int SendGMMailReq::kEndTimeFieldNumber;
const int SendGMMailReq::kToCharNameFieldNumber;
const int SendGMMailReq::kMailTitleFieldNumber;
const int SendGMMailReq::kMailContentFieldNumber;
#endif  // !_MSC_VER

SendGMMailReq::SendGMMailReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SendGMMailReq::InitAsDefaultInstance() {
}

SendGMMailReq::SendGMMailReq(const SendGMMailReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SendGMMailReq::SharedCtor() {
  _cached_size_ = 0;
  to_acc_id_ = 0u;
  to_char_id_ = 0u;
  to_lv_low_ = 0u;
  to_lv_high_ = 0u;
  end_time_ = 0u;
  to_char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mail_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mail_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendGMMailReq::~SendGMMailReq() {
  SharedDtor();
}

void SendGMMailReq::SharedDtor() {
  if (to_char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete to_char_name_;
  }
  if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_title_;
  }
  if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_content_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SendGMMailReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendGMMailReq& SendGMMailReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SendGMMailReq* SendGMMailReq::default_instance_ = NULL;

SendGMMailReq* SendGMMailReq::New() const {
  return new SendGMMailReq;
}

void SendGMMailReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    to_acc_id_ = 0u;
    to_char_id_ = 0u;
    to_lv_low_ = 0u;
    to_lv_high_ = 0u;
    end_time_ = 0u;
    if (has_to_char_name()) {
      if (to_char_name_ != &::google::protobuf::internal::kEmptyString) {
        to_char_name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_mail_title()) {
      if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
        mail_title_->clear();
      }
    }
    if (has_mail_content()) {
      if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
        mail_content_->clear();
      }
    }
  }
  item_id_.Clear();
  item_num_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SendGMMailReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 to_acc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_acc_id_)));
          set_has_to_acc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_char_id;
        break;
      }

      // optional uint32 to_char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_char_id_)));
          set_has_to_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_to_lv_low;
        break;
      }

      // optional uint32 to_lv_low = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_lv_low:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_lv_low_)));
          set_has_to_lv_low();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_to_lv_high;
        break;
      }

      // optional uint32 to_lv_high = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_lv_high:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_lv_high_)));
          set_has_to_lv_high();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_id;
        break;
      }

      // repeated uint32 item_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_item_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_id;
        if (input->ExpectTag(48)) goto parse_item_num;
        break;
      }

      // repeated uint32 item_num = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_item_num;
        if (input->ExpectTag(56)) goto parse_end_time;
        break;
      }

      // optional uint32 end_time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_to_char_name;
        break;
      }

      // optional bytes to_char_name = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_to_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_mail_title;
        break;
      }

      // optional bytes mail_title = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mail_title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mail_title()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_mail_content;
        break;
      }

      // optional bytes mail_content = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mail_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mail_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendGMMailReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 to_acc_id = 1;
  if (has_to_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->to_acc_id(), output);
  }

  // optional uint32 to_char_id = 2;
  if (has_to_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_char_id(), output);
  }

  // optional uint32 to_lv_low = 3;
  if (has_to_lv_low()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_lv_low(), output);
  }

  // optional uint32 to_lv_high = 4;
  if (has_to_lv_high()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_lv_high(), output);
  }

  // repeated uint32 item_id = 5;
  for (int i = 0; i < this->item_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->item_id(i), output);
  }

  // repeated uint32 item_num = 6;
  for (int i = 0; i < this->item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->item_num(i), output);
  }

  // optional uint32 end_time = 7;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->end_time(), output);
  }

  // optional bytes to_char_name = 8;
  if (has_to_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->to_char_name(), output);
  }

  // optional bytes mail_title = 9;
  if (has_mail_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->mail_title(), output);
  }

  // optional bytes mail_content = 10;
  if (has_mail_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->mail_content(), output);
  }

}

int SendGMMailReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 to_acc_id = 1;
    if (has_to_acc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_acc_id());
    }

    // optional uint32 to_char_id = 2;
    if (has_to_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_char_id());
    }

    // optional uint32 to_lv_low = 3;
    if (has_to_lv_low()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_lv_low());
    }

    // optional uint32 to_lv_high = 4;
    if (has_to_lv_high()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_lv_high());
    }

    // optional uint32 end_time = 7;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_time());
    }

    // optional bytes to_char_name = 8;
    if (has_to_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->to_char_name());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes mail_title = 9;
    if (has_mail_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mail_title());
    }

    // optional bytes mail_content = 10;
    if (has_mail_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mail_content());
    }

  }
  // repeated uint32 item_id = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_id(i));
    }
    total_size += 1 * this->item_id_size() + data_size;
  }

  // repeated uint32 item_num = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_num(i));
    }
    total_size += 1 * this->item_num_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendGMMailReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendGMMailReq*>(&from));
}

void SendGMMailReq::MergeFrom(const SendGMMailReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_id_.MergeFrom(from.item_id_);
  item_num_.MergeFrom(from.item_num_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_to_acc_id()) {
      set_to_acc_id(from.to_acc_id());
    }
    if (from.has_to_char_id()) {
      set_to_char_id(from.to_char_id());
    }
    if (from.has_to_lv_low()) {
      set_to_lv_low(from.to_lv_low());
    }
    if (from.has_to_lv_high()) {
      set_to_lv_high(from.to_lv_high());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
    if (from.has_to_char_name()) {
      set_to_char_name(from.to_char_name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_mail_title()) {
      set_mail_title(from.mail_title());
    }
    if (from.has_mail_content()) {
      set_mail_content(from.mail_content());
    }
  }
}

void SendGMMailReq::CopyFrom(const SendGMMailReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendGMMailReq::IsInitialized() const {

  return true;
}

void SendGMMailReq::Swap(SendGMMailReq* other) {
  if (other != this) {
    std::swap(to_acc_id_, other->to_acc_id_);
    std::swap(to_char_id_, other->to_char_id_);
    std::swap(to_lv_low_, other->to_lv_low_);
    std::swap(to_lv_high_, other->to_lv_high_);
    item_id_.Swap(&other->item_id_);
    item_num_.Swap(&other->item_num_);
    std::swap(end_time_, other->end_time_);
    std::swap(to_char_name_, other->to_char_name_);
    std::swap(mail_title_, other->mail_title_);
    std::swap(mail_content_, other->mail_content_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SendGMMailReq::GetTypeName() const {
  return "message.SendGMMailReq";
}


// ===================================================================

#ifndef _MSC_VER
const int SendGMMailAck::kResultFieldNumber;
#endif  // !_MSC_VER

SendGMMailAck::SendGMMailAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SendGMMailAck::InitAsDefaultInstance() {
}

SendGMMailAck::SendGMMailAck(const SendGMMailAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SendGMMailAck::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendGMMailAck::~SendGMMailAck() {
  SharedDtor();
}

void SendGMMailAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SendGMMailAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendGMMailAck& SendGMMailAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SendGMMailAck* SendGMMailAck::default_instance_ = NULL;

SendGMMailAck* SendGMMailAck::New() const {
  return new SendGMMailAck;
}

void SendGMMailAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SendGMMailAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendGMMailAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result(), output);
  }

}

int SendGMMailAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendGMMailAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendGMMailAck*>(&from));
}

void SendGMMailAck::MergeFrom(const SendGMMailAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void SendGMMailAck::CopyFrom(const SendGMMailAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendGMMailAck::IsInitialized() const {

  return true;
}

void SendGMMailAck::Swap(SendGMMailAck* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SendGMMailAck::GetTypeName() const {
  return "message.SendGMMailAck";
}


// ===================================================================

#ifndef _MSC_VER
const int NewMailNotice::kNewMailFieldNumber;
#endif  // !_MSC_VER

NewMailNotice::NewMailNotice()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NewMailNotice::InitAsDefaultInstance() {
}

NewMailNotice::NewMailNotice(const NewMailNotice& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NewMailNotice::SharedCtor() {
  _cached_size_ = 0;
  new_mail_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewMailNotice::~NewMailNotice() {
  SharedDtor();
}

void NewMailNotice::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NewMailNotice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NewMailNotice& NewMailNotice::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

NewMailNotice* NewMailNotice::default_instance_ = NULL;

NewMailNotice* NewMailNotice::New() const {
  return new NewMailNotice;
}

void NewMailNotice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    new_mail_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NewMailNotice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 new_mail = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &new_mail_)));
          set_has_new_mail();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewMailNotice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 new_mail = 1;
  if (has_new_mail()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->new_mail(), output);
  }

}

int NewMailNotice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 new_mail = 1;
    if (has_new_mail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->new_mail());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewMailNotice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NewMailNotice*>(&from));
}

void NewMailNotice::MergeFrom(const NewMailNotice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_new_mail()) {
      set_new_mail(from.new_mail());
    }
  }
}

void NewMailNotice::CopyFrom(const NewMailNotice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewMailNotice::IsInitialized() const {

  return true;
}

void NewMailNotice::Swap(NewMailNotice* other) {
  if (other != this) {
    std::swap(new_mail_, other->new_mail_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NewMailNotice::GetTypeName() const {
  return "message.NewMailNotice";
}


// ===================================================================

#ifndef _MSC_VER
const int SelectMailInfoAck::kMailDataFieldNumber;
const int SelectMailInfoAck::kIsLastOneFieldNumber;
#endif  // !_MSC_VER

SelectMailInfoAck::SelectMailInfoAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SelectMailInfoAck::InitAsDefaultInstance() {
}

SelectMailInfoAck::SelectMailInfoAck(const SelectMailInfoAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SelectMailInfoAck::SharedCtor() {
  _cached_size_ = 0;
  is_last_one_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SelectMailInfoAck::~SelectMailInfoAck() {
  SharedDtor();
}

void SelectMailInfoAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SelectMailInfoAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SelectMailInfoAck& SelectMailInfoAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SelectMailInfoAck* SelectMailInfoAck::default_instance_ = NULL;

SelectMailInfoAck* SelectMailInfoAck::New() const {
  return new SelectMailInfoAck;
}

void SelectMailInfoAck::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    is_last_one_ = 0u;
  }
  mail_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SelectMailInfoAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes mail_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mail_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_mail_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_mail_data;
        if (input->ExpectTag(16)) goto parse_is_last_one;
        break;
      }

      // optional uint32 is_last_one = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_last_one:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_last_one_)));
          set_has_is_last_one();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SelectMailInfoAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes mail_data = 1;
  for (int i = 0; i < this->mail_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->mail_data(i), output);
  }

  // optional uint32 is_last_one = 2;
  if (has_is_last_one()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->is_last_one(), output);
  }

}

int SelectMailInfoAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 is_last_one = 2;
    if (has_is_last_one()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_last_one());
    }

  }
  // repeated bytes mail_data = 1;
  total_size += 1 * this->mail_data_size();
  for (int i = 0; i < this->mail_data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->mail_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SelectMailInfoAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SelectMailInfoAck*>(&from));
}

void SelectMailInfoAck::MergeFrom(const SelectMailInfoAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  mail_data_.MergeFrom(from.mail_data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_is_last_one()) {
      set_is_last_one(from.is_last_one());
    }
  }
}

void SelectMailInfoAck::CopyFrom(const SelectMailInfoAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectMailInfoAck::IsInitialized() const {

  return true;
}

void SelectMailInfoAck::Swap(SelectMailInfoAck* other) {
  if (other != this) {
    mail_data_.Swap(&other->mail_data_);
    std::swap(is_last_one_, other->is_last_one_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SelectMailInfoAck::GetTypeName() const {
  return "message.SelectMailInfoAck";
}


// ===================================================================

#ifndef _MSC_VER
const int GetSkillInfoReq::kNvalueFieldNumber;
#endif  // !_MSC_VER

GetSkillInfoReq::GetSkillInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetSkillInfoReq::InitAsDefaultInstance() {
}

GetSkillInfoReq::GetSkillInfoReq(const GetSkillInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetSkillInfoReq::SharedCtor() {
  _cached_size_ = 0;
  nvalue_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetSkillInfoReq::~GetSkillInfoReq() {
  SharedDtor();
}

void GetSkillInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetSkillInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetSkillInfoReq& GetSkillInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetSkillInfoReq* GetSkillInfoReq::default_instance_ = NULL;

GetSkillInfoReq* GetSkillInfoReq::New() const {
  return new GetSkillInfoReq;
}

void GetSkillInfoReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    nvalue_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetSkillInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 nvalue = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nvalue_)));
          set_has_nvalue();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetSkillInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 nvalue = 1;
  if (has_nvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->nvalue(), output);
  }

}

int GetSkillInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 nvalue = 1;
    if (has_nvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nvalue());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetSkillInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetSkillInfoReq*>(&from));
}

void GetSkillInfoReq::MergeFrom(const GetSkillInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nvalue()) {
      set_nvalue(from.nvalue());
    }
  }
}

void GetSkillInfoReq::CopyFrom(const GetSkillInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSkillInfoReq::IsInitialized() const {

  return true;
}

void GetSkillInfoReq::Swap(GetSkillInfoReq* other) {
  if (other != this) {
    std::swap(nvalue_, other->nvalue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetSkillInfoReq::GetTypeName() const {
  return "message.GetSkillInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetSkillInfoAck::kSkillPointFieldNumber;
const int GetSkillInfoAck::kNextAddTimeFieldNumber;
#endif  // !_MSC_VER

GetSkillInfoAck::GetSkillInfoAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetSkillInfoAck::InitAsDefaultInstance() {
}

GetSkillInfoAck::GetSkillInfoAck(const GetSkillInfoAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetSkillInfoAck::SharedCtor() {
  _cached_size_ = 0;
  skill_point_ = 0u;
  next_add_time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetSkillInfoAck::~GetSkillInfoAck() {
  SharedDtor();
}

void GetSkillInfoAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetSkillInfoAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetSkillInfoAck& GetSkillInfoAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetSkillInfoAck* GetSkillInfoAck::default_instance_ = NULL;

GetSkillInfoAck* GetSkillInfoAck::New() const {
  return new GetSkillInfoAck;
}

void GetSkillInfoAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    skill_point_ = 0u;
    next_add_time_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetSkillInfoAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 skill_point = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_point_)));
          set_has_skill_point();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_next_add_time;
        break;
      }

      // optional uint32 next_add_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_next_add_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &next_add_time_)));
          set_has_next_add_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetSkillInfoAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 skill_point = 1;
  if (has_skill_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->skill_point(), output);
  }

  // optional uint32 next_add_time = 2;
  if (has_next_add_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->next_add_time(), output);
  }

}

int GetSkillInfoAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 skill_point = 1;
    if (has_skill_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_point());
    }

    // optional uint32 next_add_time = 2;
    if (has_next_add_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->next_add_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetSkillInfoAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetSkillInfoAck*>(&from));
}

void GetSkillInfoAck::MergeFrom(const GetSkillInfoAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_skill_point()) {
      set_skill_point(from.skill_point());
    }
    if (from.has_next_add_time()) {
      set_next_add_time(from.next_add_time());
    }
  }
}

void GetSkillInfoAck::CopyFrom(const GetSkillInfoAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSkillInfoAck::IsInitialized() const {

  return true;
}

void GetSkillInfoAck::Swap(GetSkillInfoAck* other) {
  if (other != this) {
    std::swap(skill_point_, other->skill_point_);
    std::swap(next_add_time_, other->next_add_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetSkillInfoAck::GetTypeName() const {
  return "message.GetSkillInfoAck";
}


// ===================================================================

#ifndef _MSC_VER
const int EquipUpgradeItemReq::kMercIdFieldNumber;
const int EquipUpgradeItemReq::kEquipPosFieldNumber;
#endif  // !_MSC_VER

EquipUpgradeItemReq::EquipUpgradeItemReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EquipUpgradeItemReq::InitAsDefaultInstance() {
}

EquipUpgradeItemReq::EquipUpgradeItemReq(const EquipUpgradeItemReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EquipUpgradeItemReq::SharedCtor() {
  _cached_size_ = 0;
  merc_id_ = 0u;
  equip_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EquipUpgradeItemReq::~EquipUpgradeItemReq() {
  SharedDtor();
}

void EquipUpgradeItemReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EquipUpgradeItemReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EquipUpgradeItemReq& EquipUpgradeItemReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

EquipUpgradeItemReq* EquipUpgradeItemReq::default_instance_ = NULL;

EquipUpgradeItemReq* EquipUpgradeItemReq::New() const {
  return new EquipUpgradeItemReq;
}

void EquipUpgradeItemReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_id_ = 0u;
    equip_pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EquipUpgradeItemReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 merc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_id_)));
          set_has_merc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_equip_pos;
        break;
      }

      // optional uint32 equip_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equip_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &equip_pos_)));
          set_has_equip_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EquipUpgradeItemReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 merc_id = 1;
  if (has_merc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_id(), output);
  }

  // optional uint32 equip_pos = 2;
  if (has_equip_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->equip_pos(), output);
  }

}

int EquipUpgradeItemReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 merc_id = 1;
    if (has_merc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_id());
    }

    // optional uint32 equip_pos = 2;
    if (has_equip_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->equip_pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EquipUpgradeItemReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EquipUpgradeItemReq*>(&from));
}

void EquipUpgradeItemReq::MergeFrom(const EquipUpgradeItemReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_id()) {
      set_merc_id(from.merc_id());
    }
    if (from.has_equip_pos()) {
      set_equip_pos(from.equip_pos());
    }
  }
}

void EquipUpgradeItemReq::CopyFrom(const EquipUpgradeItemReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipUpgradeItemReq::IsInitialized() const {

  return true;
}

void EquipUpgradeItemReq::Swap(EquipUpgradeItemReq* other) {
  if (other != this) {
    std::swap(merc_id_, other->merc_id_);
    std::swap(equip_pos_, other->equip_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EquipUpgradeItemReq::GetTypeName() const {
  return "message.EquipUpgradeItemReq";
}


// ===================================================================

#ifndef _MSC_VER
const int UnlockedSkill::kMercPosFieldNumber;
const int UnlockedSkill::kSkillPosFieldNumber;
#endif  // !_MSC_VER

UnlockedSkill::UnlockedSkill()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UnlockedSkill::InitAsDefaultInstance() {
}

UnlockedSkill::UnlockedSkill(const UnlockedSkill& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UnlockedSkill::SharedCtor() {
  _cached_size_ = 0;
  merc_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnlockedSkill::~UnlockedSkill() {
  SharedDtor();
}

void UnlockedSkill::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnlockedSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnlockedSkill& UnlockedSkill::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

UnlockedSkill* UnlockedSkill::default_instance_ = NULL;

UnlockedSkill* UnlockedSkill::New() const {
  return new UnlockedSkill;
}

void UnlockedSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_pos_ = 0u;
  }
  skill_pos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UnlockedSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 merc_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_pos;
        break;
      }

      // repeated uint32 skill_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_skill_pos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_skill_pos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skill_pos;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UnlockedSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 merc_pos = 1;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_pos(), output);
  }

  // repeated uint32 skill_pos = 2;
  for (int i = 0; i < this->skill_pos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->skill_pos(i), output);
  }

}

int UnlockedSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 merc_pos = 1;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

  }
  // repeated uint32 skill_pos = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->skill_pos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->skill_pos(i));
    }
    total_size += 1 * this->skill_pos_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnlockedSkill::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnlockedSkill*>(&from));
}

void UnlockedSkill::MergeFrom(const UnlockedSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  skill_pos_.MergeFrom(from.skill_pos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
  }
}

void UnlockedSkill::CopyFrom(const UnlockedSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnlockedSkill::IsInitialized() const {

  return true;
}

void UnlockedSkill::Swap(UnlockedSkill* other) {
  if (other != this) {
    std::swap(merc_pos_, other->merc_pos_);
    skill_pos_.Swap(&other->skill_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UnlockedSkill::GetTypeName() const {
  return "message.UnlockedSkill";
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGetLastPvpRewardTime::kValueFieldNumber;
#endif  // !_MSC_VER

ReqGetLastPvpRewardTime::ReqGetLastPvpRewardTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReqGetLastPvpRewardTime::InitAsDefaultInstance() {
}

ReqGetLastPvpRewardTime::ReqGetLastPvpRewardTime(const ReqGetLastPvpRewardTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReqGetLastPvpRewardTime::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGetLastPvpRewardTime::~ReqGetLastPvpRewardTime() {
  SharedDtor();
}

void ReqGetLastPvpRewardTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReqGetLastPvpRewardTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReqGetLastPvpRewardTime& ReqGetLastPvpRewardTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReqGetLastPvpRewardTime* ReqGetLastPvpRewardTime::default_instance_ = NULL;

ReqGetLastPvpRewardTime* ReqGetLastPvpRewardTime::New() const {
  return new ReqGetLastPvpRewardTime;
}

void ReqGetLastPvpRewardTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReqGetLastPvpRewardTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqGetLastPvpRewardTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ReqGetLastPvpRewardTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGetLastPvpRewardTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReqGetLastPvpRewardTime*>(&from));
}

void ReqGetLastPvpRewardTime::MergeFrom(const ReqGetLastPvpRewardTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ReqGetLastPvpRewardTime::CopyFrom(const ReqGetLastPvpRewardTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGetLastPvpRewardTime::IsInitialized() const {

  return true;
}

void ReqGetLastPvpRewardTime::Swap(ReqGetLastPvpRewardTime* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReqGetLastPvpRewardTime::GetTypeName() const {
  return "message.ReqGetLastPvpRewardTime";
}


// ===================================================================

#ifndef _MSC_VER
const int PvpRewardTimeAck::kLastTimeFieldNumber;
#endif  // !_MSC_VER

PvpRewardTimeAck::PvpRewardTimeAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PvpRewardTimeAck::InitAsDefaultInstance() {
}

PvpRewardTimeAck::PvpRewardTimeAck(const PvpRewardTimeAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PvpRewardTimeAck::SharedCtor() {
  _cached_size_ = 0;
  last_time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PvpRewardTimeAck::~PvpRewardTimeAck() {
  SharedDtor();
}

void PvpRewardTimeAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PvpRewardTimeAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PvpRewardTimeAck& PvpRewardTimeAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

PvpRewardTimeAck* PvpRewardTimeAck::default_instance_ = NULL;

PvpRewardTimeAck* PvpRewardTimeAck::New() const {
  return new PvpRewardTimeAck;
}

void PvpRewardTimeAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    last_time_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PvpRewardTimeAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 last_time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &last_time_)));
          set_has_last_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PvpRewardTimeAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 last_time = 1;
  if (has_last_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->last_time(), output);
  }

}

int PvpRewardTimeAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 last_time = 1;
    if (has_last_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->last_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PvpRewardTimeAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PvpRewardTimeAck*>(&from));
}

void PvpRewardTimeAck::MergeFrom(const PvpRewardTimeAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_last_time()) {
      set_last_time(from.last_time());
    }
  }
}

void PvpRewardTimeAck::CopyFrom(const PvpRewardTimeAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PvpRewardTimeAck::IsInitialized() const {

  return true;
}

void PvpRewardTimeAck::Swap(PvpRewardTimeAck* other) {
  if (other != this) {
    std::swap(last_time_, other->last_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PvpRewardTimeAck::GetTypeName() const {
  return "message.PvpRewardTimeAck";
}


// ===================================================================

#ifndef _MSC_VER
const int GetClimbTowerEnemyReq::kMapIdFieldNumber;
#endif  // !_MSC_VER

GetClimbTowerEnemyReq::GetClimbTowerEnemyReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetClimbTowerEnemyReq::InitAsDefaultInstance() {
}

GetClimbTowerEnemyReq::GetClimbTowerEnemyReq(const GetClimbTowerEnemyReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetClimbTowerEnemyReq::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetClimbTowerEnemyReq::~GetClimbTowerEnemyReq() {
  SharedDtor();
}

void GetClimbTowerEnemyReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetClimbTowerEnemyReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetClimbTowerEnemyReq& GetClimbTowerEnemyReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetClimbTowerEnemyReq* GetClimbTowerEnemyReq::default_instance_ = NULL;

GetClimbTowerEnemyReq* GetClimbTowerEnemyReq::New() const {
  return new GetClimbTowerEnemyReq;
}

void GetClimbTowerEnemyReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetClimbTowerEnemyReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetClimbTowerEnemyReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

}

int GetClimbTowerEnemyReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetClimbTowerEnemyReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetClimbTowerEnemyReq*>(&from));
}

void GetClimbTowerEnemyReq::MergeFrom(const GetClimbTowerEnemyReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
  }
}

void GetClimbTowerEnemyReq::CopyFrom(const GetClimbTowerEnemyReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetClimbTowerEnemyReq::IsInitialized() const {

  return true;
}

void GetClimbTowerEnemyReq::Swap(GetClimbTowerEnemyReq* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetClimbTowerEnemyReq::GetTypeName() const {
  return "message.GetClimbTowerEnemyReq";
}


// ===================================================================

#ifndef _MSC_VER
const int SelectClimbTowerEnemy::kMapIdFieldNumber;
const int SelectClimbTowerEnemy::kCharIdFieldNumber;
const int SelectClimbTowerEnemy::kServerIdFieldNumber;
const int SelectClimbTowerEnemy::kBattleScoreLowFieldNumber;
const int SelectClimbTowerEnemy::kBattleScoreHighFieldNumber;
#endif  // !_MSC_VER

SelectClimbTowerEnemy::SelectClimbTowerEnemy()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SelectClimbTowerEnemy::InitAsDefaultInstance() {
}

SelectClimbTowerEnemy::SelectClimbTowerEnemy(const SelectClimbTowerEnemy& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SelectClimbTowerEnemy::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  char_id_ = 0u;
  server_id_ = 0u;
  battle_score_low_ = 0u;
  battle_score_high_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SelectClimbTowerEnemy::~SelectClimbTowerEnemy() {
  SharedDtor();
}

void SelectClimbTowerEnemy::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SelectClimbTowerEnemy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SelectClimbTowerEnemy& SelectClimbTowerEnemy::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SelectClimbTowerEnemy* SelectClimbTowerEnemy::default_instance_ = NULL;

SelectClimbTowerEnemy* SelectClimbTowerEnemy::New() const {
  return new SelectClimbTowerEnemy;
}

void SelectClimbTowerEnemy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0u;
    char_id_ = 0u;
    server_id_ = 0u;
    battle_score_low_ = 0u;
    battle_score_high_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SelectClimbTowerEnemy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // optional uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_battle_score_low;
        break;
      }

      // optional uint32 battle_score_low = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_battle_score_low:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_score_low_)));
          set_has_battle_score_low();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_battle_score_high;
        break;
      }

      // optional uint32 battle_score_high = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_battle_score_high:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_score_high_)));
          set_has_battle_score_high();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SelectClimbTowerEnemy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // optional uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

  // optional uint32 server_id = 3;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->server_id(), output);
  }

  // optional uint32 battle_score_low = 4;
  if (has_battle_score_low()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->battle_score_low(), output);
  }

  // optional uint32 battle_score_high = 5;
  if (has_battle_score_high()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->battle_score_high(), output);
  }

}

int SelectClimbTowerEnemy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // optional uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // optional uint32 server_id = 3;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional uint32 battle_score_low = 4;
    if (has_battle_score_low()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_score_low());
    }

    // optional uint32 battle_score_high = 5;
    if (has_battle_score_high()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_score_high());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SelectClimbTowerEnemy::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SelectClimbTowerEnemy*>(&from));
}

void SelectClimbTowerEnemy::MergeFrom(const SelectClimbTowerEnemy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_battle_score_low()) {
      set_battle_score_low(from.battle_score_low());
    }
    if (from.has_battle_score_high()) {
      set_battle_score_high(from.battle_score_high());
    }
  }
}

void SelectClimbTowerEnemy::CopyFrom(const SelectClimbTowerEnemy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectClimbTowerEnemy::IsInitialized() const {

  return true;
}

void SelectClimbTowerEnemy::Swap(SelectClimbTowerEnemy* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(char_id_, other->char_id_);
    std::swap(server_id_, other->server_id_);
    std::swap(battle_score_low_, other->battle_score_low_);
    std::swap(battle_score_high_, other->battle_score_high_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SelectClimbTowerEnemy::GetTypeName() const {
  return "message.SelectClimbTowerEnemy";
}


// ===================================================================

#ifndef _MSC_VER
const int ClimbTowerEnemyData::kQueryTypeFieldNumber;
const int ClimbTowerEnemyData::kCharIdFieldNumber;
const int ClimbTowerEnemyData::kCharSexFieldNumber;
const int ClimbTowerEnemyData::kCharJobFieldNumber;
const int ClimbTowerEnemyData::kCharLevelFieldNumber;
const int ClimbTowerEnemyData::kCharNameFieldNumber;
const int ClimbTowerEnemyData::kMercDataFieldNumber;
const int ClimbTowerEnemyData::kEquipDataFieldNumber;
#endif  // !_MSC_VER

ClimbTowerEnemyData::ClimbTowerEnemyData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ClimbTowerEnemyData::InitAsDefaultInstance() {
}

ClimbTowerEnemyData::ClimbTowerEnemyData(const ClimbTowerEnemyData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ClimbTowerEnemyData::SharedCtor() {
  _cached_size_ = 0;
  query_type_ = 0u;
  char_id_ = 0u;
  char_sex_ = 0u;
  char_job_ = 0u;
  char_level_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  merc_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  equip_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClimbTowerEnemyData::~ClimbTowerEnemyData() {
  SharedDtor();
}

void ClimbTowerEnemyData::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  if (merc_data_ != &::google::protobuf::internal::kEmptyString) {
    delete merc_data_;
  }
  if (equip_data_ != &::google::protobuf::internal::kEmptyString) {
    delete equip_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClimbTowerEnemyData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClimbTowerEnemyData& ClimbTowerEnemyData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ClimbTowerEnemyData* ClimbTowerEnemyData::default_instance_ = NULL;

ClimbTowerEnemyData* ClimbTowerEnemyData::New() const {
  return new ClimbTowerEnemyData;
}

void ClimbTowerEnemyData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    query_type_ = 0u;
    char_id_ = 0u;
    char_sex_ = 0u;
    char_job_ = 0u;
    char_level_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    if (has_merc_data()) {
      if (merc_data_ != &::google::protobuf::internal::kEmptyString) {
        merc_data_->clear();
      }
    }
    if (has_equip_data()) {
      if (equip_data_ != &::google::protobuf::internal::kEmptyString) {
        equip_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClimbTowerEnemyData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 query_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &query_type_)));
          set_has_query_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // optional uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_char_sex;
        break;
      }

      // optional uint32 char_sex = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_sex_)));
          set_has_char_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_char_job;
        break;
      }

      // optional uint32 char_job = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_job_)));
          set_has_char_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_char_level;
        break;
      }

      // optional uint32 char_level = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_level_)));
          set_has_char_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_char_name;
        break;
      }

      // optional bytes char_name = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_merc_data;
        break;
      }

      // optional bytes merc_data = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_merc_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_merc_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_equip_data;
        break;
      }

      // optional bytes equip_data = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_equip_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_equip_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClimbTowerEnemyData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 query_type = 1;
  if (has_query_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->query_type(), output);
  }

  // optional uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

  // optional uint32 char_sex = 3;
  if (has_char_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->char_sex(), output);
  }

  // optional uint32 char_job = 4;
  if (has_char_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->char_job(), output);
  }

  // optional uint32 char_level = 5;
  if (has_char_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->char_level(), output);
  }

  // optional bytes char_name = 6;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->char_name(), output);
  }

  // optional bytes merc_data = 7;
  if (has_merc_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->merc_data(), output);
  }

  // optional bytes equip_data = 8;
  if (has_equip_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->equip_data(), output);
  }

}

int ClimbTowerEnemyData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 query_type = 1;
    if (has_query_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->query_type());
    }

    // optional uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // optional uint32 char_sex = 3;
    if (has_char_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_sex());
    }

    // optional uint32 char_job = 4;
    if (has_char_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_job());
    }

    // optional uint32 char_level = 5;
    if (has_char_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_level());
    }

    // optional bytes char_name = 6;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // optional bytes merc_data = 7;
    if (has_merc_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->merc_data());
    }

    // optional bytes equip_data = 8;
    if (has_equip_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->equip_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClimbTowerEnemyData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClimbTowerEnemyData*>(&from));
}

void ClimbTowerEnemyData::MergeFrom(const ClimbTowerEnemyData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_query_type()) {
      set_query_type(from.query_type());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_char_sex()) {
      set_char_sex(from.char_sex());
    }
    if (from.has_char_job()) {
      set_char_job(from.char_job());
    }
    if (from.has_char_level()) {
      set_char_level(from.char_level());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_merc_data()) {
      set_merc_data(from.merc_data());
    }
    if (from.has_equip_data()) {
      set_equip_data(from.equip_data());
    }
  }
}

void ClimbTowerEnemyData::CopyFrom(const ClimbTowerEnemyData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClimbTowerEnemyData::IsInitialized() const {

  return true;
}

void ClimbTowerEnemyData::Swap(ClimbTowerEnemyData* other) {
  if (other != this) {
    std::swap(query_type_, other->query_type_);
    std::swap(char_id_, other->char_id_);
    std::swap(char_sex_, other->char_sex_);
    std::swap(char_job_, other->char_job_);
    std::swap(char_level_, other->char_level_);
    std::swap(char_name_, other->char_name_);
    std::swap(merc_data_, other->merc_data_);
    std::swap(equip_data_, other->equip_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ClimbTowerEnemyData::GetTypeName() const {
  return "message.ClimbTowerEnemyData";
}


// ===================================================================

#ifndef _MSC_VER
const int GetClimbTowerEnemyAck_MercInfo::kMercIdFieldNumber;
const int GetClimbTowerEnemyAck_MercInfo::kMercLevelFieldNumber;
const int GetClimbTowerEnemyAck_MercInfo::kMercColorFieldNumber;
const int GetClimbTowerEnemyAck_MercInfo::kMercStarFieldNumber;
const int GetClimbTowerEnemyAck_MercInfo::kMercBloodFieldNumber;
const int GetClimbTowerEnemyAck_MercInfo::kMercSkillEnergyFieldNumber;
#endif  // !_MSC_VER

GetClimbTowerEnemyAck_MercInfo::GetClimbTowerEnemyAck_MercInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetClimbTowerEnemyAck_MercInfo::InitAsDefaultInstance() {
}

GetClimbTowerEnemyAck_MercInfo::GetClimbTowerEnemyAck_MercInfo(const GetClimbTowerEnemyAck_MercInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetClimbTowerEnemyAck_MercInfo::SharedCtor() {
  _cached_size_ = 0;
  merc_id_ = 0u;
  merc_level_ = 0u;
  merc_color_ = 0u;
  merc_star_ = 0u;
  merc_blood_ = 0u;
  merc_skill_energy_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetClimbTowerEnemyAck_MercInfo::~GetClimbTowerEnemyAck_MercInfo() {
  SharedDtor();
}

void GetClimbTowerEnemyAck_MercInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetClimbTowerEnemyAck_MercInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetClimbTowerEnemyAck_MercInfo& GetClimbTowerEnemyAck_MercInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetClimbTowerEnemyAck_MercInfo* GetClimbTowerEnemyAck_MercInfo::default_instance_ = NULL;

GetClimbTowerEnemyAck_MercInfo* GetClimbTowerEnemyAck_MercInfo::New() const {
  return new GetClimbTowerEnemyAck_MercInfo;
}

void GetClimbTowerEnemyAck_MercInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_id_ = 0u;
    merc_level_ = 0u;
    merc_color_ = 0u;
    merc_star_ = 0u;
    merc_blood_ = 0u;
    merc_skill_energy_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetClimbTowerEnemyAck_MercInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 merc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_id_)));
          set_has_merc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_merc_level;
        break;
      }

      // optional uint32 merc_level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_level_)));
          set_has_merc_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_merc_color;
        break;
      }

      // optional uint32 merc_color = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_color_)));
          set_has_merc_color();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_merc_star;
        break;
      }

      // optional uint32 merc_star = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_star_)));
          set_has_merc_star();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_merc_blood;
        break;
      }

      // optional uint32 merc_blood = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_blood:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_blood_)));
          set_has_merc_blood();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_merc_skill_energy;
        break;
      }

      // optional uint32 merc_skill_energy = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_skill_energy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_skill_energy_)));
          set_has_merc_skill_energy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetClimbTowerEnemyAck_MercInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 merc_id = 1;
  if (has_merc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_id(), output);
  }

  // optional uint32 merc_level = 2;
  if (has_merc_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->merc_level(), output);
  }

  // optional uint32 merc_color = 3;
  if (has_merc_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->merc_color(), output);
  }

  // optional uint32 merc_star = 4;
  if (has_merc_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->merc_star(), output);
  }

  // optional uint32 merc_blood = 5;
  if (has_merc_blood()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->merc_blood(), output);
  }

  // optional uint32 merc_skill_energy = 6;
  if (has_merc_skill_energy()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->merc_skill_energy(), output);
  }

}

int GetClimbTowerEnemyAck_MercInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 merc_id = 1;
    if (has_merc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_id());
    }

    // optional uint32 merc_level = 2;
    if (has_merc_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_level());
    }

    // optional uint32 merc_color = 3;
    if (has_merc_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_color());
    }

    // optional uint32 merc_star = 4;
    if (has_merc_star()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_star());
    }

    // optional uint32 merc_blood = 5;
    if (has_merc_blood()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_blood());
    }

    // optional uint32 merc_skill_energy = 6;
    if (has_merc_skill_energy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_skill_energy());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetClimbTowerEnemyAck_MercInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetClimbTowerEnemyAck_MercInfo*>(&from));
}

void GetClimbTowerEnemyAck_MercInfo::MergeFrom(const GetClimbTowerEnemyAck_MercInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_id()) {
      set_merc_id(from.merc_id());
    }
    if (from.has_merc_level()) {
      set_merc_level(from.merc_level());
    }
    if (from.has_merc_color()) {
      set_merc_color(from.merc_color());
    }
    if (from.has_merc_star()) {
      set_merc_star(from.merc_star());
    }
    if (from.has_merc_blood()) {
      set_merc_blood(from.merc_blood());
    }
    if (from.has_merc_skill_energy()) {
      set_merc_skill_energy(from.merc_skill_energy());
    }
  }
}

void GetClimbTowerEnemyAck_MercInfo::CopyFrom(const GetClimbTowerEnemyAck_MercInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetClimbTowerEnemyAck_MercInfo::IsInitialized() const {

  return true;
}

void GetClimbTowerEnemyAck_MercInfo::Swap(GetClimbTowerEnemyAck_MercInfo* other) {
  if (other != this) {
    std::swap(merc_id_, other->merc_id_);
    std::swap(merc_level_, other->merc_level_);
    std::swap(merc_color_, other->merc_color_);
    std::swap(merc_star_, other->merc_star_);
    std::swap(merc_blood_, other->merc_blood_);
    std::swap(merc_skill_energy_, other->merc_skill_energy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetClimbTowerEnemyAck_MercInfo::GetTypeName() const {
  return "message.GetClimbTowerEnemyAck.MercInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GetClimbTowerEnemyAck::kErrorCodeFieldNumber;
const int GetClimbTowerEnemyAck::kCharIdFieldNumber;
const int GetClimbTowerEnemyAck::kCharNameFieldNumber;
const int GetClimbTowerEnemyAck::kCharSexFieldNumber;
const int GetClimbTowerEnemyAck::kCharJobFieldNumber;
const int GetClimbTowerEnemyAck::kCharLevelFieldNumber;
const int GetClimbTowerEnemyAck::kMercDataFieldNumber;
#endif  // !_MSC_VER

GetClimbTowerEnemyAck::GetClimbTowerEnemyAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetClimbTowerEnemyAck::InitAsDefaultInstance() {
}

GetClimbTowerEnemyAck::GetClimbTowerEnemyAck(const GetClimbTowerEnemyAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetClimbTowerEnemyAck::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  char_id_ = 0u;
  char_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  char_sex_ = 0u;
  char_job_ = 0u;
  char_level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetClimbTowerEnemyAck::~GetClimbTowerEnemyAck() {
  SharedDtor();
}

void GetClimbTowerEnemyAck::SharedDtor() {
  if (char_name_ != &::google::protobuf::internal::kEmptyString) {
    delete char_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetClimbTowerEnemyAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetClimbTowerEnemyAck& GetClimbTowerEnemyAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetClimbTowerEnemyAck* GetClimbTowerEnemyAck::default_instance_ = NULL;

GetClimbTowerEnemyAck* GetClimbTowerEnemyAck::New() const {
  return new GetClimbTowerEnemyAck;
}

void GetClimbTowerEnemyAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    char_id_ = 0u;
    if (has_char_name()) {
      if (char_name_ != &::google::protobuf::internal::kEmptyString) {
        char_name_->clear();
      }
    }
    char_sex_ = 0u;
    char_job_ = 0u;
    char_level_ = 0u;
  }
  merc_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetClimbTowerEnemyAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // optional uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_char_name;
        break;
      }

      // optional bytes char_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_char_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_char_sex;
        break;
      }

      // optional uint32 char_sex = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_sex_)));
          set_has_char_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_char_job;
        break;
      }

      // optional uint32 char_job = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_job_)));
          set_has_char_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_char_level;
        break;
      }

      // optional uint32 char_level = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_level_)));
          set_has_char_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_merc_data;
        break;
      }

      // repeated .message.GetClimbTowerEnemyAck.MercInfo merc_data = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_merc_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_merc_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_merc_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetClimbTowerEnemyAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // optional uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

  // optional bytes char_name = 3;
  if (has_char_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->char_name(), output);
  }

  // optional uint32 char_sex = 4;
  if (has_char_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->char_sex(), output);
  }

  // optional uint32 char_job = 5;
  if (has_char_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->char_job(), output);
  }

  // optional uint32 char_level = 6;
  if (has_char_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->char_level(), output);
  }

  // repeated .message.GetClimbTowerEnemyAck.MercInfo merc_data = 7;
  for (int i = 0; i < this->merc_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->merc_data(i), output);
  }

}

int GetClimbTowerEnemyAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // optional uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // optional bytes char_name = 3;
    if (has_char_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->char_name());
    }

    // optional uint32 char_sex = 4;
    if (has_char_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_sex());
    }

    // optional uint32 char_job = 5;
    if (has_char_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_job());
    }

    // optional uint32 char_level = 6;
    if (has_char_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_level());
    }

  }
  // repeated .message.GetClimbTowerEnemyAck.MercInfo merc_data = 7;
  total_size += 1 * this->merc_data_size();
  for (int i = 0; i < this->merc_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->merc_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetClimbTowerEnemyAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetClimbTowerEnemyAck*>(&from));
}

void GetClimbTowerEnemyAck::MergeFrom(const GetClimbTowerEnemyAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  merc_data_.MergeFrom(from.merc_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_char_name()) {
      set_char_name(from.char_name());
    }
    if (from.has_char_sex()) {
      set_char_sex(from.char_sex());
    }
    if (from.has_char_job()) {
      set_char_job(from.char_job());
    }
    if (from.has_char_level()) {
      set_char_level(from.char_level());
    }
  }
}

void GetClimbTowerEnemyAck::CopyFrom(const GetClimbTowerEnemyAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetClimbTowerEnemyAck::IsInitialized() const {

  return true;
}

void GetClimbTowerEnemyAck::Swap(GetClimbTowerEnemyAck* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(char_id_, other->char_id_);
    std::swap(char_name_, other->char_name_);
    std::swap(char_sex_, other->char_sex_);
    std::swap(char_job_, other->char_job_);
    std::swap(char_level_, other->char_level_);
    merc_data_.Swap(&other->merc_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetClimbTowerEnemyAck::GetTypeName() const {
  return "message.GetClimbTowerEnemyAck";
}


// ===================================================================

#ifndef _MSC_VER
const int GetClimbTowerRewardReq::kValueFieldNumber;
#endif  // !_MSC_VER

GetClimbTowerRewardReq::GetClimbTowerRewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetClimbTowerRewardReq::InitAsDefaultInstance() {
}

GetClimbTowerRewardReq::GetClimbTowerRewardReq(const GetClimbTowerRewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetClimbTowerRewardReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetClimbTowerRewardReq::~GetClimbTowerRewardReq() {
  SharedDtor();
}

void GetClimbTowerRewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetClimbTowerRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetClimbTowerRewardReq& GetClimbTowerRewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetClimbTowerRewardReq* GetClimbTowerRewardReq::default_instance_ = NULL;

GetClimbTowerRewardReq* GetClimbTowerRewardReq::New() const {
  return new GetClimbTowerRewardReq;
}

void GetClimbTowerRewardReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetClimbTowerRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetClimbTowerRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int GetClimbTowerRewardReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetClimbTowerRewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetClimbTowerRewardReq*>(&from));
}

void GetClimbTowerRewardReq::MergeFrom(const GetClimbTowerRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void GetClimbTowerRewardReq::CopyFrom(const GetClimbTowerRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetClimbTowerRewardReq::IsInitialized() const {

  return true;
}

void GetClimbTowerRewardReq::Swap(GetClimbTowerRewardReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetClimbTowerRewardReq::GetTypeName() const {
  return "message.GetClimbTowerRewardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetClimbTowerRewardAck::kErrorCodeFieldNumber;
const int GetClimbTowerRewardAck::kMoneyNumFieldNumber;
const int GetClimbTowerRewardAck::kCtMoneyFieldNumber;
const int GetClimbTowerRewardAck::kItemIdFieldNumber;
const int GetClimbTowerRewardAck::kItemNumFieldNumber;
#endif  // !_MSC_VER

GetClimbTowerRewardAck::GetClimbTowerRewardAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetClimbTowerRewardAck::InitAsDefaultInstance() {
}

GetClimbTowerRewardAck::GetClimbTowerRewardAck(const GetClimbTowerRewardAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetClimbTowerRewardAck::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  money_num_ = 0u;
  ct_money_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetClimbTowerRewardAck::~GetClimbTowerRewardAck() {
  SharedDtor();
}

void GetClimbTowerRewardAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetClimbTowerRewardAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetClimbTowerRewardAck& GetClimbTowerRewardAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

GetClimbTowerRewardAck* GetClimbTowerRewardAck::default_instance_ = NULL;

GetClimbTowerRewardAck* GetClimbTowerRewardAck::New() const {
  return new GetClimbTowerRewardAck;
}

void GetClimbTowerRewardAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    money_num_ = 0u;
    ct_money_ = 0u;
  }
  item_id_.Clear();
  item_num_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetClimbTowerRewardAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_money_num;
        break;
      }

      // optional uint32 money_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &money_num_)));
          set_has_money_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ct_money;
        break;
      }

      // optional uint32 ct_money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ct_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ct_money_)));
          set_has_ct_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_id;
        break;
      }

      // repeated uint32 item_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_item_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_id;
        if (input->ExpectTag(40)) goto parse_item_num;
        break;
      }

      // repeated uint32 item_num = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_item_num())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_item_num())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_num;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetClimbTowerRewardAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // optional uint32 money_num = 2;
  if (has_money_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->money_num(), output);
  }

  // optional uint32 ct_money = 3;
  if (has_ct_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->ct_money(), output);
  }

  // repeated uint32 item_id = 4;
  for (int i = 0; i < this->item_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->item_id(i), output);
  }

  // repeated uint32 item_num = 5;
  for (int i = 0; i < this->item_num_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->item_num(i), output);
  }

}

int GetClimbTowerRewardAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // optional uint32 money_num = 2;
    if (has_money_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->money_num());
    }

    // optional uint32 ct_money = 3;
    if (has_ct_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ct_money());
    }

  }
  // repeated uint32 item_id = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_id(i));
    }
    total_size += 1 * this->item_id_size() + data_size;
  }

  // repeated uint32 item_num = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_num_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->item_num(i));
    }
    total_size += 1 * this->item_num_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetClimbTowerRewardAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetClimbTowerRewardAck*>(&from));
}

void GetClimbTowerRewardAck::MergeFrom(const GetClimbTowerRewardAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_id_.MergeFrom(from.item_id_);
  item_num_.MergeFrom(from.item_num_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_money_num()) {
      set_money_num(from.money_num());
    }
    if (from.has_ct_money()) {
      set_ct_money(from.ct_money());
    }
  }
}

void GetClimbTowerRewardAck::CopyFrom(const GetClimbTowerRewardAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetClimbTowerRewardAck::IsInitialized() const {

  return true;
}

void GetClimbTowerRewardAck::Swap(GetClimbTowerRewardAck* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(money_num_, other->money_num_);
    std::swap(ct_money_, other->ct_money_);
    item_id_.Swap(&other->item_id_);
    item_num_.Swap(&other->item_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetClimbTowerRewardAck::GetTypeName() const {
  return "message.GetClimbTowerRewardAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ReliveMercReq::kMercIdFieldNumber;
#endif  // !_MSC_VER

ReliveMercReq::ReliveMercReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReliveMercReq::InitAsDefaultInstance() {
}

ReliveMercReq::ReliveMercReq(const ReliveMercReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReliveMercReq::SharedCtor() {
  _cached_size_ = 0;
  merc_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReliveMercReq::~ReliveMercReq() {
  SharedDtor();
}

void ReliveMercReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReliveMercReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReliveMercReq& ReliveMercReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReliveMercReq* ReliveMercReq::default_instance_ = NULL;

ReliveMercReq* ReliveMercReq::New() const {
  return new ReliveMercReq;
}

void ReliveMercReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReliveMercReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 merc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_id_)));
          set_has_merc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReliveMercReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 merc_id = 1;
  if (has_merc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_id(), output);
  }

}

int ReliveMercReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 merc_id = 1;
    if (has_merc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReliveMercReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReliveMercReq*>(&from));
}

void ReliveMercReq::MergeFrom(const ReliveMercReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_id()) {
      set_merc_id(from.merc_id());
    }
  }
}

void ReliveMercReq::CopyFrom(const ReliveMercReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReliveMercReq::IsInitialized() const {

  return true;
}

void ReliveMercReq::Swap(ReliveMercReq* other) {
  if (other != this) {
    std::swap(merc_id_, other->merc_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReliveMercReq::GetTypeName() const {
  return "message.ReliveMercReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ReliveMercAck::kErrorCodeFieldNumber;
const int ReliveMercAck::kMercPosFieldNumber;
#endif  // !_MSC_VER

ReliveMercAck::ReliveMercAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReliveMercAck::InitAsDefaultInstance() {
}

ReliveMercAck::ReliveMercAck(const ReliveMercAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReliveMercAck::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  merc_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReliveMercAck::~ReliveMercAck() {
  SharedDtor();
}

void ReliveMercAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReliveMercAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReliveMercAck& ReliveMercAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ReliveMercAck* ReliveMercAck::default_instance_ = NULL;

ReliveMercAck* ReliveMercAck::New() const {
  return new ReliveMercAck;
}

void ReliveMercAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    merc_pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReliveMercAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_merc_pos;
        break;
      }

      // optional uint32 merc_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_merc_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_pos_)));
          set_has_merc_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReliveMercAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }

  // optional uint32 merc_pos = 2;
  if (has_merc_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->merc_pos(), output);
  }

}

int ReliveMercAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }

    // optional uint32 merc_pos = 2;
    if (has_merc_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_pos());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReliveMercAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReliveMercAck*>(&from));
}

void ReliveMercAck::MergeFrom(const ReliveMercAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_merc_pos()) {
      set_merc_pos(from.merc_pos());
    }
  }
}

void ReliveMercAck::CopyFrom(const ReliveMercAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReliveMercAck::IsInitialized() const {

  return true;
}

void ReliveMercAck::Swap(ReliveMercAck* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(merc_pos_, other->merc_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReliveMercAck::GetTypeName() const {
  return "message.ReliveMercAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ResetClimbTowerReq::kValueFieldNumber;
#endif  // !_MSC_VER

ResetClimbTowerReq::ResetClimbTowerReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResetClimbTowerReq::InitAsDefaultInstance() {
}

ResetClimbTowerReq::ResetClimbTowerReq(const ResetClimbTowerReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResetClimbTowerReq::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetClimbTowerReq::~ResetClimbTowerReq() {
  SharedDtor();
}

void ResetClimbTowerReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResetClimbTowerReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResetClimbTowerReq& ResetClimbTowerReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ResetClimbTowerReq* ResetClimbTowerReq::default_instance_ = NULL;

ResetClimbTowerReq* ResetClimbTowerReq::New() const {
  return new ResetClimbTowerReq;
}

void ResetClimbTowerReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResetClimbTowerReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResetClimbTowerReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->value(), output);
  }

}

int ResetClimbTowerReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetClimbTowerReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResetClimbTowerReq*>(&from));
}

void ResetClimbTowerReq::MergeFrom(const ResetClimbTowerReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ResetClimbTowerReq::CopyFrom(const ResetClimbTowerReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetClimbTowerReq::IsInitialized() const {

  return true;
}

void ResetClimbTowerReq::Swap(ResetClimbTowerReq* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResetClimbTowerReq::GetTypeName() const {
  return "message.ResetClimbTowerReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ClimbTowerBattleResult_SaveData::kMercIdFieldNumber;
const int ClimbTowerBattleResult_SaveData::kBloodNumFieldNumber;
const int ClimbTowerBattleResult_SaveData::kSkillEnergyFieldNumber;
#endif  // !_MSC_VER

ClimbTowerBattleResult_SaveData::ClimbTowerBattleResult_SaveData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ClimbTowerBattleResult_SaveData::InitAsDefaultInstance() {
}

ClimbTowerBattleResult_SaveData::ClimbTowerBattleResult_SaveData(const ClimbTowerBattleResult_SaveData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ClimbTowerBattleResult_SaveData::SharedCtor() {
  _cached_size_ = 0;
  merc_id_ = 0u;
  blood_num_ = 0u;
  skill_energy_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClimbTowerBattleResult_SaveData::~ClimbTowerBattleResult_SaveData() {
  SharedDtor();
}

void ClimbTowerBattleResult_SaveData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClimbTowerBattleResult_SaveData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClimbTowerBattleResult_SaveData& ClimbTowerBattleResult_SaveData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ClimbTowerBattleResult_SaveData* ClimbTowerBattleResult_SaveData::default_instance_ = NULL;

ClimbTowerBattleResult_SaveData* ClimbTowerBattleResult_SaveData::New() const {
  return new ClimbTowerBattleResult_SaveData;
}

void ClimbTowerBattleResult_SaveData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    merc_id_ = 0u;
    blood_num_ = 0u;
    skill_energy_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClimbTowerBattleResult_SaveData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 merc_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &merc_id_)));
          set_has_merc_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_blood_num;
        break;
      }

      // optional uint32 blood_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blood_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &blood_num_)));
          set_has_blood_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skill_energy;
        break;
      }

      // optional uint32 skill_energy = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill_energy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skill_energy_)));
          set_has_skill_energy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClimbTowerBattleResult_SaveData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 merc_id = 1;
  if (has_merc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->merc_id(), output);
  }

  // optional uint32 blood_num = 2;
  if (has_blood_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->blood_num(), output);
  }

  // optional uint32 skill_energy = 3;
  if (has_skill_energy()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->skill_energy(), output);
  }

}

int ClimbTowerBattleResult_SaveData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 merc_id = 1;
    if (has_merc_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->merc_id());
    }

    // optional uint32 blood_num = 2;
    if (has_blood_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->blood_num());
    }

    // optional uint32 skill_energy = 3;
    if (has_skill_energy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skill_energy());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClimbTowerBattleResult_SaveData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClimbTowerBattleResult_SaveData*>(&from));
}

void ClimbTowerBattleResult_SaveData::MergeFrom(const ClimbTowerBattleResult_SaveData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merc_id()) {
      set_merc_id(from.merc_id());
    }
    if (from.has_blood_num()) {
      set_blood_num(from.blood_num());
    }
    if (from.has_skill_energy()) {
      set_skill_energy(from.skill_energy());
    }
  }
}

void ClimbTowerBattleResult_SaveData::CopyFrom(const ClimbTowerBattleResult_SaveData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClimbTowerBattleResult_SaveData::IsInitialized() const {

  return true;
}

void ClimbTowerBattleResult_SaveData::Swap(ClimbTowerBattleResult_SaveData* other) {
  if (other != this) {
    std::swap(merc_id_, other->merc_id_);
    std::swap(blood_num_, other->blood_num_);
    std::swap(skill_energy_, other->skill_energy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ClimbTowerBattleResult_SaveData::GetTypeName() const {
  return "message.ClimbTowerBattleResult.SaveData";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ClimbTowerBattleResult::kMapIdFieldNumber;
const int ClimbTowerBattleResult::kBattleResultFieldNumber;
const int ClimbTowerBattleResult::kSourceDataFieldNumber;
const int ClimbTowerBattleResult::kTargetDataFieldNumber;
#endif  // !_MSC_VER

ClimbTowerBattleResult::ClimbTowerBattleResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ClimbTowerBattleResult::InitAsDefaultInstance() {
}

ClimbTowerBattleResult::ClimbTowerBattleResult(const ClimbTowerBattleResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ClimbTowerBattleResult::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  battle_result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClimbTowerBattleResult::~ClimbTowerBattleResult() {
  SharedDtor();
}

void ClimbTowerBattleResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClimbTowerBattleResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClimbTowerBattleResult& ClimbTowerBattleResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ClimbTowerBattleResult* ClimbTowerBattleResult::default_instance_ = NULL;

ClimbTowerBattleResult* ClimbTowerBattleResult::New() const {
  return new ClimbTowerBattleResult;
}

void ClimbTowerBattleResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0u;
    battle_result_ = 0u;
  }
  source_data_.Clear();
  target_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClimbTowerBattleResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_battle_result;
        break;
      }

      // optional uint32 battle_result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_battle_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battle_result_)));
          set_has_battle_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_source_data;
        break;
      }

      // repeated .message.ClimbTowerBattleResult.SaveData source_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_source_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_source_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_source_data;
        if (input->ExpectTag(34)) goto parse_target_data;
        break;
      }

      // repeated .message.ClimbTowerBattleResult.SaveData target_data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_target_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_target_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClimbTowerBattleResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // optional uint32 battle_result = 2;
  if (has_battle_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->battle_result(), output);
  }

  // repeated .message.ClimbTowerBattleResult.SaveData source_data = 3;
  for (int i = 0; i < this->source_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->source_data(i), output);
  }

  // repeated .message.ClimbTowerBattleResult.SaveData target_data = 4;
  for (int i = 0; i < this->target_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->target_data(i), output);
  }

}

int ClimbTowerBattleResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // optional uint32 battle_result = 2;
    if (has_battle_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battle_result());
    }

  }
  // repeated .message.ClimbTowerBattleResult.SaveData source_data = 3;
  total_size += 1 * this->source_data_size();
  for (int i = 0; i < this->source_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->source_data(i));
  }

  // repeated .message.ClimbTowerBattleResult.SaveData target_data = 4;
  total_size += 1 * this->target_data_size();
  for (int i = 0; i < this->target_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->target_data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClimbTowerBattleResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClimbTowerBattleResult*>(&from));
}

void ClimbTowerBattleResult::MergeFrom(const ClimbTowerBattleResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  source_data_.MergeFrom(from.source_data_);
  target_data_.MergeFrom(from.target_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_battle_result()) {
      set_battle_result(from.battle_result());
    }
  }
}

void ClimbTowerBattleResult::CopyFrom(const ClimbTowerBattleResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClimbTowerBattleResult::IsInitialized() const {

  return true;
}

void ClimbTowerBattleResult::Swap(ClimbTowerBattleResult* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(battle_result_, other->battle_result_);
    source_data_.Swap(&other->source_data_);
    target_data_.Swap(&other->target_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ClimbTowerBattleResult::GetTypeName() const {
  return "message.ClimbTowerBattleResult";
}


// ===================================================================

#ifndef _MSC_VER
const int SaveCTEnemyInfo::kMapIdFieldNumber;
const int SaveCTEnemyInfo::kCharIdFieldNumber;
const int SaveCTEnemyInfo::kServerIdFieldNumber;
const int SaveCTEnemyInfo::kEnemyInfoFieldNumber;
#endif  // !_MSC_VER

SaveCTEnemyInfo::SaveCTEnemyInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SaveCTEnemyInfo::InitAsDefaultInstance() {
}

SaveCTEnemyInfo::SaveCTEnemyInfo(const SaveCTEnemyInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SaveCTEnemyInfo::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  char_id_ = 0u;
  server_id_ = 0u;
  enemy_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaveCTEnemyInfo::~SaveCTEnemyInfo() {
  SharedDtor();
}

void SaveCTEnemyInfo::SharedDtor() {
  if (enemy_info_ != &::google::protobuf::internal::kEmptyString) {
    delete enemy_info_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SaveCTEnemyInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SaveCTEnemyInfo& SaveCTEnemyInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SaveCTEnemyInfo* SaveCTEnemyInfo::default_instance_ = NULL;

SaveCTEnemyInfo* SaveCTEnemyInfo::New() const {
  return new SaveCTEnemyInfo;
}

void SaveCTEnemyInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0u;
    char_id_ = 0u;
    server_id_ = 0u;
    if (has_enemy_info()) {
      if (enemy_info_ != &::google::protobuf::internal::kEmptyString) {
        enemy_info_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SaveCTEnemyInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // optional uint32 char_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_server_id;
        break;
      }

      // optional uint32 server_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_enemy_info;
        break;
      }

      // optional bytes enemy_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_enemy_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_enemy_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SaveCTEnemyInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // optional uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

  // optional uint32 server_id = 3;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->server_id(), output);
  }

  // optional bytes enemy_info = 4;
  if (has_enemy_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->enemy_info(), output);
  }

}

int SaveCTEnemyInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // optional uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // optional uint32 server_id = 3;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_id());
    }

    // optional bytes enemy_info = 4;
    if (has_enemy_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->enemy_info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaveCTEnemyInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SaveCTEnemyInfo*>(&from));
}

void SaveCTEnemyInfo::MergeFrom(const SaveCTEnemyInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_enemy_info()) {
      set_enemy_info(from.enemy_info());
    }
  }
}

void SaveCTEnemyInfo::CopyFrom(const SaveCTEnemyInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveCTEnemyInfo::IsInitialized() const {

  return true;
}

void SaveCTEnemyInfo::Swap(SaveCTEnemyInfo* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(char_id_, other->char_id_);
    std::swap(server_id_, other->server_id_);
    std::swap(enemy_info_, other->enemy_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SaveCTEnemyInfo::GetTypeName() const {
  return "message.SaveCTEnemyInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int SendPvpRankRiseAwards::kHistoryRankFieldNumber;
const int SendPvpRankRiseAwards::kNowRankFieldNumber;
const int SendPvpRankRiseAwards::kScrollPointFieldNumber;
const int SendPvpRankRiseAwards::kRankRiseFieldNumber;
#endif  // !_MSC_VER

SendPvpRankRiseAwards::SendPvpRankRiseAwards()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SendPvpRankRiseAwards::InitAsDefaultInstance() {
}

SendPvpRankRiseAwards::SendPvpRankRiseAwards(const SendPvpRankRiseAwards& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SendPvpRankRiseAwards::SharedCtor() {
  _cached_size_ = 0;
  history_rank_ = 0u;
  now_rank_ = 0u;
  scroll_point_ = 0u;
  rank_rise_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendPvpRankRiseAwards::~SendPvpRankRiseAwards() {
  SharedDtor();
}

void SendPvpRankRiseAwards::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SendPvpRankRiseAwards::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendPvpRankRiseAwards& SendPvpRankRiseAwards::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

SendPvpRankRiseAwards* SendPvpRankRiseAwards::default_instance_ = NULL;

SendPvpRankRiseAwards* SendPvpRankRiseAwards::New() const {
  return new SendPvpRankRiseAwards;
}

void SendPvpRankRiseAwards::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    history_rank_ = 0u;
    now_rank_ = 0u;
    scroll_point_ = 0u;
    rank_rise_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SendPvpRankRiseAwards::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 history_rank = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &history_rank_)));
          set_has_history_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_now_rank;
        break;
      }

      // optional uint32 now_rank = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_now_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &now_rank_)));
          set_has_now_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_scroll_point;
        break;
      }

      // optional uint32 scroll_point = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_scroll_point:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &scroll_point_)));
          set_has_scroll_point();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_rank_rise;
        break;
      }

      // optional uint32 rank_rise = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rank_rise:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_rise_)));
          set_has_rank_rise();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendPvpRankRiseAwards::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 history_rank = 1;
  if (has_history_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->history_rank(), output);
  }

  // optional uint32 now_rank = 2;
  if (has_now_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->now_rank(), output);
  }

  // optional uint32 scroll_point = 3;
  if (has_scroll_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->scroll_point(), output);
  }

  // optional uint32 rank_rise = 4;
  if (has_rank_rise()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rank_rise(), output);
  }

}

int SendPvpRankRiseAwards::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 history_rank = 1;
    if (has_history_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->history_rank());
    }

    // optional uint32 now_rank = 2;
    if (has_now_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->now_rank());
    }

    // optional uint32 scroll_point = 3;
    if (has_scroll_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->scroll_point());
    }

    // optional uint32 rank_rise = 4;
    if (has_rank_rise()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank_rise());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendPvpRankRiseAwards::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendPvpRankRiseAwards*>(&from));
}

void SendPvpRankRiseAwards::MergeFrom(const SendPvpRankRiseAwards& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_history_rank()) {
      set_history_rank(from.history_rank());
    }
    if (from.has_now_rank()) {
      set_now_rank(from.now_rank());
    }
    if (from.has_scroll_point()) {
      set_scroll_point(from.scroll_point());
    }
    if (from.has_rank_rise()) {
      set_rank_rise(from.rank_rise());
    }
  }
}

void SendPvpRankRiseAwards::CopyFrom(const SendPvpRankRiseAwards& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendPvpRankRiseAwards::IsInitialized() const {

  return true;
}

void SendPvpRankRiseAwards::Swap(SendPvpRankRiseAwards* other) {
  if (other != this) {
    std::swap(history_rank_, other->history_rank_);
    std::swap(now_rank_, other->now_rank_);
    std::swap(scroll_point_, other->scroll_point_);
    std::swap(rank_rise_, other->rank_rise_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SendPvpRankRiseAwards::GetTypeName() const {
  return "message.SendPvpRankRiseAwards";
}


// ===================================================================

#ifndef _MSC_VER
const int VipOperResult::kOperTypeFieldNumber;
const int VipOperResult::kOperResultFieldNumber;
const int VipOperResult::kOperOtherFieldNumber;
#endif  // !_MSC_VER

VipOperResult::VipOperResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VipOperResult::InitAsDefaultInstance() {
}

VipOperResult::VipOperResult(const VipOperResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VipOperResult::SharedCtor() {
  _cached_size_ = 0;
  oper_type_ = 0u;
  oper_result_ = 0u;
  oper_other_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VipOperResult::~VipOperResult() {
  SharedDtor();
}

void VipOperResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VipOperResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VipOperResult& VipOperResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

VipOperResult* VipOperResult::default_instance_ = NULL;

VipOperResult* VipOperResult::New() const {
  return new VipOperResult;
}

void VipOperResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    oper_type_ = 0u;
    oper_result_ = 0u;
    oper_other_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VipOperResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 oper_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_type_)));
          set_has_oper_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_oper_result;
        break;
      }

      // optional uint32 oper_result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_result_)));
          set_has_oper_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_oper_other;
        break;
      }

      // optional uint32 oper_other = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oper_other:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oper_other_)));
          set_has_oper_other();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VipOperResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 oper_type = 1;
  if (has_oper_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->oper_type(), output);
  }

  // optional uint32 oper_result = 2;
  if (has_oper_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->oper_result(), output);
  }

  // optional uint32 oper_other = 3;
  if (has_oper_other()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->oper_other(), output);
  }

}

int VipOperResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 oper_type = 1;
    if (has_oper_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_type());
    }

    // optional uint32 oper_result = 2;
    if (has_oper_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_result());
    }

    // optional uint32 oper_other = 3;
    if (has_oper_other()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oper_other());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VipOperResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VipOperResult*>(&from));
}

void VipOperResult::MergeFrom(const VipOperResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_oper_type()) {
      set_oper_type(from.oper_type());
    }
    if (from.has_oper_result()) {
      set_oper_result(from.oper_result());
    }
    if (from.has_oper_other()) {
      set_oper_other(from.oper_other());
    }
  }
}

void VipOperResult::CopyFrom(const VipOperResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VipOperResult::IsInitialized() const {

  return true;
}

void VipOperResult::Swap(VipOperResult* other) {
  if (other != this) {
    std::swap(oper_type_, other->oper_type_);
    std::swap(oper_result_, other->oper_result_);
    std::swap(oper_other_, other->oper_other_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VipOperResult::GetTypeName() const {
  return "message.VipOperResult";
}


// ===================================================================

#ifndef _MSC_VER
const int ItemCombineReq::kItemIdFieldNumber;
#endif  // !_MSC_VER

ItemCombineReq::ItemCombineReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ItemCombineReq::InitAsDefaultInstance() {
}

ItemCombineReq::ItemCombineReq(const ItemCombineReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ItemCombineReq::SharedCtor() {
  _cached_size_ = 0;
  item_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemCombineReq::~ItemCombineReq() {
  SharedDtor();
}

void ItemCombineReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ItemCombineReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ItemCombineReq& ItemCombineReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Message_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Message_2eproto();
#endif
  return *default_instance_;
}

ItemCombineReq* ItemCombineReq::default_instance_ = NULL;

ItemCombineReq* ItemCombineReq::New() const {
  return new ItemCombineReq;
}

void ItemCombineReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ItemCombineReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 item_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemCombineReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 item_id = 1;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->item_id(), output);
  }

}

int ItemCombineReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 item_id = 1;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemCombineReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ItemCombineReq*>(&from));
}

void ItemCombineReq::MergeFrom(const ItemCombineReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
  }
}

void ItemCombineReq::CopyFrom(const ItemCombineReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemCombineReq::IsInitialized() const {

  return true;
}

void ItemCombineReq::Swap(ItemCombineReq* other) {
  if (other != this) {
    std::swap(item_id_, other->item_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ItemCombineReq::GetTypeName() const {
  return "message.ItemCombineReq";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)
